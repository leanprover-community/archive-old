[
    {
        "content": "<p>I finally figured out how to port level  8 in advanced proposition world to lean4, but it's not pretty.  See <a href=\"https://lovettsoftware.com/NaturalNumbers/AdvancedPropositionWorld/Level8.lean.html\">solution</a>.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">hP</span> <span class=\"n\">hQR</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hQR</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">hQ</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">left</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"n\">assumption</span>\n      <span class=\"n\">assumption</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">hR</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">right</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"n\">assumption</span>\n      <span class=\"n\">assumption</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">hPQ</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hPQ</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">hP</span> <span class=\"n\">hQ</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"n\">assumption</span>\n      <span class=\"n\">left</span>\n      <span class=\"n\">assumption</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">hPR</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hPR</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">hP</span> <span class=\"n\">hR</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"n\">assumption</span>\n      <span class=\"n\">right</span>\n      <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Here's the lean 3 solution for comparison:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hp</span> <span class=\"n\">hqr</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span> <span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hpq</span> <span class=\"n\">hpr</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hpq</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hpr</span> <span class=\"k\">with</span> <span class=\"n\">hp</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Notice how the single line cases tactics make for a much more condensed proof.  Is there another way to simplify my lean4 proof (using tactic proofs)?</p>",
        "id": 303541266,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665534270
    },
    {
        "content": "<p>I see that mathlib4 has a <code>cases'</code> tactic for backwards compatibility.<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/f275d4b0c8762abd3eb75a4e5c2e9a8e9e2a2254/Mathlib/Tactic/Cases.lean\">https://github.com/leanprover-community/mathlib4/blob/f275d4b0c8762abd3eb75a4e5c2e9a8e9e2a2254/Mathlib/Tactic/Cases.lean</a></p>",
        "id": 303564303,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665554658
    },
    {
        "content": "<p>Right now the lean 4 version looks much harder to teach, not least because of the syntax and spacing. I didn't even teach <code>{ tac }</code> brackets in lean 3, instead saying \"tactics operate on the top goal\".</p>",
        "id": 303573001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665559614
    },
    {
        "content": "<p>You can put multiple tactics on one line by separating them with <code>;</code> (instead of <code>,</code>), which should give you the ability to more or less directly copy the lean 3 proof</p>",
        "id": 303575989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665561016
    },
    {
        "content": "<p>Here's an approximation of a literal port of the lean 3 proof in lean 4, using the <code>cases'</code> and <code>left</code>/<code>right</code> tactics from mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Cases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LeftRight</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hp</span> <span class=\"n\">hqr</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span> <span class=\"n\">q</span> <span class=\"n\">r</span>\n    <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hpq</span> <span class=\"n\">hpr</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases'</span> <span class=\"n\">hpq</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n      <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n      <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases'</span> <span class=\"n\">hpr</span> <span class=\"k\">with</span> <span class=\"n\">hp</span> <span class=\"n\">hr</span>\n      <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n      <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>The use of <code>·</code> for subgoals is required only because of a bug in <code>cases'</code> which appears to cause it to drop goals when it is applied on a goal state already containing multiple goals (which of course you shouldn't have in a well structured proof, but in this example we're specifically going for the stream of consciousness style so those <code>·</code> are undesirable).</p>",
        "id": 303576686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665561349
    },
    {
        "content": "<p>I just found the same bug. :-)</p>",
        "id": 303576757,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665561373
    },
    {
        "content": "<p>Here's a version that uses only core lean 4 but retains the lean 3 style as much as possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hqr</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">hpq</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hpr</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hpq</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hpr</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hr</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 303577001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665561489
    },
    {
        "content": "<p>If <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>'s NNG version takes care of \"deemphasizing syntax worries as much as possible\", I'd argue teaching <em>some</em> structuring in this \"pure Lean\" version is not wrong</p>",
        "id": 303577445,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665561697
    },
    {
        "content": "<p>here's a version with the natural structuring suggested by the cases tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hqr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">hpq</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hpq</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hpr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hpr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hr</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 303577774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665561831
    },
    {
        "content": "<p>(as usual, a syntax error after the proof caused me to write nonsense that lean wasn't actually checking... -_- Should be fixed now.)</p>",
        "id": 303578731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665562216
    },
    {
        "content": "<p>now I have to go find out why <code>cases h with | _ hpq =&gt; ?_ | _ hpr =&gt; ?_</code> doesn't work to destructure an or</p>",
        "id": 303578855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665562287
    },
    {
        "content": "<p>How do you expect that to work? <code>_</code> means \"all remaining cases\"</p>",
        "id": 303580225,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665562918
    },
    {
        "content": "<p>posted in <a href=\"https://github.com/leanprover/lean4/pull/1718\">lean4#1718</a>. In short, uses of <code>_</code> before the last pattern should target the first constructor that has not yet been claimed by an earlier arm</p>",
        "id": 303583225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564219
    },
    {
        "content": "<p>and the last <code>| _ =&gt;</code> arm is applied to all remaining goals if there is more than one</p>",
        "id": 303583362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564268
    },
    {
        "content": "<p>Yeah, I just saw the issue. I feel like it's overloading the meaning of <code>_</code> in <code>cases</code> a bit too much - why not use <code>next/all_goals</code> at that point to be explicit.</p>",
        "id": 303583465,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665564312
    },
    {
        "content": "<p>In this particular case, the point is so that we can use the <code>=&gt; ?_</code> form of <code>cases</code> to dump the goals in the main context. <code>next</code> and <code>case</code> and <code>all_goals</code> are all block tactics</p>",
        "id": 303583654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564395
    },
    {
        "content": "<p>I think cases tries a little too hard to be a half-assed version of <code>match</code>. It's not doing pattern matching, but it has some similar features and the combination is confusing</p>",
        "id": 303583925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564494
    },
    {
        "content": "<p>Seems like your proposal would move it further away from <code>match</code> :)</p>",
        "id": 303584083,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665564576
    },
    {
        "content": "<p>it would</p>",
        "id": 303584094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564584
    },
    {
        "content": "<p>I don't think they should be using similar syntax, because that just invites misunderstandings when people try to write <code>cases x with | inl (a, b) =&gt; ...</code></p>",
        "id": 303584216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564624
    },
    {
        "content": "<p>or why name resolution on the variants works differently, you can't write <code>cases x with | Or.inl a =&gt; ...</code> but you have to write it like that (or use <code>.inl</code>) in <code>match</code></p>",
        "id": 303584679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564806
    },
    {
        "content": "<p>Also <code>?_</code> at the end of <code>cases</code> / <code>match</code> is non-compositional, you can't put any tactics before it. I would prefer if this was just a general mechanism to get out of a block context</p>",
        "id": 303584956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665564925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/shorter.20cases.20tactic/near/303584679\">said</a>:</p>\n<blockquote>\n<p>or why name resolution on the variants works differently, you can't write <code>cases x with | Or.inl a =&gt; ...</code> but you have to write it like that (or use <code>.inl</code>) in <code>match</code></p>\n</blockquote>\n<p>Heh, in the other thread I was arguing for moving that <em>closer</em> to <code>match</code></p>",
        "id": 303585146,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665564975
    },
    {
        "content": "<p>I mean, I think it's mostly fine, but I think the data is in that it's a lot more cumbersome to write compared to lean 3 cases</p>",
        "id": 303585302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565035
    },
    {
        "content": "<p>I don't think we should be going back to the unstructured list of names approach, but something like rcases patterns seems like a reasonable compromise</p>",
        "id": 303585372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565075
    },
    {
        "content": "<p>and that PR is just the smallest delta I can make on current lean 4 to make it possible to do lean 3 style cases in lean 4</p>",
        "id": 303585561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565133
    },
    {
        "content": "<p>(I don't think <code>cases'</code> is an adequate solution because it is mainly intended for backward compatibility and will go away eventually if it doesn't make the bar to go into official lean 4)</p>",
        "id": 303585689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565190
    },
    {
        "content": "<p>Maybe a naive question but... here's the same proof in Coq:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">/\\</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">\\/</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">&lt;-&gt;</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">/\\</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">\\/</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">/\\</span> <span class=\"n\">R</span><span class=\"o\">).</span>\n  <span class=\"k\">split</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">intros</span> <span class=\"o\">[</span><span class=\"n\">HP</span> <span class=\"o\">[</span><span class=\"n\">HQ</span><span class=\"o\">|</span><span class=\"n\">HR</span><span class=\"o\">]].</span>\n    <span class=\"o\">-</span> <span class=\"k\">left</span><span class=\"o\">.</span> <span class=\"k\">split</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n    <span class=\"o\">-</span> <span class=\"k\">right</span><span class=\"o\">.</span> <span class=\"k\">split</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">intros</span> <span class=\"o\">[[</span><span class=\"n\">HP</span> <span class=\"n\">HQ</span><span class=\"o\">]|[</span><span class=\"n\">HP</span> <span class=\"n\">HR</span><span class=\"o\">]].</span>\n    <span class=\"o\">-</span> <span class=\"k\">split</span><span class=\"o\">.</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span> <span class=\"k\">left</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n    <span class=\"o\">-</span> <span class=\"k\">split</span><span class=\"o\">.</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span> <span class=\"k\">right</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>What's wrong with having a linear/non-structured case (or here intros) and then structuring with bullets?</p>",
        "id": 303585834,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665565231
    },
    {
        "content": "<p>that's what I mean by <code>rcases</code> patterns</p>",
        "id": 303585889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565253
    },
    {
        "content": "<p>rcases was in large part inspired by coq's syntax for pattern matching intros</p>",
        "id": 303585941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565277
    },
    {
        "content": "<p>Here's a lean 4 transcription of the coq proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.RCases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LeftRight</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">·</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">left</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">·</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">right</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 303586471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565446
    },
    {
        "content": "<p>There was a lot of support for somehow unifying <code>intro</code> and <code>rintro</code> from the mathlib crowd, but they are fairly syntactically incompatible even though they are very similar</p>",
        "id": 303586783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565573
    },
    {
        "content": "<p>I would like <code>rcases</code> to land in lean core in some way, maybe with some syntax modifications but essentially the same interface</p>",
        "id": 303586881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665565624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> the natural number game was written for mathematicians who have no programming background and I made a conscious decision not to teach any structuring.  You would not believe the horrors I saw when I was beta testing with mathematics undergraduates. If we add some sort of structuring in Lean 4 then part of me thinks that this is a great idea to teach mathematicians about how to think correctly about a proof being a program, but another part of me is just worried that this will confuse them (certainly I do not want to assume that they have ever seen functional programming, for example). Perhaps one solution that we could have in Lean 4 is that whenever a proof breaks into 2, we literally end up with 2 windows where they can type.</p>",
        "id": 303610633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665575614
    },
    {
        "content": "<p>Right, it seems reasonable to separate these concerns. (I mean I would never have doubted  that mathematicians have an intuition of a subproof within a proof, but you've clearly seen more than I have. xD) So in that regard, separating the splitting/recursing from the structuring does make sense.</p>",
        "id": 303625133,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665580684
    },
    {
        "content": "<p>For the sake of listing one more option, one can also use <code>next</code> to avoid the <code>with | ...</code> syntax.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Plain Lean, no imports</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span><span class=\"n\">HQR</span><span class=\"o\">⟩</span>\n    <span class=\"n\">cases</span> <span class=\"n\">HQR</span>\n    <span class=\"n\">next</span> <span class=\"n\">HQ</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">HP</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">HQ</span>\n    <span class=\"n\">next</span> <span class=\"n\">HR</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">HP</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">HR</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">H</span>\n    <span class=\"n\">cases</span> <span class=\"n\">H</span>\n    <span class=\"n\">next</span> <span class=\"n\">HPQ</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">HPQ.left</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n        <span class=\"n\">exact</span> <span class=\"n\">HPQ.right</span>\n    <span class=\"n\">next</span> <span class=\"n\">HPR</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">HPR.left</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n        <span class=\"n\">exact</span> <span class=\"n\">HPR.right</span>\n</code></pre></div>",
        "id": 303681794,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1665594108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/shorter.20cases.20tactic/near/303577774\">said</a>:</p>\n<blockquote>\n<p>here's a version with the natural structuring suggested by the cases tactic:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">hp</span> <span class=\"n\">hqr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> In this proof of yours (cropped for clarity), is it conventional that you indented </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">cases</span> <span class=\"n\">hqr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>?  In Lean 3 we wouldn't brace after a step which doesn't increase the number of goals.</p>",
        "id": 303722079,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665608850
    },
    {
        "content": "<p>I indented it because the thing after <code>cases</code> is a block of tactics, it's like <code>all_goals</code> or other tactic combinator. When you say \"we wouldn't brace after a step which doesn't increase the number of goals\", that implies that <code>cases h with | _ hp hqr =&gt;</code> is a tactic, and it's not. The standalone tactic version would be written <code>cases h with | _ hp hqr =&gt; ?_</code>, and I would not indent after that since you can put parentheses around that tactic without causing a syntax error</p>",
        "id": 303723525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665609574
    },
    {
        "content": "<p>In particular, you can see the <code>intro h</code> is not indented along with the <code>cases hqr</code>. If you were to dedent the block, it would actually change the meaning of the code, since the <code>intro h</code> would be brought into the block as well</p>",
        "id": 303723751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665609685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/shorter.20cases.20tactic/near/303723751\">said</a>:</p>\n<blockquote>\n<p>In particular, you can see the <code>intro h</code> is not indented along with the <code>cases hqr</code>. If you were to dedent the block, it would actually change the meaning of the code, since the <code>intro h</code> would be brought into the block as well</p>\n</blockquote>\n<p>To check, you mean the second <code>intro h</code>?</p>",
        "id": 303724072,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665609844
    },
    {
        "content": "<p>yes</p>",
        "id": 303724136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665609876
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 303724229,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665609938
    },
    {
        "content": "<p>Speaking of semi-colons, the NNG for lean3 says \"Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".  I take it this is not the case in lean4, where it just means the same as a newline?</p>",
        "id": 303738591,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665618365
    },
    {
        "content": "<p>in lean 4 that remark is directed to <code>&lt;;&gt;</code></p>",
        "id": 303738825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665618581
    },
    {
        "content": "<p>Can someone explain why/what the \"dot\" is exactly so I can explain it in the <a href=\"http://lovettsoftware.com/NaturalNumbers/AdvancedPropositionWorld/Level8.lean.html\">updated version of the tutorial</a> ?  Specifically, why can't an indent do the same thing? I noticed the inner dots on the rintro subgoals where not needed, what are the guidelines, only use dot when necessary? Or use them everywhere for consistency?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 303743743,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665622513
    },
    {
        "content": "<p>The dot focuses, so the other goals disappear from view, until you reach the next dot.</p>",
        "id": 303745414,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665624196
    },
    {
        "content": "<p>So it's cleaner to use the dot, and helpful if someone is ever going to read the proof. Using the dot consistently prevents you from writing proofs in which the reader has to track multiple goals in their head, and work out from the proof where the argument close one and moves on to the next.</p>",
        "id": 303745547,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665624334
    },
    {
        "content": "<p>The dot is valuable for readers because of all the ways you <em>could</em> have written the code that wouldn't compile with the dots. For example, this doesn't compile:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>That's because the first goal is not closed by the <code>rintro</code> line, it still has two subgoals and you get an error saying the proof isn't done yet. So by looking at a proof like this I can immediately see that <code>constructor</code> would have to produce six goals for the proof to compile. While it is true that the inner dots are not required, the following proof has the same structure and also compiles:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">left</span>\n    <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n    <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>but now that I've scrambled the lines it's not clear where one goal ends and the next one starts. Adding the dots provides visual proof that I didn't scramble the goals like this.</p>",
        "id": 303752337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665630826
    },
    {
        "content": "<p>My question though was about this case which also compiles, but it seems the inner dots are not needed.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">.</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">.</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"bp\">.</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">.</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>it's almost like the mathlib <code>left</code> tactic is also acting like a dot?  So is it recommended i include these inner dots or not?  </p>\n<p>Can I think of dot almost like a \"push tail; pop tail\" operation that hides all the trailing goals so I can focus on the topmost goal? If I am to believe the tactic state I see in the InfoView as I move my cursor around, it seems like \"pop\" is automatic as soon as the goals are accomplished the remaining goal re-appears, so I'm not sure why I need a dot on the second <code>rintro</code>.</p>",
        "id": 303910271,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665689947
    },
    {
        "content": "<p>Dots are never needed if you have placed them correctly</p>",
        "id": 303911528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665690448
    },
    {
        "content": "<p>The value of placing dots is to say \"the fact that it still compiles means my proof must actually have this structure\"</p>",
        "id": 303911605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665690478
    },
    {
        "content": "<p>The actual effect of the dot is the following:</p>\n<p>Given a goal state <code>[g1, g2, ... gn]</code>, <code>. tacs</code> is a tactic which first changes the goal state to <code>[g1]</code>, then runs <code>tacs</code>. If the resulting goal state is not <code>[]</code>, throw an error. Then restore the remaining goals <code>[g2, ..., gn]</code>.</p>",
        "id": 303912075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665690641
    },
    {
        "content": "<p>In other words, it's a checkpoint at the <em>end</em> of <code>tacs</code> which ensures that at that point the goal <code>g1</code> has been completely dealt with. It's just like an <code>assert()</code> in the middle of some code - if you remove it, stuff still works, but that doesn't mean the <code>assert</code> doesn't have value</p>",
        "id": 303912598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665690829
    },
    {
        "content": "<blockquote>\n<p>it seems like \"pop\" is automatic as soon as the goals are accomplished the remaining goal re-appears, so I'm not sure why I need a dot on the second rintro.</p>\n</blockquote>\n<p>When there is only one goal remaining, the dot is a no-op, and sometimes people will leave off the dot on the last case, especially if the cases are very asymmetric like in a proof by induction where the base case is one line and the induction step is the rest of the proof, and they want to avoid indenting the rest of the proof. But you might keep the dots in if you want to emphasize the symmetry of the cases like in a <code>by_cases</code> proof or one that destructures an <code>\\/</code> as in this case. If we were to leave off the last-case dots, it would look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">.</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n  <span class=\"bp\">.</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 303913384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665691131
    },
    {
        "content": "<p>this is similar to whether you like to format a function with a big <code>if</code> statement as:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">then_stuff</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">else_stuff</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">then_stuff</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">else_stuff</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 303913723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665691272
    },
    {
        "content": "<blockquote>\n<p>So is it recommended i include these inner dots or not?</p>\n</blockquote>\n<p>It is recommended you always add the dots after any tactic that produces more than one goal. When the tactics are on one line, my personal preference is to use <code>{ }</code> (which is the lean 3 version of the dot which is still available in lean 4) instead of <code>(. tacs); ...</code>. With that style, the proof would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">.</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">.</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"bp\">.</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">.</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 303914711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665691657
    },
    {
        "content": "<p>Now I can tell by looking at the proof that the <code>constructor</code> on the last line made two goals and <code>assumption</code> clears the first one and <code>right; assumption</code> clears the second.</p>",
        "id": 303914898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665691719
    },
    {
        "content": "<p>Thanks very helpful, if you prefer curly braces why not write this instead?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"o\">}</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 303919057,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665693260
    },
    {
        "content": "<p>that used to not work at all in lean 4, does that work now?</p>",
        "id": 303919578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693478
    },
    {
        "content": "<p>the lean 3 style looks like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 303919691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693519
    },
    {
        "content": "<p>and it does work now in lean 4, but I think the dots are more in keeping with the whitespace sensitive and newline-terminated style of lean 4</p>",
        "id": 303919754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693554
    },
    {
        "content": "<p>Yep I'm getting Goals accomplished <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> with the curly bracket version.</p>",
        "id": 303919778,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665693568
    },
    {
        "content": "<p>although you are still missing some braces there</p>",
        "id": 303919873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693603
    },
    {
        "content": "<p>it's more like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">and_or_distrib_left</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span> <span class=\"bp\">|</span> <span class=\"n\">HR</span><span class=\"o\">⟩</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HQ</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">HP</span><span class=\"o\">,</span> <span class=\"n\">HR</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">{</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n    <span class=\"o\">{</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 303919920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693624
    },
    {
        "content": "<p>Well hmmm.  Gets a bit much.  I ended up documenting both styles and including your nice definition of dot here <a href=\"http://lovettsoftware.com/NaturalNumbers/AdvancedPropositionWorld/Level8.lean.html\">http://lovettsoftware.com/NaturalNumbers/AdvancedPropositionWorld/Level8.lean.html</a></p>",
        "id": 303919965,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665693653
    },
    {
        "content": "<p>the dots definitely look cleaner</p>",
        "id": 303919997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693671
    },
    {
        "content": "<p>But it is interesting one can mix the style of grouping with parens when necessary, but also chipping away at the top goal without parens also works, so you can \"simplify\" the use of braces...</p>",
        "id": 303920213,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665693758
    },
    {
        "content": "<p>the idea with the \"structured style\" is to never call a tactic when more than one goal is visible</p>",
        "id": 303920282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693788
    },
    {
        "content": "<p>mathlib would reject your proof if you use the unstructured style</p>",
        "id": 303920344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693824
    },
    {
        "content": "<p>it's good for hacking on the problem but it isn't \"professional looking\" and more importantly it's difficult to maintain</p>",
        "id": 303920435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693857
    },
    {
        "content": "<p>if a tactic goes from closing a goal to no longer closing the goal, then the next tactic will be called on the wrong goal and you get all sorts of crazy cascading errors</p>",
        "id": 303920547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665693904
    },
    {
        "content": "<p>so \"simplifying\" the braces is not allowed - every brace there is required (although you can write it using <code>.</code> or <code>case</code> or <code>next</code> if you prefer, or use a tactic with built in structuring like <code>cases e with | a =&gt; tac | b =&gt; tac</code>)</p>",
        "id": 303921115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665694161
    },
    {
        "content": "<p>Also, just to be clear, parentheses in tactics are also legal but they have no block structuring effect. <code>(tac1; tac2); tac3</code> means the same as <code>tac1; tac2; tac3</code>. The main reason to use parentheses is to clear up a precedence or parsing issue, or run multiple tactics in a slot where only one tactic is allowed like <code>tac1 &lt;;&gt; (tac2; tac3)</code> (which would run <code>tac2</code> then <code>tac3</code> on every subgoal produced by <code>tac1</code>).</p>",
        "id": 303921792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665694418
    },
    {
        "content": "<p>I see, good to know, I definitely follow the maintainability argument.  It was surprising to me to learn that tactics that do nothing don't report an error in general.  Some do, like intro tells you when there's no way to introduce a new hypothesis, but <code>rw</code> silently fails...</p>",
        "id": 303922035,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665694528
    },
    {
        "content": "<p>Example? We had a conversation about finding and removing those issues earlier, so I'm interested to see where that happens</p>",
        "id": 303922233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665694606
    },
    {
        "content": "<p>if you mean <code>rw []</code>, that one is defined to do nothing (other than the reducible rfl at the end) so it shouldn't fail, but if a rewrite is attempted it should not fail silently</p>",
        "id": 303922340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665694652
    },
    {
        "content": "<p>in lean 3 tactics would fail by convention if they make no progress, and I think we want to adopt the same behavior in lean 4</p>",
        "id": 303922489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665694710
    },
    {
        "content": "<p>Ok, good to know.  I know I've seen it but can't reproduce it right now, I will file a bug if I see it again with a repro.<br>\nPS: thanks for the <code>tac1 &lt;;&gt; (tac2; tac3)</code> tip, that indeed seems handy.</p>",
        "id": 303930852,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665698295
    },
    {
        "content": "<p>It is <code>apply</code> that silently fails, not <code>rw</code>.</p>",
        "id": 303933006,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665699362
    },
    {
        "content": "<p>Again, can you show an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, I have not experienced this</p>",
        "id": 303933543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665699698
    },
    {
        "content": "<p>It might be an incremental editing issue.  If I have unfinished work ahead in the proof then apply produces no error:</p>\n<p><a href=\"/user_uploads/3121/Jux5HZfwQOZJkhng-NBVIziP/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Jux5HZfwQOZJkhng-NBVIziP/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Jux5HZfwQOZJkhng-NBVIziP/image.png\"></a></div><p>But if I fix the missing syntax ahead, then apply shows the error:</p>\n<p><a href=\"/user_uploads/3121/sFXwebprpEuW6bSXcVh0P6Kl/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sFXwebprpEuW6bSXcVh0P6Kl/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/sFXwebprpEuW6bSXcVh0P6Kl/image.png\"></a></div>",
        "id": 303936849,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1665701562
    },
    {
        "content": "<p>one way to deal with that is to make sure your proof always compiles (unless you are mid-line) by placing <code>sorry</code>s that fill in all the holes in you proof.</p>",
        "id": 303961700,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665721572
    }
]
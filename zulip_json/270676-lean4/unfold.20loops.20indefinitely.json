[
    {
        "content": "<p>Hi. I have encountered a situation where <code>unfold</code> tactic loops indefinitely (until a timeout is reached), and it depends on the use of <code>match</code> inside a proof in the definition.<br>\nHere is the example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">PositionalNotation</span> <span class=\"o\">{</span><span class=\"n\">base</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">base</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">base</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">toPositionalNotation</span> <span class=\"o\">{</span><span class=\"n\">base</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">base</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"bp\">@</span><span class=\"n\">PositionalNotation</span> <span class=\"n\">base</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">isLt</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">base</span> <span class=\"k\">then</span>\n    <span class=\"o\">[]</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">rem</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">base</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">quot</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">base</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">h'</span><span class=\"o\">:</span> <span class=\"n\">base</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"gr\">sorry</span><span class=\"bp\">;</span>\n    <span class=\"o\">}</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">n_gt_0</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"c1\">-- replacing the following \"match\" with \"sorry\" fixes the infinite loop.</span>\n      <span class=\"k\">match</span> <span class=\"n\">Nat.lt_or_ge</span> <span class=\"n\">n</span> <span class=\"n\">base</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span><span class=\"bp\">;</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span><span class=\"bp\">;</span>\n    <span class=\"o\">}</span><span class=\"bp\">;</span>\n    <span class=\"n\">Fin.mk</span> <span class=\"n\">rem</span> <span class=\"o\">(</span><span class=\"n\">Nat.mod_lt</span> <span class=\"n\">n</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"bp\">@</span><span class=\"n\">toPositionalNotation</span> <span class=\"n\">base</span> <span class=\"n\">h</span> <span class=\"n\">quot</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"n\">decreasing_by</span> <span class=\"o\">{</span>\n  <span class=\"gr\">sorry</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">three_gt_one</span><span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"bp\">;</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ex1</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">toPositionalNotation</span> <span class=\"mi\">3</span> <span class=\"n\">three_gt_one</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"c1\">-- this \"unfold\" loops indefinitely:</span>\n  <span class=\"c1\">-- (deterministic) timeout at 'whnf', maximum number of heartbeats (50000) has been reached (use 'set_option maxHeartbeats &lt;num&gt;' to set the limit)</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">toPositionalNotation</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>The <code>unfold</code> at last loops until the timeout, but if we replace <code>match</code> in <code>n_gt_0</code> with <code>sorry</code>, the <code>unfold</code> unfolds the definition as expected.<br>\nI'm using <code>Lean (version 4.0.0-nightly-2022-02-22, commit c932d9d33cea, Release)</code> on Windows 10 with Lean4 VSCode extension.</p>",
        "id": 272902723,
        "sender_full_name": "pandaman",
        "timestamp": 1645589293
    },
    {
        "content": "<p>I think this is working as intended</p>",
        "id": 272909435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645597314
    },
    {
        "content": "<p><code>unfold</code> unfolds all instances of the chosen constant, which means it usually diverges when applied to recursive functions. I'm not sure what the best ways to do this in lean 4 are, lean 3 would use <code>rw [foo]</code> or <code>simp only [foo] {single_pass := tt}</code> to limit the unfolding. Perhaps <code>unfold</code> has a config option for this</p>",
        "id": 272909526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645597418
    },
    {
        "content": "<p>But without <code>match</code>, it unfolds only one step. At least, the behavior looks inconsistent.</p>",
        "id": 272912946,
        "sender_full_name": "pandaman",
        "timestamp": 1645601257
    },
    {
        "content": "<p>This seems to be a bug. I wrote some diagnosis at <a href=\"https://github.com/leanprover/lean4/pull/1026\">leanprover/lean4#1026</a></p>",
        "id": 272936035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645615857
    }
]
[
    {
        "content": "<p>I'm learning lean 4 meta-programming and as an exercise, I want to generate a structure programmatically from a command.<br>\nI'm inside CommandElabM here, so I don't know how to add a definition from syntax. As a result I'm trying to use Environment.addAndCompile stuff to create an inductive definition directly from an internal representation.<br>\nI've managed to generate my structure without universes, but I run into problems when I try to add universes in.<br>\nHere is my failing mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"gen_structure\"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">type_u</span> <span class=\"o\">:=</span> <span class=\"n\">mkSort</span> <span class=\"o\">(</span><span class=\"n\">mkLevelSucc</span> <span class=\"o\">(</span><span class=\"n\">mkLevelParam</span> <span class=\"s2\">\"u\"</span><span class=\"o\">))</span>\n  <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"n\">mkInductiveDeclEs</span> <span class=\"o\">[</span><span class=\"s2\">\"u\"</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">[{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">id.getId</span>\n    <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">mkForall</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"bp\">.</span><span class=\"n\">default</span> <span class=\"n\">type_u</span> <span class=\"n\">type_u</span>\n    <span class=\"n\">ctors</span> <span class=\"o\">:=</span> <span class=\"o\">[{</span>\n      <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">id.getId</span> <span class=\"bp\">++</span> <span class=\"s2\">\"mk\"</span>\n      <span class=\"n\">type</span> <span class=\"o\">:=</span>\n        <span class=\"n\">mkForall</span> <span class=\"s2\">\"α\"</span> <span class=\"bp\">.</span><span class=\"n\">implicit</span> <span class=\"n\">type_u</span>\n        <span class=\"bp\">&lt;|</span> <span class=\"n\">mkForall</span> <span class=\"s2\">\"x\"</span> <span class=\"bp\">.</span><span class=\"n\">default</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n        <span class=\"bp\">&lt;|</span> <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"n\">id.getId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">}]</span>\n  <span class=\"o\">}]</span> <span class=\"n\">false</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">addAndCompile</span> <span class=\"o\">{}</span> <span class=\"n\">decl</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"o\">(</span><span class=\"s2\">\"addAndCompile error: \"</span> <span class=\"bp\">++</span> <span class=\"n\">e.toMessageData</span> <span class=\"o\">{})</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">setEnv</span> <span class=\"n\">env</span>\n\n<span class=\"n\">gen_structure</span> <span class=\"n\">struct</span>\n<span class=\"k\">#print</span> <span class=\"n\">struct</span>\n</code></pre></div>\n<p>The error I get is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">incorrect</span> <span class=\"n\">number</span> <span class=\"n\">of</span> <span class=\"kd\">universe</span> <span class=\"n\">levels</span> <span class=\"kd\">parameters</span> <span class=\"n\">for</span> <span class=\"bp\">'</span><span class=\"n\">struct'</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"mi\">1</span> <span class=\"n\">expected</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"mi\">0</span> <span class=\"n\">provided</span>\n</code></pre></div>\n<p>The code works if I replace the universe list [\"u\"] with an empty list, and (mkLevelParam \"u\") with levelZero.<br>\nIt looks like it expects a u variable somewhere but I can't see where.  Is it a bug or am I missing something?<br>\nThanks for suggestions. I'm using nightly-2022-05-21</p>",
        "id": 283172266,
        "sender_full_name": "Michael Jam",
        "timestamp": 1653137548
    },
    {
        "content": "<p>If you want to create a definition from syntax in CommandElabM you can do <code>elabCommand &lt;|&lt;- `(def foo : Nat := 1)</code></p>",
        "id": 283186451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653157283
    },
    {
        "content": "<p>By the way the usual way to quote names is <code> `x</code> not <code>\"x\"</code></p>",
        "id": 283186526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653157379
    },
    {
        "content": "<p>the issue is that in your <code>mkConst</code> you did not pass the universe parameter. Here's the fixed version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"gen_structure\"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">type_u</span> <span class=\"o\">:=</span> <span class=\"n\">mkSort</span> <span class=\"o\">(</span><span class=\"n\">mkLevelSucc</span> <span class=\"o\">(</span><span class=\"n\">mkLevelParam</span> <span class=\"bp\">`</span><span class=\"n\">u</span><span class=\"o\">))</span>\n  <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"n\">mkInductiveDeclEs</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">[{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">id.getId</span>\n    <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">mkForall</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"bp\">.</span><span class=\"n\">default</span> <span class=\"n\">type_u</span> <span class=\"n\">type_u</span>\n    <span class=\"n\">ctors</span> <span class=\"o\">:=</span> <span class=\"o\">[{</span>\n      <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">id.getId</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">mk</span>\n      <span class=\"n\">type</span> <span class=\"o\">:=</span>\n        <span class=\"n\">mkForall</span> <span class=\"bp\">`</span><span class=\"n\">α</span> <span class=\"bp\">.</span><span class=\"n\">implicit</span> <span class=\"n\">type_u</span>\n        <span class=\"bp\">&lt;|</span> <span class=\"n\">mkForall</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"bp\">.</span><span class=\"n\">default</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n        <span class=\"bp\">&lt;|</span> <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"n\">id.getId</span> <span class=\"o\">[</span><span class=\"n\">mkLevelParam</span> <span class=\"bp\">`</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">}]</span>\n  <span class=\"o\">}]</span> <span class=\"n\">false</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">addAndCompile</span> <span class=\"o\">{}</span> <span class=\"n\">decl</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"o\">(</span><span class=\"s2\">\"addAndCompile error: \"</span> <span class=\"bp\">++</span> <span class=\"n\">e.toMessageData</span> <span class=\"o\">{})</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">setEnv</span> <span class=\"n\">env</span>\n</code></pre></div>",
        "id": 283186662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653157589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span></p>",
        "id": 283186677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653157664
    },
    {
        "content": "<p>Thanks Mario, that helps. It seems way more convenient to create a syntax for the code I want and elab it with elabCommand. Using mkInductiveDeclEx and addAndCompile feels too bare bones. One issue I have is that I can't use match on my created structure, it's probably not generating some background stuff that's usually auto generated. <br>\nThis works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">struct</span> <span class=\"n\">α</span>\n<span class=\"kd\">def</span> <span class=\"n\">proj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">struct</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">struct.mk</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But this doesn't :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">gen_structure</span> <span class=\"n\">struct</span>\n<span class=\"kd\">def</span> <span class=\"n\">proj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">struct</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">struct.mk</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>with the following error:</p>\n<div class=\"codehilite\" data-code-language=\"tactic\"><pre><span></span><code>tactic 'cases' failed, not applicable to the given hypothesis, ...\n</code></pre></div>\n<p>Another problem, is that I am actually implementing an attribute that parses an inductive type to generate a new structure from it, so I'm not in CommandElabM, but in  AttrM which doesn't seem to support elabCommand. Is there a way to generate the structure from syntax in AttrM (or CoreM ?)</p>",
        "id": 283193360,
        "sender_full_name": "Michael Jam",
        "timestamp": 1653167716
    },
    {
        "content": "<blockquote>\n<p>Another problem, is that I am actually implementing an attribute that parses an inductive type to generate a new structure from it, so I'm not in CommandElabM, but in AttrM which doesn't seem to support elabCommand. Is there a way to generate the structure from syntax in AttrM (or CoreM ?)</p>\n</blockquote>\n<p>I know that you can at least run <code>MetaM</code> and <code>TermElabM</code> there, as in this <a href=\"https://github.com/leanprover/lean4/blob/56cd6c1ff519d8be39f35875b5bf8719e6101c20/src/Lean/Server/Rpc/RequestHandling.lean#L111\">usage example</a>. <code>CommandElabM</code> is probably also possible, but I couldn't immediately find a <code>run</code>/<code>run'</code> method for it.</p>",
        "id": 283197672,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1653174290
    },
    {
        "content": "<p>I could not find a way to elab a command in AttrM/CoreM/MetaM. It seems all the lift / run functions take me away from CommandElabM. I'll try to understand better what all these monads do</p>",
        "id": 283220464,
        "sender_full_name": "Michael Jam",
        "timestamp": 1653207996
    },
    {
        "content": "<p>This thread should help: <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20monads\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Lean.204.20monads</a></p>\n<p>Additionally, from my (limited) understanding:</p>\n<ul>\n<li><code>CoreM</code> seems to only provide low-level tools like the environment and timeout systems</li>\n<li><code>MetaM</code> gives you normalization, definitional equality, type inference and typeclass resolution. See also <a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/main/metam.md\">this</a>. All the meta-level code I've encountered so far runs in it.</li>\n<li><code>TermElabM</code> is (unsurprisingly) used for term elaboration, it gives you access to term utilities like metavariables, coercions, etc. You usually get there by elaborating syntax rules for terms (eg. <code>macro_rules</code> or the term elab attribute).</li>\n<li><code>CommandElabM</code> is for command elaboration. It doesn't depend on <code>TermElabM</code> but it still has a method to run term elaboration so you still have access to term utils. You usually get there with the <code>elab</code> or <code>elab_rules</code> command, or the command elab attribute.</li>\n</ul>\n<p>Syntax quotations <code>`()</code> are available at several levels, <a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/main/macros.md#monadquotation-and-monadref\">see here</a>.</p>",
        "id": 283221233,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1653209147
    }
]
[
    {
        "content": "<p>The <code>{}</code> annotation has been disabled in inductive, structures and classes. I see how to work around it for inductive definitions, but I don't know how to easily work around it for structures and classes.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Is42</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">is42</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span>\n</code></pre></div>\n<p>used to give <code>Is42.is42 : ∀ (n : Nat) [self : Is42 n], n = 42</code>.</p>\n<p>The only way I found to reproduce the old behavior is to manually define the inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">Is42</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span> <span class=\"bp\">→</span> <span class=\"n\">Is42</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Is42.is42</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Is42</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Is there an easier way to do this?</p>",
        "id": 278993577,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1649956123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> We removed the feature because it was rarely used. All occurrences in the main repo were legacy (i.e., they are not necessary with the Lean 4 elaborator), and as far as we can tell this feature is not used in Mathlib 4. Haskell also seems to do well without having a similar feature. When removing this feature, we observed that every single existing instance looks now better without it. We are assuming that in most cases the <code>n</code> can be inferred from the expected type. In the rare cases where the expected type is not available, named arguments seem to be a reasonable alternative. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">Is42.is42</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If there are many instances where you have to use named arguments, an abbreviation is also a good solution.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Is42.is42'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Is42</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is42</span>\n</code></pre></div>\n<p>BTW, you don't have to use <code>class inductive</code>. Here is the full example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Is42</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">is42</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Is42</span> <span class=\"mi\">42</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Is42.is42</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">Is42.is42</span> <span class=\"o\">:</span> <span class=\"mi\">42</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Is42.is42'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Is42</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is42</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Is42.is42'</span> <span class=\"mi\">42</span>\n</code></pre></div>\n<p>I realize this is an artificial example to explain the problem you hit. If this comment is not useful, could you please point us to your actual development? We assumed the impact of this change would be minimal (or zero), if we are mistaken, it would be useful to see the actual use-cases where the removed feature is useful.</p>",
        "id": 279081063,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1650030172
    },
    {
        "content": "<p>Thanks for the quick reply Leo!</p>\n<p>I only had a couple of uses for this feature. I was never a big fan of it, so I'm not mourning the loss. I was asking in case I could reproduce the exact behavior using a macro or something. </p>\n<p>The <code>abbrev</code> solution works in most cases but there is one thing that I miss. The <code>{}</code> annotation was smart about <code>outParam</code>. For example, I used generic classes for common identities as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OpRightInv</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">op_right_inv</span> <span class=\"o\">{}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span>\n<span class=\"kn\">export</span> <span class=\"n\">OpRightInv</span> <span class=\"o\">(</span><span class=\"n\">op_right_inv</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This automatically gives the desired signature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">op_right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">OpRightInv</span> <span class=\"n\">op</span> <span class=\"n\">inv</span> <span class=\"n\">id</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>This is really cool because I originally thought <code>{}</code> would also make <code>inv</code> and <code>id</code> explicit (as it does without <code>outParam</code>). Before I realized this, I wasn't using the <code>{}</code> annotation and would always specify <code>(op:=...)</code> since this type class needs at least this hook to trigger in most use cases. I was really happy when I noticed <code>{}</code> was smart about <code>outParam</code>. Ironically, this was just a few days before <code>{}</code> was dropped <span aria-label=\"disappointed\" class=\"emoji emoji-1f61e\" role=\"img\" title=\"disappointed\">:disappointed:</span></p>\n<p>Now, since <code>{}</code> was dropped, I use the <code>abbrev</code> trick as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OpRightInv</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">OpRightInv</span> <span class=\"n\">op</span> <span class=\"n\">inv</span> <span class=\"n\">id</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">self.op_right_inv</span>\n</code></pre></div>\n<p>This works in the same way but I have to calculate the signature by hand. This is admittedly not hard to do but <code>{}</code> as definitely more convenient. I'll eventually make a macro to automate this but this works fine for now.</p>",
        "id": 279162831,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650107403
    },
    {
        "content": "<p>A little shorter:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">OpRightInv.op_right_inv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 279163047,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1650107666
    },
    {
        "content": "<p>Thanks Sebastian!</p>\n<p>I was thinking about how to make this into a macro, but I'm still pretty clumsy at macro writing. What's the idiomatic way to handle binders? Ideally, I would like a macro that expands something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">identity</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OpRightInv</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">op_right_inv</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">OpRightInv</span> <span class=\"n\">op</span> <span class=\"n\">inv</span> <span class=\"n\">id</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">self.op_right_inv</span>\n</code></pre></div>",
        "id": 279166080,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650111946
    },
    {
        "content": "<p>I'm starting to think a macro is not the right idea for this.</p>",
        "id": 279166237,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650112180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>:  I've found another pattern where I used <code>{}</code>. These are classes that attempt to extract a normal form for objects that aren't of inductive type. My primary uses for these is to synthesize homomorphisms from a free algebra into a real-world algebra.</p>\n<p>For illustration, here is a simple but complete example. Here the free algebra is a <code>List</code> monoid and the real-world algebra is <code>Prop</code> with <code>And</code> and <code>True</code>. (This is the version with <code>{}</code> for the new version, delete that annotation and replace <code>all_eq x</code> with <code>all_eq (p:=x)</code> where necessary.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">And.assoc</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">propext</span> <span class=\"o\">⟨</span><span class=\"bp\">λ|</span> <span class=\"o\">⟨⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"n\">hq</span><span class=\"o\">⟩,</span><span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span><span class=\"n\">hr</span><span class=\"o\">⟩⟩,</span> <span class=\"bp\">λ|</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span><span class=\"n\">hr</span><span class=\"o\">⟩⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"n\">hq</span><span class=\"o\">⟩,</span><span class=\"n\">hr</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">All</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">::</span><span class=\"n\">ps</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">All</span> <span class=\"n\">ps</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">All.nil</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">]</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">All.single</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">]</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">All.append</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"n\">qs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"bp\">++</span> <span class=\"n\">qs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">All</span> <span class=\"n\">ps</span> <span class=\"bp\">∧</span> <span class=\"n\">All</span> <span class=\"n\">qs</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">qs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">::</span><span class=\"n\">ps</span><span class=\"o\">,</span> <span class=\"n\">qs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">,</span> <span class=\"n\">And.assoc</span><span class=\"o\">,</span> <span class=\"n\">All.append</span> <span class=\"n\">ps</span> <span class=\"n\">qs</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">AssocAnds</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"n\">list</span> <span class=\"bp\">=</span> <span class=\"n\">p</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AssocAnds</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">prio</span><span class=\"o\">:=</span><span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AssocAnds</span> <span class=\"n\">p</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"n\">All.single</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">AssocAnds</span> <span class=\"n\">True</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"n\">All.nil</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AssocAnds</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AssocAnds</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LiftAnds</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">p</span> <span class=\"bp\">++</span> <span class=\"n\">list</span> <span class=\"n\">q</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">All.append</span><span class=\"o\">,</span> <span class=\"n\">all_eq</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">all_eq</span> <span class=\"n\">q</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">AssocAnds</span>\n</code></pre></div>\n<p>This example is not that useful since we can use <code>simp only [And.assoc]</code> to similar effect. Not quite though, since <code>simp</code> works bottom-up whereas <code>AssocAnds</code> works top-down and stops as soon as it hits a snag. Of course, there are more sophisticated examples of this pattern where <code>simp</code> isn't a viable alternative.</p>\n<p>In any case, the point is that <code>AssocAnds.all_eq</code> is not very useful with the parameter <code>p</code> as implicit. This was fixed by the <code>{}</code> annotation, now I must use <code>(p:=...)</code> in the majority use cases (e.g. all backwards rewrites). Adding an <code>abbrev</code> works too but <code>{}</code> was really the most convenient thing to have.</p>\n<p>Bottom line, the <code>{}</code> annotation was actually useful for fields in classes and structures (but not necessarily for other uses). I would really appreciate bringing it back for this use or providing an equivalent alternative. This is pretty low priority for me, so no rush! (I also won't be heartbroken if you decide not to bring this feature back.)</p>",
        "id": 279276448,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650279562
    },
    {
        "content": "<blockquote>\n<p>For the new version, delete that annotation and replace all_eq x with all_eq (p:=x) where necessary.)</p>\n</blockquote>\n<p>It works for me without any annotation. That is, I did not have to write <code>(p := x)</code>. BTW, this was also our experience in other cases.</p>\n<blockquote>\n<p>In any case, the point is that AssocAnds.all_eq is not very useful with the parameter p as implicit. </p>\n</blockquote>\n<p>Do you have other examples where the parameter <code>(p := x)</code> is needed? I could remove all instances from your example.</p>\n<p>Here is your example without extra annotations.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">And.assoc</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">propext</span> <span class=\"o\">⟨</span><span class=\"bp\">λ|</span> <span class=\"o\">⟨⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"n\">hq</span><span class=\"o\">⟩,</span><span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span><span class=\"n\">hr</span><span class=\"o\">⟩⟩,</span> <span class=\"bp\">λ|</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span><span class=\"n\">hr</span><span class=\"o\">⟩⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"n\">hq</span><span class=\"o\">⟩,</span><span class=\"n\">hr</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">All</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">::</span><span class=\"n\">ps</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">All</span> <span class=\"n\">ps</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">All.nil</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">]</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">All.single</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">]</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">All.append</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"n\">qs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"bp\">++</span> <span class=\"n\">qs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">All</span> <span class=\"n\">ps</span> <span class=\"bp\">∧</span> <span class=\"n\">All</span> <span class=\"n\">qs</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">qs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">::</span><span class=\"n\">ps</span><span class=\"o\">,</span> <span class=\"n\">qs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All</span><span class=\"o\">,</span> <span class=\"n\">And.assoc</span><span class=\"o\">,</span> <span class=\"n\">All.append</span> <span class=\"n\">ps</span> <span class=\"n\">qs</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">AssocAnds</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"n\">list</span> <span class=\"bp\">=</span> <span class=\"n\">p</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AssocAnds</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">prio</span><span class=\"o\">:=</span><span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AssocAnds</span> <span class=\"n\">p</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"n\">All.single</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">AssocAnds</span> <span class=\"n\">True</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"n\">All.nil</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AssocAnds</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AssocAnds</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">AssocAnds</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">p</span> <span class=\"bp\">++</span> <span class=\"n\">list</span> <span class=\"n\">q</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">All.append</span><span class=\"o\">,</span> <span class=\"n\">all_eq</span><span class=\"o\">,</span> <span class=\"n\">all_eq</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Same `instance` with `simp`</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AssocAnds</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AssocAnds</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">AssocAnds</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">list</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">p</span> <span class=\"bp\">++</span> <span class=\"n\">list</span> <span class=\"n\">q</span>\n  <span class=\"n\">all_eq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">All.append</span><span class=\"o\">,</span> <span class=\"n\">all_eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">AssocAnds</span>\n</code></pre></div>",
        "id": 279283101,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1650285938
    },
    {
        "content": "<p>You're right! I gutted too much and should have left some sample uses of the class...</p>\n<p>The issue is with backwards rewrites <code>rw [←all_eq p]</code>. These don't work without the parameter. These are the most common when using these classes since we usually have the real world term <code>p</code> and we want to lift to the free algebra, which is <code>list</code> in this case. The free algebra is usually some inductive type or similar, so there's more tools to work with there than with the plain term <code>p</code>.</p>",
        "id": 279283831,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650286517
    },
    {
        "content": "<p>Could you please paste here this use case?</p>",
        "id": 279284039,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1650286680
    },
    {
        "content": "<p>To avoid more errors gutting stuff, I've moved two full examples from a private to a public repo on github:</p>\n<ul>\n<li><a href=\"https://github.com/fgdorais/GMLInit/blob/main/GMLInit/Algebra/Reflect/Semigroup.lean\">Semigroup.reflect</a>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reflect</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">SemigroupSig</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semigroup</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Reflect.expr</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Reflect.expr</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Reflect.eval_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:=</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:=</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">),</span> <span class=\"bp\">←</span> <span class=\"n\">Reflect.eval_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:=</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:=</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://github.com/fgdorais/GMLInit/blob/main/GMLInit/Algebra/Reflect/Monoid.lean\">Monoid.reflect</a>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reflect</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">MonoidSig</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Reflect.expr</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Reflect.expr</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Reflect.eval_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:=</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:=</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">),</span> <span class=\"bp\">←</span><span class=\"n\">Reflect.eval_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:=</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:=</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 279409981,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650375570
    },
    {
        "content": "<p>In both cases, the original implementation used <code>{}</code> at both <code>Reflect.expr</code> and <code>Reflect.eval_eq</code>.</p>",
        "id": 279413848,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650377310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> Thanks for sharing the example. I didn't install it on my machine yet, but I browsed the sources. <br>\nI think they do not make a compelling case for adding <code>{}</code> back. Even if we do it, every example you had would still require the <code>←</code>. It feels natural to manually define an abbreviation <code>eq_eval</code> in this case that uses the explicit binder annotations and flips the equation. Then, you will be able to write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reflect</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">SemigroupSig</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semigroup</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Reflect.expr</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Reflect.expr</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:=</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_eval</span> <span class=\"n\">s</span>  <span class=\"n\">a</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">eq_eval</span> <span class=\"n\">s</span> <span class=\"n\">b</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 279429533,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1650383952
    },
    {
        "content": "<p>OK. I can live with that. The issue with <code>Reflect.expr</code> is a bit more nagging. But it only ever needs just the <code>(xs:=...)</code> so I won't do a wrapper for that one.</p>",
        "id": 279449953,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1650392952
    },
    {
        "content": "<p>I got another question regarding this. I implemented the slim check port for mathlib4 and it contains a typeclass:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">SampleableExt</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">proxy</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"o\">[</span><span class=\"n\">proxyRepr</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">proxy</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">shrink</span> <span class=\"o\">:</span> <span class=\"n\">Shrinkable</span> <span class=\"n\">proxy</span><span class=\"o\">]</span>\n  <span class=\"n\">sample</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">Gen</span> <span class=\"n\">proxy</span>\n  <span class=\"n\">interp</span> <span class=\"o\">:</span> <span class=\"n\">proxy</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>where I now have to remove the {} in order to get my type fixed, howver both fields dont allow the lean compiler to infer the alpha parameter over which the type class is actually declared so where I could previously write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>        <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">sample</span> <span class=\"n\">Nat</span>\n        <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">Char.ofNat</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>I now have to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>        <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">sample</span>\n        <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">Char.ofNat</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>which the lean compiler cannot infer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Char.ofNat</span> <span class=\"n\">n</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">n</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">proxy</span> <span class=\"bp\">?</span><span class=\"n\">m.9290</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℕ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>What's the recommended way to address this use case? Have a manual wrapper as well?</p>",
        "id": 280490823,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1651151445
    }
]
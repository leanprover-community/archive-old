[
    {
        "content": "<p>While Lean features pervasive overloading for numbers, there doesn't seem to be anything similar for list literals. <code>Notation.lean</code> contains a <code>macro_rules</code> that expands list literal syntax directly into invocations of <code>List.cons</code> and <code>List.nil</code>. </p>\n<p>Similarly, string literals are not overloaded so far as I can see.</p>\n<p>What is the thought process behind determining which syntactic literals should admit overloading? I've had good luck with overloaded list in Idris for various kinds of indexed list types (e.g. environments for an interpreter that are indexed by the types of the values found in them). Overloaded strings are useful in contexts where there are embedded external strings, but this seems less compelling, because these contexts are likely to be under the control of a macro anyway.</p>\n<p>In any case, it would be nice to know why the system is as it is.</p>\n<p>Thanks!</p>",
        "id": 281731933,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1652123606
    },
    {
        "content": "<p>Technically speaking there is absolutely nothing stopping you from writing your own elaborator that define the semantics of list literals and build that semantic in a way that allows overloading, all syntax is overridable.</p>",
        "id": 281737913,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1652126362
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List.nil</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[]</span> <span class=\"bp\">==</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>yields true.</p>",
        "id": 281738616,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1652126666
    },
    {
        "content": "<p>Lean 4 supports both ad-hoc overloading and typeclass-based overloading. TC-based polymorphism has many advantages, but some limitations too. For example: it forces the overloads to have a \"similar shape\". We also use expected type-based overloading where we use the expected type to provide the name of a namespace where we expect to have operations (e.g., the expected type is <code>Foo ...</code>, we could check whether we have <code>Foo.cons</code> and <code>Foo.nil</code> and build the list literal using them).<br>\nHere is the <code>[ ... ]</code> notation for <code>Vector</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"o\">)</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"]\"</span>  <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elems.getElems.foldrM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Vector.nil</span><span class=\"o\">)))</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>One can also use scoped parsers and priorities, and make sure, for example, <code>[ ... ]</code> is always a <code>Vector</code>.</p>",
        "id": 281738848,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1652126777
    },
    {
        "content": "<p>:O how does it figure out when to use the vector vs the regular list macro?</p>",
        "id": 281739242,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1652126966
    },
    {
        "content": "<p>The parser creates a <code>Choice</code> node for the overloaded notation. The elaborator tries to elaborate both of them. If only one succeeds, it uses it. If more than one, then it generates an \"ambiguous\" error. In the example above, if we add </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>we get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">ambiguous</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">interpretations</span>\n  <span class=\"n\">Vector.cons</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"bp\">?</span><span class=\"n\">m.1531</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n  <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"bp\">?</span><span class=\"n\">m.1575</span>\n</code></pre></div>",
        "id": 281739710,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1652127167
    },
    {
        "content": "<p>Here is the scoped + priority approach for temporarily overriding notation</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">VectorNotation</span>\n\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"]\"</span>  <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elems.getElems.foldrM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Vector.nil</span><span class=\"o\">)))</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">VectorNotation</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">VectorNotation</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"c1\">-- ys is a List</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">VectorNotation</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">zs</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"c1\">-- zs is a Vector</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">zs</span>\n<span class=\"c1\">-- Vector Nat (0+1+1+1)</span>\n</code></pre></div>",
        "id": 281740889,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1652127798
    },
    {
        "content": "<p>Thanks, this is really helpful! This might be a good example for the manual - I think it very clearly illustrates something interesting and useful.</p>\n<p>Have you encountered problems with nested elaborators with <code>Choice</code> nodes leading to quadratic blow-ups of elaboration time?</p>",
        "id": 281944665,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1652264904
    },
    {
        "content": "<p>Here's an example of something that stays orange for a long time on my machine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"s2\">\"S\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"s2\">\"S\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">Nat.zero</span>\n</code></pre></div>\n<p>Not only is elaboration very slow, but the quadratically-growing error message causes challenges for at least the Emacs mode.</p>\n<p>I suppose the answer is akin to the old joke: \"Doctor, it hurts when I raise my arm!\" \"Then don't do it!\"</p>",
        "id": 281945336,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1652265360
    },
    {
        "content": "<p>(I could see something like this coming up if writing down a typing context using ordinary notation, as a snoc list that grows to the right, in a module that defines two variations of contexts (e.g. one for variables, one for the kinds of type variables))</p>",
        "id": 281945695,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1652265580
    },
    {
        "content": "<blockquote>\n<p>Have you encountered problems with nested elaborators with Choice nodes leading to quadratic blow-ups of elaboration time?</p>\n</blockquote>\n<p>Not really, but it is the least used form of overloading. The most used is typeclass-based overloading by far. In the \"second\" place, we have type-based overloading. Here is an example of type-based overloading: the <code>a[i]</code> notation. Lean infers the type of <code>a</code>, suppose it is <code>C ...</code>, then it looks for a function named <code>C.getOp</code>, and then expands the term to <code>C.getOp (self := a) (idx := i)</code>.<br>\nWe do use ad-hoc polymorphism in examples such as the typed interpreter example: <a href=\"https://github.com/leanprover/lean4/blob/master/doc/examples/interp.lean\">https://github.com/leanprover/lean4/blob/master/doc/examples/interp.lean</a><br>\nwhere <code>::</code> is notation for <code>List.cons</code>, <code>Vector.cons</code>, and <code>Env.con</code>. Everything is fast there because we do not build big \"lists\" using them.<br>\nThe <code>Choice</code> node also works well if all but one alternative fail quickly. That is, there is enough contextual information for quickly discarding alternatives. This is not the case in your example since the two different <code>S</code>expand to the same thing. <br>\nThere is also room for improving the performance of <code>Choice</code> node elaboration by implementing more aggressive alternative pruning.<br>\nWe can also address the big error messages and suppress irrelevant information. However, I see it as a very low priority right now, since users are not currently hitting this problem in real examples.</p>",
        "id": 281965289,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1652275861
    }
]
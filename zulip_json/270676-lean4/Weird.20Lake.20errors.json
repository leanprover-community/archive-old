[
    {
        "content": "<p>I just migrated doc-gen4 to the 06-30 nightly on this branch: <a href=\"https://github.com/leanprover/doc-gen4/tree/update\">https://github.com/leanprover/doc-gen4/tree/update</a> but had to do this blindly since both vscode and emacs kept shooting:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2022-06-30/bin/lake print-paths Init DocGen4.Process DocGen4.Load DocGen4.IncludeStr DocGen4.Output DocGen4.LeanInk` failed:</span>\n\n<span class=\"n\">stderr</span><span class=\"o\">:</span>\n<span class=\"n\">warning</span><span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"n\">for</span> <span class=\"n\">package</span> <span class=\"n\">dependencies</span> <span class=\"n\">has</span> <span class=\"n\">changed.</span> <span class=\"n\">Use</span> <span class=\"n\">the</span> <span class=\"n\">new</span> <span class=\"bp\">`</span><span class=\"n\">require</span><span class=\"bp\">`</span> <span class=\"n\">syntax.</span>\n<span class=\"n\">warning</span><span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"n\">for</span> <span class=\"n\">package</span> <span class=\"n\">dependencies</span> <span class=\"n\">has</span> <span class=\"n\">changed.</span> <span class=\"n\">Use</span> <span class=\"n\">the</span> <span class=\"n\">new</span> <span class=\"bp\">`</span><span class=\"n\">require</span><span class=\"bp\">`</span> <span class=\"n\">syntax.</span>\n</code></pre></div>\n<p>at me and refused to analyze anything in the file. Funnily enough if I execute this command myself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2022-06-30/bin/lake print-paths Init DocGen4.Process DocGen4.Load DocGen4.IncludeStr DocGen4.Output DocGen4.LeanInk</span>\n<span class=\"o\">{</span><span class=\"s2\">\"srcPath\"</span><span class=\"o\">:[</span><span class=\"s2\">\"./lean_packages/Cli/./.\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/leanInk/./.\"</span><span class=\"o\">,</span><span class=\"s2\">\"./.\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/Unicode/./.\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/mathlib/./.\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/lake/./.\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/CMark/./.\"</span><span class=\"o\">],</span><span class=\"s2\">\"oleanPath\"</span><span class=\"o\">:[</span><span class=\"s2\">\"./lean_packages/Cli/./build/lib\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/leanInk/./build/lib\"</span><span class=\"o\">,</span><span class=\"s2\">\"./build/lib\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/Unicode/./build/lib\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/mathlib/./build/lib\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/lake/./build/lib\"</span><span class=\"o\">,</span><span class=\"s2\">\"./lean_packages/CMark/./build/lib\"</span><span class=\"o\">],</span><span class=\"s2\">\"loadDynlibPaths\"</span><span class=\"o\">:[]}</span>\n</code></pre></div>\n<p>I can see no error message at all, I already tried to delete the build and lean_package directories etc. but nothing changed so I fixed the things using <code>lake build</code> + vim in the hopes that it will disappear after the build works again but nope, I'm still stuck in this state. What am I doing wrong?</p>",
        "id": 288328342,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656855819
    },
    {
        "content": "<p>To add to this error I get from my emacs I'm now also observing segfaults when running doc-gen4, even just against a <code>lake new</code> test project (with fitting compiler version of course):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"mi\">0</span>  <span class=\"mi\">0x0000000003898ba2</span> <span class=\"k\">in</span> <span class=\"n\">l_Lake_WfName_ofName</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">1</span>  <span class=\"mi\">0x00000000038e2ee8</span> <span class=\"k\">in</span> <span class=\"n\">l_Lake_Package_loadUnsafe___lambda__1</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">2</span>  <span class=\"mi\">0x00000000038e3cf3</span> <span class=\"k\">in</span> <span class=\"n\">l_Lake_Package_loadUnsafe___lambda__2</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">3</span>  <span class=\"mi\">0x00000000038e5290</span> <span class=\"k\">in</span> <span class=\"n\">l_Lake_Package_loadUnsafe</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">4</span>  <span class=\"mi\">0x000000000386615f</span> <span class=\"k\">in</span> <span class=\"n\">l_Lake_loadWorkspace</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">5</span>  <span class=\"mi\">0x0000000003709a72</span> <span class=\"k\">in</span> <span class=\"n\">l_DocGen4_lakeSetup</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">6</span>  <span class=\"mi\">0x00000000036feb62</span> <span class=\"k\">in</span> <span class=\"n\">l_runDocGenCmd</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">7</span>  <span class=\"mi\">0x0000000005e6ab18</span> <span class=\"k\">in</span> <span class=\"n\">lean_apply_2</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">8</span>  <span class=\"mi\">0x0000000005e6afe9</span> <span class=\"k\">in</span> <span class=\"n\">lean_apply_2</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">9</span>  <span class=\"mi\">0x0000000005e6ad20</span> <span class=\"k\">in</span> <span class=\"n\">lean_apply_2</span> <span class=\"o\">()</span>\n<span class=\"bp\">#</span><span class=\"mi\">10</span> <span class=\"mi\">0x000000000370064e</span> <span class=\"k\">in</span> <span class=\"n\">main</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>coming from this line: <a href=\"https://github.com/leanprover/doc-gen4/blob/update/DocGen4/Load.lean#L26\">https://github.com/leanprover/doc-gen4/blob/update/DocGen4/Load.lean#L26</a> which used to work perfectly fine until this update. Am I doing something wrong here as well? Most likely <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> will know</p>",
        "id": 288328987,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656856795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288328342\">said</a>:</p>\n<blockquote>\n<p>I just migrated doc-gen4 to the 06-30 nightly on this branch: <a href=\"https://github.com/leanprover/doc-gen4/tree/update\">https://github.com/leanprover/doc-gen4/tree/update</a> but had to do this blindly since both vscode and emacs kept shooting:</p>\n</blockquote>\n<p>This is very weird because there were no changes to the bundled Lake between the Lean version on main (06-24) and 06-30.</p>",
        "id": 288348204,
        "sender_full_name": "Mac",
        "timestamp": 1656883403
    },
    {
        "content": "<p>Can you at least reproduce it on your machine?</p>",
        "id": 288348260,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656883449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Yep, I was able to reproduce the segfault. I think the problem is clash between the Lake version distributed with Lean and the one you are depending on. You need to depend on the Lake version of your Lean version (i.e., <code>401e738e4ca989ced8d9bb0cf7f66be9133fc435</code> / <code>tsyntax</code>).</p>",
        "id": 288357170,
        "sender_full_name": "Mac",
        "timestamp": 1656897124
    },
    {
        "content": "<p>I would also advise trying to update to the latest nightly as opposed to an old one.</p>",
        "id": 288357187,
        "sender_full_name": "Mac",
        "timestamp": 1656897189
    },
    {
        "content": "<p>I'm always trying to update to the nightly that is in sync with the one of mathlib to avoid ABI issues when building mathlib.... testing the other lake commit, I thought I already got the right one :/</p>",
        "id": 288373471,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656918462
    },
    {
        "content": "<p>Okay that did indeed fix both issues. Do you have any idea why my emacs started throwing this error message at me? And how we could at least improve it in the future? This seems near impossible to debug without the correct guess.</p>",
        "id": 288373725,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656918665
    },
    {
        "content": "<p>Sadly, no. I have no idea why the bugs appeared, I was just able to figure out how to fix them by guessing that the version mismatch may be causing problems.</p>",
        "id": 288380324,
        "sender_full_name": "Mac",
        "timestamp": 1656923073
    },
    {
        "content": "<p>If we could narrow down the source of the problem though, that might help me figure out what it is and fix it. A <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would be quite helpful -- doc-gen4 is a big project with a lot of dependencies and many moving parts which make it hard to debug what part of the build system is failing (and if that is even the source of the problem).</p>",
        "id": 288381426,
        "sender_full_name": "Mac",
        "timestamp": 1656923757
    },
    {
        "content": "<p>One of the problems I did have when inspected doc-gen4 was that I got a n error saying that the <code>Lake.olean</code>  object file did not exists. This one I do know the cause of and it was already fixed (hopefully) in v3.2.0. The problem is the Lake would use the workspace's Lake module to evaluate the lakefile rather than the builtin one. For instance, it would use the Lake required by doc-gen4 rather than the Lake in the toolchain, which could cause all kinds of errors. That may also be the source of your editor woes, but I am not sure (since your error looks different).</p>",
        "id": 288382118,
        "sender_full_name": "Mac",
        "timestamp": 1656924230
    },
    {
        "content": "<p>Note: <strong>Doc-gen4 may also have this bug</strong> as it initializes the search path using <code>initSearchPath</code> which similarly prioritizes user modules over builtin ones.</p>",
        "id": 288382543,
        "sender_full_name": "Mac",
        "timestamp": 1656924486
    },
    {
        "content": "<p>It also uses <code>findSysroot</code> rather than just using the sysroot of the Lean found by Lake(i.e., <code>lean.sysroot</code>) which is a bit weird.</p>",
        "id": 288382649,
        "sender_full_name": "Mac",
        "timestamp": 1656924572
    },
    {
        "content": "<p>More generally, there is no reason to initialize the search path in doc-gen4 anyway since you call out to <code>Lake.loadWorkspace</code> which already initializes the search path itself.</p>",
        "id": 288382860,
        "sender_full_name": "Mac",
        "timestamp": 1656924707
    },
    {
        "content": "<p>The main reason I started using Lake as a library instead of calling to it as a foreign binary was that I wanted to add the links to the source of the libraries which required me to interact with the Lake project structure in order to figure out the remote urls (here: <a href=\"https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean\">https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean</a>). If I could somehow get this information without depending on <code>Lake.loadWorkspace</code> to give me the workspace I can fetch this information from I would gladly avoid pulling in Lake as yet another dependency.</p>\n<p>I'll remove the initSearchPath then, thank you^^</p>",
        "id": 288382986,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656924759
    },
    {
        "content": "<p>Also, sorry for the stream of consciousness critique. I don't mean to be critical. I am just noting down oddities as I see them in a (hopefully not vain attempt) to stumble upon whatever may be the bug.</p>",
        "id": 288383076,
        "sender_full_name": "Mac",
        "timestamp": 1656924837
    },
    {
        "content": "<p>No worries, my interactions with lake have always been on a eh... \"it works, commit it\" basis so its good if someone cleans it up :D</p>",
        "id": 288383428,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656925038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288382986\">said</a>:</p>\n<blockquote>\n<p>to figure out the remote urls</p>\n</blockquote>\n<p>One super low-tech, hacky way to do this without Lake would be to just iterate over the directories in <code>lean_packages</code> and capture the output of <code>git remote get-url origin</code>. However, using Lake for this is probably a more principled solution. On the other hand, it may be worth it to create some Lake CLI command (ala <code>print-paths</code>) that outputs a JSON blob containing the information you want from Lake.</p>",
        "id": 288383567,
        "sender_full_name": "Mac",
        "timestamp": 1656925119
    },
    {
        "content": "<p>Now, removing the initSearchPath call causes the CI to fail: <a href=\"https://github.com/leanprover/doc-gen4/runs/7177244361?check_suite_focus=true\">https://github.com/leanprover/doc-gen4/runs/7177244361?check_suite_focus=true</a> because it cannot find Mathlib as a library so that did not work out.</p>",
        "id": 288383660,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656925171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288383567\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288382986\">said</a>:</p>\n<blockquote>\n<p>to figure out the remote urls</p>\n</blockquote>\n<p>One super low-tech, hacky way to do this without Lake would be to just iterate over the directories in <code>lean_packages</code> and capture the output of <code>git remote get-url origin</code>. However, using Lake for this is probably a more principled solution. On the other hand, it may be worth it to create some Lake CLI command (ala <code>print-paths</code>) that outputs a JSON blob containing the information you want from Lake.</p>\n</blockquote>\n<p>What part of that is missing from the new <code>manifest.json</code>?</p>",
        "id": 288383790,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656925224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288383660\">said</a>:</p>\n<blockquote>\n<p>Now, removing the initSearchPath call causes the CI to fail: <a href=\"https://github.com/leanprover/doc-gen4/runs/7177244361?check_suite_focus=true\">https://github.com/leanprover/doc-gen4/runs/7177244361?check_suite_focus=true</a> because it cannot find Mathlib as a library so that did not work out.</p>\n</blockquote>\n<p>It's also noting that it is loading its oleans from here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Loading</span> <span class=\"n\">modules</span> <span class=\"k\">from</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">runner</span><span class=\"bp\">/</span><span class=\"n\">work</span><span class=\"bp\">/</span><span class=\"n\">doc</span><span class=\"bp\">-</span><span class=\"n\">gen4</span><span class=\"bp\">/</span><span class=\"n\">doc</span><span class=\"bp\">-</span><span class=\"n\">gen4</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"o\">,</span> <span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">runner</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2022-06-30/lib/lean]</span>\n</code></pre></div>\n<p>So it somehow remembered where it was built in even.</p>",
        "id": 288383999,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656925343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288383790\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288383567\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288382986\">said</a>:</p>\n<blockquote>\n<p>to figure out the remote urls</p>\n</blockquote>\n<p>One super low-tech, hacky way to do this without Lake would be to just iterate over the directories in <code>lean_packages</code> and capture the output of <code>git remote get-url origin</code>. However, using Lake for this is probably a more principled solution. On the other hand, it may be worth it to create some Lake CLI command (ala <code>print-paths</code>) that outputs a JSON blob containing the information you want from Lake.</p>\n</blockquote>\n<p>What part of that is missing from the new <code>manifest.json</code>?</p>\n</blockquote>\n<p>True, that does seem to contain almost the informations I need. There is one thing missing though, in my source linker I perform this check: <a href=\"https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean#L78\">https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean#L78</a> which attempts to find which lake package a certain module came from in order to use the correct remote URL, that's missing still.</p>",
        "id": 288384274,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656925522
    },
    {
        "content": "<p>Also if i end up parsing this JSON I have an other more general question: Both with LeanInk and Lake I would end up parsing some JSON files. This is just some data stuff but I'd hate to replicate the code from both other libraries to doc-gen which is also the reson it is pulling in LeanInk as a foreign library right now (the actual LeanInk work is done by a real LeanInk binary). Do we have some nice solution to this idea of just importing the data representation of something? Maybe splitting up libraries?</p>",
        "id": 288385639,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656926416
    },
    {
        "content": "<p>You only really pay for the <code>import</code>s you actually use from a dependency, so moving those data structures into separate modules should be sufficient I think</p>",
        "id": 288386065,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656926685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288384274\">said</a>:</p>\n<blockquote>\n<p>There is one thing missing though, in my source linker I perform this check: <a href=\"https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean#L78\">https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean#L78</a> which attempts to find which lake package a certain module came from in order to use the correct remote URL, that's missing still.</p>\n</blockquote>\n<p>How about a <code>lake graph &lt;mods&gt;</code> that prints out all the information about the dependency graph of mods (package, imports, source file, olean file, ilean file, etc.). Does that sound like a generally useful tool?</p>",
        "id": 288443983,
        "sender_full_name": "Mac",
        "timestamp": 1656963496
    },
    {
        "content": "<p>Definitely yeah, we could even have some tool that processes this (presumably JSON?) output to a dot file or w/e to visualize dependencies</p>",
        "id": 288444931,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656964237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288382986\">said</a>:</p>\n<blockquote>\n<p>I'll remove the initSearchPath then, thank you^^</p>\n</blockquote>\n<p>I just realized gave you bad advice here. Lake does initialize the search path itself. However, it does not initialize it with the workspace's olean directories, which is what you want. So you do need to initialize the search path yourself.  Using <code>initSearchPath</code>, though can lead to the problem I mentioned (prioritizing user modules over built-in ones) so you will need to rolll your own like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">sp</span> <span class=\"o\">:</span> <span class=\"n\">Lean.SearchPath</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"n\">sp</span> <span class=\"bp\">←</span> <span class=\"n\">addSearchPathFromEnv</span> <span class=\"n\">sp</span>\n<span class=\"n\">sp</span> <span class=\"o\">:=</span> <span class=\"n\">lake.oleanDir</span> <span class=\"o\">::</span> <span class=\"n\">lean.oleanDir</span> <span class=\"o\">::</span> <span class=\"n\">sp</span>\n<span class=\"n\">sp</span> <span class=\"o\">:=</span> <span class=\"n\">ws.oleanPath</span> <span class=\"bp\">++</span> <span class=\"n\">sp</span>\n<span class=\"n\">searchPathRef.set</span> <span class=\"n\">sp</span>\n</code></pre></div>",
        "id": 288460801,
        "sender_full_name": "Mac",
        "timestamp": 1656977461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288443983\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288384274\">said</a>:</p>\n<blockquote>\n<p>There is one thing missing though, in my source linker I perform this check: <a href=\"https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean#L78\">https://github.com/leanprover/doc-gen4/blob/main/DocGen4/Output/SourceLinker.lean#L78</a> which attempts to find which lake package a certain module came from in order to use the correct remote URL, that's missing still.</p>\n</blockquote>\n</blockquote>\n<p>Regarding this, I also have another idea that lake might be able to address. In doc-gen4 and by now also in other projects my include_str macro for statically reading a file at compile time into a static Lean string has spread. But the issue to this day remains that the Lean compiler has of course no clue that this file is part of its dependency chain and thus the lean files that include it should be rebuilt. Could we maybe have some mechanism to explicitly add nodes to the dependency graph? So in this case e.g. tell Lake that if style.css is more recently touched than StaticStrings.lean rebuild StaticStrings.lean?....although at this point we are basically a full blown make :D<br>\nHow about a <code>lake graph &lt;mods&gt;</code> that prints out all the information about the dependency graph of mods (package, imports, source file, olean file, ilean file, etc.). Does that sound like a generally useful tool?</p>",
        "id": 288513950,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657020668
    },
    {
        "content": "<p>(Template Haskell has <a href=\"https://hackage.haskell.org/package/template-haskell-2.18.0.0/docs/Language-Haskell-TH-Syntax.html#v:addDependentFile\"><code>addDependentFile</code></a> etc. to address this issue.)</p>",
        "id": 288518797,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1657023279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/288513950\">said</a>:</p>\n<blockquote>\n<p>But the issue to this day remains that the Lean compiler has of course no clue that this file is part of its dependency chain and thus the lean files that include it should be rebuilt. </p>\n</blockquote>\n<p>And that issue is logged here: <a href=\"https://github.com/leanprover/lake/issues/86\">https://github.com/leanprover/lake/issues/86</a> <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 288577150,
        "sender_full_name": "Mac",
        "timestamp": 1657047083
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> , it looks like in Lake 4.0 there is no <code>target</code> property on targets. How can I use another target as a dep now, as in <a href=\"https://github.com/EdAyers/lean4-samples/blob/0abeda1ff93dbce3bd43e966af28471abb33a9bf/RubiksCube/lakefile.lean#L25\">here</a>?</p>",
        "id": 292311956,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659867823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> That is because that entire notion of targets no longer exists (including <code>FileTarget</code>).</p>",
        "id": 292345837,
        "sender_full_name": "Mac",
        "timestamp": 1659912651
    },
    {
        "content": "<p>See the updated FFI <a href=\"https://github.com/leanprover/lake/blob/b899c0abac7d6c7ad69c06cd5b7964ac5684d3f0/examples/ffi/lib/lakefile.lean\">example</a> for example as to how to use another target as a dep. (You build it with <code>fetch &lt;| pkg.target &lt;target-name&gt;</code>).</p>",
        "id": 292345920,
        "sender_full_name": "Mac",
        "timestamp": 1659912798
    },
    {
        "content": "<p>From looking at your example, I realized that you really needed the feature mentioned in your <a href=\"https://github.com/leanprover/lake/issues/86#issuecomment-1185028364\">#86 comment</a>. Sadly, it is not there yet as I did not realize it was that pivotal. I will try to implement it 2 weeks from now when I have some free time (and will be trying to ensure everything is ship-shape for Lake).</p>",
        "id": 292346314,
        "sender_full_name": "Mac",
        "timestamp": 1659913298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292346314\">said</a>:</p>\n<blockquote>\n<p>See the updated FFI <a href=\"https://github.com/leanprover/lake/blob/b899c0abac7d6c7ad69c06cd5b7964ac5684d3f0/examples/ffi/lib/lakefile.lean\">example</a> for example as to how to use another target as a dep. (You build it with <code>fetch &lt;| pkg.target &lt;target-name&gt;</code>).</p>\n</blockquote>\n<p>I saw that example, but unfortunately it does not work. We get the following error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tsxTarget</span> <span class=\"o\">(</span><span class=\"n\">pkg</span> <span class=\"o\">:</span> <span class=\"n\">Package</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tsxName</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IndexBuildM</span> <span class=\"o\">(</span><span class=\"n\">BuildJob</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">data</span> <span class=\"bp\">←</span> <span class=\"n\">fetch</span> <span class=\"o\">(</span><span class=\"n\">pkg.target</span> <span class=\"bp\">``</span><span class=\"n\">packageLock</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">deps</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">BuildJob</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> application type mismatch</span>\n<span class=\"cm\">      List.cons data</span>\n<span class=\"cm\">    argument</span>\n<span class=\"cm\">      data</span>\n<span class=\"cm\">    has type</span>\n<span class=\"cm\">      CustomData (Package.name pkg, `packageLock) : Type</span>\n<span class=\"cm\">    but is expected to have type</span>\n<span class=\"cm\">      BuildJob FilePath : Type -/</span>\n    <span class=\"n\">data</span>\n  <span class=\"o\">]</span>\n</code></pre></div>\n<p>It does work if I put this code inside a <code>target rubiksTarget (pkg : Package) : FilePath</code>, but then I no longer have a single and reusable <code>tsxTarget</code> which is polymorphic over the <code>tsxName : Name</code> of the file to build. I think the reason why <code>target rubiksTarget</code> works is thanks to the custom elaborator which inserts the right value for <code>pkg</code> that makes the <code>fetch</code> open family give the right type. This brings me to, not to bash your work as overall Lake is great, but I'm sorry to say I think the open family API is a mistake. It uses really advanced language features in a user-facing part of a build system, and it's guaranteed to cause lots of confusion, as well as errors like the one we see above. The API in Lake 3 wherein we simply got a <code>BuildTarget FilePath</code> (or whatever wrapper around a <em>concrete</em> type <code>FilePath</code>) out of the plain <code>def</code> created by <code>target packageLock</code> was easier to use.</p>",
        "id": 292368790,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659943737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292368790\">said</a>:</p>\n<blockquote>\n<p>The API in Lake 3 wherein we simply got a <code>BuildTarget FilePath</code> (or whatever wrapper around a <em>concrete</em> type <code>FilePath</code>) out of the plain <code>def</code> created by <code>target packageLock</code> was easier to use.</p>\n</blockquote>\n<p>The problem with this is that API was broken. It was not (and could not be) properly integrated with the build store so the same target could end up being rebuilt multiple times (and separate builds could race with each other). It only worked in its very limited application because the targets being used (e.g., <code>extern_lib</code>, <code>extraDepTarget</code>) were not meant to depend on each other. </p>\n<p>However, in your case, you were already violating this assumption. So, if the library was building multiple TSX targets at once, it would attempt to build <code>packageLock</code> multiple times simultaneously, which could cause problems. Even if bugs did not emerge, such rebuilds also are performance hits.</p>",
        "id": 292498276,
        "sender_full_name": "Mac",
        "timestamp": 1659993681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292368790\">said</a>:</p>\n<blockquote>\n<p>It uses really advanced language features in a user-facing part of a build system, and it's guaranteed to cause lots of confusion, as well as errors like the one we see above.</p>\n</blockquote>\n<p>It should be noted that custom targets are not really meant to be a novice user-facing part of the system. After all, writing them requires looking into Lake's source code and understanding the internal Build API (or, previously, the Target API). It is meant for advanced users who want as much power as they can get.</p>",
        "id": 292498660,
        "sender_full_name": "Mac",
        "timestamp": 1659993898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292368790\">said</a>:</p>\n<blockquote>\n<p>I think the reason why <code>target rubiksTarget</code> works is thanks to the custom elaborator which inserts the right value for <code>pkg</code> that makes the <code>fetch</code> open family give the right type.</p>\n</blockquote>\n<p>You are mostly correct, the problem with your general solution is that it does not necessarily ensure that the <code>pkg</code> is the right package, which the <code>target</code> does ensure. You can however replicate this by mirroring the <code>target</code>'s function signature. That is, add a <code>[Fact (pkg.name = _package.name)]</code> argument to <code>tsxTarget</code>.</p>",
        "id": 292499086,
        "sender_full_name": "Mac",
        "timestamp": 1659994164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292368790\">said</a>:</p>\n<blockquote>\n<p>The API in Lake 3 wherein we simply got a <code>BuildTarget FilePath</code> (or whatever wrapper around a <em>concrete</em> type <code>FilePath</code>) out of the plain <code>def</code> created by <code>target packageLock</code> was easier to use.</p>\n</blockquote>\n<p>Note that <code>target</code> still generates just as plain of a definition as the previous Lake 3 <code>target</code> command did. It is still just a macro, no custom elaboration shenanigans.</p>",
        "id": 292500131,
        "sender_full_name": "Mac",
        "timestamp": 1659994709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292499086\">said</a>:</p>\n<blockquote>\n<p>That is, add a <code>[Fact (pkg.name = _package.name)]</code> argument to <code>tsxTarget</code>.</p>\n</blockquote>\n<p>Fyi, in case you are curious as to why you need to do this. The problem is rather straightforward: the target in question (e.g., <code>packageLock</code>) is only available on package you are defining, not other packages (e.g., dependencies, dependents) -- thus you need to ensure the package being passed to <code>tsxTarget</code> is the current package, not some other package (and this is what the <code>Fact</code> does).</p>",
        "id": 292500997,
        "sender_full_name": "Mac",
        "timestamp": 1659995183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292368790\">said</a>:</p>\n<blockquote>\n<p>not to bash your work as overall Lake is great</p>\n</blockquote>\n<p>No worries. Feel free to critique away! (Though, I will, of course, not always agree.)</p>",
        "id": 292504186,
        "sender_full_name": "Mac",
        "timestamp": 1659997086
    },
    {
        "content": "<blockquote>\n<p>It should be noted that custom targets are not really meant to be a novice user-facing part of the system.</p>\n</blockquote>\n<p>Let me push back a bit on this. Being able to write down a few commands and state \"these produce file <code>foo</code>\", then another few commands and state \"these produce <code>bar</code> but make sure <code>foo</code> is built first\" is <strong>the most basic</strong> functionality of a build system. This is trivial to do in Make and it should be easy in Lake. All the nice features for auto-building Lean modules, shared libraries and so on are conceptually sugar on top of this. I totally understand that there are engineering constraints such as the target duplication you mention that can make (hah) a good balance difficult to achieve, but I think we should err on the side of simplicity.</p>\n<blockquote>\n<p>You can however replicate this by mirroring the <code>target</code>'s function signature. That is, add a <code>[Fact (pkg.name = _package.name)]</code> argument to <code>tsxTarget</code>.</p>\n</blockquote>\n<p>So to ensure that the <code>pkg</code> argument I get is my package, I need to synthesize a propositional equation through typeclass inference so that more typeclass inference can use a value-indexed dependent type family to synthesize the right type for the path of my file? I'm sorry, I just think this is way too complicated. Setting up a build script for a project is often the first step one takes in trying out a new language, and it is easy to get discouraged - I know I have. I don't think doing this should require a PhD in type theory.</p>\n<blockquote>\n<p>you need to ensure the package being passed to <code>tsxTarget</code> is the current package, not some other package (and this is what the <code>Fact</code> does)</p>\n</blockquote>\n<p>I understand, thank you for explaining. My point is mostly about the mechanism by which this is ensured.</p>\n<p>So far this was not very constructive. I don't understand the internals enough to really propose something, but perhaps:</p>\n<ul>\n<li>could we have a global <code>__package__</code>, like the global <code>__dir__</code>? There is some disconnect in that the latter is global, whereas the former is given as an argument.</li>\n<li>whatever the API, could we hide the name-indexing families as an implementation detail and keep only concrete <code>Type</code>s (of course modulo monadic wrappers which are unavoidable) in the user-facing API? Hopefully I highlighted above why simplicity seems important to me here.</li>\n</ul>\n<p>And let me say again -- thank you for all your work spent on Lake! It really does work very well, and was clearly a lot of effort. It is just this one corner I am complaining about :)</p>",
        "id": 292504234,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659997127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292504234\">said</a>:</p>\n<blockquote>\n<ul>\n<li>could we have a global <code>__package__</code>, like the global <code>__dir__</code>? There is some disconnect in that the latter is global, whereas the former is given as an argument.</li>\n</ul>\n</blockquote>\n<p>No, this is impossible, because the <code>Package</code> object can only be constructed after the whole Lakefile is elaborate (and dependencies are resolved, etc.). The pattern here is that of <a href=\"https://en.wikipedia.org/wiki/Dependency_injection\">dependency injection</a>, which is a very common pattern for systems with dynamic dependencies like a build system.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292504234\">said</a>:</p>\n<blockquote>\n<ul>\n<li>whatever the API, could we hide the name-indexing families as an implementation detail and keep only concrete <code>Type</code>s (of course modulo monadic wrappers which are unavoidable) in the user-facing API? Hopefully I highlighted above why simplicity seems important to me here.</li>\n</ul>\n</blockquote>\n<p>This is specifically what <code>target</code> is intended to do, hide the ugliness.. You broke this by defining a separate <code>def</code> (such parameterization is non-trivial even in make). I am still not sure what you mean by concrete <code>Type</code>s, everything here is concrete (i.e., <code>target</code> has a concrete signature)?</p>",
        "id": 292504897,
        "sender_full_name": "Mac",
        "timestamp": 1659997522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292504234\">said</a>:</p>\n<blockquote>\n<p>Being able to write down a few commands and state \"these produce file <code>foo</code>\", then another few commands and state \"these produce <code>bar</code> but make sure <code>foo</code> is built first\" is <strong>the most basic</strong> functionality of a build system. This is trivial to do in Make and it should be easy in Lake.</p>\n</blockquote>\n<p>I agree. However, the arbitrary build system portion of Lake was not initially its primary purpose, and is essentially a new feature implemented this summer. It is thus very much in its infancy and thus missing many niceties. I plan on improving this part as more use cases are found and better idea of what is desired is established.</p>\n<p>Thus, the following statement is not really true:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292504234\">said</a>:</p>\n<blockquote>\n<p>All the nice features for auto-building Lean modules, shared libraries and so on are conceptually sugar on top of this.</p>\n</blockquote>\n<p>In fact, as originally designed, the arbitrary build support was largely a hack to support a few specific use cases -- the building Lean modules was the core system. It is only with the Lake v4 overhaul that building Lean modules are really a convivence layer on top of the arbitrary builds.</p>",
        "id": 292505646,
        "sender_full_name": "Mac",
        "timestamp": 1659997985
    },
    {
        "content": "<blockquote>\n<p>This is specifically what <code>target</code> is intended to do, hide the ugliness.. You broke this by defining a separate <code>def</code> (such parameterization is non-trivial even in make). </p>\n</blockquote>\n<p>Here is a Makefile doing what I would like to:</p>\n<div class=\"codehilite\" data-code-language=\"Makefile\"><pre><span></span><code><span class=\"nf\">.PHONY</span><span class=\"o\">:</span> <span class=\"n\">all</span>\n<span class=\"nf\">all</span><span class=\"o\">:</span> <span class=\"n\">dist</span>/<span class=\"n\">rubiks</span>.<span class=\"n\">js</span>\n\n<span class=\"nf\">package-lock.json</span><span class=\"o\">:</span> <span class=\"n\">package</span>.<span class=\"n\">json</span>\n        npm install\n\n<span class=\"nf\">dist/%.js</span><span class=\"o\">:</span> <span class=\"n\">src</span>/%.<span class=\"n\">tsx</span> <span class=\"n\">package</span>-<span class=\"n\">lock</span>.<span class=\"n\">json</span> <span class=\"n\">rollup</span>.<span class=\"n\">config</span>.<span class=\"n\">js</span> <span class=\"n\">tsconfig</span>.<span class=\"n\">json</span>\n        npm run build -- --tsxName <span class=\"k\">$(</span>basename <span class=\"k\">$(</span>notdir <span class=\"nv\">$@</span><span class=\"k\">))</span>\n</code></pre></div>\n<blockquote>\n<p>I am still not sure what you mean by concrete <code>Type</code>s, everything here is concrete (i.e., <code>target</code> has a concrete signature)</p>\n</blockquote>\n<p>I wasn't specific enough, sorry. I meant a dependent type, basically. In particular <code>opaque CustomData (target : Name × Name) : Type</code> which appeared in the error message I originally got.</p>",
        "id": 292506574,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659998566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292504234\">said</a>:</p>\n<blockquote>\n<p>I'm sorry, I just think this is way too complicated. Setting up a build script for a project is often the first step one takes in trying out a new language, and it is easy to get discouraged - I know I have. I don't think doing this should require a PhD in type theory.</p>\n</blockquote>\n<p>I am not sure I agree with this framing. Most arbitrary build systems are not what I call easy-to-use for beginners (Rake, CMake, Make, Shake, etc.). Generally, there is a simple default template beginners use and then very complicate build magic that experts use. Just look at Lean's CMake configuration -- not something I think a beginner would ever be able to comprehend.</p>\n<p>Now, I don't think this is necessarily good, so I would very much like to make Lake as user-friendly as possible. But, I do not think arbitrary build scripts are generally meant for beginners, that is what the pretty declarative library and executable configurations are for. The build scripts are meant to be written by users with a strong grasp of Lean who need specific build magic on their unique project (like you do, with the complicated magic of widgets).</p>",
        "id": 292506659,
        "sender_full_name": "Mac",
        "timestamp": 1659998633
    },
    {
        "content": "<blockquote>\n<p>However, the arbitrary build system portion of Lake was not initially its primary purpose, and is essentially a new feature implemented this summer. It is thus very much in its infancy and thus missing many niceties.</p>\n</blockquote>\n<p>Totally understandable! This is not easy. I think my frustration here is mostly about the fact that something which used to work now doesn't seem to, insofar as I don't think I would have been able to figure this out without your help.</p>",
        "id": 292506767,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659998694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292506574\">said</a>:</p>\n<blockquote>\n<p>Here is a Makefile doing what I would like to</p>\n</blockquote>\n<p>Yes, your particular case can be done concisely in Make because of its <code>%</code> magic for file names. However, were the input and output file names not directly related in this manner, parameterization would not be so easy. Which is kind of my point, build systems generally introduce some magic to make common applications easier, but once you leave these bounds, things start getting very complex.</p>",
        "id": 292507116,
        "sender_full_name": "Mac",
        "timestamp": 1659998916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292506767\">said</a>:</p>\n<blockquote>\n<p>I think my frustration here is mostly about the fact that something which used to work now doesn't seem to, insofar as I don't think I would have been able to figure this out without your help.</p>\n</blockquote>\n<p>I am still surprised you figured out how to get it working with the old API. The <code>.target</code> part of a target was not documented (and was not really meant to be used the way you did), so you kind of lucked into a solution. That is, you were doing things that weren't intended to be supported in the first place. <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 292507456,
        "sender_full_name": "Mac",
        "timestamp": 1659999143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292504234\">said</a>:</p>\n<blockquote>\n<p>So to ensure that the <code>pkg</code> argument I get is my package, I need to synthesize a propositional equation through typeclass inference</p>\n</blockquote>\n<p>One alternative would be to use a <code>Package</code> type parameterized by the package name (e.g., <code>TPackage name</code>), which might be a bit more clear? The package name does need to statically known to be correct, there is no way to avoid that.</p>",
        "id": 292508275,
        "sender_full_name": "Mac",
        "timestamp": 1659999728
    },
    {
        "content": "<p>Could we replace (at least in the user-facing API) <code>fetch</code> with something like <code>buildTargetOn (t : TargetDecl a) (pkg : Package) : M a</code> which works in a plain <code>def</code> as well as in a <code>target</code>? Note that this requires indexing <code>TargetDecl</code> by the output type, but it drops the name-indexed state injected by <code>target</code>.</p>",
        "id": 292508574,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659999928
    },
    {
        "content": "<p>If that fails at runtime given the wrong <code>Package</code>, that's fine with me.</p>",
        "id": 292508679,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1659999993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292508679\">said</a>:</p>\n<blockquote>\n<p>If that fails at runtime given the wrong <code>Package</code>, that's fine with me.</p>\n</blockquote>\n<p>I very much don't like this. If a <code>Package</code> configuration is successfully loaded its builds should be well-formed (unless the user did something evil). The point of a strongly typed language is to avoid such dynamic checking runtime errors.</p>",
        "id": 292508879,
        "sender_full_name": "Mac",
        "timestamp": 1660000182
    },
    {
        "content": "<p>You are probably right! I am too tired to generate any good ideas now so I will head off, but thank you for the discussion so far.</p>",
        "id": 292509396,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660000552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292508574\">said</a>:</p>\n<blockquote>\n<p>Could we replace (at least in the user-facing API) <code>fetch</code> with something like <code>buildTargetOn (t : TargetDecl a) (pkg : Package) : M a</code> which works in a plain <code>def</code> as well as in a <code>target</code>? Note that this requires indexing <code>TargetDecl</code> by the output type, but it drops the name-indexed state injected by <code>target</code>.</p>\n</blockquote>\n<p>Note that <code>fetch</code> is not just used for fetching custom package targets,, so this would not be a replacement.  </p>\n<p>To the main question, sadly, no, for multiple reasons. First, <code>TargetDecl</code> is specifically designed not to be parameterized by type (because it needs to be loaded via <code>evalConstCheck</code> in the package loader). Second, the package still needs to be verified to be the right one (because that is how the result type in the build store is determined).</p>\n<p>It is possible to do what you want via a runtime check and a per-target projection (which could be generated by the <code>target</code> macro). For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">packageLock.fetchFor</span> <span class=\"o\">(</span><span class=\"n\">pkg</span> <span class=\"o\">:</span> <span class=\"n\">Package</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IndexBuildM</span> <span class=\"o\">(</span><span class=\"n\">BuildJob</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">pkg.name</span> <span class=\"bp\">=</span> <span class=\"n\">_package.name</span> <span class=\"k\">then</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">pkg.name</span> <span class=\"bp\">=</span> <span class=\"n\">_package.name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"n\">fetch</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">pkg.target</span> <span class=\"bp\">`</span><span class=\"n\">packageLock</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">error</span> <span class=\"s2\">\"wrong package\"</span>\n</code></pre></div>",
        "id": 292509703,
        "sender_full_name": "Mac",
        "timestamp": 1660000752
    },
    {
        "content": "<p>Honestly, to me, what your example really wants is just some syntactic sugar for parameterized targets (ala <code>%</code> in Make).</p>",
        "id": 292510019,
        "sender_full_name": "Mac",
        "timestamp": 1660001005
    },
    {
        "content": "<p>It would be useful! I made a <a href=\"https://github.com/leanprover/lake/issues/114\">feature request</a> for it, but since the workaround works, please consider it low priority.</p>",
        "id": 292625136,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660066856
    },
    {
        "content": "<p>Okay, I have been thinking a little about this. I would say parametric targets would already make everything much easier. The other thing I am still hung up on is the mysterious signature of <code>fetch</code> whose output type depends on a separate declaration and is only synthesized through typeclass inference. It seems like the root cause is this:</p>\n<blockquote>\n<p>First, <code>TargetDecl</code> is specifically designed not to be parameterized by type (because it needs to be loaded via evalConstCheck in the package loader). Second, the package still needs to be verified to be the right one (because that is how the result type in the build store is determined).</p>\n</blockquote>\n<p>Could you say a bit more about why the <code>evalConst</code> is necessary? Could we have a typed wrapper around <code>TargetDecl</code> which is not itself <code>evalConst</code>-able but which keeps the target's output type around? It seems to me that having <code>target abc : Foo</code> generate a <code>TTargetDecl Foo</code>, or <code>TTargetDecl Foo `thisPkg</code> would be exactly the thing we'd need to simplify <code>fetch</code> into something like <code>def fetch (pkg : TPackage `thisPkg) (tgt : TargetDecl Foo `thisPkg) : IndexBuildM Foo</code>. (Note: It seems <code>TPackage</code> might also be a good idea, so I was already assuming it here.)</p>",
        "id": 292967746,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660236683
    },
    {
        "content": "<blockquote>\n<p>I very much don't like this. If a <code>Package</code> configuration is successfully loaded its builds should be well-formed (unless the user did something evil). The point of a strongly typed language is to avoid such dynamic checking runtime errors.</p>\n</blockquote>\n<p>Come to think of this, is it even possible to load another package's <code>lakefile</code>? Suppose that in any given <code>lakefile</code>, the <code>(pkg : Package)</code> part of a <code>target</code> <em>could not possibly</em> refer to anything other than the current package. Then making that a privileged special case would be quite natural, and a runtime failure would be impossible. (It would also avoid the <code>TPackage</code>/<code>TTargetDecl</code> from my post above.)</p>",
        "id": 292968449,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660236920
    },
    {
        "content": "<p>A short way to put what I am trying to get at: from the build system's perspective, it is important to keep track of target/package IDs. But as a user, I really don't want to care about this, and trying to come up with ways to hide it.</p>",
        "id": 292968897,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660237056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292968449\">said</a>:</p>\n<blockquote>\n<p>Come to think of this, is it even possible to load another package's <code>lakefile</code>? </p>\n</blockquote>\n<p>Of course, this is what <code>require</code> does. You can also build targets from dependencies (and even dependents) in local packages (for example, one might wish to build the <code>docs</code> facet contributed by doc-gen4).</p>",
        "id": 292969037,
        "sender_full_name": "Mac",
        "timestamp": 1660237090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292968897\">said</a>:</p>\n<blockquote>\n<p>A short way to put what I am trying to get at: from the build system's perspective, it is important to keep track of target/package IDs. But as a user, I really don't want to care about this, and trying to come up with ways to hide it.</p>\n</blockquote>\n<p>This stuff is very important for cross-package targets, which may not be of use to you, but does have its uses elsewhere.</p>",
        "id": 292969397,
        "sender_full_name": "Mac",
        "timestamp": 1660237211
    },
    {
        "content": "<p>Poor wording, sorry. I get that facets support being built on any module/library/etc, even in other packages. But do <em>targets</em>?</p>",
        "id": 292969649,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660237290
    },
    {
        "content": "<p>In particular, because of the typeclass constraint <code>pkg.name = _package.name</code>, I couldn't possibly build a dependency's target with/on my own <code>Package</code>, right?</p>",
        "id": 292969850,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660237343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292967746\">said</a>:</p>\n<blockquote>\n<p>Could you say a bit more about why the <code>evalConst</code> is necessary?</p>\n</blockquote>\n<p>Because that is how Lake loads targets from configuration files. It loads <code>TargetDecl</code> defs marked <code>@[target]</code> from the configuration environment using <code>evalConstCheck</code>. I imagine widgets do something similar with their <code>widget</code> declarations.</p>",
        "id": 292969875,
        "sender_full_name": "Mac",
        "timestamp": 1660237355
    },
    {
        "content": "<p>I think I understand this now, thank you.</p>",
        "id": 292969998,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660237410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Lake.20errors/near/292969850\">said</a>:</p>\n<blockquote>\n<p>In particular, because of the typeclass constraint <code>pkg.name = _package.name</code>, I couldn't possibly build a dependency's target with/on my own <code>Package</code>, right?</p>\n</blockquote>\n<p>Not on the passed package. no. But you can easily search for other packages and build targets on them via <code>findPackage?</code>. Or find targets directly via <code>findTarget?</code>.</p>",
        "id": 292970186,
        "sender_full_name": "Mac",
        "timestamp": 1660237474
    },
    {
        "content": "<p>If I use <code>findPackage?</code>, how would I satisfy the constraint <code>pkg.name = something</code>? The output type is just <code>Option Package</code> with no proof about the name.</p>",
        "id": 292970907,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660237740
    },
    {
        "content": "<p>You'd have to do a runtime check for proper typing. (Avoiding this would be another of the benefits having Packages parameterized by name.)</p>",
        "id": 292971152,
        "sender_full_name": "Mac",
        "timestamp": 1660237834
    },
    {
        "content": "<p>However, you could still build the target and get back an opaque job.</p>",
        "id": 292971319,
        "sender_full_name": "Mac",
        "timestamp": 1660237912
    },
    {
        "content": "<p>One reason why Packages have not already been refactored to include the name in the type, is that there are many places in the Lake codebase where this is not desirable, so this would introduce back and forth coercions in a number of places.</p>",
        "id": 292971527,
        "sender_full_name": "Mac",
        "timestamp": 1660237999
    },
    {
        "content": "<p>Got it. So to come back to my main question, do you see any path towards simplifying <code>fetch</code> to get its output type <code>a</code> from a <code>TTargetDecl a</code>?</p>",
        "id": 292972264,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660238283
    },
    {
        "content": "<p>I had a much simpler idea. I can see that transferring bundled data of arbitrary type between build jobs is tricky. What would entirely suffice here instead is if I could tell Lake \"You know that other <code>FilePath</code> you know how to build? Please make sure  it's built first before building this other one, i.e. please make it a dependency of the other\". It would need to support substituting both \"the current target when we're in <code>IndexBuildM</code>\" as well as \"some target that Lake defines implicitly, as in a specific <code>.olean</code>\" for \"this other one\". This would also basically solve the part of <a href=\"https://github.com/leanprover-community/lake/pull/86\">lake#86</a> that doesn't depend on custom elaborators communicating data to Lake.</p>",
        "id": 293002307,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1660249103
    }
]
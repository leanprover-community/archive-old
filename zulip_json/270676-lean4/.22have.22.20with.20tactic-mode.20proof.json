[
    {
        "content": "<p>Here's the beginning of a simple proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>This seems to me to be a reasonable way to start this proof.  After all, I can start the proof with <code>have h4 : x ∈ B :=</code> followed by a term-mode proof of <code>x ∈ B</code>, so it seems to me I should be able to add <code>by</code> and then give a tactic-mode proof.  But in the Infoview window, I don't see a tactic state at this point--the message at the top of the window is just \"No info found.\"  Now, if I look under \"All Messages,\" I do see the goals I would expect: one called \"case h4\" in which the goal is to prove <code>x ∈ B</code>, and a second in which <code>h4 : x ∈ B</code> is listed as a hypothesis and the goal is to prove <code>x ∈ C</code>.</p>\n<p>If I just go ahead and assume I'm working on the first goal, even though no tactic state is listed, I might do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h1</span>\n</code></pre></div>\n<p>Now I see a tactic state.  For some reason it's now called case a, rather than case h4, but it contains what I would expect.  I can now finish the proof of h4, and then go on to finish the proof of the theorem.  Lean is happy with my final proof, which looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h1</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h3</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h2</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h4</span>\n</code></pre></div>\n<p>I know there are other ways to do this proof.  But is there something wrong with doing it the way I'm doing it?  If not, shouldn't Lean show me a tactic state when I start working on the proof of <code>h4</code>?</p>",
        "id": 299851826,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663709809
    },
    {
        "content": "<p>As a general trick if i wanna see a state (not even a tactic state also in programming) I just put a sorry there and hover it, work 9/10 times.</p>",
        "id": 299852103,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663709958
    },
    {
        "content": "<p>No, sorry doesn't seem to help.  I thought perhaps using braces would help.  And in fact, if I type this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>and put the cursor between the braces, then I see the tactic state.  However, this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h1</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h3</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>I get an error \"unknown identifier 'exact'\".  But this does work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h1</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h3</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>No doubt there is some logic to this, but it escapes me.</p>",
        "id": 299869552,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663721704
    },
    {
        "content": "<p>By the way, my interest here is mostly pedagogical:  What do I tell students about how to use the <code>have</code> tactic?</p>",
        "id": 299870523,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663722501
    },
    {
        "content": "<p>Oh, I guess TPIL 4 says that if you use curly braces you have to use semicolons.</p>",
        "id": 299871322,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663723223
    },
    {
        "content": "<p>What seems to work best is putting an underscore:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">_</span>\n</code></pre></div>\n<p>If I put the cursor just before the underscore, Lean shows me the tactic state I wanted.  (If I put the cursor just after the underscore, the tactic state is, confusingly, \"Goals accomplished\"--perhaps what it means is that, once the blank is filled in, the goal will have been accomplished?  But there is an error message associated with the underscore, saying there are unsolved goals.)</p>",
        "id": 300045214,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663797159
    },
    {
        "content": "<p>You didn't post your Lean version or an MWE, but this just works for me <a href=\"/user_uploads/3121/MGEHLmupxaztLsgDwClYgpp1/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/MGEHLmupxaztLsgDwClYgpp1/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/MGEHLmupxaztLsgDwClYgpp1/image.png\"></a></div>",
        "id": 300106513,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663837860
    },
    {
        "content": "<p>Having said that, it does show the wrong state in the next line, independent of indentation</p>",
        "id": 300106757,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663837996
    },
    {
        "content": "<p><code>lean --version</code> returns <code>Lean (version 4.0.0-nightly-2022-09-20, commit 772beeeb29d5, Release)</code>.  <code>#eval Lean.versionString</code> returns <code>4.0.0-nightly-2022-09-15</code>.  I am using MacOS 12.6.</p>\n<p>I tried your example, and got the same result as you.  But then I added <code>import Mathlib</code> and got a different result.  Here's a screenshot:<br>\n<a href=\"/user_uploads/3121/CAraLuOzmyuctaglNU8_p-D8/Screen-Shot-2022-09-22-at-9.50.52-AM.png\">Screen-Shot-2022-09-22-at-9.50.52-AM.png</a><br>\nNotice that the second red squiggle is now under <code>:=</code> rather than <code>by</code>, and I don't see a tactic state.  When I moved the cursor to the next line, I got the message <code>No info found.</code>:<br>\n<a href=\"/user_uploads/3121/x4AWCFz0d9bP5ZUeKdxli_FH/Screen-Shot-2022-09-22-at-9.51.30-AM.png\">Screen-Shot-2022-09-22-at-9.51.30-AM.png</a> <br>\nSo is this an issue with Mathlib?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/CAraLuOzmyuctaglNU8_p-D8/Screen-Shot-2022-09-22-at-9.50.52-AM.png\" title=\"Screen-Shot-2022-09-22-at-9.50.52-AM.png\"><img src=\"/user_uploads/3121/CAraLuOzmyuctaglNU8_p-D8/Screen-Shot-2022-09-22-at-9.50.52-AM.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/x4AWCFz0d9bP5ZUeKdxli_FH/Screen-Shot-2022-09-22-at-9.51.30-AM.png\" title=\"Screen-Shot-2022-09-22-at-9.51.30-AM.png\"><img src=\"/user_uploads/3121/x4AWCFz0d9bP5ZUeKdxli_FH/Screen-Shot-2022-09-22-at-9.51.30-AM.png\"></a></div>",
        "id": 300167479,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663855040
    },
    {
        "content": "<p>Oh, I see.  Mathlib.Tactic.Have.lean redefines the <code>have</code> tactic, right?  Is that what's causing this?  So maybe this discussion should be moved to the mathlib4 stream?</p>",
        "id": 300170277,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663855815
    },
    {
        "content": "<p><code>have : Foo := by</code> is ill-formed syntax. In lean it gives an error at the <code>by</code> because that's the first broken token, but in mathlib there is a <code>have : Foo</code> tactic, so it parses that and then fails at the <code>:=</code></p>",
        "id": 300186207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663860649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> This is an interesting consequence from our decision (in <code>longestMatchStep</code>) that a successful parse should be preferred over a longer but unsuccessful parse. I think we have discussed both approaches before, but it does seem plausible that the opposite choice would give more consistent results when incrementally appending text in an editor. I'm sure there are downsides to that choice as well though...</p>",
        "id": 300188387,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663861267
    },
    {
        "content": "<p>I think <code>by</code> should have a fallback if <code>colGt</code> fails which parses nothing and acts like a list of zero tactics</p>",
        "id": 300188910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663861424
    },
    {
        "content": "<p>If I understand the issue correctly:  <code>example : ∃ (x : Nat), x = 0 := by</code> is also ill-formed syntax, and Lean gives an error at <code>by</code>.  But if I go on and start applying tactics to prove the theorem, Lean is kind enough to show me the tactic state as I go along.  I've been assuming that that's what I'm supposed to do: ignore the error at <code>by</code> because it will go away when the proof is complete, and write tactics, guided by the tactic state, until I achieve all goals.  I was thinking I could use the same approach with <code>have : Foo := by</code>, but apparently not with the <code>have</code> tactic in Mathlib.</p>",
        "id": 300189413,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663861567
    },
    {
        "content": "<p>I use <code>done</code> at the end of tactic blocks these days to get <code>end</code>-like behavior</p>",
        "id": 300189642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663861644
    },
    {
        "content": "<p>it's just the zero-tactic case that's messed up here, because it's syntactically broken and so the errors are degraded and not easily controllable. The <code>_</code> tactic was added for exactly this reason</p>",
        "id": 300190439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663861894
    },
    {
        "content": "<p>We do want this to work as well as possible without dummy tactics. I last improved it this spring before our Lean lab course, but we didn't import mathlib4 there.</p>",
        "id": 300190826,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663862004
    },
    {
        "content": "<p>So when you start proving a theorem, you write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>and then insert your tactics before <code>done</code>?</p>\n<p>As I said, my interest here is pedagogical.  How should I tell students how to set up a tactic proof?</p>",
        "id": 300191165,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663862096
    },
    {
        "content": "<p>this is an annoyance I hope to fix in lean core such that bare <code>by</code> just works</p>",
        "id": 300191526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663862216
    },
    {
        "content": "<p>but until then, sure that's a reasonable suggestion. You can remove the <code>done</code> once you have written at least one tactic in the block</p>",
        "id": 300191632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663862249
    },
    {
        "content": "<p>although it might be useful to get the error at the end anyway instead of at the <code>by</code></p>",
        "id": 300191820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663862292
    },
    {
        "content": "<p><code>_</code> or <code>{}</code> are also options for <code>done</code> like behavior</p>",
        "id": 300191969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663862334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.22have.22.20with.20tactic-mode.20proof/near/300191526\">said</a>:</p>\n<blockquote>\n<p>this is an annoyance I hope to fix in lean core such that bare <code>by</code> just works</p>\n</blockquote>\n<p>That doesn't really fix anything, it would use the wrong <code>have</code> again on the next syntax error such as <code>by simp [</code></p>",
        "id": 300193717,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663862764
    },
    {
        "content": "<p>once it reads the <code>by</code>, shouldn't it commit to the <code>byTactic</code> and fail inside that on the <code>simp [</code>?</p>",
        "id": 300205819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663866418
    },
    {
        "content": "<p>There is no such concept in the current parser at least</p>",
        "id": 300217811,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663870420
    },
    {
        "content": "<p>I thought that was what <code>atomic</code> was about</p>",
        "id": 300219435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663871076
    },
    {
        "content": "<p>I don't completely understand the issues here, but I'm going to weigh in anyway.  If my comments are too confused to be useful, feel free to ignore them.</p>\n<p>Suppose I write <code>example : 0 ≠ 1 := by</code>.  I get a red squiggle under <code>by</code>, but the question is, why?  As things are now, the answer is that what I wrote is syntactically ill-formed.  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is proposing that it should be considered to be a syntactically well-formed proof consisting of an empty sequence of tactics.  Of course, I would still get a red squiggle under <code>by</code>, but for a different reason--the reason now is that the proof is incomplete because the goal has not been achieved.</p>\n<p>Here's another effect that this change would have.  Suppose my file looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thm1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">thm2</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>I get a red squiggle under both <code>by</code>s, and also under the second <code>theorem</code> because Lean regards the first theorem as being syntactically ill-formed, so it tries to parse the second theorem as a continuation of the first.  If I add a step to the first theorem, that changes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thm1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">thm2</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>Now I have red squiggles under both <code>by</code>s, but nothing else.  I assume that's because Lean now regards the first theorem as syntactically correct but incomplete, so it doesn't try to parse the second theorem as part of the first.  I'm inclined to think that Mario is right: the two cases should be treated the same way, as syntactically correct but incomplete proofs.  It never occurred to me, as an inexpert Lean user, that the two cases were different.</p>\n<p>Now, <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  points out that this won't completely solve the problem with mathlib4's <code>have</code>.  True, but I think it would still be an improvement.  In particular, it would make the tactic state appear in the Infoview as soon as I type <code>by</code>, even if it comes after <code>have : 0 = 0 :=</code>, wouldn't it?  Sebastian worries about what happens if I now type <code>simp [</code>.  Well, consider doing that in my example above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thm1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">thm2</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>Now I get a red squiggle under the second <code>theorem</code>, not under <code>simp [</code>.  That's not really where I made my mistake, but I'm accustomed to the fact that, when I make a syntactic error, Lean will make a valiant attempt to make sense of what I wrote, and that may involve putting red squiggles in places that may surprise me.  What confused me about <code>have : 0 = 0 := by</code> was that I didn't think I had made a syntactic error; I thought I had just initiated a tactic proof but hadn't completed it, and I didn't understand why Lean didn't see it that way.</p>",
        "id": 300221093,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663871625
    },
    {
        "content": "<p>My preferred solution to the <code>have</code> issue is to just move it to core so that the two syntaxes can coexist properly</p>",
        "id": 300221689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663871831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> If you declare a high priority syntax subsuming a previous one, is there a way to call the old tactic?</p>",
        "id": 300221918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663871915
    },
    {
        "content": "<p>If the shadowed syntax is imported, you should be able to use a named quotation for it</p>",
        "id": 300230303,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663874713
    },
    {
        "content": "<p>Note the same problem occurs with <code>suffices</code>.  In fact, it's worse.  Consider this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">Q</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>I get a red squiggle under <code>suffices Q by</code>.  If I put the cursor on the line under the <code>suffices</code> line, the tactic state is incorrect.  The main goal should be proving that <code>Q</code> suffices, but that's not what the tactic state says.  Under <code>All Messages</code>, the goals are listed correctly.  If one goes ahead and proceeds with a tactic proof that <code>Q</code> suffices, even though that's not what the tactic state says to do, it works.  For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">Q</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>Now the tactic state is listed correctly.</p>",
        "id": 300388867,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663945873
    },
    {
        "content": "<p>Yes, that is the same behavior/bug as with <code>have</code> without mathlib4.<br>\n<span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/.22have.22.20with.20tactic-mode.20proof/near/300106757\">said</a>:</p>\n<blockquote>\n<p>Having said that, it does show the wrong state in the next line, independent of indentation</p>\n</blockquote>",
        "id": 300389463,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663945997
    },
    {
        "content": "<p>I was not quite right about that though: it does work if we indent to at least the <code>by</code> in the line above. So the correct solution should be to disable indentation sensitivity in the server code for an empty <code>by</code>, as we can start a tactic on any line in that case.</p>",
        "id": 300390168,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663946181
    },
    {
        "content": "<p>In the <code>suffices</code> example, even indenting past <code>by</code> doesn't fix it.</p>\n<p>Again, I'm not an expert, but:  wouldn't allowing a <code>tacticSeq</code> to be the empty sequence fix these problems?  As things are now, as soon as you type in at least one tactic, the tactic state is displayed correctly.  As I understand it, that's because a nonempty list of tactics is recognized as a <code>tacticSeq</code>, but an empty list isn't.</p>\n<p>Of course, maybe allowing a <code>tacticSeq</code> to be empty would cause all kinds of other problems ...</p>",
        "id": 300396815,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663947996
    },
    {
        "content": "<p>Also, even with the cursor at the end of the line <code>suffices Q by</code>, the tactic state is wrong.</p>\n<p>On the other hand, <code>suffices Q from by</code> acts the same as <code>have</code> (without Mathlib).  That is, the tactic state is right with the cursor at the end of the line <code>suffices Q from by</code>, then it is wrong if you go to the next line, but if you indent at least up to <code>by</code>, then it is right again.</p>",
        "id": 300398739,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1663948572
    },
    {
        "content": "<p>Note that for <code>suffices</code> the info is wrong even on the <code>by</code> itself. This might be due to a token antiquotation in <code>expandSuffices</code>, which may be fixed by <a href=\"https://github.com/leanprover/lean4/pull/1620\">https://github.com/leanprover/lean4/pull/1620</a> /cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 300398793,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663948592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453098\">@Dan Velleman</span>  You can quite easily make a <code>tacticSeq</code> with an empty list of tactics, since it's just a syntax wrapper that has two options, <code>Bracketed</code> or <code>1Indented</code>. You can have an empty tacticSeq with just the brackets <code>{}</code>. Note though that the syntax of an empty <code>1Indented</code> block makes little sense, since it can only detect indentation if there is a nonzero amount of tactics.</p>\n<p>So I was also using <code>_</code> or <code>sorry</code> royally to make the by block syntactically correct (which I think is pedagogically fine, since you're warned of having sorry's in your proof anyways), but I found out we also have a tactic called <code>skip</code> which simply does nothing. Using <code>skip</code>, you get an error on an unsolved goal, as well as the same state with your cursor before and after the skip. Guess that works the same as <code>done</code>, though, so make of that what you will.</p>",
        "id": 300526134,
        "sender_full_name": "Reinier van der Gronden",
        "timestamp": 1664020156
    },
    {
        "content": "<p>I have a small (rotating) team of undergraduate students that have been using Lean 4 since the first public release in January 2021. The early days were rough, they all had Lean 3 experience but Lean 4 was really barren at the time. They took to the <code>by ... done</code> pattern pretty quickly. After a year or so, they would also plan ahead and write things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">constructor</span>\n<span class=\"bp\">.</span> <span class=\"n\">done</span>\n<span class=\"bp\">.</span> <span class=\"n\">done</span>\n</code></pre></div>\n<p>when breaking up a conjunction and then fill in the blanks. Even with just a little training, students know how to draft a proof skeleton like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">done</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">constructor</span>\n   <span class=\"bp\">.</span> <span class=\"n\">done</span>\n   <span class=\"bp\">.</span> <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 300580902,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1664051598
    },
    {
        "content": "<p>That said, these are hand picked students who get paid to learn Lean 4!</p>\n<p>If I were to teach a regular class of students, I would not use tactic language and I would create my own DSL for that purpose. This would allow me to:</p>\n<ul>\n<li>Restrict tactics to a small subset that are relevant to the course.</li>\n<li>Use tactic names and syntax that are more relevant to students in the course.</li>\n<li>Enable reasonably sound automatic grading, even when using mathlib and such, since students would not be able to use sledgehammers in this DSL.</li>\n</ul>",
        "id": 300581369,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1664052005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> :  You suggested that the problem with <code>suffices</code> might be fixed by <a href=\"https://github.com/leanprover/lean4/pull/1620\">https://github.com/leanprover/lean4/pull/1620</a>.  But it looks to me like that change has been merged and the problem still exists, doesn't it?  Any further thoughts?</p>",
        "id": 302109443,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1664817524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> It looks like the <code>by</code> is correctly marked as canonical, but I don't know yet why the server doesn't pick it up. Actually I don't understand why <code>Elab.info</code> shows its whole range as synthetic, the last token is original.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>                                                  <span class=\"bp\">•</span> <span class=\"n\">Tactic</span> <span class=\"bp\">@</span> <span class=\"o\">⟨</span><span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">⟩</span><span class=\"bp\">†-</span><span class=\"o\">⟨</span><span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">14</span><span class=\"o\">⟩</span><span class=\"bp\">†</span>\n                                                    <span class=\"o\">(</span><span class=\"n\">Term.byTactic</span>\n                                                     <span class=\"mi\">162</span><span class=\"bp\">!</span><span class=\"o\">:</span><span class=\"s2\">\"by\"</span><span class=\"o\">:</span><span class=\"mi\">164</span>\n                                                     <span class=\"o\">(</span><span class=\"n\">Tactic.tacticSeq</span>\n                                                      <span class=\"o\">(</span><span class=\"n\">Tactic.tacticSeq1Indented</span>\n                                                       <span class=\"o\">[(</span><span class=\"n\">Tactic.exact</span>\n                                                         <span class=\"o\">:</span><span class=\"mi\">169</span><span class=\"o\">:</span><span class=\"s2\">\"exact\"</span><span class=\"o\">:</span><span class=\"mi\">174</span><span class=\"o\">:</span>\n                                                         <span class=\"o\">(</span><span class=\"n\">Lean.termThis</span>\n                                                          <span class=\"o\">:</span><span class=\"mi\">175</span><span class=\"o\">:</span><span class=\"s2\">\"this\"</span><span class=\"o\">:</span><span class=\"mi\">179</span><span class=\"o\">:</span>\n                                                          <span class=\"o\">))])))</span>\n                                                    <span class=\"n\">before</span>\n                                                    <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n                                                    <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span>\n                                                    <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span>\n                                                    <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n                                                    <span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"n\">Q</span>\n                                                    <span class=\"bp\">⊢</span> <span class=\"n\">R</span>\n</code></pre></div>",
        "id": 302126956,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664823080
    },
    {
        "content": "<p>I lost the context here. What bug are we fixing?</p>",
        "id": 302127209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664823159
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">Q</span> <span class=\"kd\">by</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n</code></pre></div>\n<p>shows the wrong goal on <code>by</code></p>",
        "id": 302127412,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664823240
    },
    {
        "content": "<p>I'm not reproducing on a relatively recent commit, let me pull master</p>",
        "id": 302127859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664823390
    },
    {
        "content": "<p>oh wait, the goal should be <code>this : Q |- R</code> not <code>|- Q</code></p>",
        "id": 302128037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664823456
    }
]
[
    {
        "content": "<p>Now that I'm more confortable composing monad operations, I would like to proove some properties of such compositions. I'm aware that this is probably jumping ahead of <span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span>'s section 8 so I made an MWE to precisely illustrate the problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Data.HashMap</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Data.HashSet</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">Lean.HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">h.toList.repr</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">Lean.HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">h.toList.repr</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE</span>\n\n<span class=\"kd\">inductive</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">aspect</span>\n    <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">«</span><span class=\"n\">specializations</span><span class=\"bp\">»</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">List.nil</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">concept</span>\n    <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">«</span><span class=\"n\">specializations</span><span class=\"bp\">»</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">List.nil</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">».</span><span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span><span class=\"o\">):</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">aspect</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">concept</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">».«</span><span class=\"n\">specializations</span><span class=\"bp\">»</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span><span class=\"o\">):</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">aspect</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">concept</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">class</span> <span class=\"bp\">«</span><span class=\"n\">Vocabulary</span><span class=\"bp\">»</span><span class=\"n\">where</span>\n  <span class=\"bp\">«</span><span class=\"n\">ownedStatements</span><span class=\"bp\">»</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">Vocabulary</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">ownedStatements</span> <span class=\"o\">:=</span> <span class=\"o\">[</span>\n    <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">».</span><span class=\"n\">aspect</span> <span class=\"s2\">\"base:Container\"</span><span class=\"o\">,</span>\n    <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">».</span><span class=\"n\">concept</span> <span class=\"s2\">\"mission:Component\"</span> <span class=\"o\">[</span> <span class=\"s2\">\"base:Container\"</span> <span class=\"o\">]</span>\n  <span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">RDeclarationKind</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rAspect</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rConcept</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">».</span><span class=\"n\">toKind</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span><span class=\"o\">):</span> <span class=\"n\">RDeclarationKind</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">aspect</span> <span class=\"n\">_</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">concept</span> <span class=\"n\">_</span> <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">rConcept</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Exception</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">error</span> <span class=\"o\">(</span><span class=\"n\">message</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Names</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.HashSet</span> <span class=\"n\">String</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Name2NamesMap</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.HashMap</span> <span class=\"n\">String</span> <span class=\"n\">Names</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">declarations</span> <span class=\"o\">:</span> <span class=\"n\">Lean.HashMap</span> <span class=\"n\">String</span> <span class=\"n\">RDeclarationKind</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n  <span class=\"n\">aspectSpecializations</span> <span class=\"o\">:</span> <span class=\"n\">Name2NamesMap</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n  <span class=\"n\">conceptSpecializations</span> <span class=\"o\">:</span> <span class=\"n\">Name2NamesMap</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Context</span> <span class=\"n\">where</span>\n  <span class=\"n\">vocabularies</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"bp\">«</span><span class=\"n\">Vocabulary</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">MCore</span> <span class=\"o\">:=</span> <span class=\"n\">EStateM</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">M</span>     <span class=\"o\">:=</span> <span class=\"n\">ReaderT</span> <span class=\"n\">Context</span> <span class=\"n\">MCore</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">EStateM.Result.getState</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">EStateM.Result.ok</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.appendSpecializations</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dts</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">RDeclarationKind</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">ds</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">coll</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"n\">Name2NamesMap</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">update</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Names</span> <span class=\"bp\">→</span> <span class=\"n\">State</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">dts.contains</span> <span class=\"n\">k</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">rds</span> <span class=\"o\">:</span> <span class=\"n\">Names</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">coll</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">findD</span> <span class=\"n\">d</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n      <span class=\"k\">let</span> <span class=\"n\">merged</span> <span class=\"o\">:</span> <span class=\"n\">Names</span> <span class=\"o\">:=</span> <span class=\"n\">ds.foldl</span> <span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">rds</span>\n      <span class=\"k\">let</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">update</span> <span class=\"n\">s</span> <span class=\"n\">d</span> <span class=\"n\">merged</span>\n      <span class=\"n\">set</span> <span class=\"n\">s'</span>\n      <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throw</span> <span class=\"o\">(</span><span class=\"n\">Exception.error</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Error: appendSpecializations: {repr d} is registered as a {repr k}, not one of {repr dts}.\"</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">throw</span> <span class=\"o\">(</span><span class=\"n\">Exception.error</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Error: appendSpecializations: there is no registered {repr dts}: {repr d} to append specializations to.\"</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.updateAspectSpecializations</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ds</span><span class=\"o\">:</span> <span class=\"n\">Names</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">aspectSpecializations</span> <span class=\"o\">:=</span> <span class=\"n\">s.aspectSpecializations.insert</span> <span class=\"n\">d</span> <span class=\"n\">ds</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.appendAspectSpecializations</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">appendSpecializations</span> <span class=\"n\">a</span> <span class=\"o\">[</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span> <span class=\"o\">]</span> <span class=\"n\">as</span> <span class=\"n\">State.aspectSpecializations</span> <span class=\"n\">State.updateAspectSpecializations</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.updateConceptSpecializations</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ds</span><span class=\"o\">:</span> <span class=\"n\">Names</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">conceptSpecializations</span> <span class=\"o\">:=</span> <span class=\"n\">s.conceptSpecializations.insert</span> <span class=\"n\">d</span> <span class=\"n\">ds</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.appendConceptSpecializations</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">appendSpecializations</span> <span class=\"n\">c</span> <span class=\"o\">[</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">rConcept</span> <span class=\"o\">]</span> <span class=\"n\">cs</span> <span class=\"n\">State.conceptSpecializations</span> <span class=\"n\">State.updateConceptSpecializations</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateStatementDeclaration</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span><span class=\"o\">):</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">e.name</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">ek</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">throw</span> <span class=\"o\">(</span><span class=\"n\">Exception.error</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Error: declaration conflict: {repr e} is already registered as a {repr ek}.\"</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.insert</span> <span class=\"n\">e.name</span> <span class=\"n\">e.toKind</span> <span class=\"o\">}</span>\n    <span class=\"n\">set</span> <span class=\"n\">s</span>\n    <span class=\"n\">pure</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateVocabularyStatementDeclarations</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">for</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">e</span> <span class=\"k\">in</span> <span class=\"n\">v.ownedStatements</span> <span class=\"k\">do</span>\n      <span class=\"n\">validateStatementDeclaration</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecialization</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">Entity</span><span class=\"bp\">»</span><span class=\"o\">):</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">e.name</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">ek</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">ek</span> <span class=\"bp\">==</span> <span class=\"n\">e.toKind</span> <span class=\"k\">then</span>\n      <span class=\"k\">match</span> <span class=\"n\">ek</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">State.appendAspectSpecializations</span> <span class=\"n\">e.name</span> <span class=\"n\">e.specializations</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">rConcept</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">State.appendConceptSpecializations</span> <span class=\"n\">e.name</span> <span class=\"n\">e.specializations</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throw</span> <span class=\"o\">(</span><span class=\"n\">Exception.error</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Error: declaration inconsistency: {repr e} is registered as a {repr ek}, not a {repr e.toKind}.\"</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">pure</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">for</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">e</span> <span class=\"k\">in</span> <span class=\"n\">v.ownedStatements</span> <span class=\"k\">do</span>\n      <span class=\"n\">validateVocabularySpecialization</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">c0</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">vocabularies</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">v</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s0</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s1</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">EStateM.Result.getState</span> <span class=\"o\">(</span><span class=\"n\">validateVocabularyStatementDeclarations</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c0</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s0</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s1</span>\n<span class=\"c1\">-- { declarations := [(\"base:Container\", MWE.RDeclarationKind.rAspect),</span>\n<span class=\"c1\">--                    (\"mission:Component\", MWE.RDeclarationKind.rConcept)],</span>\n<span class=\"c1\">--   aspectSpecializations := [],</span>\n<span class=\"c1\">--   conceptSpecializations := [] }</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">EStateM.Result.getState</span> <span class=\"o\">(</span><span class=\"n\">validateVocabularySpecializations</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c0</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s1</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s2</span>\n<span class=\"c1\">-- { declarations := [(\"base:Container\", MWE.RDeclarationKind.rAspect),</span>\n<span class=\"c1\">--                    (\"mission:Component\", MWE.RDeclarationKind.rConcept)],</span>\n<span class=\"c1\">--   aspectSpecializations := [(\"base:Container\", [])],</span>\n<span class=\"c1\">--   conceptSpecializations := [(\"mission:Component\", [\"base:Container\"])] }</span>\n\n<span class=\"c1\">-- All keys of the aspectSpecialization map must have a corresponding declaration as an rAspect</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">AllAspectsSpecializationsKeysAreDeclared</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">s.aspectSpecializations.contains</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- All values of the aspectSpecialization map must have a corresponding declaration as an rAspect</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">AllAspectsSpecializationsValuesAreDeclared</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">s.aspectSpecializations.findD</span> <span class=\"n\">a</span> <span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sup</span> <span class=\"bp\">→</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sup</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- All keys of the conceptSpecializations map must have a corresponding declaration as an rConcept</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">AllConceptSpecializationsKeysAreDeclared</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">s.conceptSpecializations.contains</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">rConcept</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- All values of the conceptSpecializations map must have a corresponding declaration as an rAspect or rConcept</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">AllConceptSpecializationsValuesAreDeclared</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">s.conceptSpecializations.findD</span> <span class=\"n\">a</span> <span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sup</span> <span class=\"bp\">→</span>\n    <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sup</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span> <span class=\"bp\">||</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sup</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">rConcept</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span> <span class=\"n\">MWE</span>\n</code></pre></div>\n<p>In the above, <code>s2</code> is a simple example of the <code>State</code> for which I would like to proove 4 theorems. However, I am not sure how to exploit properties of the monad operations and of their composition to do this.</p>\n<p>For example, consider the first theorem, which I hope will be easy to proove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- All keys of the aspectSpecialization map must have a corresponding declaration as an rAspect</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">AllAspectsSpecializationsKeysAreDeclared</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">s.aspectSpecializations.contains</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">rAspect</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Intuitively, it should follow from the composition of these two monad operations: <code>validateVocabularyStatementDeclarations</code> and <code>validateVocabularySpecializations</code>:</p>\n<ul>\n<li>both operations iterate over the same <code>Context</code> of <code>vocabularies</code> and their <code>ownedStatements</code>.</li>\n<li>the validation of statement declarations adds an entry in the <code>State.declarations</code></li>\n<li>the validation of statement specializations adds entries in the <code>State.aspectSpecializations</code> for the same keys as the previous step.</li>\n</ul>\n<p>I hope that I've explained sufficiently clearly the problem and I'm open to suggestions.</p>",
        "id": 318674727,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672448609
    },
    {
        "content": "<p>The essence of the long MWE above can be reduced to this smaller MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Data.HashMap</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Data.HashSet</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE4</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">declarations</span><span class=\"o\">:</span> <span class=\"n\">Lean.HashMap</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"n\">Lean.HashSet</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- all declaration values must be declaration keys</span>\n<span class=\"kd\">def</span> <span class=\"n\">State.wff</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.toList.all</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.toList.all</span> <span class=\"n\">s.declarations.contains</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withDeclaration</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.insert</span> <span class=\"n\">d</span> <span class=\"bp\">.</span><span class=\"n\">empty</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withSpecialization</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.withDeclaration</span> <span class=\"n\">sup</span>\n  <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.insert</span> <span class=\"n\">sub</span> <span class=\"o\">((</span><span class=\"n\">s.declarations.findD</span> <span class=\"n\">sub</span> <span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclarationWff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecializationWff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE4</span>\n</code></pre></div>\n<p>Looking at examples in Lean and the Std4 library, I realized that I should try to use inductive data types instead, so I reformulated the MWE using Std4, preserving the intent of the example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE5</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Sups</span> <span class=\"o\">:=</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">declarations</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Sups</span>\n\n<span class=\"c1\">-- all declaration values must be declaration keys</span>\n<span class=\"kd\">def</span> <span class=\"n\">State.wff</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.all</span>\n    <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">sups</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sups.all</span>\n      <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">sup</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withDeclaration</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.replace</span> <span class=\"n\">d</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withSpecialization</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.withDeclaration</span> <span class=\"n\">sup</span>\n  <span class=\"k\">let</span> <span class=\"n\">sups</span> <span class=\"o\">:</span> <span class=\"n\">Sups</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sub</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.replace</span> <span class=\"n\">sup</span> <span class=\"o\">()</span>\n  <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.replace</span> <span class=\"n\">sub</span> <span class=\"n\">sups</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclarationWff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecializationWff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE5</span>\n</code></pre></div>\n<p>I have several questions about this:</p>\n<p>1) I noticed that there are different ways to define well-formedness predicates as <code>Bool</code> vs. <code>Prop</code>.</p>\n<p><a href=\"https://github.com/leanprover/lean4/blob/master/tests/playground/pge.lean\">https://github.com/leanprover/lean4/blob/master/tests/playground/pge.lean</a><br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/doc/examples/bintree.lean\">https://github.com/leanprover/lean4/blob/master/doc/examples/bintree.lean</a><br>\n<a href=\"https://github.com/leanprover/std4/blob/main/Std/Data/AssocList.lean\">https://github.com/leanprover/std4/blob/main/Std/Data/AssocList.lean</a></p>\n<p>It seems that one can use either form to define subtypes. <br>\nIs this difference a matter of proof writing style, or is there something more subtle going on?</p>\n<p>2) Even though <code>State</code> is defined above in terms of inductive datatypes, it is not inductively defined.</p>\n<p>It seems that this approach complicates writing proofs since we cannot use the <code>cases</code> tactic.<br>\nSo, I suspect I must reformulate my MWE using an inductive datatype definition.</p>",
        "id": 318918496,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672618928
    },
    {
        "content": "<blockquote>\n<p>It seems that one can use either form to define subtypes.</p>\n</blockquote>\n<p><code>Bool</code> can be coerced to <code>Prop</code> (with <code>true</code> =&gt; <code>True</code> and <code>false</code> =&gt; <code>False</code>), so anywhere that expects a <code>Prop</code> you can also pass a <code>Bool</code> (including, e.g. the predicate for subtypes)</p>",
        "id": 318921006,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672621156
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span>; I see that there's indeed a conversion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">boolToProp</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Bool</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>I managed to proove a simple theorem about the data structure above; however, I'm getting stuck for others:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE5</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Sups</span> <span class=\"o\">:=</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">Sups</span> <span class=\"n\">where</span> <span class=\"n\">reprPrec</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">s.toList.repr</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">declarations</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.empty</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"c1\">-- all declaration values must be declaration keys</span>\n<span class=\"kd\">def</span> <span class=\"n\">State.wff</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.all</span>\n    <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">sups</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sups.all</span>\n      <span class=\"k\">fun</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withDeclaration</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.cons</span> <span class=\"n\">d</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withSpecialization</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.withDeclaration</span> <span class=\"n\">sub</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">withDeclaration</span> <span class=\"n\">sup</span>\n  <span class=\"k\">let</span> <span class=\"n\">sups</span> <span class=\"o\">:</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sub</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">xs.contains</span> <span class=\"n\">sup</span> <span class=\"k\">then</span> <span class=\"n\">xs</span> <span class=\"k\">else</span> <span class=\"n\">xs.cons</span> <span class=\"n\">sup</span>\n  <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.replace</span> <span class=\"n\">sub</span> <span class=\"n\">sups</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.noChange</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.added</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.contains</span> <span class=\"n\">d</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">,</span> <span class=\"n\">List.all</span><span class=\"o\">,</span> <span class=\"n\">List.any</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecialization.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withSpecialization</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">,</span> <span class=\"n\">List.all</span><span class=\"o\">,</span> <span class=\"n\">List.any</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s0</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">State.empty</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">withSpecialization</span> <span class=\"s2\">\"a\"</span> <span class=\"s2\">\"b\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s0</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE5</span>\n</code></pre></div>\n<p>For the 2nd one, I am wondering how to simplify a nested expression in the goal; i.e.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.added</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.contains</span> <span class=\"n\">d</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The tactic state before <code>sorry</code> shows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span>\n<span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"n\">Std.AssocList.contains</span> <span class=\"n\">d</span> <span class=\"n\">s.declarations</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Std.AssocList.contains</span> <span class=\"n\">d</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">Std.AssocList.contains</span> <span class=\"n\">d</span> <span class=\"n\">s.declarations</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n      <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">d</span> <span class=\"o\">[]</span> <span class=\"n\">s.declarations</span> <span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">declarations</span> <span class=\"bp\">=</span>\n  <span class=\"n\">true</span>\n</code></pre></div>\n<p>Is there a trick to apply <code>!h</code> inside the goal and simplify the <code>match</code> expression?</p>\n<p>For the last 2 theorems, I am wondering if I am on the right path.</p>\n<p>Any suggestions?</p>",
        "id": 319111579,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672706310
    },
    {
        "content": "<p>I managed to make some progress, proving 3 theorems out of 7; any suggestions for the last 4?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE5</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Sups</span> <span class=\"o\">:=</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">Sups</span> <span class=\"n\">where</span> <span class=\"n\">reprPrec</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">s.toList.repr</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">declarations</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.empty</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"c1\">-- all declaration values must be declaration keys</span>\n<span class=\"kd\">def</span> <span class=\"n\">State.wff</span><span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.all</span>\n    <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">sups</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sups.all</span>\n      <span class=\"k\">fun</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withDeclaration</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.cons</span> <span class=\"n\">d</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">State.withSpecialization</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.withDeclaration</span> <span class=\"n\">sub</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">withDeclaration</span> <span class=\"n\">sup</span>\n  <span class=\"k\">let</span> <span class=\"n\">sups</span> <span class=\"o\">:</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sub</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- this case can never happen since sub has been declared.</span>\n    <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">xs.contains</span> <span class=\"n\">sup</span> <span class=\"k\">then</span> <span class=\"n\">xs</span> <span class=\"k\">else</span> <span class=\"n\">xs.cons</span> <span class=\"n\">sup</span>\n  <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">declarations</span> <span class=\"o\">:=</span> <span class=\"n\">s.declarations.replace</span> <span class=\"n\">sub</span> <span class=\"n\">sups</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.noChange</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.added1</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.contains</span> <span class=\"n\">d</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">,</span> <span class=\"n\">List.any</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.added2</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">[]</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">,</span> <span class=\"n\">List.any</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">split</span>\n  <span class=\"bp\">.</span><span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">done</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecialization.noChange</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sub</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sub</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">sups</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sups.contains</span> <span class=\"n\">sup</span><span class=\"o\">))</span>\n<span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--unfold State.withSpecialization State.withDeclaration at *</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.withSpecialization</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecialization.added</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">sub</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.contains</span> <span class=\"n\">sub</span> <span class=\"bp\">&amp;&amp;</span>\n  <span class=\"o\">(</span><span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.contains</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withSpecialization</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">,</span> <span class=\"n\">Std.AssocList.contains</span><span class=\"o\">,</span> <span class=\"n\">List.any</span><span class=\"o\">,</span> <span class=\"n\">List.replaceF</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">apply</span> <span class=\"n\">And.intro</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecialization.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withSpecialization</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s0</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">State.empty</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">withSpecialization</span> <span class=\"s2\">\"a\"</span> <span class=\"s2\">\"b\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s0</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE5</span>\n</code></pre></div>",
        "id": 319118780,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672712925
    },
    {
        "content": "<p>Ah, sure -- check out the <code>split</code> tactic!</p>\n<p>To finish <code>State.withDeclaration.added1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">split</span>\n<span class=\"bp\">.</span> <span class=\"n\">assumption</span>\n<span class=\"bp\">.</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Something similar should work for the others!</p>",
        "id": 319127176,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672721117
    },
    {
        "content": "<p>Oh, wait, I misunderstood your question...</p>\n<p>Rewriting within a match is generally a hard to do. I'm not sure if there's a way to rewrite through it. The only way I know to do what you want is to <code>split</code> and then do the simp/rewrite in each case. Usually this isn't too bad, since you can use the <code>&lt;;&gt;</code> combinator like <code>split &lt;;&gt; simp</code> or similar</p>",
        "id": 319129137,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672723029
    },
    {
        "content": "<p>Honestly, a good strategy with any goals involving <code>match</code> is to just split on it. Sometimes I find it much easier to clean up unnecessary splits after the fact, instead of thinking too deeply about whether I need to split or not...</p>",
        "id": 319129446,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672723328
    },
    {
        "content": "<p>Thanks, I managed to simplify a few proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.added1</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.contains</span> <span class=\"n\">d</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp_all</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.added2</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">s.declarations.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">[]</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp_all</span>\n</code></pre></div>\n<p>For the next one, I am not sure how to split the nested Or:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">split</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp_all</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Before <code>sorry</code>, the tactic state shows:</p>\n<div class=\"codehilite\" data-code-language=\"case\"><pre><span></span><code>s: State\nd: String\nx✝: Bool\nh: (List.all (Std.AssocList.toList s.declarations) fun x =&gt;\n    List.all x.snd fun sup =&gt; List.any (Std.AssocList.toList s.declarations) fun x =&gt; x.fst == sup) =\n  true\nheq✝: (List.any (Std.AssocList.toList s.declarations) fun x =&gt; x.fst == d) = false\n⊢ (List.all (Std.AssocList.toList s.declarations) fun x =&gt;\n    List.all x.snd fun sup =&gt; d == sup || List.any (Std.AssocList.toList s.declarations) fun x =&gt; x.fst == sup) =\n  true\n</code></pre></div>\n<p>What are the grayed symbols: <code>x✝</code> and <code>heq✝</code>?</p>\n<p>In the above, the assumption <code>h</code> is very close to the goal.<br>\nThe goal has an Or with the left <code>d == sup</code> that seems ought to match with <code>heq✝</code>if I could somehow bind it to an assumption (I tried but it is not available); the right could match the assumption <code>h</code>.</p>\n<p>Since the Or is nested, <code>split</code> is not readily applicable.</p>\n<p>How can I tackle this situation?</p>\n<p>For the next one, the problem is similar that I cannot readily apply an assumption to a nested expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecialization.noChange</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sub</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sub</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">sups</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sups.contains</span> <span class=\"n\">sup</span><span class=\"o\">))</span>\n<span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--unfold State.withSpecialization State.withDeclaration at *</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.withSpecialization</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp_all</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h3</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The application of <code>h3</code> fails because:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">apply'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"n\">Option.all</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">sups</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.contains</span> <span class=\"n\">sups</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">Option.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.snd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.find</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"n\">true</span>\n<span class=\"k\">with</span>\n  <span class=\"n\">s</span> <span class=\"bp\">=</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">declarations</span> <span class=\"o\">:=</span>\n        <span class=\"n\">Std.AssocList.replace</span> <span class=\"n\">sub</span>\n          <span class=\"o\">(</span><span class=\"k\">match</span>\n            <span class=\"n\">Option.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.snd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.find</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">List.contains</span> <span class=\"n\">xs</span> <span class=\"n\">sup</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"n\">xs</span> <span class=\"k\">else</span> <span class=\"n\">sup</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n          <span class=\"n\">s.declarations</span> <span class=\"o\">}</span>\n<span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span>\n<span class=\"n\">subsup</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List.any</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List.any</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"n\">Option.all</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">sups</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.contains</span> <span class=\"n\">sups</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Option.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.snd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.find</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">true</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">s</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">declarations</span> <span class=\"o\">:=</span>\n      <span class=\"n\">Std.AssocList.replace</span> <span class=\"n\">sub</span>\n        <span class=\"o\">(</span><span class=\"k\">match</span>\n          <span class=\"n\">Option.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.snd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.find</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">List.contains</span> <span class=\"n\">xs</span> <span class=\"n\">sup</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"n\">xs</span> <span class=\"k\">else</span> <span class=\"n\">sup</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n        <span class=\"n\">s.declarations</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The last two proofs involve much more complicated expressions; I have not figured out how to tackle them.</p>",
        "id": 319130037,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672723810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"362579\">Nicolas Rouquette</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20to.20prove.20properties.20about.20monad.20operations.3F/near/319130037\">said</a>:</p>\n<blockquote>\n<p>What are the grayed symbols: <code>x✝</code> and <code>heq✝</code>?</p>\n</blockquote>\n<p>Those are auto-generated, inaccessible names. There's a bunch of different ways to introduce accessible names, but the easiest here is probably to use <code>next</code> instead of <code>.</code> for the second case, like <code>next x heq =&gt;</code>.</p>\n<p>Almost all (all?) autogenerated names are inaccessible, I believe that's to ensure autogenerated names don't have to be stable.</p>\n<blockquote>\n<p>Since the Or is nested, <code>split</code> is not readily applicable.</p>\n</blockquote>\n<p>Yeah, you have to do quite a lot of unpacking before you can use split. My first attempt at doing so reached an unprovable goal, but maybe it's still helpful to look at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">s.wff</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">split</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"n\">next</span> <span class=\"n\">x</span> <span class=\"n\">heq</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp_all</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">clear</span> <span class=\"n\">h</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">funext</span> <span class=\"n\">sup</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span>\n    <span class=\"n\">case</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span> <span class=\"o\">:=</span> <span class=\"n\">eq_of_beq</span> <span class=\"n\">h</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">heq</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"n\">case</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span>\n    <span class=\"n\">done</span>\n</code></pre></div>\n<p>How can I tackle this situation?</p>\n<p>For the next one, the problem is similar that I cannot readily apply an assumption to a nested expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withSpecialization.noChange</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sub</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">s.declarations.contains</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.declarations.find</span><span class=\"bp\">?</span> <span class=\"n\">sub</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">sups</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sups.contains</span> <span class=\"n\">sup</span><span class=\"o\">))</span>\n<span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s.withSpecialization</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--unfold State.withSpecialization State.withDeclaration at *</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.withSpecialization</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">simp_all</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h3</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 319132145,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672725799
    },
    {
        "content": "<p>As you can probably tell, Lean currently has very little automation for proofs about even relatively small programs... I don't know if I have good advice aside from keeping your lemmas very small and focused, since that's the only way I know to parse large expressions in Lean</p>",
        "id": 319132519,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672726076
    },
    {
        "content": "<p>here's my attempt at that theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n<span class=\"bp\">...</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.wff</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">ss</span><span class=\"o\">)</span>\n  <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"o\">{</span><span class=\"n\">intro.</span><span class=\"o\">}</span>\n    <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">h'</span> <span class=\"n\">_</span> <span class=\"n\">hs</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 319135674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672728356
    },
    {
        "content": "<p>I should really learn the rintro black magic at some point....</p>",
        "id": 319135846,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672728484
    },
    {
        "content": "<p>the thing that pulls the most weight in this proof is the <code>simp</code> on the first line, plus the <code>Std.Data.List.Lemmas</code> to make it actually do something</p>",
        "id": 319135911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672728527
    },
    {
        "content": "<p>The original proof had a <code>simp [List.all]</code>, that's the wrong move. You want to turn all those boolean functions into logical functions (in this case a <code>\\forall</code>) ASAP since then all the other stuff like <code>intro</code> and <code>fun</code> do useful things</p>",
        "id": 319136023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672728625
    },
    {
        "content": "<p>This does seem a bit situational, since we kinda luck out that <code>List.all</code> and <code>List.any</code> are succinct to describe in proposition land</p>",
        "id": 319136198,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672728818
    },
    {
        "content": "<p>A common situation, nonetheless <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 319136278,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672728850
    },
    {
        "content": "<p>not really. If you look at <code>AssocList</code> you will notice that <em>every single function</em> has a theorem which relates it to proposition land written immediately afterward</p>",
        "id": 319136841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672729255
    },
    {
        "content": "<p>this is very much by design</p>",
        "id": 319137027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672729412
    },
    {
        "content": "<p>Thanks for all of your suggestions; I have plenty to think about.</p>",
        "id": 319233811,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672763884
    },
    {
        "content": "<p>I want to make sure that I understand correctly <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> 's ingenious proof that I've reformatted like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">State.withDeclaration.wff</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">s.wff</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.withDeclaration</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wff</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">State.wff</span><span class=\"o\">,</span> <span class=\"n\">State.withDeclaration</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">ss</span><span class=\"o\">)</span>\n  <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro.</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">h'</span> <span class=\"n\">x</span> <span class=\"n\">hs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Just before <code>rintro</code>, the goal is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">s1</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">∧</span> <span class=\"n\">ss</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">ss</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ss</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Based on VS code feedback, I see that <code>rintro (⟨rfl, rfl⟩ | h')</code> matches the left hand side of the implication: <code>s1 = d ∧ ss = [] ∨ (s1, ss) ∈ Std.AssocList.toList s.declarations</code>.</p>\n<p>Why is it matching just the LHS of the goal instead of the whole goal expression?</p>\n<p>On the last line, the goal is the RHS of the above, I am really amazed by the flexibility of the equivalence between universal quantifiers and functions; it seems to me far more powerful than what is explained in section 4 here: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html\">https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html</a></p>\n<p>If I understand correctly, the goal at the <code>exact</code> line above is a universal quantifier expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ss</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>So it is equivalent to a function like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ss</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>That equivalence allows matching the <code>exact</code> pattern function: <code>exact fun x hs =&gt;</code> </p>\n<p>Then on the right, the <code>.inr</code> construction involves the reverse.</p>\n<p>With:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Strings</span><span class=\"o\">),</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"n\">x_1</span> <span class=\"bp\">∈</span> <span class=\"n\">x.snd</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">x_1</span>\n<span class=\"n\">h'</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">ss</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">s.declarations</span>\n<span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">hs</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ss</span>\n</code></pre></div>\n<p>The expression: <code>(h _ h' x hs)</code> effectively uses <code>h</code> as a function of 4 arguments:</p>\n<ul>\n<li><code>(x : String × Strings)</code> given by the placeholder <code>_</code></li>\n<li><code>x ∈ Std.AssocList.toList s.declarations</code> given by the hypothesis <code>h'</code></li>\n<li><code>(x_1 : String)</code> given by <code>x</code></li>\n<li><code>x_1 ∈ x.snd</code> given by the hypothesis <code>hs</code></li>\n</ul>\n<p>Did I get this right?</p>",
        "id": 320007767,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673126810
    },
    {
        "content": "<p>Are you asking about what the <code>rintro</code> tactic does? <code>rintro</code> is just <code>intro</code> then <code>cases</code>, and <code>rintro rfl</code> is just <code>intro h</code> and then <code>subst h</code>.</p>",
        "id": 320070490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1673181359
    },
    {
        "content": "<p>I read this in the doc; however p, it’s application in this particular proof is unclear to me because it seems to be matching the LHS of the goal instead of the whole goal.</p>\n<p>Then it took me a while to understand how the last line works; which is close to magical.</p>",
        "id": 320098324,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673197208
    },
    {
        "content": "<p>The goal looks like <code>A -&gt; B</code> (here both A and B are complicated). <code>intro</code> doesn't \"match on the LHS\", rather it introduces <code>a : A</code> into the context and turns the goal into <code>B</code></p>\n<p>In particular, <code>A</code> here looks like <code>x /\\ y \\/ z</code>. Normally, you could do <code>intro h</code>, which would give you <code>h : x /\\ y \\/ z</code> in the context. Then you can destruct the ands and ors with <code>split</code>, etc. <code>rintro</code> just makes things easier by allowing you to destruct while introducing. So you could also write <code>rintro ((hx, hy) | hz)</code>, where the <code>|</code> eliminates on <code>or</code>, and the <code>&lt;hx, hy&gt;</code> destructs the and. However, notice <code>x</code> and <code>y</code> are also equalities, and most likely your next step would have been <code>subst hx; subst hy</code> -- so <code>rintro</code> also allows the sugar <code>rfl</code> to automatically do that for you.</p>",
        "id": 320099449,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673197963
    },
    {
        "content": "<p>Ah, thanks <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span> for the explanation.</p>",
        "id": 320118159,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673211156
    },
    {
        "content": "<p>Also worth clarifying, small but important distinction:</p>\n<ul>\n<li><code>∀ (x : String), x ∈ ss → ...</code> is a type (specifically a dependent function type)</li>\n<li><code>(x : String) → x ∈ ss → ...</code> is equivalent to that type, written in a syntax that emphasizes the function aspect</li>\n</ul>\n<p>These are distinct from</p>\n<ul>\n<li><code>fun (x : String) =&gt; fun (hs : x ∈ ss) =&gt; ...</code>, a value of the above types</li>\n<li><code>fun (x : String) (hs : x ∈ ss) =&gt; ...</code> is equivalent to the above value, just with more syntax sugar</li>\n</ul>\n<p>So the function value inhabits the (dependent) function type, and the forall quantifier is secretly just a dependent function type. <code>exact blah</code> is a tactic that lets you provide a term whose type is <code>exact</code>ly the goal. So here we are providing a value of type <code>∀ (x : String), ...</code>, but terms of that type look like <code>fun (x : String) =&gt; ...</code></p>",
        "id": 320126994,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673218865
    },
    {
        "content": "<p>Oh, thanks <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span>, this is indeed a subtle aspect of the propositions-as-types correspondence that I misunderstood.</p>\n<p>To be fair, what you wrote above is clearer to me than the cryptic doc here:<br>\n<a href=\"https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html\">https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html</a></p>\n<blockquote>\n<p>The Calculus of Constructions therefore identifies dependent arrow types with forall-expressions in this way. If p is any expression, ∀ x : α, p is nothing more than alternative notation for (x : α) → p, with the idea that the former is more natural than the latter in cases where p is a proposition.</p>\n</blockquote>\n<p>I've read the above several times and I had not quite grasped the subtle distinction you're making, particularly the last paragraph.</p>",
        "id": 320128324,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673220170
    },
    {
        "content": "<p>Ah, yeah, that page seems hard to parse. I'll look into cleaning it up...</p>",
        "id": 320128566,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673220388
    },
    {
        "content": "<p>Following earlier advice to simplify the functions even more, I reduced my struggle to the following MWE.</p>\n<p>Below, there is a single function, <code>addSup</code>, for which I want to show that the result contains the element being added.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"n\">l</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I tried to proove this by induction on <code>l</code>; however, I ended up getting stuck at showing that a proof terminates.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE5a</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addSup</span> <span class=\"o\">:</span> <span class=\"n\">Strings</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Strings</span>\n<span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">sup</span>       <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">sup</span>  <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span> <span class=\"k\">then</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"k\">else</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"n\">xs</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addSup.nil</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">List.elem</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"o\">[]</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addSup</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addSup.more</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">List.elem</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">sup</span><span class=\"o\">))</span>\n<span class=\"o\">:</span>   <span class=\"n\">List.elem</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addSup</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span>\n    <span class=\"bp\">.</span> <span class=\"n\">next</span> <span class=\"n\">ht</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp_all</span>\n    <span class=\"bp\">.</span> <span class=\"n\">next</span> <span class=\"n\">hf</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp_all</span>\n      <span class=\"n\">split</span>\n      <span class=\"bp\">.</span> <span class=\"n\">rfl</span>\n      <span class=\"bp\">.</span> <span class=\"n\">split</span>\n        <span class=\"bp\">.</span> <span class=\"n\">simp_all</span>\n        <span class=\"bp\">.</span> <span class=\"n\">next</span> <span class=\"n\">ht</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.elem</span><span class=\"o\">]</span>\n          <span class=\"n\">split</span>\n          <span class=\"bp\">.</span> <span class=\"n\">rfl</span>\n          <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">addSup.more</span><span class=\"o\">]</span>     <span class=\"c1\">-- lean says: failed to prove termination</span>\n    <span class=\"n\">assumption</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">addSup.more</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">xs</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.length</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addSup.cons</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">List.elem</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">xs</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">addSup</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">inl</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp_all</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">inr</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">next</span> <span class=\"n\">hf</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n        <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">apply</span> <span class=\"n\">addSup.more</span> <span class=\"n\">x</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"n\">sup</span> <span class=\"n\">tail_ih</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE5a</span>\n</code></pre></div>\n<p>Above, the line <code>rw [← addSup.more] </code> shows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">remaining</span> <span class=\"n\">goals</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">decreasing_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">your</span> <span class=\"n\">own</span> <span class=\"n\">tactic</span> <span class=\"n\">for</span> <span class=\"n\">discharging</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">goal</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n<span class=\"n\">xhead</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">List.elem</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">List.length</span> <span class=\"n\">xs</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"n\">as</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Since I matched on <code>xs</code> and obtained a case: <code>a :: as</code>, the goal above should be true.</p>\n<p>I get the feeling that this proof strategy is overly complicated but I am not sure what it is that I'm missing.</p>\n<p>Any suggestions?</p>",
        "id": 320149972,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673240735
    },
    {
        "content": "<p>If you just want to expose the fact that you pattern matched on <code>xs</code>, you can instead <code>match h_xs : xs with ...</code> and then use <code>subst_vars</code> to substitute <code>a::as</code> for <code>xs</code>. Not sure RE: simplifying the overall proof structure though...</p>",
        "id": 320150514,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673241304
    },
    {
        "content": "<p>Here's how I would approach your original theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addSup</span> <span class=\"n\">l</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.contains</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">List.elem_eq_true_of_mem</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addSup</span><span class=\"o\">]</span>\n  <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><code>List.elem_eq_true_of_mem</code> should be a simp lemma, which would have eliminated that line</p>",
        "id": 320150757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673241599
    },
    {
        "content": "<p>also <code>addSup</code> is called <code>List.insert</code> in std (although it pushes the element to the front instead of the end)</p>",
        "id": 320150860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673241676
    },
    {
        "content": "<p>ok, I followed Mario's suggestion to use <code>List.insert</code> instead of my own...</p>\n<p>Now, I am getting stuck at prooving an existential property:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE7</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addBoth</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span>            <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bif</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">as.insert</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"n\">tail</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.nil</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.sub</span> <span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">ss</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ss</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n   <span class=\"c1\">-- apply Exists.elim</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE7</span>\n</code></pre></div>\n<p>Just before the <code>sorry</code>, the tactic state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"n\">bif</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">List.insert</span> <span class=\"n\">sup</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">tail</span>\n        <span class=\"k\">else</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n</code></pre></div>\n<p>According to <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier\">https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier</a><br>\nI should be able to apply the <code>Exists.elim</code> tactic; however, there are implicit variables in that theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Exists.elim</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n   <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Exists</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h₂</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>So if I apply this tactic, I get subgoals that I have no idea how to discharge:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">h₁</span>\n<span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"n\">case</span> <span class=\"n\">h₂</span>\n<span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"bp\">?</span><span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n          <span class=\"n\">Std.AssocList.toList</span>\n            <span class=\"o\">(</span><span class=\"n\">bif</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">List.insert</span> <span class=\"n\">sup</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">tail</span>\n            <span class=\"k\">else</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n        <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"n\">case</span> <span class=\"n\">α</span>\n<span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">⊢</span> <span class=\"kt\">Sort</span> <span class=\"bp\">?</span><span class=\"n\">u.3967</span>\n<span class=\"n\">case</span> <span class=\"n\">p</span>\n<span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">?</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>How do I handle this kind of proof?</p>",
        "id": 321284747,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673657040
    },
    {
        "content": "<p>Exists.elim lets you sort of “forward” the burden of existence to a different existential. Here, if you apply <code>Exists.elim tail_ih</code>, you’ll be left with the goal to prove that the tail_ih property implies the goal before Exists.elim</p>",
        "id": 321289364,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673660388
    },
    {
        "content": "<p>And since you’re supplying h1 in Exists.elim explicitly, it will unify against that to figure out the implicit variables in the theorem :)</p>",
        "id": 321289446,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673660439
    },
    {
        "content": "<p>I think I need something that deconstructs the goal, not the hypothesis and split the cases for the nested <code>bif ...</code> expression.</p>\n<p>The closest I managed to get is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">addBoth</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span>            <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bif</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">as.insert</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"n\">tail</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.sub</span> <span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">ss</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ss</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span>\n    <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n\n    <span class=\"o\">}</span>\n    <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">nh</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n\n    <span class=\"o\">}</span>\n</code></pre></div>\n<p>Now, in the <code>pos</code> case, the tactic state becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"n\">bif</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">List.insert</span> <span class=\"n\">sup</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">tail</span>\n        <span class=\"k\">else</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n</code></pre></div>\n<p>and in the <code>neg</code>case, I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"n\">nh</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"n\">bif</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">List.insert</span> <span class=\"n\">sup</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">tail</span>\n        <span class=\"k\">else</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n</code></pre></div>\n<p>Now, it seems that I need to deconstruct the existential quantifier of the goal, not the <code>tail_ih</code> hypothesis.</p>\n<p>With <code>apply Elim.exists</code>, I get multiple cases for the implicit parameters of the theorem; that does not seem the right way to go.</p>\n<p>With <code>apply Elim.exists tail_ih</code>, the goal transforms from just an existential quantification into an implication of a universal quantification for the existential quantification. That seems to me going backwards, not towards deconstructing the goal.</p>\n<p>It seems to me that there is something missing in the guidance for dealing w/ existential quantifiers.</p>",
        "id": 321413043,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673734053
    },
    {
        "content": "<p>The <code>tail_ih</code> hypothesis can be split using <code>match</code> or <code>cases</code> to put the <code>x</code> and the proof of its properties into context.</p>\n<p>Then, if you can come up with some expression <code>e</code> for which the goal properties hold, you can <code>refine ⟨e, ?_⟩</code> to claim <code>e</code> satisfies those properties (you then have to prove it does satisfy those properties)</p>",
        "id": 321413269,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673734274
    },
    {
        "content": "<p>I had the impression that the <code>x</code> of <code>tail_ih</code> is the same <code>x</code> that works for the goal, in which case <code>apply Exists.elim tail_ih; intro h</code> is basically the same as doing the above steps one at a time</p>",
        "id": 321413428,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673734394
    },
    {
        "content": "<p>TPIL has a <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier\">section</a> about existentials that will probably explain better than I can</p>",
        "id": 321413728,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673734618
    },
    {
        "content": "<p>I found something helpful: <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Golfable.20proof.3F/near/311749494\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.9C.94.20Golfable.20proof.3F/near/311749494</a></p>\n<p>Then I managed to make progress:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addBoth</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span>            <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bif</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">as.insert</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"n\">tail</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cond_eq_ite</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cond</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.sub</span> <span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">ss</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ss</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond_eq_ite</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">sub</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ss</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"gr\">sorry</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>When the condition is true, I solved the goal by simply applying the condition to simplify the <code>if</code>.</p>\n<p>When the condition is false, it seems that I need some other theorem to simplify the <code>if</code>, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">sub</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">sup</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">List.insert</span> <span class=\"n\">sup</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">tail</span>\n        <span class=\"k\">else</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sup</span> <span class=\"n\">value</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n</code></pre></div>",
        "id": 321414281,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673735071
    },
    {
        "content": "<p>Got it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE7</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addBoth</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span>            <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bif</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">as.insert</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"n\">tail</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.nil</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cond_eq_ite</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cond</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.sub</span> <span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">ss</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ss</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond_eq_ite</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">sub</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ss</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE7</span>\n</code></pre></div>\n<p>There is probably a way to simplify the proof; this is my first non-trivial proof about a non-trivial data structure operation that I managed to do in Lean! Yeah!</p>",
        "id": 321414482,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673735254
    },
    {
        "content": "<p>If you want cool lean tricks, you can write the induction as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">ss</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"n\">next</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond_eq_ite</span><span class=\"o\">]</span>\n    <span class=\"bp\">....</span>\n</code></pre></div>\n<p>It looks pretty clean overall :D</p>",
        "id": 321415637,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673736213
    },
    {
        "content": "<p>Thanks for the tip. Encouraged by this progress, I tried to prove something a bit more difficult that requires dealing w/ an existential quantifier. <br>\nI think I can simplify the proof w/ an auxiliary lemma but I am not sure how to handle this pattern.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.AssocList</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE8</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Strings</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addBoth</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span>            <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"n\">sup</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bif</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">sub</span> <span class=\"o\">(</span><span class=\"n\">as.insert</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"n\">tail</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.nil</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">cond_eq_ite</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cond</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.tail</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">tail</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">tail</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp_all</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">h</span> <span class=\"n\">ht</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp_all</span>\n      <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addBoth.sup</span> <span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">ss</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sup</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.AssocList.contains</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ss</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n  <span class=\"bp\">.</span> <span class=\"n\">next</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond_eq_ite</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">sub</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"n\">ss</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ss</span><span class=\"o\">]</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Exists.elim</span> <span class=\"n\">tail_ih</span>\n        <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n        <span class=\"n\">apply</span> <span class=\"n\">addBoth.tail</span> <span class=\"n\">a</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span> <span class=\"n\">h</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE8</span>\n</code></pre></div>\n<p>For the <code>nil</code> case, the <code>sorry</code> tactic state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Strings</span>\n<span class=\"n\">subsup</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">,</span> <span class=\"o\">[])</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">sup</span><span class=\"o\">]))</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p>Here, <code>h</code> is \"obviously\" false so I should be able to proove this by contradiction, splitting over <code>h</code>.<br>\nNot sure how to do this...</p>\n<p>For the <code>cons.neg</code> case, the <code>sorry</code> tactic state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Strings</span>\n<span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">tail</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">tail</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"n\">ht</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">tail</span> <span class=\"bp\">∧</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n</code></pre></div>\n<p>This seems like regressing back to the original goal. </p>\n<p>I am wondering if this is the right proof strategy.</p>",
        "id": 321419843,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1673740030
    }
]
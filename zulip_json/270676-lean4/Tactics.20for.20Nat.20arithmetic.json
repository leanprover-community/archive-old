[
    {
        "content": "<p>Are there tactics I can use to handle basic Nat arithmetic?  Here is an example that I was trying to solve with <code>simp</code>,<code>ring</code>, <code>nlarith</code>, to no avail.  I couldn't even get the <code>fn</code>term to cancel out without manually reassociating terms, etc.</p>\n<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Ring</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">fn</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">demo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">:</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">fn</span> <span class=\"n\">tail</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">accum</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">+</span> <span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"bp\">-</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">List.length</span> <span class=\"n\">tail</span> <span class=\"bp\">=</span>\n  <span class=\"n\">fn</span> <span class=\"n\">tail</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"bp\">-</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">List.length</span> <span class=\"n\">tail</span> <span class=\"bp\">+</span>\n    <span class=\"n\">accum</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 318347588,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1672277492
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 318349531,
        "sender_full_name": "Dean Young",
        "timestamp": 1672279688
    },
    {
        "content": "<p>It's not clear to me that your goal is true. It seems to me that it would follow if you knew that <code>(x + y) - z = x + (y - z)</code> in the particular case <code>x = accum * 10</code>, <code>y = Char.toNat head</code> and <code>z = Char.toNat (Char.ofNat 48)</code>, and this is not true for naturals in general because of stupid natural subtraction. You would be OK if you know z &lt;= y but it's not the job of tactics like <code>ring</code> to supply this proof obligation; this is one of the reasons you're having no luck. Modulo that issue, in Lean 3 you would probably be able to use the <code>ring_exp</code> tactic but I'm not sure that this has been ported yet. A good first move would be <code>rw [Nat.succ_eq_add_one, pow_add, pow_one]</code> (which now takes you into <code>ring</code> territory) but now automation is blocked on the missing proof that <code>z &lt;= y</code>.</p>",
        "id": 318352810,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672283027
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">demo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">:</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">fn</span> <span class=\"n\">tail</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">accum</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">+</span> <span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"bp\">-</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">List.length</span> <span class=\"n\">tail</span> <span class=\"bp\">=</span>\n    <span class=\"n\">fn</span> <span class=\"n\">tail</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"bp\">-</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">List.length</span> <span class=\"n\">tail</span> <span class=\"bp\">+</span>\n    <span class=\"n\">accum</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">,</span> <span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">pow_one</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- is this true? If not your goal is probably false</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_sub_assoc</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 318353176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672283382
    },
    {
        "content": "<p>Ok interesting, it looks like the difficulty here was an unexpected difference in the association on either side of the equation.  Once that is fixed, <code>ring</code> will <em>almost</em> solve it, it just needs <code>Nat.succ_eq_add_one</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">demo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">:</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">fn</span> <span class=\"n\">tail</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">accum</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"bp\">-</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">)))</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">List.length</span> <span class=\"n\">tail</span> <span class=\"bp\">=</span>\n  <span class=\"n\">fn</span> <span class=\"n\">tail</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Char.toNat</span> <span class=\"n\">head</span> <span class=\"bp\">-</span> <span class=\"n\">Char.toNat</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"mi\">48</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">List.length</span> <span class=\"n\">tail</span> <span class=\"bp\">+</span>\n    <span class=\"n\">accum</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>A few follow-up questions:</p>\n<ol>\n<li>Is <code>Nat.succ</code> bad for using these sorts of arithmetic tactics, so I should always manually eliminate it? (Maybe this could be done automatically?)</li>\n<li>Outside of a proof assistant, the way I would approach this proof is to check if it is true in Z, and then check that each step of my proof also holds in N.  Is there a tactic that would do something like this?</li>\n<li>The reason why this stumped me so much was because the <code>ring</code> tactic wasn't making any progress despite the fact that it was very close to working.  It would be more user friendly if there was a tactic that would distribute and eliminate matching terms even if it wasn't able to solve it, as this would highlight the problematic terms that remain.</li>\n</ol>",
        "id": 318366289,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1672296569
    },
    {
        "content": "<p>For 2. there is a mathlib(4) tactic called zify that is used to do this sort of thing, automatically translating to a Z version of an N goal.<br>\nFor 1. It's probably a good idea yes.<br>\nAnd for 3. That is indeed annoying, sometimes you can rewrite and equality to a subtraction equals zero and use <code>ring_nf</code> to normalize and see what's left</p>",
        "id": 318386236,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1672307899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>, doesn't your tactic aim to do 3.?</p>",
        "id": 318403249,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672314844
    },
    {
        "content": "<p>Please no more lean 3 tactics! All they do is cause trouble for the port right now.</p>",
        "id": 318419261,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672320812
    },
    {
        "content": "<p>For </p>\n<ol>\n<li>I had a look at the source code for the <code>ring</code> tactic, but I couldn't figure out a good place to add <code>Nat.succ</code> normalization.</li>\n<li><code>zify</code> seems to require the user to know ahead of time which inequalities are necessary to solve in Z. Is there a version that will generate additional goals instead?</li>\n<li>I would be interested in knowing what Damiano's tactic is :)</li>\n</ol>\n<p>I'd love to try to help improve things so they are more user friendly and discoverable.  For someone who is more experienced it probably doesn't make much of a difference, but for a newbie like me it can save hours of being confused!</p>",
        "id": 318656491,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1672435388
    },
    {
        "content": "<p>Damiano's tactic is <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#move_add\">tactic#move_add</a></p>",
        "id": 318657797,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672436146
    },
    {
        "content": "<p>Here is another example of a <code>Nat</code> equality that was causing me problems.  Ultimately I had to introduce three lemmas to make <code>zify</code> convert everything to <code>Z</code>, and <code>ring</code> still wouldn't solve it without <code>apply Int.eq_of_sub_eq_zero</code> first.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Ring</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">fn</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">demo</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">&lt;</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)):</span>\n  <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>  <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">≥</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₃</span><span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">calc</span>\n    <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₄</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_pred_of_lt</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"n\">zify</span> <span class=\"o\">[</span><span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"n\">h₄</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Int.eq_of_sub_eq_zero</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 318662285,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1672439078
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">demo</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">&lt;</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n    <span class=\"n\">Eq.symm</span> <span class=\"o\">(</span><span class=\"n\">Nat.sub_sub_self</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_sub_of_add_le</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>We have enough library stuff to make a term mode proof pretty painless. The <code>Eq.symm</code> is because you shouldn't be stating theorems like that -- when you write <code>A = B</code> the convention is to have <code>A</code> the more complicated side; this is the convention which aligns with the way <code>rw</code> works for example. In general you would use a tactic like <code>omega</code> to do this but we don't have an <code>omega</code> in Lean 4 yet.</p>",
        "id": 318664746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672440737
    }
]
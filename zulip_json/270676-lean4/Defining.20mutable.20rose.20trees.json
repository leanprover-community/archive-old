[
    {
        "content": "<p>I'm trying to define a data structure that, in slightly simplified form, amounts to a mutable rose tree, where nodes carry references to their children and a reference back to their parent. I've found a way to do it (see below), but it's a bit cumbersome. Is there a more elegant way?</p>\n<p>My construction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">inductive</span> <span class=\"n\">MutRoseTreeImp</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span>\n  <span class=\"o\">(</span><span class=\"n\">parent</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">IO.Ref</span> <span class=\"o\">(</span><span class=\"n\">MutRoseTreeImp</span> <span class=\"n\">α</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">IO.Ref</span> <span class=\"o\">(</span><span class=\"n\">MutRoseTreeImp</span> <span class=\"n\">α</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">payload</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MutRoseTreeSpec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">MutRoseTree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"n\">construct</span> <span class=\"o\">:</span>\n    <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">IO.Ref</span> <span class=\"n\">MutRoseTree</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">IO.Ref</span> <span class=\"n\">MutRoseTree</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">α</span> <span class=\"bp\">→</span>\n    <span class=\"n\">MutRoseTree</span>\n  <span class=\"n\">parent</span> <span class=\"o\">:</span> <span class=\"n\">MutRoseTree</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">IO.Ref</span> <span class=\"n\">MutRoseTree</span><span class=\"o\">)</span>\n  <span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">MutRoseTree</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">IO.Ref</span> <span class=\"n\">MutRoseTree</span><span class=\"o\">)</span>\n  <span class=\"n\">payload</span> <span class=\"o\">:</span> <span class=\"n\">MutRoseTree</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"c1\">-- We could add equations relating `construct` and the field accessors.</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MutRoseTreeImp</span> <span class=\"k\">in</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">MutRoseTreeSpecImp</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">MutRoseTreeSpec</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">MutRoseTree</span> <span class=\"o\">:=</span> <span class=\"n\">MutRoseTreeImp</span> <span class=\"n\">α</span>\n  <span class=\"n\">construct</span> <span class=\"o\">:=</span> <span class=\"n\">MutRoseTreeImp.mk</span>\n  <span class=\"n\">parent</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"n\">children</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"n\">payload</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[implementedBy MutRoseTreeSpecImp]</span>\n<span class=\"kd\">constant</span> <span class=\"n\">mutRoseTreeSpec</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">MutRoseTreeSpec</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">MutRoseTree</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n  <span class=\"n\">construct</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"n\">parent</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">arbitrary</span>\n  <span class=\"n\">children</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">arbitrary</span>\n  <span class=\"n\">payload</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MutRoseTree</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">mutRoseTreeSpec</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">MutRoseTree</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MutRoseTree</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mutRoseTreeSpec</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">construct</span>\n<span class=\"kd\">def</span> <span class=\"n\">parent</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mutRoseTreeSpec</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">parent</span>\n<span class=\"kd\">def</span> <span class=\"n\">children</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mutRoseTreeSpec</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">children</span>\n<span class=\"kd\">def</span> <span class=\"n\">payload</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mutRoseTreeSpec</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">payload</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MutRoseTree</span>\n</code></pre></div>\n<p>Some questions you might have:</p>\n<ul>\n<li>Why is <code>MutRoseTreeImp</code> unsafe in the first place? Because apparently the kernel doesn't know that IORefs are strictly positive, so without the <code>unsafe</code> it complains about an invalid occurrence of <code>MutRoseTreeImp</code> in a constructor argument.</li>\n<li>Can you generalise to <code>STRef</code>? No, this gives error \"(kernel) mutually inductive types must live in the same universe\". This seems like a bug. I imagine Lean tries to compile the data type as a nested type and introduces some universe issue during that. (But why doesn't the same happen with <code>IORef</code>?)</li>\n<li>Why do you need the type to be non-<code>unsafe</code> in the first place? I don't really, this is for a tactic so I guess I could just leave everything unsafe. But where's the fun in that?</li>\n</ul>",
        "id": 241375063,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1622718012
    },
    {
        "content": "<p>Regarding Q2:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Ref</span> <span class=\"o\">:=</span> <span class=\"n\">ST.Ref</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">inductive</span> <span class=\"n\">MutRoseTreeImp</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span>\n  <span class=\"o\">(</span><span class=\"n\">parent</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">MutRoseTreeImp</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">MutRoseTreeImp</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">payload</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 241378243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622720265
    },
    {
        "content": "<p>very strange</p>",
        "id": 241378253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622720271
    },
    {
        "content": "<p>Ah, that's a nice workaround for now. Thanks!</p>",
        "id": 241378394,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1622720375
    },
    {
        "content": "<p>I'm not sure it's a good idea, but you can use the type unsafety mechanism I just posted about in order to avoid <code>unsafe</code> here, by storing effectively <code>void*</code> pointers in the inductive (which means it doesn't need to be recursive) and casting them to rose tree pointers for the API</p>",
        "id": 241380118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622721482
    },
    {
        "content": "<p>Evil (but delightful?). This would make the construction a lot shorter, but I guess the STRefs will become opaque at some point so I won't rely on it.</p>",
        "id": 241381769,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1622722428
    }
]
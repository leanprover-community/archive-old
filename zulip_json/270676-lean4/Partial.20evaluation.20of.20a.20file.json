[
    {
        "content": "<p>I'm having a hard time working with a file with some heavy computations. I have few questions regarding this:</p>\n<ol>\n<li>\n<p>Is it possible to evaluate file only up to the cursor position? I do not want to waste computation on recomputing all the heavy computations that I'm not currently working. In Coq(Proof General mode in emacs) you can 'confirm' line by line, this way you have a bit more control when stuff gets evaluated.</p>\n</li>\n<li>\n<p>When I modify a proof, is it evaluated from scratch or from the last valid non modified point?</p>\n</li>\n</ol>\n<p>I have mwe for this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">4000</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxHeartbeats</span> <span class=\"mi\">500000</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxSize</span> <span class=\"mi\">100000</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">maxRecDepth</span> <span class=\"mi\">10000</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lhs</span>\n    <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>When you modify <code>enter [1]</code> to <code>enter [1,1]</code> the goal should changes from <code>(1 + 1) * n + 1 * n</code> to <code>(1 + 1) * n</code> and I would expect this to happen immediately as it is just traversing an expression. However, it looks like that each time you modify anything <code>rw[foo]</code> gets reevaluated  and that takes a long time :( </p>\n<p>Are there some editor options on how a file is evaluated?</p>",
        "id": 277212980,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648680629
    },
    {
        "content": "<blockquote>\n<p>Is it possible to evaluate file only up to the cursor position?</p>\n</blockquote>\n<p>Simple workaround: put an <code>#exit</code>command at the place you want Lean to stop. It helps for files with a bunch of theorems/definitions. It will not help in the example above.</p>\n<blockquote>\n<p>When I modify a proof, is it evaluated from scratch or from the last valid non modified point?</p>\n</blockquote>\n<p>Lean starts from the last checkpoint (i.e., at the beginning of the current command).</p>",
        "id": 277213362,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648680986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277213362\">said</a>:</p>\n<blockquote>\n<p>Lean starts from the last checkpoint (i.e., at the beginning of the current command).</p>\n</blockquote>\n<p>That is odd, because even if the code looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>  <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>When changing <code>enter [1]</code> to <code>enter [1,1]</code>, it takes quite time for the goal to update from <code>1 * n + 1 * n</code> to <code>1 * n</code>. It looks like that the goal view is updated only once the whole proof is traversed. (This might be a problem with emacs, I didn't test it in VS Code)</p>",
        "id": 277213668,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648681228
    },
    {
        "content": "<p>The checkpoint is at the beginning of the <code>example</code> command. Every modification on this command will force Lean to re-elaborate the command from the beginning. The <code>rw [foo]</code> step is quite expensive because Lean needs to synthesize <code>[A 4000 a b]</code>.</p>",
        "id": 277213988,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648681461
    },
    {
        "content": "<p>I am using Emacs, and it seems to be working as expected. For every modification I make at <code>example</code>, I get the orange bar only at this command.</p>",
        "id": 277214063,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648681543
    },
    {
        "content": "<p>My use case is that I'm working with a quite complicated expression that I simplify with quite expensive <code>simp</code> call. Then I need to navigate to its subexpression with <code>conv</code> to modify it to desired final form. Figuring out the desired <code>enter [??]</code> to navigate to the correct subexpression is difficult without interactivity.</p>",
        "id": 277214210,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648681680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277214063\">said</a>:</p>\n<blockquote>\n<p>I am using Emacs, and it seems to be working as expected. For every modification I make at <code>example</code>, I get the orange bar only at this command.</p>\n</blockquote>\n<p>I'm having the same behavior. I just didn't know that checkpoints are only at commands. A long time ago when I was playing with Coq, it had checkpoints after every tactic call and I was hoping that Lean would have that too.</p>",
        "id": 277214403,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648681815
    },
    {
        "content": "<p>It is difficult to integrate this with lean's elaboration mechanism since tactics can appear in subterms and generally trade off elaboration with other tactic blocks or subterms</p>",
        "id": 277214468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648681908
    },
    {
        "content": "<p>it wouldn't even be syntactically correct to just stop in the middle of a tactic proof and then pick it up later</p>",
        "id": 277214516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648681937
    },
    {
        "content": "<p>How do people write complicated proofs if every modification to it makes it re-evaluate?</p>",
        "id": 277214601,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648682025
    },
    {
        "content": "<p>they use more lemmas</p>",
        "id": 277214837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682215
    },
    {
        "content": "<p>or use <code>sorry { ... }</code> to stub out subproofs</p>",
        "id": 277214848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682230
    },
    {
        "content": "<p>very large proofs are a bad idea for several reasons so it doesn't bother me so much that this live response slowdown gently prods people to break up big proofs into smaller pieces</p>",
        "id": 277214928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682315
    },
    {
        "content": "<p><span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span>  I'm sad about this. I want to use tactic mode to do something like what computer algebra systems do where you step by step modify an expression to a desired form. Some manipulations can be quite expensive and you do not know the intermediate forms to break it up to several pieces.</p>",
        "id": 277215172,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648682564
    },
    {
        "content": "<p>Would it be possible to have a tactic <code>checkpoint</code>? That would cache the state?</p>",
        "id": 277215195,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648682601
    },
    {
        "content": "<p>in your example, you can work around this by writing the intermediate form after the expensive <code>simp [...]</code>, and then do <code>suffices : ... by sorry</code> in place of the <code>simp</code></p>",
        "id": 277215216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682632
    },
    {
        "content": "<p>There have been talks about plans to checkpoint between tactics this but I don't know what stage they are in</p>",
        "id": 277215287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682678
    },
    {
        "content": "<p>I would guess it's not a very high priority</p>",
        "id": 277215307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682701
    },
    {
        "content": "<p>I wonder whether it is possible to write such a tactic in userland using <code>IO</code> references</p>",
        "id": 277215407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682773
    },
    {
        "content": "<p>which IIUC are not rolled back along with the environment</p>",
        "id": 277215433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277215216\">said</a>:</p>\n<blockquote>\n<p>in your example, you can work around this by writing the intermediate form after the expensive <code>simp [...]</code>, and then do <code>suffices : ... by sorry</code> in place of the <code>simp</code></p>\n</blockquote>\n<p>The problem is that the intermediate form is often quite complicated and just copy pasting it does not work as it is quite often missing some type anotations.</p>",
        "id": 277215437,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648682815
    },
    {
        "content": "<p>my impression was that lean 4 is better at pp roundtripping, but <code>pp.all</code> is a hammer to solve the problem</p>",
        "id": 277215465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648682857
    },
    {
        "content": "<p>Yay the expression I'm working with is 570 lines of code with <code>pp.all</code> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 277215582,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648682983
    },
    {
        "content": "<p>maybe unfolding everything wasn't a good idea...?</p>",
        "id": 277215679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648683053
    },
    {
        "content": "<p>It is just a complicated algebraic expression where every operation contains the projection e.g. from <code>VectorSpace</code> to <code>AddCommGroup</code> to <code>AddGroup</code> to <code>SubNegMonoid</code> to <code>Sub</code>. That totally explodes the expression.</p>",
        "id": 277216085,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648683431
    },
    {
        "content": "<p>turning off implicits should help with that. Those subterms are shared anyway</p>",
        "id": 277216584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648683891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277215407\">said</a>:</p>\n<blockquote>\n<p>I wonder whether it is possible to write such a tactic in userland using <code>IO</code> references</p>\n</blockquote>\n<p>Not sure how to do <code>checkpoint</code> but maybe something like <code>cached simp</code> would be possible. It would store the state before and after you execute <code>simp</code>. The next time it gets evaluated you first check if the state corresponds to the cached one and just load the state after.</p>",
        "id": 277217215,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648684470
    },
    {
        "content": "<p>that's what I'm trying now. the hard part is that the state is completely different with regard to metavariable and local variable unique names</p>",
        "id": 277217259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648684521
    },
    {
        "content": "<p>you can't just use the old expression</p>",
        "id": 277217269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648684532
    },
    {
        "content": "<p>Step ahead :) yeah that is indeed a problem</p>",
        "id": 277217347,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648684592
    },
    {
        "content": "<p>What would be sufficient for me it to cache only <code>conv</code> commands. If I understand it right, it would be enough to store the final form and equality to the original after a rewrite. This should get rid off metavariables. The problem with local variables stays.</p>",
        "id": 277217700,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648684853
    },
    {
        "content": "<p>my plan is to support <code>macro \"checkpoint\" \" =&gt; \" tacs:tacticSeq : tactic =&gt; ...</code></p>",
        "id": 277217763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648684908
    },
    {
        "content": "<p>which works like what you said about <code>cached</code></p>",
        "id": 277217820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648684932
    },
    {
        "content": "<p>you could have a version of this for conv too</p>",
        "id": 277217829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648684944
    },
    {
        "content": "<p>Having that would be really great!</p>",
        "id": 277217839,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648684962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277214928\">said</a>:</p>\n<blockquote>\n<p>very large proofs are a bad idea for several reasons so it doesn't bother me so much that this live response slowdown gently prods people to break up big proofs into smaller pieces</p>\n</blockquote>\n<p>I think this opinion comes from the fact that most of mathlib is still laying down very elementary foundations. In real mathematics most proofs simply can't be broken up like this. I consider this a major issue of Lean 3. Of course this isn't blocking mathport so it isn't a priority in Lean 4, but it could very well be the very top priority from a user perspective after the port.</p>",
        "id": 277237193,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1648707087
    },
    {
        "content": "<p>I used to laugh at Coq's curtain going up and down the file, but nowadays I really wish I could have this in Lean so that I would get an immediate tactic state update when typing.</p>",
        "id": 277237276,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1648707154
    },
    {
        "content": "<p>The reasons to break up proofs also have to do with readability to other people, not just lean. These huge proofs are really not desirable in any sense. Of course we should try to address these issues with tooling support where possible, but it's papering over the issue. I am reminded of an adage I learned from who knows where: if you hit a system limit like a timeout or stack overflow, you should first consider whether you are doing something wrong before increasing the limit</p>",
        "id": 277237576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648707472
    },
    {
        "content": "<p>The \"elementarity\" of the proof has nothing at all to do with it. You can have large proofs and modular proofs at the high level and the low level equally well</p>",
        "id": 277237793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648707656
    },
    {
        "content": "<p>in CS, a common rule of thumb is to not let your functions get too large or too deeply nested. Saying \"it's okay because I'm building on a big framework\" is not an excuse, and the rule is not related to the effectiveness of the compiler on your code (although if you let it get really bad then you might hit a compiler limit).</p>",
        "id": 277237985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648707827
    },
    {
        "content": "<p>Having abstract principles like this sounds nice, but math simply doesn't work like this.</p>",
        "id": 277238915,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1648708737
    },
    {
        "content": "<p>And cutting a proof into ten lemmas that have the same assumptions and are used only once doesn't increase readability.</p>",
        "id": 277238989,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1648708808
    },
    {
        "content": "<p>it's difficult to get concrete in absence of an example, but I have done plenty of big proofs enough to say that it's possible to have discipline to use definitions when needed to break proofs into parts, even if some of the lemmas have no reasonable names</p>",
        "id": 277239127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648708950
    },
    {
        "content": "<p>they at least give you a place to hang documentation</p>",
        "id": 277239139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648708967
    },
    {
        "content": "<p>Another way to phrase what I'm doing. I write down a program specification as a goal and then use bunch of tactics to generate executable code. </p>\n<p>The whole point is that user can write down a simple, short specification that is guaranteed to be correct/exactly what user wants. And lean helps you to build the program you want. </p>\n<p>Breaking it down to multiple steps kind of defeats the purpose.</p>\n<p>Loosing interactivity after few steps of program synthesis is a major problem here.</p>",
        "id": 277239272,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648709086
    },
    {
        "content": "<blockquote>\n<p>Another way to phrase what I'm doing. I write down a program specification as a goal and then use bunch of tactics to generate executable code. </p>\n</blockquote>\n<p>I had a feeling that this was the reason for your code (which was why the claim that it was about algebra was surprising to me)</p>",
        "id": 277239304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709139
    },
    {
        "content": "<p>I am probably incurably of the opinion that anything that takes more than a few seconds to check is Doing It Wrong but I am clearly biased by my experiences with metamath and MM0</p>",
        "id": 277239441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709258
    },
    {
        "content": "<p>I'm building ode solver right now, and the simp tactic was doing complicated gradient computation of an energy function.</p>\n<p>After the differentiation I want to massage the resulting gradient to a form that is fast to execute.</p>",
        "id": 277239515,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648709314
    },
    {
        "content": "<p>Surely that can be done without <code>simp</code></p>",
        "id": 277239520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709327
    },
    {
        "content": "<p>if it is based on syntactically matching the input then it should be doable in ~linear time (aka very fast) using lemma applications</p>",
        "id": 277239578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709399
    },
    {
        "content": "<p>and that's including the <code>conv</code> bits afterward</p>",
        "id": 277239643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709425
    },
    {
        "content": "<p>Not sure what 'syntactic matching' is, but I don't think it is that simple. In particular, I'm taking a differential w.r.t to a function(not a simple variable) and then compute an adjoint of the resulting differential(a linear function) to obtain gradient.</p>",
        "id": 277240074,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648709759
    },
    {
        "content": "<p>Some rewrite steps need proofs that certain functions are linear. Or expressions with sums and Kronecker deltas appear and to eliminate them I need proofs that certain functions are invertible so that the sum can be reindexed and Kronecker's delta eliminated.</p>",
        "id": 277240283,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648709887
    },
    {
        "content": "<p>By syntactic matching, I mean that the form of the output is a function of the syntax that you are given on input (i.e you recurse on the structure of the term). Most things that can be done with typeclasses have this form</p>",
        "id": 277240291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709892
    },
    {
        "content": "<p>all of those things can be handled, especially if you have a closed set of things to handle</p>",
        "id": 277240343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709943
    },
    {
        "content": "<p>even if you don't you can use an attribute</p>",
        "id": 277240354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648709949
    },
    {
        "content": "<p>I have bunch of theorems as rewrite rules that I want to apply. So what am I supposed to use if not simp to apply these theorems?</p>",
        "id": 277240721,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648710197
    },
    {
        "content": "<p><code>norm_num</code> is written like this BTW. You match on the input syntax, and in each case you know exactly which rule you want to apply</p>",
        "id": 277240852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648710299
    },
    {
        "content": "<p>so it's not really just throwing a bag of rewrites at the term until things stop changing</p>",
        "id": 277240889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648710330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277214928\">said</a>:</p>\n<blockquote>\n<p>very large proofs are a bad idea for several reasons so it doesn't bother me so much that this live response slowdown gently prods people to break up big proofs into smaller pieces</p>\n</blockquote>\n<p>As a data point, in my paper on the formalization of the Morse lemma in hyperbolic geometry in Isabelle, the proof of the main lemma (after having isolated everything that could reasonably be split off) is more than 1000 lines long -- it is an intricate double-induction, which it wouldn't make any sense to break into separate lemmas. In Isabelle, it works very smoothly because the system doesn't recompile the whole proof every time, it caches everything until your first modification.</p>",
        "id": 277241043,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1648710467
    },
    {
        "content": "<p>I would actually have just the double-induction framework in the main theorem and break the body into a separate lemma</p>",
        "id": 277241192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648710545
    },
    {
        "content": "<p>that's a pretty clear split point</p>",
        "id": 277241207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648710562
    },
    {
        "content": "<p>aka: I'm glad your compiler can handle 8 levels of nested brackets but I sure can't</p>",
        "id": 277241314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648710640
    },
    {
        "content": "<p>the Con-NF proof also contains a really huge transfinite induction, which spans most of the paper. In the <a href=\"#narrow/stream/116395-maths/topic/The.20consistency.20of.20NF/near/271940213\">lean version</a> this is broken out into a bunch of definitions and theorems, with only a single line definition to tie the knot at the end</p>",
        "id": 277241500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648710798
    },
    {
        "content": "<blockquote>\n<p><code>norm_num</code> is written like this BTW. You match on the input syntax, and in each case you know exactly which rule you want to apply</p>\n</blockquote>\n<p>Once I know the set of rules I want to use, I might implement it like <code>norm_num</code> but right now I'm still figuring out the set of rewrite rules, their order and priorities.</p>",
        "id": 277242201,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648711277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277241192\">said</a>:</p>\n<blockquote>\n<p>I would actually have just the double-induction framework in the main theorem and break the body into a separate lemma</p>\n</blockquote>\n<p>I'm not sure that's a reasonable course of action when the induction assumptions would be like 80 lines.</p>",
        "id": 277242374,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1648711387
    },
    {
        "content": "<p>you would put the assumptions in a definition in that case</p>",
        "id": 277242398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648711413
    },
    {
        "content": "<p>It's not one definition, it's literally 80 lines of properties. Or build up an 80 lines definition, but I'm not sure it's a big gain.</p>",
        "id": 277242486,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1648711466
    },
    {
        "content": "<p>I mean an 80 lines definition, or possibly multiple levels of definition if it's that bad</p>",
        "id": 277242523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648711489
    },
    {
        "content": "<p>the idea is to limit what has to stick around in the reader's head all at once</p>",
        "id": 277242577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648711549
    },
    {
        "content": "<p>Mario I think that what's happening here is that the kind of maths you've seen formalised is of a different nature to the kind of maths Patrick and Sebastien are talking about.</p>",
        "id": 277249173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648715906
    },
    {
        "content": "<p>Perhaps. The proof of the prime number theorem was on similar levels of hairy though, so I'm not really convinced</p>",
        "id": 277250504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648716622
    },
    {
        "content": "<p>The prime number theorem is undergraduate mathematics (at my university).</p>",
        "id": 277251091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648716957
    },
    {
        "content": "<p>yes, it's \"elementary\"</p>",
        "id": 277251159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648716982
    },
    {
        "content": "<p>doesn't make it a small proof though</p>",
        "id": 277251169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648716992
    },
    {
        "content": "<p>it ended up as something like 23 numbered lemmas in order with ~20 hypotheses in most of them</p>",
        "id": 277251225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648717026
    },
    {
        "content": "<p>I agree it doesn't make it a small proof. But it might make it a conceptually simpler proof somehow. I think this is a very interesting question. I finished my course with a proof of the Hilbert Basis Theorem and, just like Sebastien was saying, beyond some point it's extremely difficult to start factoring out sublemmas; you could I guess just do <code>extract_goal</code> at some arbitrary point but then you will end up with single-use very ugly lemmas; beyond some point in history, delicate and complex arguments became more commonplace. Whether or not things scale is something we'll find out soon enough, I suspect.</p>",
        "id": 277258710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648721464
    },
    {
        "content": "<p>It's not even clear it scales for mathematicians. I mean, papers of 100 pages doing one single proof are not uncommon today, and essentially no-one can check these seriously.</p>",
        "id": 277259485,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1648722006
    },
    {
        "content": "<p>I had a good experience with CoqIDE's curtain, as Patrick called it. It felt particularly good when I was reading a Coq book (from the Software Foundations series) in it because it helped me with a sense of progression. The only problem was that it didn't save my progress and then I had to remember where I was and re-run it everytime I closed CoqIDE, so I ended up leaving it open (and idle) for several hours.</p>\n<p>I think the best solution would aggregate the best of both worlds in a on/off toggle fashion. For common programming tasks I prefer Lean to just eat up the entire file everytime I change something. But for heavy typechecking tasks, such as advanced mathematics, there might exist advantages of having cached states in between tactics so Lean doesn't have to compile the same thing over and over.</p>",
        "id": 277259750,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648722202
    },
    {
        "content": "<p>I think that even if the best you can do is <code>extract_goal</code> this is still useful in the sense that it keeps the context bounded in size and you can choose optimal cut-points to keep things manageable</p>",
        "id": 277259903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648722324
    },
    {
        "content": "<p>the lemma might have no useful name, that's okay</p>",
        "id": 277259920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648722335
    },
    {
        "content": "<p>I mean, if the process of making definitions for groups of stuff helps you discover a new concept, great, but it's a useful exercise even if it's just <code>lemma_1, foo.aux_2</code> stuff</p>",
        "id": 277260038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648722404
    },
    {
        "content": "<p>I was getting odd sense of satisfaction for every line that turned green in Coq and I was missing that when I switched to Lean :)</p>",
        "id": 277260058,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648722424
    },
    {
        "content": "<p>And to be clear, I am not at all against checkpointing within a proof, if we can find a way around the technical hurdles. That's a straight win. But it is in service of proofs I would not consider \"good\"</p>",
        "id": 277260171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648722484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277259903\">said</a>:</p>\n<blockquote>\n<p>I think that even if the best you can do is <code>extract_goal</code> this is still useful in the sense that it keeps the context bounded in size and you can choose optimal cut-points to keep things manageable</p>\n</blockquote>\n<p>Might have been my lack of skill, but I've had troubles with <code>extract_goal</code> when there were metavariables involved</p>",
        "id": 277260240,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648722543
    },
    {
        "content": "<p>yes, checkpointing has the same issues</p>",
        "id": 277260279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648722578
    },
    {
        "content": "<p>if you want to be able to checkpoint at an arbitrary position, at least</p>",
        "id": 277260296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648722593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277259750\">said</a>:</p>\n<blockquote>\n<p>I think the best solution would aggregate the best of both worlds. For common programming tasks I prefer Lean to just eat up the entire file everytime I change something. But for heavy typechecking tasks, such as advanced mathematics, there might exist advantages of having cached states in between tactics so Lean doesn't have to compile the same thing over and over.</p>\n</blockquote>\n<p>I'm not sure I understand your distinction. \"Should we check the entirety of the remaining file on each change\" (which is the only mode in Lean 4 mainly because of limitations in editor implementations of LSP) and \"can we restore a tactic's state when the change is strictly below it\" are essentially orthogonal issues.</p>",
        "id": 277260421,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1648722643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277260058\">said</a>:</p>\n<blockquote>\n<p>I was getting odd sense of satisfaction for every line that turned green in Coq and I was missing that when I switched to Lean :)</p>\n</blockquote>\n<p>Moving from an orange bar for the non-processed parts to a green bar for the processed parts would be a comparatively trivial change :) . IIRC Isabelle/jEdit does this?</p>",
        "id": 277260503,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1648722714
    },
    {
        "content": "<p>I see. Let me rephrase it: I think it would be nice to have an option to toggle the automatic processing on and off. But I didn't know it was a limitation of VS Code.</p>",
        "id": 277260727,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648722867
    },
    {
        "content": "<p>Yeah, this would unfortunately mean that the semantic highlighting and other metadata would never update</p>",
        "id": 277261047,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1648723133
    },
    {
        "content": "<p>I wish it wasn't so laboriously boring to develop our own IDE <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 277261210,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648723253
    },
    {
        "content": "<p>We pushed the <code>checkpoint</code> tactic, but it is very experimental, and we don't have an infrastructure for testing it in the CI yet. <br>\nThe test file based on <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>'s example looks more responsive now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">4000</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxHeartbeats</span> <span class=\"mi\">500000</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxSize</span> <span class=\"mi\">100000</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">maxRecDepth</span> <span class=\"mi\">10000</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.debug</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">trace</span> <span class=\"s2\">\"hello world\"</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 277368250,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648785447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>  Really cool, it works! Unfortunately it is a bit inconsistent. When you modify the string in the example to <code>\"hello world123456789\"</code> one character at a time you get quick response on odd numbers but slow on even numbers.</p>",
        "id": 277387997,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648803725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/Partial.20evaluation.20of.20a.20file/near/277368250\">said</a>:</p>\n<blockquote>\n<p>We pushed the <code>checkpoint</code> tactic, but it is very experimental</p>\n</blockquote>\n<p>Oh wow! This is a biggie IMO <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 277402464,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648812396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I pushed a fix. Could you please try again?</p>",
        "id": 277412804,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648817741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>  Great! works as expected now!</p>\n<p>Few problems when you modify in between checkpoints. This might be important when you have already complicated proof done, but you have to modify it due to some changes above.</p>\n<p>Here the tracing message does not update when you modify it. (probably because tracing does not change the state)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">trace</span> <span class=\"s2\">\"hello world123456789\"</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Something that changes state has to wait until all the following tactics are finished. Here modifying <code>enter [1]</code> has to wait for the second <code>rw[foo]</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Of course, the solution is to comment out the rest. Is this a limitation of LSP, the state can't be updated until the whole command is processed?</p>",
        "id": 277417075,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648819578
    },
    {
        "content": "<p>What about the following hack?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"stop\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">repeat</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then, you put the <code>stop</code> before the second <code>checkpoint</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"n\">stop</span>\n  <span class=\"n\">checkpoint</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 277418086,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648819987
    },
    {
        "content": "<p>Using <code>stop</code> is a lot less messy then commenting and uncommenting the remainder of the proof. I will play around with it see how comfortable it is to use.</p>",
        "id": 277453225,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648834579
    }
]
[
    {
        "content": "<p>Trying to feel out some simple things in Lean 4, I'm not able to get this Lean 3 theorem to work, but I'm not sure why. Is there an easy way to get more information out of the <code>?m.166</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Lean 3 version</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean3</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"n\">q</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">Point.rec_on</span> <span class=\"n\">p</span> <span class=\"bp\">$</span>\n<span class=\"k\">fun</span> <span class=\"n\">z1</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">Point.rec_on</span> <span class=\"n\">q</span> <span class=\"bp\">$</span>\n<span class=\"k\">fun</span> <span class=\"n\">z2</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z2</span><span class=\"o\">)),</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">hA</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"n\">q</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">Point.recOn</span> <span class=\"n\">p</span> <span class=\"bp\">$</span>\n<span class=\"k\">fun</span> <span class=\"n\">z1</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Point.recOn</span> <span class=\"n\">q</span> <span class=\"bp\">$</span>\n<span class=\"k\">fun</span> <span class=\"n\">z2</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z2</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">hA</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  Point.recOn p</span>\n<span class=\"cm\">    fun (z1 : Int) (q : Point) =&gt;</span>\n<span class=\"cm\">      Point.recOn q fun (z2 : Int) (hA : { x := z1 }.x = { x := z2 }.x) =&gt; congrArg Point.mk hA</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ?m.166 p p</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  (q : Point) → p.x = q.x → p = q</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 225226077,
        "sender_full_name": "Chris B",
        "timestamp": 1612474425
    },
    {
        "content": "<p>I think this is because the <code>elab_as_eliminator</code> elaboration strategy doesn't exist anymore</p>",
        "id": 225227325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612474918
    },
    {
        "content": "<p>which means that using <code>recOn</code> directly is always going to be painful</p>",
        "id": 225227483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612474970
    },
    {
        "content": "<p>The alternative is to use <code>induction using</code></p>",
        "id": 225227531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612474995
    },
    {
        "content": "<p>Here's a version using match:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p.x</span> <span class=\"bp\">=</span> <span class=\"n\">q.x</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">z1</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">z2</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z2</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">hA</span>\n</code></pre></div>",
        "id": 225228675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612475484
    },
    {
        "content": "<p>Thanks, I wasn't aware of how much work <code>elab_as_eliminator</code> was doing in the garden-variety case. The lean 4 version does work if I specify the motive.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"n\">q</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">Point.recOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">hp</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">forall</span> <span class=\"n\">hq</span> <span class=\"o\">(</span><span class=\"n\">hh</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"n\">hp</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"n\">hq</span><span class=\"o\">),</span> <span class=\"n\">hp</span> <span class=\"bp\">=</span> <span class=\"n\">hq</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"bp\">$</span>\n<span class=\"k\">fun</span> <span class=\"n\">z1</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Point.recOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Point.x</span> <span class=\"bp\">$</span> <span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Point.x</span> <span class=\"n\">_x</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_x</span><span class=\"o\">))</span> <span class=\"n\">q</span> <span class=\"bp\">$</span>\n<span class=\"k\">fun</span> <span class=\"n\">z2</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z2</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">hA</span>\n</code></pre></div>",
        "id": 225228686,
        "sender_full_name": "Chris B",
        "timestamp": 1612475491
    },
    {
        "content": "<p>We will not support <code>elab_as_eliminator</code>. Users should use <code>match ... with ...</code> or tactics such as <code>induction</code> and <code>cases</code>.<br>\nIf <code>match ... with ...</code> is not applicable, and you want to keep working in term mode, you can write a macro that \"switches\" to tactic mode and back into term mode.</p>",
        "id": 225228721,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612475506
    },
    {
        "content": "<p>Thanks to both of you. That match example is nice. I'll take a closer look at the new version induction.</p>",
        "id": 225229010,
        "sender_full_name": "Chris B",
        "timestamp": 1612475614
    },
    {
        "content": "<p>Is there a way to use <code>match</code> and/or <code>induction</code> such that we can be sure that <code>recOn</code> is getting called (as opposed to some more complicated <code>below</code> compilation or such)?</p>",
        "id": 225229053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612475636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228466\">@Chris B</span> Note that writing <code>: forall (q : Point) ...</code> is a trick to make Lean3 <code>elam_as_eliminator</code> + <code>recOn</code> work. You don't need this kind of trick when using <code>match</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">h1</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">h1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">h1</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4'</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span>\n  <span class=\"n\">cases</span> <span class=\"n\">q</span>\n  <span class=\"n\">exact</span> <span class=\"n\">congrArg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">h1</span>\n</code></pre></div>",
        "id": 225229324,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612475762
    },
    {
        "content": "<p>Here's a proof using <code>induction using</code>, which I think should get the term right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p.x</span> <span class=\"bp\">=</span> <span class=\"n\">q.x</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"n\">using</span> <span class=\"n\">Point.recOn</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">z1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">induction</span> <span class=\"n\">q</span> <span class=\"n\">using</span> <span class=\"n\">Point.recOn</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">z2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Point.x</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"n\">z2</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Point.mk</span> <span class=\"n\">hA</span>\n</code></pre></div>",
        "id": 225229403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612475788
    },
    {
        "content": "<p>(of course there are much easier ways to write this expression, like Leo's version)</p>",
        "id": 225229551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612475871
    },
    {
        "content": "<p>Wow, Lean Zulip really coming through on this one</p>",
        "id": 225229565,
        "sender_full_name": "Chris B",
        "timestamp": 1612475879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225229053\">said</a>:</p>\n<blockquote>\n<p>Is there a way to use <code>match</code> and/or <code>induction</code> such that we can be sure that <code>recOn</code> is getting called (as opposed to some more complicated <code>below</code> compilation or such)?</p>\n</blockquote>\n<p>The <code>induction</code> tactic by default uses <code>rec</code>. <code>recOn</code> is just a simple wrapper on top of <code>rec</code> that puts the major premise before minor premises.</p>",
        "id": 225229740,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612475956
    },
    {
        "content": "<p><code>rec</code> works too. I'm just thinking about those examples where lean 3's compilation strategy either results in a term that is slow to kernel-compute or doesn't support something like small eliminating inductive predicates</p>",
        "id": 225229962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612476049
    },
    {
        "content": "<p>I would usually either use <code>rec</code>/<code>rec_on</code> or <code>induction</code> to construct the term in those cases</p>",
        "id": 225230039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612476080
    },
    {
        "content": "<p>here's the golf version</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">PointExt_lean4</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p.x</span> <span class=\"bp\">=</span> <span class=\"n\">q.x</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 225230378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612476247
    },
    {
        "content": "<p>Nice to see that the <code>rfl</code> trick still works :-)</p>",
        "id": 225232115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612477017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>I'm just thinking about those examples where lean 3's compilation strategy either results in a term that is slow to kernel-compute </p>\n</blockquote>\n<p>I'm not concerned about this case. We don't rely on kernel-compute that much. Have you measured the overhead of <code>brecOn</code> vs <code>rec</code> in real examples?</p>\n<blockquote>\n<p>doesn't support something like small eliminating inductive predicates</p>\n</blockquote>\n<p>Yes, this one is a real problem. I have seen many examples where using equations would be much nicer.<br>\nRight now, the best option is to switch to the tactic mode and use <code>induction</code>. In Lean 4, this is not as bad as in Lean 3 since the <code>induction</code> tactic notation is nicer. </p>\n<p>I know you have been asking for this feature for ages, but it will not come anytime soon. The \"equation compiler\" decouples dependent pattern matching from termination checking. The code is more modular, the dependent pattern matching uses the <code>casesOn</code> recursor, and structural termination checker uses <code>brecOn</code>. Moreover, we can add new termination strategies (e.g., well-founded recursion) without even touching the dependent pattern matching modulo. To support <code>rec</code>/<code>recOn</code>, we would have to implement yet another strategy that does a bit of both: patter matching and termination checking. It will be implemented one day, but don't hold your breath :)</p>",
        "id": 225232330,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612477125
    },
    {
        "content": "<blockquote>\n<p>I'm not concerned about this case. We don't rely on kernel-compute that much. Have you measured the overhead of brecOn vs rec in real examples?</p>\n</blockquote>\n<p>These are lean 3 concerns. I'm sure that the calculus in lean 4 is completely different, but that's just an example of why I would want to do something as masochistic as using recursors directly instead of the many bits of sugar on top.</p>",
        "id": 225232586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477263
    },
    {
        "content": "<blockquote>\n<p>These are lean 3 concerns. I'm sure that the calculus in lean 4 is completely different, but that's just an example of why I would want to do something as masochistic as using recursors directly instead of the many bits of sugar on top.</p>\n</blockquote>\n<p>Do you have examples where you had to use <code>rec</code> manually because of a performance problem in Lean 3? How much faster was it when you switched from <code>brec_on</code> to <code>rec</code>/<code>rec_on</code>?</p>",
        "id": 225232760,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612477361
    },
    {
        "content": "<p>Is <code>decTrivial</code> still a thing in lean 4? That's the main place where kernel compute comes up in mathlib, although I think it also shows up in code with a different style in third party lean 3 projects</p>",
        "id": 225232788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477383
    },
    {
        "content": "<p>Profiling kernel computation in lean 3 is very difficult, it doesn't show up with <code>set_option profiler true</code>, so my judgment on these matters is a little coarse-grained</p>",
        "id": 225232943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477473
    },
    {
        "content": "<blockquote>\n<p>Right now, the best option is to switch to the tactic mode and use induction. In Lean 4, this is not as bad as in Lean 3 since the induction tactic notation is nicer. </p>\n</blockquote>\n<p>I think this is fine, I have enough experience doing just this in lean 3</p>",
        "id": 225233235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225232788\">said</a>:</p>\n<blockquote>\n<p>Is <code>decTrivial</code> still a thing in lean 4? That's the main place where kernel compute comes up in mathlib, although I think it also shows up in code with a different style in third party lean 3 projects</p>\n</blockquote>\n<p>Yes, it is. We have a macro called <code>decide!</code>.</p>",
        "id": 225233282,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612477653
    },
    {
        "content": "<p>A similar example where the kernel term is more or less unwritable in lean 3 is <code>eq.rec</code>, where it's worth it to use tactic mode just to use <code>rw</code> even if nothing else is in tactic mode</p>",
        "id": 225233388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225233388\">said</a>:</p>\n<blockquote>\n<p>A similar example where the kernel term is more or less unwritable in lean 3 is <code>eq.rec</code>, where it's worth it to use tactic mode just to use <code>rw</code> even if nothing else is in tactic mode</p>\n</blockquote>\n<p>We have a custom elaborator for generating <code>Eq.rec</code> applications in term mode.<br>\nThe notation is also available in Lean 3  <code>h ▸ e</code>. However, the Lean 4 elaborator for this notation is supposed to be better.</p>",
        "id": 225233622,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612477833
    },
    {
        "content": "<p>But supposing the user wanted to have a syntax like applying a term, I guess it wouldn't be too bad to add a macro like <code>elim!(Foo.rec_on) x ...</code> which either calls <code>induction</code> internals or just reimplements the <code>elab_as_eliminator</code> magic itself</p>",
        "id": 225233678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477876
    },
    {
        "content": "<p>(that should be implementable outside the core, I think?)</p>",
        "id": 225233769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612477925
    },
    {
        "content": "<p>Yeah, <code> h ▸ e</code> does show up in mathlib occasionally, but it fails in a lot of situations where <code>by rw h; exact e</code> works - I think the main reason is metavariables in the expected type</p>",
        "id": 225233917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612478024
    },
    {
        "content": "<p>Yes, if one wants to add support to <code>elab_as_eliminator</code>. I think the one to go is to add a macro such as <code>elim! ...</code>.</p>\n<blockquote>\n<p>(that should be implementable outside the core, I think?)</p>\n</blockquote>\n<p>Yes, and if I had to do it, I would do it on top of the <code>induction</code> tactic.</p>",
        "id": 225233926,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612478030
    },
    {
        "content": "<p>Do we still need <code>recOn</code> at all in lean 4? As I understand it the main reason is to make it easier to write these term proofs, since it's more natural to put the scrutinee first, but if users can't really write it anymore then it doesn't seem necessary to have it at all</p>",
        "id": 225234401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612478255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Returning to <code>brecOn</code> vs <code>rec</code>, it would be very useful if you could get numbers for <code>dec_trivial</code> in mathlib with <code>rec</code> and <code>brecOn</code>. We have been assuming the difference is not big. If it is big, then we have a problem because the generated code for definitions using <code>rec</code> sucks. That is, one may speed up kernel reduction using <code>rec</code>, but they are also slowing down the generated C code.</p>",
        "id": 225234830,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612478484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/type.20mismatch.20error/near/225234401\">said</a>:</p>\n<blockquote>\n<p>Do we still need <code>recOn</code> at all in lean 4? As I understand it the main reason is to make it easier to write these term proofs, since it's more natural to put the scrutinee first, but if users can't really write it anymore then it doesn't seem necessary to have it at all</p>\n</blockquote>\n<p>We needed it while transitioning from the old to the new frontend, but it is now a \"leftover\". We may still have code that depends on it though. It is also useful to keep it for Daniel's porting tool. Otherwise, he will have to add support for converting <code>rec_on</code> applications into <code>rec</code>.</p>",
        "id": 225235075,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612478615
    },
    {
        "content": "<p>I don't think the difference is big, but it is one of the things on my list of \"how to optimize code for kernel computation\". The fact that optimizing for kernel computation vs VM computation is often in opposition is a long standing problem that I hope lean 4's <code>implementedBy</code> will solve</p>",
        "id": 225235105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612478627
    },
    {
        "content": "<p>I will see if I can come up with an example</p>",
        "id": 225235161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612478645
    },
    {
        "content": "<blockquote>\n<p>I hope lean 4's implementedBy will solve</p>\n</blockquote>\n<p>Unfortunately, it doesn't solve this problem since it only requires the two definitions to have the same type. <br>\nWhen we use <code>@[implementedBy f] def g ...</code>, we are telling the code generator: \"trust me,  it is safe to replace <code>g</code> with <code>f</code>\".<br>\nFor solving the issue you raised, we can use another feature we are planning to add: simp lemmas for the compiler. The user provers an equation lemma and tells the compiler to use it as a rewriting rule to optimize code. Haskell has a similar feature, but the rewriting rules come without proof.</p>",
        "id": 225236086,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612479110
    },
    {
        "content": "<blockquote>\n<p>It is also useful to keep it for Daniel's porting tool. Otherwise, he will have to add support for converting <code>rec_on</code> applications into <code>rec</code>.</p>\n</blockquote>\n<p>FYI I am not currently aligning <code>rec_on</code> to <code>recOn</code>.</p>",
        "id": 225237082,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612479636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span>  What about <code>noConfusion</code>, <code>casesOn</code>, and <code>brecOn</code>?</p>",
        "id": 225238049,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612480148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I am not currently aligning any of them.</p>",
        "id": 225238866,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612480639
    },
    {
        "content": "<p>I haven't even checked which ones are identical. For a pair that is identical, it is very easy to align.</p>",
        "id": 225239054,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612480757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> We need them. Otherwise, we will not be able to pattern match, use tactics such as <code>cases</code> and <code>injection</code>, use recursive equations, etc. If aligning is problematic, another option is to invoke the generators for <code>noConfusion</code>, <code>casesOn</code>, and <code>brecOn</code> from the porting tool.</p>",
        "id": 225239559,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612481072
    },
    {
        "content": "<p>I will add.</p>",
        "id": 225239996,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612481342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I just did a test using the primality test in <code>data.num.prime</code>, which has been optimized for kernel computation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.num.prime</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">num.min_fac</span> <span class=\"mi\">104729</span> <span class=\"bp\">=</span> <span class=\"mi\">104729</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I tested replacements for three of the core functions in this computation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">pos_num.rec_on</span> <span class=\"n\">a</span> <span class=\"n\">succ</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">pos_num.cases_on</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">pos_num.cases_on</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"n\">b</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">pos_num.rec_on</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">pos_num.add</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">IH</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">bit0</span> <span class=\"n\">IH</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">min_fac_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">nat.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">fuel</span> <span class=\"n\">IH</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k.bit1</span> <span class=\"bp\">*</span> <span class=\"n\">k.bit1</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">k.bit1</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">k.bit1</span> <span class=\"k\">else</span>\n  <span class=\"n\">IH</span> <span class=\"n\">k.succ</span><span class=\"o\">)</span> <span class=\"n\">k</span>\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span>        <span class=\"n\">b</span>        <span class=\"o\">:=</span> <span class=\"n\">succ</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span>        <span class=\"mi\">1</span>        <span class=\"o\">:=</span> <span class=\"n\">succ</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span>        <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">min_fac_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pos_num</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span> <span class=\"bp\">→</span> <span class=\"n\">pos_num</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k.bit1</span> <span class=\"bp\">*</span> <span class=\"n\">k.bit1</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">k.bit1</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">k.bit1</span> <span class=\"k\">else</span>\n  <span class=\"n\">min_fac_aux</span> <span class=\"n\">fuel</span> <span class=\"n\">k.succ</span>\n</code></pre></div>\n<p>Since the built in profiler doesn't work, I used <code>rm test.olean; /usr/bin/time -f %U lean --make test.lean</code> to test, so the data is a bit noisy. For the equation compiler definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">13</span><span class=\"bp\">.</span><span class=\"mi\">89</span><span class=\"o\">,</span> <span class=\"mi\">13</span><span class=\"bp\">.</span><span class=\"mi\">82</span><span class=\"o\">,</span> <span class=\"mi\">14</span><span class=\"bp\">.</span><span class=\"mi\">02</span><span class=\"o\">,</span> <span class=\"mi\">13</span><span class=\"bp\">.</span><span class=\"mi\">64</span><span class=\"o\">,</span> <span class=\"mi\">13</span><span class=\"bp\">.</span><span class=\"mi\">71</span>\n</code></pre></div>\n<p>For the <code>rec</code> definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">76</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">59</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">66</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">51</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">60</span>\n</code></pre></div>\n<p>This suggests that the difference, while not large, is measurable, especially in hot functions like <code>add</code> and <code>mul</code> in this example, which should be called ~3,000,000 times in this test</p>",
        "id": 225242216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612482695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Thanks for testing it.</p>",
        "id": 225242942,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612483152
    }
]
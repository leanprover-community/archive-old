[
    {
        "content": "<p>When updating the nightly build by a month (in sync with mathlib4), some of my code no longer typechecked. A somewhat minimized version of what causes the problem is as in the example below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eg1IsFalse</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">eg1Soln.isSat</span>\n<span class=\"k\">#eval</span> <span class=\"n\">eg1IsFalse</span>                                                <span class=\"c1\">-- gives false</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">eg1IsFalse</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>              <span class=\"c1\">-- gives an error</span>\n</code></pre></div>\n<p>Is there some way I can ask <code>eg1False</code> to be simplified when making the definition, or some tactic replacing <code>rfl</code> where we reduce to normal form?</p>\n<p>Thanks.</p>",
        "id": 254902990,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1632636245
    },
    {
        "content": "<p>Let's say your definition was originally 1 + 0, your eval gave 1, and your example 1 + 0 = 1 := rfl worked. But then the definition of addition changed (such that zero on the left was the defintional equality), so your original rfl proof would no longer work.</p>",
        "id": 254924841,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1632656528
    },
    {
        "content": "<p>My understanding is that rfl is the proof only if #reduce would have given you false.</p>",
        "id": 254924858,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1632656555
    },
    {
        "content": "<p>I just checked: <code>#reduce eg1IsFalse</code> does indeed give <code>false</code>. <br>\nIn my case <code>eg1Soln</code> is complicated and involves propositions in its constructions, so I am guessing that some optimization is stopping reduction, and I should force it by an annotation or tactic.</p>",
        "id": 254925671,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1632657399
    },
    {
        "content": "<p>I have been checking further what simplifications are made. Here are some experiments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">eg1IsFalse</span>\n<span class=\"k\">#print</span> <span class=\"n\">eg1Soln</span>\n</code></pre></div>\n<p>give as info</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eg1IsFalse</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">SatSolution.isSat</span> <span class=\"n\">eg1Soln</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eg1Soln</span> <span class=\"o\">:</span> <span class=\"n\">SatSolution</span> <span class=\"n\">eg1Statement</span> <span class=\"o\">:=</span>\n<span class=\"n\">solveSAT</span> <span class=\"n\">eg1Statement</span>\n</code></pre></div>\n<p>So it looks as if <code>eg1Solution</code> is not being simplified. I also tried to force it to <code>whnf</code> and got the following error, perhaps because I misunderstand <code>whnf</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:=</span> <span class=\"n\">normalform</span><span class=\"o\">)</span><span class=\"s2\">\"whnf!\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"kd\">@[termElab normalform]</span> <span class=\"kd\">def</span> <span class=\"n\">normalformImpl</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">whnf</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span>\n        <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">t</span>\n        <span class=\"n\">return</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Elab.throwIllFormedSyntax</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eg1SolnNorm</span> <span class=\"o\">:=</span> <span class=\"n\">whnf</span><span class=\"bp\">!</span> <span class=\"n\">eg1Soln</span>\n</code></pre></div>\n<p>the definition at the end gives the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">_.codom</span>\n<span class=\"n\">argument</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Unit</span>\n<span class=\"n\">but</span> <span class=\"n\">function</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Containment</span> <span class=\"n\">eg1Statement</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>Indeed the function does have the type <code>Containment eg1Statement → Nat</code> and everything compiles fine since this is the type of the argument at compile time. But at the meta level apparently it is getting either optimized to <code>Unit</code> deliberately or distorted in some other way.</p>\n<p>Any clarifications will be appreciated. The meta stuff here is just my exploring with limited knowledge, my real question is whether I can make the interpreter simplify <code>eg1Soln</code>.</p>",
        "id": 254930992,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1632662430
    },
    {
        "content": "<p>This is getting curiouser and perhaps is a bug. There is a change in behaviour between the nightly builds \"leanprover/lean4:nightly-2021-09-19\" and \"leanprover/lean4:nightly-2021-09-20\" where <code>whnf</code> is failing. Here is some local output for the earlier build with <code>whnf!</code> as above:</p>\n<p>We normalize with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eg1isFalseNormal</span> <span class=\"o\">:=</span> <span class=\"n\">whnf</span><span class=\"bp\">!</span> <span class=\"n\">eg1IsFalse</span>\n</code></pre></div>\n<p>then the outputs for the following are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">eg1IsFalse</span>   <span class=\"c1\">--   def eg1IsFalse : Bool := SatSolution.isSat eg1Soln</span>\n<span class=\"k\">#print</span> <span class=\"n\">eg1isFalseNormal</span>   <span class=\"c1\">--    def eg1isFalseNormal : Bool :=false</span>\n</code></pre></div>\n<p>which is what I expect. However, in the newer versions of lean, as mentioned above the normalization gives an error.</p>\n<p>Any clarification is appreciated.</p>",
        "id": 254933979,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1632665219
    }
]
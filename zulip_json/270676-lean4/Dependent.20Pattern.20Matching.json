[
    {
        "content": "<p>I'm messing around with everyone's favorite toy example, length indexed vectors, and I can't figure out how to get pattern matching to do what I would expect.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">vnil</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">vcons</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">traverse_</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Vec.vnil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Vec.vcons</span> <span class=\"n\">a</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">traverse</span> <span class=\"n\">v'</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>This fails with the following message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">test.lean</span>     <span class=\"mi\">9</span>   <span class=\"mi\">3</span> <span class=\"n\">error</span>           <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n   <span class=\"n\">Vec.vnil</span>\n <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"mi\">0</span>\n <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n   <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">lsp</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would expect that matching on <code>vnil</code> would force us to unify <code>n</code> with <code>0</code>. I also attempted to match on both <code>n</code> and <code>v</code> simultaneously, but that didn't seem to do much of anything.</p>",
        "id": 222524250,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1610504426
    },
    {
        "content": "<p>Matching on both seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">vnil</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">vcons</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">traverse</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Vec.vnil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Vec.vcons</span> <span class=\"n\">a</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">traverse</span> <span class=\"n\">v'</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 222524398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610504582
    },
    {
        "content": "<p>Weird! Yours works, but when I add parens around <code>(n, v)</code> in the match it breaks</p>",
        "id": 222524754,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1610504885
    },
    {
        "content": "<p>I'm guessing it's because <code>(n, v)</code> is creating a term of <code>Prod Nat (Vec A n)</code>, which is then being matched, and the product has no dependence between the two components.</p>",
        "id": 222524898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610505008
    },
    {
        "content": "<p>Ah, that would make sense. Thanks for the help :)</p>",
        "id": 222524924,
        "sender_full_name": "Reed Mullanix",
        "timestamp": 1610505042
    },
    {
        "content": "<p>This typechecks, but it fails the termination check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">traverse</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">Sigma.mk</span> <span class=\"n\">n</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Vec.vnil</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Vec.vcons</span> <span class=\"n\">a</span> <span class=\"n\">v'</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">traverse</span> <span class=\"n\">v'</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 222524947,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1610505067
    },
    {
        "content": "<p>Hi, I am also playing with the typical example <code>Vec</code>, trying to define a type-safe <code>head</code> function as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span>               <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Vec</span>\n  <span class=\"kd\">def</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But Lean4 complains </p>\n<blockquote>\n<p>dependent elimination failed, stuck at auxiliary equation<br>\n Nat.add 1 n = 0</p>\n</blockquote>\n<p>which I don't see how to tell Lean that <code>nil</code> is an absurd case. The Lean3 manual has exactly the same example, but that impossible case can just be ignored.</p>",
        "id": 235305402,
        "sender_full_name": "Liang-Ting Chen",
        "timestamp": 1618906534
    },
    {
        "content": "<p><code>Nat.add</code> is defined by recursion on the second parameter. Are you sure it's not <code>n + 1</code> in the Lean 3 example?</p>",
        "id": 235305973,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618906842
    },
    {
        "content": "<p>using <code>n.succ</code> circumvents the problem, too, btw.</p>",
        "id": 235306762,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1618907258
    },
    {
        "content": "<p>Ooops!! Thanks for solving my problem so quickly!</p>",
        "id": 235306852,
        "sender_full_name": "Liang-Ting Chen",
        "timestamp": 1618907288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Dependent.20Pattern.20Matching/near/235305973\">said</a>:</p>\n<blockquote>\n<p><code>Nat.add</code> is defined by recursion on the second parameter. Are you sure it's not <code>n + 1</code> in the Lean 3 example?</p>\n</blockquote>\n<p>Yes, you're right. It is <code>n + 1</code> in the Lean 3 manual. I wasn't copying the example directly, but typed manually. I am more used to defining these operations by recursion on the first parameter.</p>",
        "id": 235307648,
        "sender_full_name": "Liang-Ting Chen",
        "timestamp": 1618907669
    }
]
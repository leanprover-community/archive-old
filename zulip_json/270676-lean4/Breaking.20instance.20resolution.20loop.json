[
    {
        "content": "<p>I'm trying to do some proof automation with typeclasses. I have two theorems that can potentially prove one another and lean gets stuck in an infinite loop while trying to synthesize an instance.</p>\n<p>The new and new goals look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>They are clearly the same goals, they just differ by an additional unused argument. Is there a way to break out of this loop and try to use different instances or fail? </p>\n<p>mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_linear</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsLin</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_linear</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>When the loop is straightforward, the loop gets broken and error <code>failed to synthesize instance</code> is reported.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_linear</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsLin</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_linear</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">w</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">loop_break</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 258429176,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1634758230
    },
    {
        "content": "<p>More investigation on this, we can have a look what is going on when doing these proofs manually.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_linear</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsLin</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_linear</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">parm</span>\n  <span class=\"n\">apply</span> <span class=\"n\">comp</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">done</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">parm</span>\n  <span class=\"n\">apply</span> <span class=\"n\">comp</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">done</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">parm</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">parm</span>\n  <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">parm</span>  <span class=\"c1\">-- this does nothing but introduces unused `α` variable</span>\n  <span class=\"n\">apply</span> <span class=\"n\">comp</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span> <span class=\"n\">done</span>\n</code></pre></div>\n<p>Playing around with these theorems reveals that applying <code>apply swap; intro; apply parm</code> at certain stage does absolutely nothing but adds a new unused variable <code>a : α</code>. The typeclass resolution gets stuck at applying this over and over. </p>\n<p>It feels like that the typeclass resolution should be able to detect this and stop. Is that the case? Or is it more complicated and fundamentally it can not be done? Or any idea how to restructure these instances such that they do not get into the loop but still automatically imply the same set of theorems?</p>",
        "id": 258542692,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1634822045
    },
    {
        "content": "<p>I have looked into the paper \"Tabled Typeclass Resolution\", the cycle problem is discussed there. I have tried to come up with the <code>Coe</code> vs <code>CoeT</code> trick, but ultimately failed in doing so.</p>\n<p>Is there any hope of a fix for this? I'm happy to wait for it. On the other hand, It looks like that this problem totally breaks my project I'm working on and I have to rethink it from ground up if this won't get a fix.</p>",
        "id": 259097580,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635255697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> the problem here is essentially as you surmised, the <code>swap</code> and <code>param</code> instances overlap in a way that produces an infinite cycle. You can fix your original MWE by removing the <code>swap</code> instance and making the <code>comp</code> instance use the actual composition function. That is, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_linear</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsLin</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_linear</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 259124309,
        "sender_full_name": "Mac",
        "timestamp": 1635266232
    },
    {
        "content": "<p>Note that deleting the swap instance though will prevent it from being inferred, though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">test3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>That is, you can only have one of <code>param</code> or <code>swap</code>. They don't work together. This makes some sense as they are both flip the arguments of <code>f</code> but are stated in two different ways that Lean has a hard time reconciling.</p>",
        "id": 259124979,
        "sender_full_name": "Mac",
        "timestamp": 1635266492
    },
    {
        "content": "<p>Unfortunately, not having <code>test3</code> automatically proven by <code>infer_instance</code>completely breaks my project I'm working on. I really need that to work.</p>\n<p>Note that lean can detect  and work with some kind of cycles. See my example <code>loop_break</code> in the first post.</p>",
        "id": 259148900,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635276656
    },
    {
        "content": "<p>Here is my attempt at the <code>Coe + CoeT</code> trick. In this case, I have <code>IsLin</code> and <code>IsLin₂ := ∀ a, IsLin (f a)</code>.</p>\n<p>For some unimportant reasons I have <code>IsSmooth</code> here instead of <code>IsLin</code> but it is the same thing.</p>\n<p>Now I can automatically do the examples above, but the problem just gets pushed down and <code>ptest2</code>, <code>ptest3</code> and <code>ptest4</code> get stuck in an infinite loop.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_smooth</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_smooth</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsSmooth₂</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">is_smooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">to_smooth₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth₂</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">proof</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth₂</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">d</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">stest1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest4</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest4</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n</code></pre></div>",
        "id": 259149516,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635276959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Breaking.20instance.20resolution.20loop/near/259148900\">said</a>:</p>\n<blockquote>\n<p>Note that lean can detect  and work with some kind of cycles. See my example <code>loop_break</code> in the first post.</p>\n</blockquote>\n<p>Yes this is true, but this only generally works when the loop cycles back to an equivalent term. As you mentioned:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Breaking.20instance.20resolution.20loop/near/258542692\">said</a>:</p>\n<blockquote>\n<p>Playing around with these theorems reveals that applying <code>apply swap; intro; apply parm</code> at certain stage does absolutely nothing but adds a new unused variable <code>a : α</code>. The typeclass resolution gets stuck at applying this over and over. </p>\n<p>It feels like that the typeclass resolution should be able to detect this and stop. Is that the case? Or is it more complicated and fundamentally it can not be done? </p>\n</blockquote>\n<p>The loop in your case produces a different term at each cycle. Thus, the resolution procedure has no way of knowing that this a pointless progression (as there could be a case where adding dozens of unused variables results in hitting a new instance). Also, it should be noted that type classes are not really intended for automated proving, that is generally  suppose to be the realm of tactics. For one, type class resolution follows a generic procedure that thus can't rely on domain specific assumptions / heuristics. A specific tactic for a case like this, on the other hand, could detect  such loops and intelligently assume they are futile and instead do something else.</p>",
        "id": 259152179,
        "sender_full_name": "Mac",
        "timestamp": 1635278166
    },
    {
        "content": "<blockquote>\n<p>as there could be a case where adding dozens of unused variables results in hitting a new instance</p>\n</blockquote>\n<p>Ohh, this didn't cross my mind. Is that really true? I thought that the kind of a sequence of terms I'm getting is clearly a loop that should be detected and stopped. I didn't realize  that you might want to continue. Do you have an example where it is necessary? </p>\n<blockquote>\n<p>Also, it should be noted that type classes are not really intended for automated proving, that is generally suppose to be the realm of tactics. </p>\n</blockquote>\n<p>Fair point, and maybe I will have to write my own tactic. On the other hand, all I want is to use <code>simp</code> tactic that conditions certain rewrite rules on whether the expression satisfies certain conditions. I can check these conditions automatically using type classes. So I feel writing my own tactic would require more or less rewriting <code>simp</code> and type class resolution ... I do not want to do that and I'm not capable of doing that.</p>",
        "id": 259154053,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635278903
    },
    {
        "content": "<p>You could just provide a set of lemmas to simp that are those rewrite rules. In mathlib3, those are called simp sets. You can take a look at the implementation of field_simp for example</p>",
        "id": 259157587,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635280721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Breaking.20instance.20resolution.20loop/near/259154053\">said</a>:</p>\n<blockquote>\n<p>Ohh, this didn't cross my mind. Is that really true? I thought that the kind of a sequence of terms I'm getting is clearly a loop that should be detected and stopped. I didn't realize  that you might want to continue. Do you have an example where it is necessary? .</p>\n</blockquote>\n<p>Here is an extremely contrived one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_linear</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsLin</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_linear</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">parm</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"bp\">;</span>\n  <span class=\"n\">apply</span> <span class=\"n\">parm</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"bp\">;</span>\n  <span class=\"n\">apply</span> <span class=\"n\">parm</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">swap</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"bp\">;</span>\n  <span class=\"n\">revert</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"n\">exact</span> <span class=\"n\">foo</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>The take away here is that any new term could itself be an instance/theorem/axiom that would resolve the search.</p>",
        "id": 259164838,
        "sender_full_name": "Mac",
        "timestamp": 1635284133
    },
    {
        "content": "<p>It is really contrived and I would argue not a valid example because when you replace <code>theorem</code> by <code>instance</code> it does not work.</p>\n<p>The thing is that when <code>foo</code> is declared as an instance it does not synthesize itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>   <span class=\"c1\">-- failed to synthesize instance</span>\n</code></pre></div>\n<p>It leads to an answer that contains metavariable and is rejected.</p>\n<p>A simple example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n<span class=\"kd\">class</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instFoo</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">arbitrary</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>The trace contains:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"n\">instFoo</span> <span class=\"bp\">?</span><span class=\"n\">m.344</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"n\">skip</span> <span class=\"n\">answer</span> <span class=\"n\">containing</span> <span class=\"n\">metavariables</span> <span class=\"n\">instFoo</span> <span class=\"bp\">?</span><span class=\"n\">m.348</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"n\">failed</span>\n</code></pre></div>",
        "id": 259205078,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635322178
    },
    {
        "content": "<p><code>instFoo</code> is a bad instance due to the argument <code>a : α</code>, which is a non-class argument that does not occur anywhere else and hence can't be found via unification.</p>",
        "id": 259205667,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635322567
    },
    {
        "content": "<p>In mathlib (Lean 3) we have a linter that checks for these kinds of issues.  This is what it prints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The `unused_arguments` linter reports: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> UNUSED ARGUMENTS. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">instFoo</span> <span class=\"c\">/-</span><span class=\"cm\"> argument 3: (a : α) -/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `impossible_instance` linter reports: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> IMPOSSIBLE INSTANCES FOUND.</span>\n<span class=\"cm\">These instances have an argument that cannot be found during type-class resolution, and therefore can never succeed. Either mark the arguments with square brackets (if it is a class), or don't make it an instance. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">instFoo</span> <span class=\"c\">/-</span><span class=\"cm\"> Impossible to infer argument 3: (a : α) -/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `instance_priority` linter reports: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> DANGEROUS INSTANCE PRIORITIES.</span>\n<span class=\"cm\">The following instances always apply, and therefore should have a priority &lt; 1000.</span>\n<span class=\"cm\">If you don't know what priority to choose, use priority 100.</span>\n<span class=\"cm\">See note [lower instance priority] for instructions to change the priority. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">instFoo</span> <span class=\"c\">/-</span><span class=\"cm\"> set priority below 1000 -/</span>\n</code></pre></div>",
        "id": 259206062,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635322858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/270676-lean4/topic/Breaking.20instance.20resolution.20loop/near/259157587\">said</a>:</p>\n<blockquote>\n<p>You could just provide a set of lemmas to simp that are those rewrite rules. In mathlib3, those are called simp sets. You can take a look at the implementation of field_simp for example</p>\n</blockquote>\n<p>Very good point! Simplification in a field sometimes needs a proof that certain terms are non-zero. I will look into it and hopefully get inspired.</p>",
        "id": 259206068,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635322861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  Yup, agree that it is a bad instance. Thus I would argue that detecting the infinite loop I have described in the first post can(should?) be detected and stopped.</p>",
        "id": 259206283,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635323003
    },
    {
        "content": "<p>Okay, looking at your original example.  You should think a bit about how you want to define \"linear\".  You probably want some kind of typeclass for the vector spaces.  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module\">docs#module</a> is how we define it in mathlib.</p>",
        "id": 259207016,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635323469
    },
    {
        "content": "<p>With that in mind, I can't make much sense of <code>test2</code>.</p>",
        "id": 259207067,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635323509
    },
    {
        "content": "<p>Surprisingly this works and the composition instances don't even cause nontermination:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_linear</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsLin</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_linear</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test1'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 259207215,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635323592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>   In my real code, I have a definition of vector space and so on. Here I'm just posting stripped down version of it to demonstrate my problem. </p>\n<p>Concerning the <code>test2</code>, it is very subtle. Consider function <code>f : V -&gt; V -&gt; R</code> that is bilinear, e.g. inner product. There are kind of two ways you can ask about linearity in the first argument, either you fix the second argument as <code>y</code> and ask if <code>fun x =&gt; f x y</code> is linear? Or you can ask if <code>f</code> is linear as a function from vector space <code>V</code> to vector space <code>V -&gt; R</code>. <br>\nThis distinction is not very interesting for linearity but this is very crucial and subtle in variational calculus when dealing with differentiability.</p>\n<p>See my other earlier post, for more tests I want to get working: <br>\n<span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Breaking.20instance.20resolution.20loop/near/259149516\">said</a>:</p>\n<blockquote>\n<p>Here is my attempt at the <code>Coe + CoeT</code> trick. In this case, I have <code>IsLin</code> and <code>IsLin₂ := ∀ a, IsLin (f a)</code>.</p>\n<p>For some unimportant reasons I have <code>IsSmooth</code> here instead of <code>IsLin</code> but it is the same thing.</p>\n<p>Now I can automatically do the examples above, but the problem just gets pushed down and <code>ptest2</code>, <code>ptest3</code> and <code>ptest4</code> get stuck in an infinite loop.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_smooth</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_smooth</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsSmooth₂</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">is_smooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">to_smooth₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth₂</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">proof</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth₂</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">d</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">stest1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest4</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest4</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 259210505,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635325467
    },
    {
        "content": "<p>I still find this hard to parse.  Some general advice:</p>\n<ul>\n<li>Avoid instances like <code>swap</code>, they're not going to help you.</li>\n<li>Compositionality instances like <code>comp</code> seem to work surprisingly well in Lean 4.  Try to write more of them, and as general as possible.  Instances like this: <code>IsSmooth f → IsSmooth g → IsSmooth h → IsSmooth λ x =&gt; f (g x) (h x)</code> or <code>IsSmooth f → IsSmooth g → IsSmooth h → IsSmooth λ x y =&gt; f (g x y) (h x y)</code>.</li>\n</ul>",
        "id": 259212422,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635326722
    },
    {
        "content": "<blockquote>\n<p>Avoid instances like <code>swap</code>, they're not going to help you.</p>\n</blockquote>\n<p>I would like to avoid it, I just do not see how. </p>\n<p>Can you write down some small set of instances that will pass all tests in the example above? Furthermore, tests <code>stest*</code> and <code>ptest*</code> naturally extend to infinity for more and more arguments. Will all of those pass?</p>\n<p>I'm trying to come up with this small set of instances for couple of weeks/months now and I'm still not there yet. Either I get into an infinite loop or I need to write down an infinite number of instances in order to pass all <code>stest*</code> for example.</p>",
        "id": 259213035,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635327113
    },
    {
        "content": "<blockquote>\n<p>Try to write more of them, and as general as possible.</p>\n</blockquote>\n<p>Yes, I have plenty more. Mainly for doubling arguments as you have pointed out. But reordering arguments is the problem and I feel that something like <code>swap</code> is necessary.</p>",
        "id": 259213276,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635327268
    },
    {
        "content": "<blockquote>\n<p>they're not going to help you</p>\n</blockquote>\n<p>In the example above, if you comment out <code>swap</code> then <code>test3</code> and all <code>stest*</code>  will fail. <br>\n<code>ptest2</code> starts working but <code>ptest3</code> and <code>ptest4</code> are still not working because they need both <code>swap</code> and <code>parm</code>.</p>",
        "id": 259214038,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635327726
    },
    {
        "content": "<p>I'm still not sure I understand how you're trying to define <code>IsSmooth</code> but if <code>IsSmooth (f : α → β → γ → δ)</code> means <code>f</code> is smooth in the first argument, then this should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_smooth</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_smooth</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">param</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">d</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">stest4</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest3</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ptest4</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">--- (deterministic) timeout at 'typeclass'</span>\n</code></pre></div>",
        "id": 259215177,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635328528
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 259225616,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635334746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  Very cool! I was unable to figure this out, it looks very promising. I have many more tests I will throw at it to see if it scales, but it looks really promising. Thank you very much!</p>\n<p>The definition of <code>IsSmooth</code> is saying that <code>f</code> is smooth only in the first argument. Because of this, the example you gave is not entirely correct as <code>comp2</code> additionally requires smoothness of <code>f</code> in the second argument and <code>comp3</code> additionally requires smoothness of <code>f</code> in the second and third argument.</p>\n<p>It also requires to add variants of <code>comp2</code> and <code>comp3</code>, but to get these tests running only one additional variant is necessary. I will investigate if that is the case all the time.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">comp2_00</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp2_01</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- instance comp2_10 (f : β → δ → γ) (h : α → δ) [IsSmooth f] [IsSmooth h] (b) : IsSmooth (λ a =&gt; f b (h a)) := sorry</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"n\">comp3_000</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- instance comp3_001 (f : β → δ → ι → γ) (g : α → β) (h : α → δ) [IsSmooth f] [∀ b, IsSmooth (f b)] [IsSmooth g] [IsSmooth h] (i) :</span>\n<span class=\"c1\">--   IsSmooth (λ a =&gt; f (g a) (h a) i) := sorry</span>\n<span class=\"c1\">-- instance comp3_010 (f : β → δ → ι → γ) (g : α → β) (i : α → ι) [IsSmooth f] [∀ b d, IsSmooth (f b d)] [IsSmooth g] [IsSmooth i] (h) :</span>\n<span class=\"c1\">--   IsSmooth (λ a =&gt; f (g a) h (i a)) := sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp3_011</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- instance comp3_100 (f : β → δ → ι → γ) (h : α → δ) (i : α → ι) [∀ b, IsSmooth (f b)] [∀ b d, IsSmooth (f b d)] [IsSmooth h] [IsSmooth i] (g) :</span>\n<span class=\"c1\">--   IsSmooth (λ a =&gt; f g (h a) (i a)) := sorry</span>\n<span class=\"c1\">-- instance comp3_101 (f : β → δ → ι → γ) (h : α → δ) [∀ b, IsSmooth (f b)] [IsSmooth h] (g i) :</span>\n<span class=\"c1\">--   IsSmooth (λ a =&gt; f g (h a) i) := sorry</span>\n<span class=\"c1\">-- instance comp3_110 (f : β → δ → ι → γ) (i : α → ι) [∀ b d, IsSmooth (f b d)] [IsSmooth i] (g h) :</span>\n<span class=\"c1\">--   IsSmooth (λ a =&gt; f g h (i a)) := sorry</span>\n</code></pre></div>\n<p>It seems to work really nicely, for example the instance you suggested previously works automatically now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 259228164,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635336267
    },
    {
        "content": "<p>A quick investigation reveals that if we have <code>comp2_**</code> and <code>comp3_0**</code> then all <code>comp3_1**</code> follow automatically. It kind of make sense. Hopefully it means that there is no combinatirial blow up of instances when writing down all instance from <code>comp1</code> to<code>comp10</code>(10 should be enough for any practical purposes)</p>",
        "id": 259228823,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635336660
    },
    {
        "content": "<p>Super cool, this also works when we add an additional instance <code>eval</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 259229763,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635337216
    },
    {
        "content": "<p>Dare I ask why it is that from your description of the problem, you are doing what looks to me like mathematics, and yet you are writing things like <code>comp10</code> which look to me like lemmas which we would never have in mathlib simply because they'd be of no use in practice? I think we rarely need to go beyond analogues of <code>comp2</code> when proving the kinds of theorems we have in mathlib. I guess what I'm saying is that I'm interested in hearing a little more about what you're doing.</p>",
        "id": 259233543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635339268
    },
    {
        "content": "<p>This is all for doing symbolic differentiation. The kicker is that I want to do symbilic differentiation in variational calculus, i.e. differentiate function w.r.t. to another functions. Ultimately, I want to write down the  integral of Lagrangian, take gradient of it to get Euler-Lagrange equations. Once I have that, I can go further and do similar calculations using <a href=\"https://en.wikipedia.org/wiki/GENERIC_formalism\">GENERIC</a> formalism used  in non-equlibrium thermodynamics to derive various PDEs for complicated fluids. Calculations there are huge pain and chore. I want a computer to do that for me.</p>\n<p>I could just write down the rules for differentiation and how to manipulate those expressions, but I'm afraid of bugs and accidentally writing down incorrect simplification rule that I will not be able to track down later on. That is the reason I'm using proof assistance. Plus it is fun to learn.</p>\n<p>From formal point of view. Variational calculus is famously subtle subject as space of differentiable function between Banach spaces is not a Banach space etc. For this reason I'm using the notion of convenient vector spaces, they form cartesian closed category, so I can do lambda calculus there. So the exercise here is more or less proving that a certain lambda function in Type category is also lambda function in category of Convenient Vector Spaces.</p>",
        "id": 259236078,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635340455
    },
    {
        "content": "<p>And I want to take this further, formalize many numerical algorithms and use Lean to help me to assemble programs that solve PDEs.</p>\n<p>A simple example of what I'm trying to achieve. Simulation of harmonic oscillator:</p>\n<p>First you define the Hamiltonian:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">p</span><span class=\"o\">⟩</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Then you state that you want an implementation of ODE solver for this particular Hamiltonian system:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">solver</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">steps</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">ode_solve</span> <span class=\"o\">(</span><span class=\"n\">HamiltonianSystem</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">m</span> <span class=\"n\">k</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>Then you turn into a tactic mode where you guide the compute how to actually build the program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span>\n  <span class=\"n\">impl_check</span> <span class=\"o\">(</span><span class=\"n\">m.toFloat</span><span class=\"bp\">&gt;</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"s2\">\"Mass has to be non zero.\"</span>\n\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">HamiltonianSystem</span><span class=\"o\">,</span> <span class=\"n\">uncurry</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">gradient</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"n\">autograd</span>\n\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ode_solve_fixed_dt</span> <span class=\"n\">runge_kutta4_step</span><span class=\"o\">]</span>\n  <span class=\"n\">lift_limit</span> <span class=\"n\">steps</span> <span class=\"s2\">\"Number of ODE solver steps.\"</span><span class=\"bp\">;</span> <span class=\"gr\">admit</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n  <span class=\"n\">finish_impl</span>\n</code></pre></div>\n<p>In order,</p>\n<div class=\"codehilite\"><pre><span></span><code>1. just preform a simple runtime check\n2. expand some definitions and run automatic differentiation to arrive at Hamiltons equations\n3. replace `ode_solve` with a particular numerical scheme\n4. currently, replacing `ode_solve` with a numerical scheme stills leaves a limit there such that you  can  proof that the numerical scheme is actually doing what you want. The command `lift_limit` just says, ok at this point I&#39;m giving up on implementing exactly the original goal, I&#39;m going to implement just an approximation. \n5. `finish_impl` is just `done` tactic. In future I want to check that the goal is actually computable function that you can run.\n</code></pre></div>\n\n<p>An example how would you then use <code>solver</code> to actually run the simulation. It is hopefully quite self explanatory.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">harmonic_oscillator_main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">steps</span> <span class=\"o\">:=</span> <span class=\"mi\">100</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">evolve</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">solver</span> <span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"n\">steps</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">assemble</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"k\">let</span> <span class=\"n\">x₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">5</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">p₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">evolve</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">x₀</span><span class=\"o\">,</span> <span class=\"n\">p₀</span><span class=\"o\">)</span>\n\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"In {t} seconds the harmonic oscillator evolved from ({x₀}, {p₀}) to ({x},{p}).\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">harmonic_oscillator_main</span>\n</code></pre></div>",
        "id": 259237530,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635341095
    },
    {
        "content": "<p>One of my big goals is to create Finite Element library that can be differentiated w.r.t. almost anything you can think of. One big applications of this would be <a href=\"https://www.google.com/search?q=topology+optimization&amp;sxsrf=AOaemvIpUdm1LDoEaWeGuhRZ6ooEMGSGYA:1635341199660&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;sqi=2&amp;ved=2ahUKEwivs6ra2OrzAhUxRPEDHY9JDGQQ_AUoAXoECAEQAw&amp;biw=960&amp;bih=941&amp;dpr=1\">topology optimization</a> . Currently, I'm just focusing on fundamentals and how to get all the core moving pieces right such that I can build something like that.</p>",
        "id": 259238283,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635341410
    },
    {
        "content": "<p>Also, my day job is to write physics simulation software that is used in visual effects. There you need to write incredibly complicated solvers that talk to each other. For example, you want to create a bear swimming in a river, you need to simulate his skin+flesh, his fur and the water. Ideally all of these elements should influence each another. Writing all of this is super hard, especially if all these elements are supposed to affect each another. So I just want to explain to the computer the mathematics behind these algorithms and then the computer will help me to write such a program.</p>",
        "id": 259239131,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635341740
    },
    {
        "content": "<p>In general, you probably don't want to rely solely on the TC inference system to provide proofs of behaviors of certain functions. You'll likely want to build a custom tactic to do so. For example, the \"smoothness\" of 1/x^2 might be used in a proof, but of course isn't smooth everywhere. Perhaps in the proof you do know you don't care about evaluating at 0. How would the TC know that constraint? You might try to bake <code>[fact (0 &lt; x)]</code> into the TC in the proof context. But then you'll have way more instance searching in the cases when that fact isn't available.</p>",
        "id": 259239135,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635341741
    },
    {
        "content": "<p>An example of such a tactic is <code>continuity</code>.</p>",
        "id": 259239325,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635341797
    },
    {
        "content": "<p>I don't think it's such a crazy idea to try out the TC system for this.  Type class synthesis is a lot nicer now, maybe we can get away without writing <code>by continuity</code> in many cases?</p>",
        "id": 259239543,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1635341881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Yes, this is definitely a problem and something I should think about. So currently, I'm focusing only on functions that are smooth everywhere or not smooth at all. My current plan to deal with <code>||x||</code> is to approximate it with <code>sqrt( ||x||^2 + eps^2 )</code> which is smooth and non-zero everywhere. Do all the automatic differentiations with this approximation and then set <code>eps</code> to zero or close to zero.</p>\n<p>Note that this is for example commonly used in <a href=\"https://en.wikipedia.org/wiki/N-body_simulation#Softening\">N-body simlation</a> to improve numerical stability.</p>",
        "id": 259239833,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635341995
    },
    {
        "content": "<p>One, maybe not so good, reason why I'm using TC for this is if you can prove that a function is linear then it is super easy to differentiate it and you do not have to decompose it into smaller parts and differentiate those.</p>\n<p>And I do not know how would I do that if I would have to manually invoke a tactic somewhere. </p>\n<p>However, I should have a closed look to <code>field_simp</code> as you have mentioned. Unfortunately, I'm not sufficiently familiar with all the details of <code>simp</code> tactic and in its core.</p>",
        "id": 259240105,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635342097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Breaking.20instance.20resolution.20loop/near/259233543\">said</a>:</p>\n<blockquote>\n<p>Dare I ask why it is that from your description of the problem, you are doing what looks to me like mathematics, and yet you are writing things like <code>comp10</code> which look to me like lemmas which we would never have in mathlib simply because they'd be of no use in practice? I think we rarely need to go beyond analogues of <code>comp2</code> when proving the kinds of theorems we have in mathlib. I guess what I'm saying is that I'm interested in hearing a little more about what you're doing.</p>\n</blockquote>\n<p>Ohh, I realized that I went on a rant without giving a concrete example.</p>\n<p>Consider neural network with <code>n</code> layers. The type of the neural network <code>f</code> can be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W₁</span> <span class=\"bp\">×</span> <span class=\"bp\">...</span> <span class=\"bp\">×</span> <span class=\"n\">Wₙ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n</code></pre></div>\n<p>where <code>Wᵢ </code> are the weights for i-th layer, <code>X</code> is the image and <code>Y</code> is the output space.</p>\n<p>To do backpropagation I will apply the bakckpropagation operator <code>𝓑</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">backprop</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"bp\">×</span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">→</span><span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">†</span><span class=\"o\">)</span>\n\n<span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"𝓑\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">backprop</span>\n</code></pre></div>\n<p>where  <code>(δ f x)†</code> is the adjoint of the differential of <code>f</code> at <code>x</code></p>\n<p>The main theorem for the backpropagation operator is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">backprop_of_composition</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n    <span class=\"o\">:</span> <span class=\"bp\">𝓑</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">𝓑</span> <span class=\"n\">f</span> <span class=\"bp\">•</span> <span class=\"bp\">𝓑</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where <code>•</code> is a special kind of composition such that the above is true, see <a href=\"https://arxiv.org/abs/1804.00746\">The simple essence of automatic differentiation</a>. Simply put, you just compose the functions, and compose the adjoints of their differentials.</p>\n<p>What I fear that at some point you will work with curried version of the network</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W₁</span> <span class=\"bp\">→</span>  <span class=\"bp\">...</span> <span class=\"bp\">→</span> <span class=\"n\">Wₙ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n</code></pre></div>\n<p>at that point theorems like <code>comp10</code> might be necessary to automatically fetch instances of <code>IsSmooth</code> in <code>backprop_of_composition</code>.</p>",
        "id": 259277526,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635356559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  The whole thing breaks again and loops indefinitely on the most simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">-- (deterministic) timeout at 'typeclass'</span>\n</code></pre></div>\n<p>The culprit  is the instance <code>comp3_000</code>.</p>\n<p>It is a very similar failure case as in my original example. Successive goals are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">Function.comp</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">Function.comp</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">Function.comp</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">Function.comp</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">....</span>\n</code></pre></div>\n<p>I really feel that the typeclass resolution should stop when it tries to resolve a goal of type <code>(a : α) → C</code> where <code>C</code> is some class that does not contain <code>a</code>. As you mentioned, in Lean 3 providing such an instance is considered invalid/bad. Why should the typeclass resolution keep looking for such instances?</p>",
        "id": 259294466,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635363212
    },
    {
        "content": "<p>To further motivate what I'm trying to do: I want some kind of automatic type deduction for \"lambda's arrows\". In mathlib you have <code>linear_map</code> or <code>smooth_map</code>, I want to write a normal lambda and automatically deduce it is <code>linear_map</code> or <code>smooth_map</code> when I pass it to a function that is expecting one of those. </p>\n<p>Something similar that is happening with types, when you write <code>fun x =&gt; x</code> and pass it somewhere, the type of <code>x</code> will be automatically deduced. You do not have to say somewhere \"show that type of <code>x</code> is <code>X</code>\" as it would be required for \"lambda's arrow\" when specialized tactic like <code>by continuity</code> is used(I might be wrong about this, happy to be proven incorrect)</p>\n<p>I have actually tried working with morphisms like <code>linear_map</code> and <code>smooth_map</code> but I managed to hit a wall that I wasn't able to pass. Quite often I had <code>affine_map</code> that after couple of transformations actually happen to be <code>linear_map</code> and there wasn't a clear point where I should convert affine to linear.</p>\n<p>When looking at this from the point of \"typing lambda's arrow\" then maybe this should all be done on the level of elaborator but I do not understand it and I would probably get nowhere when I would try to do so. Therefore, I'm trying to use typeclass system to build a prototype for this.</p>",
        "id": 259504994,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635502364
    },
    {
        "content": "<p>To give a \"nonsense\" description. If you have a category <code>C</code> and forgetful functor <code>F : C → Type</code> the typeclass system can happy tell you that for a type <code>α : Obj(Type)</code> if there is <code>A : Obj(C)</code> such that <code>F(A) = α</code>.  This the standard trick in mathlib where you work with the unbundled types and the typeclass system on the fly fetches the structure of group, ring or whatever. What I'm asking is, given a function <code>f : Morph(Type)</code> is there a morphism <code>m : Morph(C)</code> such that <code>F(m) = f</code>?</p>\n<p>If the typeclass system can do this lifting for objects, why not morphisms?</p>",
        "id": 259505780,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635502979
    },
    {
        "content": "<p>I have attempted to modify typeclass synthesis and it works!(partially). In <code>src/Lean/Meta/SynthInstance.lean</code>I have replaced</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkTableKey</span> <span class=\"o\">(</span><span class=\"n\">mctx</span> <span class=\"o\">:</span> <span class=\"n\">MetavarContext</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">MkTableKey.normExpr</span> <span class=\"n\">e</span> <span class=\"n\">mctx</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run'</span> <span class=\"o\">{}</span>\n</code></pre></div>\n<p>with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkTableKey</span> <span class=\"o\">(</span><span class=\"n\">mctx</span> <span class=\"o\">:</span> <span class=\"n\">MetavarContext</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">MkTableKey.normExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">removeUnusedArguments</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">mctx</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run'</span> <span class=\"o\">{})</span>\n</code></pre></div>\n<p>where <code>removeUnusedArguments</code>, as the name suggests, removes unused arguments. For example, if <code>e</code> is <code>(a : α) → b</code> where <code>b</code> does not contain <code>a</code> then <code>e</code> is replaced with <code>b</code>. </p>\n<p>Surprisingly, this modification breaks only 3 out of 1006 current unit tests. In order to keep Lean working as usual I remove unused arguments only when looking for an instance of <code>IsSmooth</code>. The implementaiont of <code>removeUnusedArguments</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">removeUnusedArguments</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n<span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.forallE</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forallTelescope</span> <span class=\"n\">e</span> <span class=\"k\">fun</span> <span class=\"n\">xs</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">b.getAppFn.constName</span><span class=\"bp\">!</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">IsSmooth</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n      <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">xs</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">b.containsFVar</span> <span class=\"n\">x.fvarId</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n          <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"n\">ys.concat</span> <span class=\"n\">x</span>\n      <span class=\"n\">mkForallFVars</span> <span class=\"n\">ys.toArray</span> <span class=\"n\">b</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">pure</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>With this modification, all the examples I have posted here are automatically solved when these six simple instances are provided:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">identity</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">parm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">diag</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 259747245,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1635622294
    }
]
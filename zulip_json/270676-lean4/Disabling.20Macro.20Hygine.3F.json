[
    {
        "content": "<p>I wish to write a macro which elaborates in the context of another macro. I use identifiers like <code>i32</code> to refer to types. Unfortunately, since these types are identifiers, the hygiene system changes them to things like <code>i32._@._hyg.746</code>. These fail macro expansion (since they don't look like <code>i&lt;int&gt;</code>). <strong>Question:</strong> Can I disable hygiene for certain (known) identifiers? </p>\n<p>For some context: I have a macro  <code>[mlir_op| ...]</code> provides a low-level macro for building ASTs. A high level macro  <code>prettyOp</code><br>\nexpands into <code>[mlir_op| \"std.prettyOp\" : i32]</code>. It is during this expansion that the <code>i32</code> becomes <code>i32._@._hyg.746</code>, which fails the parserule for <code>[mlir_type| $x:ident ]</code>.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Extra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser</span>\n\n\n<span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">MLIRTy</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">int</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MLIRTy</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Op</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">mk</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">:</span> <span class=\"n\">MLIRTy</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Op</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">mlir_op</span>\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">mlir_type</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">ident</span><span class=\"o\">:</span> <span class=\"n\">mlir_type</span>\n\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[mlir_type|\"</span> <span class=\"n\">mlir_type</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">mlir_type</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">xstr</span> <span class=\"o\">:=</span> <span class=\"n\">x.getId.toString</span>\n        <span class=\"k\">if</span> <span class=\"n\">xstr.front</span> <span class=\"bp\">==</span> <span class=\"sc\">'i'</span>\n        <span class=\"k\">then</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">xstr'</span> <span class=\"o\">:=</span> <span class=\"n\">xstr.drop</span> <span class=\"mi\">1</span>\n          <span class=\"k\">match</span> <span class=\"n\">xstr'.toInt</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"k\">let</span> <span class=\"n\">lit</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.mkNumLit</span> <span class=\"n\">xstr'</span>\n            <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">MLIRTy.int</span> <span class=\"bp\">$</span><span class=\"n\">lit</span><span class=\"o\">)</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"n\">Macro.throwError</span> <span class=\"bp\">$</span> <span class=\"s2\">\"cannot convert suffix of i to int: \"</span> <span class=\"bp\">++</span> <span class=\"n\">xstr</span>\n        <span class=\"k\">else</span> <span class=\"n\">Macro.throwError</span> <span class=\"s2\">\"expected i&lt;int&gt;\"</span> <span class=\"c1\">-- `(MLIRTy.int 1337)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tyi32NoGap</span> <span class=\"o\">:</span> <span class=\"n\">MLIRTy</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mlir_type</span><span class=\"bp\">|</span> <span class=\"n\">i32</span><span class=\"o\">]</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">strLit</span> <span class=\"s2\">\":\"</span> <span class=\"n\">mlir_type</span> <span class=\"o\">:</span> <span class=\"n\">mlir_op</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[mlir_op|\"</span> <span class=\"n\">mlir_op</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">mlir_op</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">strLit</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">mlir_type</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Op.mk</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">[</span><span class=\"n\">mlir_type</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"prettyOp\"</span>  <span class=\"o\">:</span> <span class=\"n\">mlir_op</span>  <span class=\"c1\">-- operation that returns an i32</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">mlir_op</span><span class=\"bp\">|</span><span class=\"n\">prettyOp</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span> <span class=\"o\">[</span><span class=\"n\">mlir_op</span><span class=\"bp\">|</span> <span class=\"s2\">\"std.prettyOp\"</span> <span class=\"o\">:</span> <span class=\"n\">i32</span><span class=\"o\">]</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prettyBad0</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mlir_op</span><span class=\"bp\">|</span> <span class=\"n\">prettyOp</span><span class=\"o\">]</span>\n<span class=\"k\">#print</span> <span class=\"n\">prettyBad0</span>\n</code></pre></div>",
        "id": 256917134,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1633832657
    },
    {
        "content": "<p>Does <code>set_option hygiene false</code> work for you?  See e.g. <a href=\"https://github.com/leanprover/lean4/blob/fb27537b8ee686251f5e51d7daf6c467731994c3/tests/lean/unhygienic.lean#L15\">https://github.com/leanprover/lean4/blob/fb27537b8ee686251f5e51d7daf6c467731994c3/tests/lean/unhygienic.lean#L15</a></p>",
        "id": 256917345,
        "sender_full_name": "David Renshaw",
        "timestamp": 1633832903
    },
    {
        "content": "<p>Yes, this seems to do the trick! In particular, changing the rule for the macro expansion of <code>prettyOp</code> to be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">hygiene</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">mlir_op</span><span class=\"bp\">|</span><span class=\"n\">prettyOp</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span> <span class=\"o\">[</span><span class=\"n\">mlir_op</span><span class=\"bp\">|</span> <span class=\"s2\">\"std.prettyOp\"</span> <span class=\"o\">:</span> <span class=\"n\">i32</span><span class=\"o\">]</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>works.</p>\n<p>Now I must ask another question: Is this an abuse of the Lean macro system? <del>Should</del> Can I achieve the same effect in a different way? I am worried that disabling hygiene will have other effects that I don't anticipate.</p>",
        "id": 256917469,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1633833048
    },
    {
        "content": "<p>You can use eraseMacroScopes to get the name the user typed (i).<br>\nI think you can also match on the i directly (i instead of $x:ident), but I'm not sure how that interacts with hygiene.</p>",
        "id": 256933681,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1633851043
    }
]
[
    {
        "content": "<p>Type class inference has changed drastically in Lean 4, with better and faster search algorithms. However, I found the following Lean 4 behavior surprising:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">P</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">op</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">natAdd</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">natAdd</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">T</span> <span class=\"n\">natAdd</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"n\">T</span> <span class=\"n\">Nat.add</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">natAdd</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">T</span> <span class=\"n\">natAdd</span> <span class=\"c1\">-- fails!?</span>\n<span class=\"k\">#check</span> <span class=\"n\">T</span> <span class=\"n\">Nat.add</span> <span class=\"c1\">-- fails!?</span>\n</code></pre></div>\n<p>In Lean 3 (after substituting <code>Nat</code> with <code>nat</code>), marking the definition reducible has the exact opposite effect where the last two checks both work. I would have expected at least the first check to continue working in Lean 4 after marking <code>natAdd</code> reducible. I can live with the last check failing but I prefer the Lean 3 behavior. What is the rationale for Lean 4's behavior?</p>",
        "id": 223659743,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1611331005
    },
    {
        "content": "<p>The current implementation assumes the reducibility settings do not change after the declaration is created. Note that the two checks succeed if you use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">natAdd</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add</span>\n</code></pre></div>\n<p>We should generate an error if the user tries to change the reducibility annotation using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">natAdd</span>\n</code></pre></div>\n<p>We are making this assumption because we don't want to spend time reconstructing all indices when reducibility settings are modified.<br>\nWe index type class instances, simp lemmas, etc.</p>",
        "id": 223661264,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1611331622
    },
    {
        "content": "<p>Thank you Leo! That makes perfect sense!</p>\n<p>Is the following a variation on the same?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">P</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">x.op</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Q</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instPOfQ</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Q</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x.op</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x₁</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add</span>\n<span class=\"kd\">instance</span> <span class=\"n\">q₁</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">x₁</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add</span>\n<span class=\"kd\">instance</span> <span class=\"n\">q₂</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">x₁.op</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">x₂.op</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">T</span> <span class=\"n\">x₁</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"n\">T</span> <span class=\"n\">x₂</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 223666546,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1611333806
    },
    {
        "content": "<p>Yes, it is. Your type class index contains an entry for <code>P x.op</code>. When you mark <code>x₂</code> as reducible, <code>P (x₂.op)</code> becomes <code>P Nat.add</code>. Then, when we ask the index for candidate instances for <code>P Nat.add</code>, we get none. <br>\nIn Lean 3, the example above works because the index uses just the head symbol, <code>P</code> in this example.<br>\nThe indexing data-structure for simp lemmas and instances work as follows:</p>\n<ul>\n<li>When adding a \"key\" to the index, we expand reducible constants.</li>\n<li>When searching the index for \"candidates\", we also expand \"reducible\" constants.</li>\n</ul>",
        "id": 223667894,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1611334469
    },
    {
        "content": "<p>BTW, we added an annotation to disable indexing on subterms. If you write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instPOfQ</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Q</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">noindex</span><span class=\"bp\">!</span> <span class=\"n\">x.op</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n</code></pre></div>\n<p>Lean 4 will treat <code>x.op</code> as a wildcard, and the example above will succeed. The <code>noindex!</code> is just an annotation.<br>\nOf course, if one overuses <code>noindex!</code>, the indexing data structures will not filter potential candidates effectively and will impact performance.</p>",
        "id": 223668450,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1611334760
    },
    {
        "content": "<p>Thank you for the detailed explanation. I will need to rethink some of the ways I use classes in Lean 4.</p>\n<p>So far, <code>noindex!</code> works for porting Lean 3 code. Thanks for the tip!</p>",
        "id": 223670951,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1611335857
    },
    {
        "content": "<p>Is it an oversight that <code>attribute [reducible]</code> is supported for structure fields, but <code>@[reducible]</code> is not?  (I think I just hit this as <a href=\"https://github.com/leanprover/lean4/issues/365\">https://github.com/leanprover/lean4/issues/365</a> ?)</p>",
        "id": 231373056,
        "sender_full_name": "Jason Gross",
        "timestamp": 1616442264
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 231396385,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616453313
    }
]
[
    {
        "content": "<p>Can someone help me get a Tree walk function working?  I'm trying to copy how the Json render function works but I'm getting a strange error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">walk</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"leaf\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"node: \"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">toString</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>error: invalid pattern, constructor or constant marked with '[matchPattern]' expected?</p>",
        "id": 284202991,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1653703364
    },
    {
        "content": "<p><code>leaf</code> and <code>node</code> aren't in scope</p>",
        "id": 284203070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653703482
    },
    {
        "content": "<p>You can fix this with either <code>open Tree</code> or <code>def Tree.walk</code> or use <code>.leaf</code> and <code>.node</code> in the patterns</p>",
        "id": 284203079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653703521
    },
    {
        "content": "<p>Doh! thanks, not the best error message... :-)</p>",
        "id": 284203085,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1653703527
    },
    {
        "content": "<p>The reason its giving you this error message is that it is interpreting <code>node</code> as a named wildcard pattern (which is in principle correct) but now you're also giving the thing arguments as if it was a function (<code>l</code> <code>k</code> <code>v</code> <code>r</code>) which doesnt make sense since the wildcard pattern can of course not receive arguments.</p>\n<p>It also did the same with <code>leaf</code> but since <code>leaf</code> doesn't have arguments it goes through as a normal named wildcard.</p>\n<p>You can also recognize the difference between a match pattern being interpreted as a wildcard and as a real constructor based on it's highlighting:</p>\n<p>As wildcard:<br>\n<a href=\"/user_uploads/3121/WEDBvA7cQJrUjuy3wey0Wi_9/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WEDBvA7cQJrUjuy3wey0Wi_9/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/WEDBvA7cQJrUjuy3wey0Wi_9/image.png\"></a></div><p>As constructor:<br>\n<a href=\"/user_uploads/3121/8aq4mxp0a51VzfHxhuUHUvAh/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8aq4mxp0a51VzfHxhuUHUvAh/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/8aq4mxp0a51VzfHxhuUHUvAh/image.png\"></a></div>",
        "id": 284227219,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653740562
    },
    {
        "content": "<p>I've just tried to run this for kicks, and I've gotten an error message I don't understand (scroll to the right if you can't see it):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n   <span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n   <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">walk</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"leaf\"</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"node: \"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">toString</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">walk</span> <span class=\"n\">r</span><span class=\"o\">)</span>     <span class=\"bp\">■</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>    <span class=\"n\">HAppend</span> <span class=\"n\">String</span> <span class=\"n\">β</span> <span class=\"bp\">?</span><span class=\"n\">m.5860</span>\n</code></pre></div>\n<p>I see in the Lean 4 source that <code>HAppend</code> is responsible for the <code>++</code>notation, and is a typeclass taking three arguments, and the first two look all right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HAppend</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n   <span class=\"n\">hAppend</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>     <span class=\"bp\">■</span> <span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">unknown</span> <span class=\"kd\">constant</span> <span class=\"bp\">'</span><span class=\"n\">Eq.ndrec'</span>\n</code></pre></div>\n<p>So I assume it's unhappy about whatever it's getting for <code>γ</code>. But I don't really understand how this class is being instantiated when you use this notation.</p>",
        "id": 284305199,
        "sender_full_name": "Malcolm Langfield",
        "timestamp": 1653857966
    },
    {
        "content": "<p>What the error message is trying to say is that Lean doesn't know how to append a <code>String</code> (<code>\"node: \" ++ (toString k)</code>) and a <code>β</code> (<code>(v)</code>)</p>",
        "id": 284305815,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1653858689
    },
    {
        "content": "<p>First things first there is not actually a reason to use the append notation here, we might as well use <code>s!</code> notation like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">def</span> <span class=\"n\">walk</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"leaf\"</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"node: {k} {v}</span><span class=\"se\">\\n</span><span class=\"s2\">{walk l}</span><span class=\"se\">\\n</span><span class=\"s2\">{walk r}\"</span>\n</code></pre></div>\n<p>this does however still throw an error (and as we will see this is also the reason why the append notation fails)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">ToString</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>so let's add that instance to our arguments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">def</span> <span class=\"n\">walk</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"leaf\"</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"node: {k} {v}</span><span class=\"se\">\\n</span><span class=\"s2\">{walk l}</span><span class=\"se\">\\n</span><span class=\"s2\">{walk r}\"</span>\n</code></pre></div>\n<p>Now everything works.</p>\n<p>So what's happening above is that everything comes down to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">def</span> <span class=\"n\">walk</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"leaf\"</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">toString</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>this not working out properly, it produces the same error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">HAppend</span> <span class=\"n\">String</span> <span class=\"n\">β</span> <span class=\"bp\">?</span><span class=\"n\">m.1520</span>\n</code></pre></div>\n<p>If we were to use toString on <code>v</code>and add the corresponding instance parameter everything would work just fine.</p>",
        "id": 284305883,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653858752
    },
    {
        "content": "<p>And i spent 5 min writing this essay /o\\</p>",
        "id": 284305888,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653858764
    },
    {
        "content": "<p>The essay is definitely more helpful :)</p>",
        "id": 284305893,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1653858785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Thanks for the quick explanations! I definitely like how the error message is a bit more clear (imo) when you use the string interpolation. So is it correct to read the square bracket/typeclass resolution notation as \"<code>β</code> must implement <code>ToString</code>\"? And for fixed <code>β</code>, we would achieve this by writing something of the form <code>instance ToString β where ...</code>?</p>",
        "id": 284307262,
        "sender_full_name": "Malcolm Langfield",
        "timestamp": 1653860887
    },
    {
        "content": "<p>You are missing a colon: <code>instance optionalName : ToString β where</code> but yes in principle you are right.</p>",
        "id": 284307359,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653861115
    },
    {
        "content": "<p>Another dumb question, I'm trying to parse XML and it took me forever to figure out that the import statement and the open statement have to be different and I'm wondering if there are any debug things that tell me what symbols are in scope when I use the <code>open</code> statement so I can debug this sort of thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Data.Xml</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Xml</span>\n<span class=\"k\">#eval</span> <span class=\"n\">parse</span> <span class=\"s2\">\"&lt;root/&gt;\"</span>\n</code></pre></div>\n<p>I also missed this magic combination a couple times until I realized that the Lean LSP was just being slow, seems when you import something it takes a few seconds to catch up?  It might be handy to change the InfoView (or popup tips) to \"busy\" in this case so I know it's not done yet...</p>",
        "id": 284410249,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1653949232
    },
    {
        "content": "<p>Regarding the first: I usually do <code>#check Lean.Xml.</code> and check out the auto completion at that point</p>\n<p>Regarding the second thing, if I import something heavy and it takes a while I can see my emacs indicating that in the left side bar by colouring it orange<br>\n<a href=\"/user_uploads/3121/oPYk8cruCLiZMCGAmWseeIJb/image.png\">image.png</a> <br>\nas the compiler progresses during the file it begins removing the orange bar from the lines that it already checked</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oPYk8cruCLiZMCGAmWseeIJb/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/oPYk8cruCLiZMCGAmWseeIJb/image.png\"></a></div>",
        "id": 284411778,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653951384
    },
    {
        "content": "<p>Thanks, I have another one, what does the <code>$</code> operator do?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">manyCore</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"bp\">$</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">manyCore</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">acc.push</span> <span class=\"bp\">$</span> <span class=\"bp\">←</span><span class=\"n\">p</span><span class=\"o\">))</span>\n  <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">acc</span>\n</code></pre></div>\n<p>I think it's implemented here, but I couldn't figure it out from there...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">macroArg</span>       <span class=\"o\">:=</span> <span class=\"n\">termParser</span> <span class=\"n\">maxPrec</span>\n<span class=\"kd\">def</span> <span class=\"n\">macroDollarArg</span> <span class=\"o\">:=</span> <span class=\"n\">leading_parser</span> <span class=\"s2\">\"$\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">termParser</span> <span class=\"mi\">10</span>\n<span class=\"kd\">def</span> <span class=\"n\">macroLastArg</span>   <span class=\"o\">:=</span> <span class=\"n\">macroDollarArg</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">macroArg</span>\n</code></pre></div>\n<p>As the only place this is referenced is in BuildinNotation under <code>elabStateRefT</code>...?</p>",
        "id": 284414858,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1653955329
    },
    {
        "content": "<p><code>Parsec $ Array α</code> is equivalent to <code>Parsec (Array α)</code>. It doesn't do anything, but it binds with very low precedence so that you can avoid stacking parentheses</p>",
        "id": 284415010,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653955522
    },
    {
        "content": "<p>So something like <code>f (g (h x y))</code> can be written as <code>f $ g $ h x y</code></p>",
        "id": 284415071,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653955575
    },
    {
        "content": "<p>Awesome thanks, totally wouldn't have figured that out from the code.  A comment to that effect in the code would have been nice.  Better yet, a comment that would then also popup when I hover my mouse over the <code>$</code> symbol...</p>",
        "id": 284416706,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1653957969
    },
    {
        "content": "<p>There is some documentation here: <a href=\"https://leanprover.github.io/lean4/doc/functions.html\">https://leanprover.github.io/lean4/doc/functions.html</a></p>\n<blockquote>\n<p>For users familiar with the Haskell programming language, Lean also supports the notation <code>f $ a</code> for the backward pipeline <code>f &lt;| a</code>.</p>\n</blockquote>\n<blockquote>\n<p>The forward pipeline <code>|&gt;</code> operator takes a function and an argument and return a value. In contrast, the backward pipeline <code>&lt;|</code> operator takes an argument and a function and returns a value. These operators are useful for minimizing the number of parentheses.</p>\n</blockquote>\n<p>Example from the manual:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add1</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">times2</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">times2</span> <span class=\"o\">(</span><span class=\"n\">add1</span> <span class=\"mi\">100</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"mi\">100</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">add1</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">times2</span>\n<span class=\"k\">#eval</span> <span class=\"n\">times2</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">add1</span> <span class=\"bp\">&lt;|</span> <span class=\"mi\">100</span>\n</code></pre></div>",
        "id": 284459808,
        "sender_full_name": "Malcolm Langfield",
        "timestamp": 1653996022
    },
    {
        "content": "<p>Admittedly it's not exactly easy to find if you're specifically looking for a definition of the <code>$</code> operator, and don't already know your way around the manual.</p>",
        "id": 284460026,
        "sender_full_name": "Malcolm Langfield",
        "timestamp": 1653996136
    },
    {
        "content": "<p>How can I write this function?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">TType.eq</span> <span class=\"o\">:</span> <span class=\"n\">TType</span> <span class=\"bp\">→</span> <span class=\"n\">TType</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">t₂</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">t₁</span> <span class=\"bp\">==</span> <span class=\"n\">t₂</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>",
        "id": 284486433,
        "sender_full_name": "Remi",
        "timestamp": 1654008118
    },
    {
        "content": "<p>Sounds like you want to derive <code>DecidableEq TType</code></p>",
        "id": 284487366,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1654008445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121918\">@Edward Ayers</span> Thanks, that exactly what I want!</p>",
        "id": 284487892,
        "sender_full_name": "Remi",
        "timestamp": 1654008681
    },
    {
        "content": "<p>You can do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">TType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">TType</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">TType.eq</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"n\">t₂</span> <span class=\"o\">:</span> <span class=\"n\">TType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>Unfortunately that doesn't quite work because <code>Option</code> only accepts types and not props. But once you have the <code>if h : P then A else B</code> pattern where <code>Decidable P</code> you can do a lot.</p>\n<p>Also have a look at this section of TPIL: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html?highlight=Decidable#decidable-propositions\">https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html?highlight=Decidable#decidable-propositions</a></p>",
        "id": 284488377,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1654008916
    },
    {
        "content": "<p>Why doesn't this work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n</code></pre></div>\n<p>I realize I can use literal syntax and do this <code>([]: List String)</code> but I'm just wondering what the deep compiler reason is to disallow the syntax I've written here.  I'm confused why I can't declare the type, put it in parens and call the nil constructor to get back a typed empty list. </p>\n<p>Seems type classes have the same limitation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Add</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>and this doesn't work either:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Foo.cons</span> <span class=\"s2\">\"hello\"</span> <span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"s2\">\"c\"</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But I can write this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"s2\">\"c\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"s2\">\"d\"</span>\n</code></pre></div>\n<p>and this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">emptyListOfStrings</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">List.nil</span>\n<span class=\"k\">#check</span> <span class=\"n\">emptyListOfStrings</span>   <span class=\"c1\">-- List String</span>\n</code></pre></div>\n<p>So it works when the type is implicit or can be inferred, and so I guess I'd understand better if the type argument to list was declared implicitly instead of explicitly ...</p>",
        "id": 294935307,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661283733
    },
    {
        "content": "<p>The useless reason is that there's no reason to think that your non-working examples should work.</p>",
        "id": 294935752,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661283884
    },
    {
        "content": "<p>Note in your working examples you have, before the <code>.</code>, either a value (<code>[\"a\", \"b\", \"c\"]</code>) or a namespace (<code>List</code>).</p>",
        "id": 294935857,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661283929
    },
    {
        "content": "<p>In the former case, because <code>[\"a\", \"b\", \"c\"] : List String</code>, <code>[\"a\", \"b\", \"c\"].cons</code> means <code>List.cons</code>.</p>",
        "id": 294936089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661284026
    },
    {
        "content": "<p>so <code>#eval (List.nil : List String)</code> would work, right? (I'm not in Lean 4 at the moment.)</p>",
        "id": 294936151,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661284053
    },
    {
        "content": "<p>Yeah, I know all the variations that work, I'm just trying to figure out what is wrong with my understanding of inductive types that makes me think I should be able to <code>#eval (List String).nil</code>.  Note that I cannot call <code>nil</code> on a list value (like I can with x.cons) since the <code>nil</code> constructor takes no arguments.</p>",
        "id": 294936582,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661284237
    },
    {
        "content": "<p><code>(List String).nil</code> should refer to <code>Type.nil</code>, I guess</p>",
        "id": 294936612,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661284254
    },
    {
        "content": "<p>Keep in mind that <code>List.nil</code> and <code>(List).nil</code> are two completely different things. The first one is a single token, a namespaced name, and the second one is the <code>|&gt;.nil</code> operation applied to the expression <code>List</code></p>",
        "id": 294937268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661284582
    },
    {
        "content": "<p>This is somewhat confused by the fact that <code>x.nil</code> (where <code>x</code> is a local variable) is ambiguous between both of them, and there is some complexity in name resolution due to this</p>",
        "id": 294937351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661284623
    },
    {
        "content": "<p>Thanks, the fact that <code> (List).nil</code> gives the same error is helpful.  Perhaps the  type argument on List is not really a type argument, it is some sort of type \"context\" that can only be inferred.  At least lean is very consistent about this, I can't do this either:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Point</span> <span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"mi\">5</span> <span class=\"mi\">7</span>              <span class=\"c1\">-- same error</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Point.mk</span> <span class=\"mi\">5</span> <span class=\"mi\">7</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"c1\">-- { x := 5.000000, y := 7.000000 }</span>\n</code></pre></div>",
        "id": 294938815,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661285238
    },
    {
        "content": "<p>So for example <code>Nat.zero</code> is a namespaced name (<code>zero</code> in namespace <code>Nat</code>) that has nothing to do with the <em>type</em> <code>Nat</code>--except that the same <code>inductive</code> command defined both of them</p>",
        "id": 294938948,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661285293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> <a href=\"#narrow/stream/270676-lean4/topic/dumb.20questions/near/294938815\">said</a>:</p>\n<blockquote>\n<p>Perhaps the  type argument on List is not really a type argument, it is some sort of type \"context\" that can only be inferred. </p>\n</blockquote>\n<p>The type argument in <code>List String</code> really <em>is</em> a type argument. But <code>List</code> in <code>List.nil</code> is <strong>not</strong> a type at all</p>",
        "id": 294939354,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661285468
    },
    {
        "content": "<p>And for consistency you can't write <code>(Nat).zero</code> either.</p>",
        "id": 294939495,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661285528
    },
    {
        "content": "<p>Well the members of an inductive type are called \"constructors\" in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html\">TPIL</a>.  So List.nil should be constructing a List but it can't resolve the required type parameter, so you get the unresolved type <code>List.nil : List ?m.10448</code>.</p>",
        "id": 294939676,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661285634
    },
    {
        "content": "<p>And I was thinking why can't I help the compiler resolve the missing type by providing it with <code>(List String).nil</code> but alas, parens are special and dot notation doesn't like them.</p>",
        "id": 294939752,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661285667
    },
    {
        "content": "<p>No, it has nothing to do with parentheses</p>",
        "id": 294939773,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661285683
    },
    {
        "content": "<p>You are inventing some interpretation of <code>List.nil</code> that does not exist in Lean.</p>",
        "id": 294939905,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661285761
    },
    {
        "content": "<p>That's a good way to put it. All inductive type constructors must then be only \"Name.ctor\" where Name is the inductive type name and ctor is the constructor name, like <code>Weekday.Monday</code> in TPIL.  But if the inductive type has one or more type parameters, those types must be inferred as they cannot be passed directly in the inductive type constructor call.</p>",
        "id": 294940314,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661285955
    },
    {
        "content": "<p>Oh, wait, yes it can with this <code>#check List.nil (α := Float) -- : List Float</code>  interesting...</p>",
        "id": 294940354,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661285981
    },
    {
        "content": "<p>Maybe it's not clear what <code>inductive</code> actually does: the <code>inductive</code> definition for List creates three new identifiers <code>List</code>, <code>List.nil</code>, <code>List.cons</code> (and a bunch of other stuff). <code>List.nil</code> has <code>List</code> as part of its name (more precisely, it is in the <code>List</code> namespace).</p>",
        "id": 294940362,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661285989
    },
    {
        "content": "<p><code>List.nil</code> doesn't mean \"give me something called <code>nil</code> of type <code>List</code>\", it is simply the identifier <code>List.nil</code>.</p>",
        "id": 294940491,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661286055
    },
    {
        "content": "<p>Well TPIL calls it an inductive type \"constructor\" so I don't want to stray too far from that definition.</p>",
        "id": 294940570,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286097
    },
    {
        "content": "<p>So I read <code>List.nil</code> as construct a List using the <code>nil</code> constructor.</p>",
        "id": 294940669,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286125
    },
    {
        "content": "<p>Well, that's not how it works <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 294940694,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661286138
    },
    {
        "content": "<p>Oh?</p>",
        "id": 294940806,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286194
    },
    {
        "content": "<p>It just means: the identifier <code>List.nil</code>.</p>",
        "id": 294940871,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661286219
    },
    {
        "content": "<p>You could imagine a version of <code>inductive</code> that instead creates constructors called <code>List_nil</code> and <code>List_cons</code>, and then the way you would construct an empty list is using <code>List_nil</code>--but it would work exactly the same way.</p>",
        "id": 294941067,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661286290
    },
    {
        "content": "<p>The C++ analogue would be something like <code>List::nil()</code></p>",
        "id": 294941208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661286353
    },
    {
        "content": "<p>this is not the same as <code>List.nil()</code> which is a method applied to an object called <code>List</code></p>",
        "id": 294941303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661286381
    },
    {
        "content": "<p>The <code>List</code> in <code>List::nil</code> is just a namespace, not an object. it's a way to construct fancy segmented names but not otherwise a thing in its own right</p>",
        "id": 294941416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661286438
    },
    {
        "content": "<p>In lean the first one is spelled <code>List.nil</code> and the second is <code>(List).nil</code> or <code>List |&gt;.nil</code> (and this latter thing doesn't work because there isn't a method <code>Type.nil</code> that would apply to <code>List</code> itself)</p>",
        "id": 294941673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661286578
    },
    {
        "content": "<p>I'm sure that all the object oriented programming I've done is where my problems are coming from so switching to C++ doesn't help because there I can call the constructor on the fully qualified type to create an empty list with <code>auto x = list&lt;float&gt;();</code></p>",
        "id": 294941692,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286595
    },
    {
        "content": "<p>The analogue of calling the constructor on the fully qualified type is <code>@List.nil Float</code></p>",
        "id": 294941781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661286623
    },
    {
        "content": "<p>But I cannot call the constructors on a fully qualified inductive type like (List String)</p>",
        "id": 294941807,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286635
    },
    {
        "content": "<p>or <code>(.nil : List String)</code></p>",
        "id": 294941836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661286655
    },
    {
        "content": "<p>thanks and I also found <code>List.nil (α := Float)</code> earlier.</p>",
        "id": 294941875,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286677
    },
    {
        "content": "<p>This one <code>(.nil : List String)</code> doesn't count in my mind because it is depending on type inference.  I was looking for a syntax that did not depend on type inference.  The <code>@</code> one is interesting, but probably not for beginners?  I think the closest so far is <code>List.nil (α := Float)</code></p>",
        "id": 294942067,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661286759
    },
    {
        "content": "<p>The <code>@</code> syntax is the most straightforward, even for beginners, although you might want to prefer the other methods for style reasons</p>",
        "id": 294942668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287041
    },
    {
        "content": "<p>If there are typeclass arguments you will need a lot of <code>_</code> when using <code>@</code></p>",
        "id": 294942696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287059
    },
    {
        "content": "<p>What makes this confusing is:</p>\n<ul>\n<li>The dot is used in two different syntactic constructs, building namespaced names (<code>List.nil</code>) and also \"dot notation\" (<code>[\"a\", \"b\", \"c\"].cons \"d\"</code>).</li>\n<li>In Lean, types are also expressions, so the type <code>List</code> is something that it would make sense to use dot notation on (at least in principle). However, that's not what's going on in <code>List.nil</code>, which is a namespaced name.</li>\n<li>The <code>inductive</code> command puts the constructors in a namespace named after the type being created. (Likewise, hand-written definitions relating to the <code>List</code> type are by convention put in the <code>List</code> namespace.) That opens the possibility of misinterpreting <code>List.nil</code> as involving the type <code>List</code> somehow.</li>\n</ul>",
        "id": 294942778,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661287093
    },
    {
        "content": "<p>It's the most direct analogue of your <code>list&lt;string&gt;()</code> example</p>",
        "id": 294942784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287095
    },
    {
        "content": "<p>It wouldn't make much sense to call a constructor on <code>List String</code>. Think about this: modulo differences that don't matter <code>List (α : Type) → Type</code>, so <code>List</code> eats a type and spits out another type. Thus <code>List String : Type</code>. If you were going to have a function that takes <code>List String</code> as an argument and returns something (like the <code>List.nil</code>) of that type, such a function would have to have type <code>Type → List String</code>. How would such a function behaves on types other than <code>List String</code>?</p>",
        "id": 294942787,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661287096
    },
    {
        "content": "<p>This also explains why if you want to have <code>List String</code> involved in the syntax you need to use type inference, because the constructor isn't taking <code>List String</code> as the argument, the argument is <code>String</code> and the resulting type is <code>List String</code></p>",
        "id": 294943081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661287237
    },
    {
        "content": "<p>BTW, our LSP server makes it clear which interpretation was used for the <code>.</code>s. You have to use a color theme that distinguishes the relevant syntactic categories or customize one.<br>\n<a href=\"/user_uploads/3121/iqLP-apAcMmDr_40Z3ZWdB9w/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/iqLP-apAcMmDr_40Z3ZWdB9w/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/iqLP-apAcMmDr_40Z3ZWdB9w/image.png\"></a></div><ul>\n<li><code>List.nil</code> is white because it is a constant.  </li>\n<li><code>val</code> and <code>values</code> are yellow because they are parameters (or local variables).</li>\n<li><code>cons</code> is purple because it is part of the dot-notation. <code>values.cons val</code> is syntax sugar <code>List.cons val values</code>. If we hover over the elements, you will also get similar information.</li>\n</ul>",
        "id": 294943835,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661287585
    },
    {
        "content": "<p>Do we have a guide of relevant syntactic categories? I start all my Lean4 files with <code>set_option autoImplicit false</code> because my color theme isn't good enough at telling me when a typo triggers autoImplicit while I meant to name some existing thing.</p>",
        "id": 294944238,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661287787
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> The key syntactic categories for Lean are <code>variable</code> (for highlighting local variables and parameters) and <code>property</code> (for highlighting the dot notation). Very few color themes handle them out of the box :(</p>",
        "id": 294944524,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661287920
    },
    {
        "content": "<p>You can configure an existing theme by editing your <code>settings.json</code>.</p>",
        "id": 294944867,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661288048
    },
    {
        "content": "<p>I found the previous discussion in <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20VS.20Code.20color.20scheme\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.E2.9C.94.20VS.20Code.20color.20scheme</a>. I'll try to write a useful summary</p>",
        "id": 294944915,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1661288076
    },
    {
        "content": "<p>Here is my config </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"s2\">\"editor.semanticHighlighting.enabled\"</span><span class=\"o\">:</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n    <span class=\"s2\">\"workbench.colorCustomizations\"</span><span class=\"o\">:</span> <span class=\"o\">{</span>\n      <span class=\"s2\">\"[Solarized Light]\"</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"s2\">\"editor.selectionHighlightBackground\"</span><span class=\"o\">:</span> <span class=\"s2\">\"#e9dcc5\"</span><span class=\"o\">}</span>\n    <span class=\"o\">},</span>\n    <span class=\"s2\">\"editor.semanticTokenColorCustomizations\"</span><span class=\"o\">:</span> <span class=\"o\">{</span>\n        <span class=\"s2\">\"[Solarized Light]\"</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"s2\">\"rules\"</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"s2\">\"function\"</span><span class=\"o\">:</span> <span class=\"s2\">\"#c1892f\"</span><span class=\"o\">,</span> <span class=\"s2\">\"property\"</span><span class=\"o\">:</span> <span class=\"s2\">\"#69878c\"</span><span class=\"o\">}},</span>\n        <span class=\"s2\">\"[Ayu Dark]\"</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"s2\">\"rules\"</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"s2\">\"property\"</span><span class=\"o\">:</span> <span class=\"s2\">\"#948fd0\"</span><span class=\"o\">,</span> <span class=\"s2\">\"variable\"</span><span class=\"o\">:</span> <span class=\"s2\">\"#cbc248\"</span><span class=\"o\">}}</span>\n    <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 294944925,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661288080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/dumb.20questions/near/294944915\">said</a>:</p>\n<blockquote>\n<p>I found the previous discussion in <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20VS.20Code.20color.20scheme\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.E2.9C.94.20VS.20Code.20color.20scheme</a>. I'll try to write a useful summary</p>\n</blockquote>\n<p>Thanks! We will add it to the manual.</p>",
        "id": 294945001,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661288126
    },
    {
        "content": "<p>Leo made an interesting point that is helpful: <code>values.cons val</code> is actually <code>List.cons val values</code>.  I was thinking of List as a sort of generic type (in the C++ sense) that can't reallybe constructed until you provide the type parameters, and <code>List String</code> then as a specialization of that same type and therefore it inherits all the methods that List has, including the constructors and this is simply not the case.    So, the fact that you can write <code>#eval [\"a\", \"b\"].cons \"c\" -- [\"c\", \"a\", \"b\"]</code> is a little misleading because it makes it appear that <code>List String</code> has a cons constructor, but it doesn't.</p>",
        "id": 294946432,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661288702
    },
    {
        "content": "<p>Building on all the interesting talk about namespaces above, I can extend the List.String namespace and add this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">List.String</span>\n<span class=\"kd\">def</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"kd\">end</span> <span class=\"n\">List.String</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">List.String.nil</span>  <span class=\"c1\">-- []</span>\n<span class=\"k\">#check</span> <span class=\"n\">List.String.nil</span>  <span class=\"c1\">--List String</span>\n</code></pre></div>\n<p>but obviously I don't want to do that for every possible type of list...</p>",
        "id": 294947181,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661289087
    },
    {
        "content": "<p>Likewise, you could also do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"kd\">end</span> <span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Nat.nil</span>  <span class=\"c1\">-- []</span>\n<span class=\"k\">#check</span> <span class=\"n\">Nat.nil</span>  <span class=\"c1\">--List String</span>\n</code></pre></div>",
        "id": 294948516,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661289779
    },
    {
        "content": "<p>The List.String namespace was empty before this, right?</p>",
        "id": 294948753,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1661289934
    },
    {
        "content": "<p>If not, that gives me a strong <code>vector&lt;bool&gt;</code> vibe</p>",
        "id": 294949105,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1661290108
    },
    {
        "content": "<p>Again, the above <code>List.String.nil</code> is <em>just</em> an identifier; it's not doing anything fancy.</p>",
        "id": 294949283,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661290199
    },
    {
        "content": "<p>Right, I should have said \"there are no other <code>List.String</code>-prefixed identifiers, right?\". Thanks for the correction.</p>",
        "id": 294949825,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1661290490
    },
    {
        "content": "<p>Sorry Mauricio, my comment was intended for aiding Chris's understanding.</p>",
        "id": 294950123,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661290659
    },
    {
        "content": "<p>I hear what you are saying about \"List.nil\" is just an identifier and \"List.String.nil\" is just an identifier and so on, but it is not satisfying given that in every other language \".\" is special.  If I followed your statement to its logical conclusion, I would think it is perfectly fine to write this function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Frump...alump</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>            <span class=\"c1\">-- unknown identifier 'Frump'</span>\n</code></pre></div>\n<p>But alas I cannot.  So \".\" in an Identifier is special.  It is a namespace separator.</p>",
        "id": 294953135,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661292485
    },
    {
        "content": "<p>Yes exactly. But the <code>List</code> namespace has no relation to the <code>List</code> type, except by convention (and how the <code>inductive</code> command works).</p>",
        "id": 294953885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661292957
    },
    {
        "content": "<p><code>.</code> in identifiers is special, but only to give a hierarchical structure to identifiers. <code>.</code> is not an \"identifier character\" so you can't directly write <code>a..b</code> as an ident</p>",
        "id": 294954170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661293122
    },
    {
        "content": "<p>Without such structure it's hard to have commands like <code>open</code> that allow you to omit namespaces in an identifier</p>",
        "id": 294954324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661293219
    },
    {
        "content": "<p>I love using \".\" in namespace qualified names.  I'm glad Lean can do the same.  Note that <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html#enumerated-types\">TPIL</a> does indeed call the <code>List</code> inductive type a namespace, with this:</p>\n<blockquote>\n<p>The constructors all live in the Weekday namespace.</p>\n</blockquote>",
        "id": 294954768,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661293504
    },
    {
        "content": "<p>No, <code>List</code> the namespace and <code>List</code> the inductive type are different, they just happen to share the same four English letters. Nevertheless, the constructors for List the inductive type do live in the List namespace.</p>",
        "id": 294955037,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661293666
    },
    {
        "content": "<p>Perhaps you are talking implementation details, or are you saying the book TPIL is wrong when it says \"The constructors all live in the Weekday namespace\" ?</p>",
        "id": 294962514,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661298997
    },
    {
        "content": "<p>The book is correct, the constructs do live in the <code>Weekday</code> namespace.</p>",
        "id": 294963360,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661299606
    },
    {
        "content": "<p>The <code>Weekday</code> type and the <code>Weekday</code> namespace are not the same thing.</p>",
        "id": 294963380,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661299623
    },
    {
        "content": "<p>Well it's tricky because in the book the Weekday inductive type and all its constructors are defined BEFORE any explicit creation of <code>namespace Weekday</code> and in fact even before defining <code>namespace Weekday</code> the code was then able to <code>open Weekday</code> and open is defined to only work on namespaces, therefore the inductive type Weekday created a namespace of the same name, but we are quibbling now, so diminishing returns, but thanks for all the excellent thoughts and clarifications.</p>",
        "id": 294964850,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661300845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span>  The book says: \"The inductive command creates a new type, Weekday. The constructors all live in the Weekday namespace.\" It looks clear to me that a namespace called \"Weekday\" was also created. Otherwise, how would we add the constructors to the namespace \"Weekday\"? <br>\nAny suggestions on how to make it clear that a namespace \"Weekday\" is also being created? Or is it not clear at this point in the book that namespaces and types are different things?</p>",
        "id": 294965516,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661301386
    },
    {
        "content": "<p>I think a namespace is \"created\" (in the sense that you can <code>open</code> it) as soon as any identifier is defined in that namespace; in any case, the <code>inductive Weekday [...]</code> <em>command</em> certainly creates the <code>Weekday</code> <em>namespace</em>, as well as the <code>Weekday</code> <em>type</em> (and various other things).</p>",
        "id": 294965525,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661301397
    },
    {
        "content": "<p>I think it would be nice to explicitly state somewhere that defining and inductive type creates both a type and a namespace of that same name.  This avoids confusion with other languages where a type name <strong>is</strong> a namespace which then avoids my original confusion thinking (List String) is a namespace that I could .cons or .nil into.  Question, does a type class also create a namespace of the same name?  What about a structure?</p>",
        "id": 294966715,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661302462
    },
    {
        "content": "<p>From TPIL: \"The structure command is essentially a \"front end\" for defining inductive data types. Every structure declaration introduces a namespace with the same name. The general form is as follows:\"</p>",
        "id": 294966804,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661302564
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html#declaring-structures\">https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html#declaring-structures</a></p>",
        "id": 294966839,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1661302629
    },
    {
        "content": "<p>that language is perfect, and I assume the same language could be used in the chapter on inductive types, and type classes?</p>",
        "id": 294967107,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661302877
    },
    {
        "content": "<p>How come Repr doesn't provide ToString?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Config</span> <span class=\"n\">where</span>\n  <span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n  <span class=\"n\">verbose</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n  <span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">output</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">({}</span> <span class=\"o\">:</span> <span class=\"n\">Config</span><span class=\"o\">)</span>\n<span class=\"c1\">-- { help := false, verbose := false, input := \"\", output := \"\" }</span>\n</code></pre></div>\n<p>But I can't seem to do <code>IO.println config</code> nor can I <code>IO.println s!\"{config}\"</code> ?  Do I have to also create a ToString instance on this?  I see stuff like this in the Lean code base:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Stats.toString</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Stats</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"</span><span class=\"err\">\\</span><span class=\"s2\">{nodes := {s.numNodes}, depth := {s.depth}, tail size := {s.tailSize}}\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Stats</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Stats.toString</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>But what's the point of Repr if we have to do this also?</p>",
        "id": 295547616,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661578104
    },
    {
        "content": "<p><code>ToString</code> and <code>Repr</code> have slightly different purposes, roughly comparable to Rust's <code>Display</code> vs <code>Debug</code>. <code>ToString</code> is for a human-readable display of the string, while <code>Repr</code> is supposed to be (mostly) suitable for copy-pasting as lean code</p>",
        "id": 295547734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661578267
    },
    {
        "content": "<p>Ok, and there's no helpers for ToString on a structure? I have to do it by hand?</p>",
        "id": 295547759,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661578300
    },
    {
        "content": "<p>for instance, the <code>ToString</code> instance for strings just spits the string back out, while the <code>Repr</code> instance puts quotes and backslashes in</p>",
        "id": 295547768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661578312
    },
    {
        "content": "<p>And also like Rust, the derive handler only exists for <code>Repr</code>, with the <code>ToString</code> instance intended for manual implementation</p>",
        "id": 295547824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661578353
    },
    {
        "content": "<p>If you would like to use the same <code>ToString</code> as <code>Repr</code>, you can derive <code>Repr</code> and then <code>instance : ToString Foo := \\&lt;repr\\&gt;</code></p>",
        "id": 295547841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661578389
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Config</span> <span class=\"n\">where</span>\n  <span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n  <span class=\"n\">verbose</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n  <span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Config</span> <span class=\"o\">:=</span>  <span class=\"o\">⟨</span><span class=\"n\">repr</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>gives an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.2361</span> <span class=\"bp\">→</span> <span class=\"n\">Std.Format</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"bp\">?</span><span class=\"n\">u.2357</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"bp\">?</span><span class=\"n\">u.2357</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">ToString</span> <span class=\"n\">Config</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>I searched the lean code for <code>⟨repr⟩</code> but found nothing like that...</p>",
        "id": 295548260,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661578939
    },
    {
        "content": "<p>That's a terrifying error message, but I can't reproduce it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"o\">{</span> <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"n\">repr</span> <span class=\"o\">}</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">repr</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.1683</span> <span class=\"bp\">→</span> <span class=\"n\">Lean.Format</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.1682</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Config</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>",
        "id": 295559569,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1661587784
    }
]
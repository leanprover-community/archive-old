[
    {
        "content": "<p>There is a proposal for theorem names at <a href=\"https://github.com/leanprover/lean4/issues/402\">https://github.com/leanprover/lean4/issues/402</a> The proposal is snake case but with camelCase for the components:</p>\n<ul>\n<li><code>nat_add_zero</code></li>\n<li><code>axiom_of_choice</code></li>\n<li><code>eq_punit</code></li>\n<li><code>runCatch_pure</code></li>\n<li><code>seqLeft_eq_bind</code></li>\n</ul>\n<p>Note that types (e.g. <code>Nat</code>, <code>Eq</code>) become lowercase. The known downside is that it cannot distinguish between e.g. <code>Or</code> and <code>or</code>, but this may acceptable in light of how bad the alternatives seem. If anybody sees any critical problems with this proposal, please share them in the GitHub issue.</p>",
        "id": 237253623,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620090185
    },
    {
        "content": "<p>Why <code>nat_add_zero</code> instead of <code>Nat.add_zero</code>?</p>",
        "id": 237254607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620090940
    },
    {
        "content": "<p>specifically, why is it no longer in the <code>Nat</code> namespace?</p>",
        "id": 237254630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620090960
    },
    {
        "content": "<p>When you say \"types became lowercase\", do you mean <code>Nat</code> becomes <code>nat</code> like in lean 3? Or is this only for theorem names, not the actual type names?</p>",
        "id": 237254877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237254607\">said</a>:</p>\n<blockquote>\n<p>Why <code>nat_add_zero</code> instead of <code>Nat.add_zero</code>?</p>\n</blockquote>\n<p>I just translated what happened to be in <code>Init</code> to the proposed style. <code>Nat.add_zero</code> is consistent with the proposal.</p>",
        "id": 237255058,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091323
    },
    {
        "content": "<p>Whatever comes between the <code>_</code> would be camelCase.</p>",
        "id": 237255117,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091358
    },
    {
        "content": "<p>So types, modules, and namespaces are all PascalCase?</p>",
        "id": 237255137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091384
    },
    {
        "content": "<p>Yes, and file names.</p>",
        "id": 237255171,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091431
    },
    {
        "content": "<p>There will be a number of specific naming conflicts to resolve, no matter what the convention is. I guess the RFC isn't the appropriate place for this, although it might influence the choice</p>",
        "id": 237255409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091604
    },
    {
        "content": "<p>I'm broadly supportive of the plan though</p>",
        "id": 237255470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091676
    },
    {
        "content": "<p>It would be helpful to find other examples of the <code>Or_True</code>/<code>or_true</code> clash, besides just <code>Prop</code>/<code>Bool</code>.</p>",
        "id": 237255496,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091684
    },
    {
        "content": "<p>Are we using <code>Title_Snake_Case</code> anywhere?</p>",
        "id": 237255539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091721
    },
    {
        "content": "<p>i.e. names that appear both uppercase as types and lowercase as values/functions</p>",
        "id": 237255546,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091735
    },
    {
        "content": "<p>No, we are not using <code>Title_Snake_Case</code> anywhere. That is option (2) in the GitHub issue. It has very little support AFAICT, in part because of the issue I mentioned: connectives (and, or) and verbs (eq) are awkward capitalized.</p>",
        "id": 237255592,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091782
    },
    {
        "content": "<p>when you say <code>Or_True</code> then are you referring to the theorem p \\/ True = True?</p>",
        "id": 237255661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091822
    },
    {
        "content": "<p>Yes, and <code>or_true</code> is <code>p || true = true</code>.</p>",
        "id": 237255691,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091839
    },
    {
        "content": "<p>That looks like <code>Bool.or_true</code></p>",
        "id": 237255730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091880
    },
    {
        "content": "<p>and I think something similar to this can avoid most of the name clashes about Prop/Bool</p>",
        "id": 237255805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091928
    },
    {
        "content": "<p>we could also go back to <code>tt</code>/<code>ff</code></p>",
        "id": 237255829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620091952
    },
    {
        "content": "<p>I agree that <code>Bool.or_true</code> is a fine solution for that particular clash.</p>",
        "id": 237255837,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620091965
    },
    {
        "content": "<p>The fact that <code>true</code> is blue and <code>True</code> isn't seems like it implicitly prefers <code>true</code>, which probably isn't the right default for mathematics</p>",
        "id": 237255922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092022
    },
    {
        "content": "<p>Well, maybe we can get by if we just use <code>⊤</code> and <code>⊥</code> for true and false, although those symbols are currently in use for lattices</p>",
        "id": 237256046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237255546\">said</a>:</p>\n<blockquote>\n<p>i.e. names that appear both uppercase as types and lowercase as values/functions</p>\n</blockquote>\n<p>Here is one possible clash:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">EvalsTo</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Program</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Value</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">def</span> <span class=\"n\">evalsTo</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Program</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Value</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">evalsTo_of_evalsTo</span>\n</code></pre></div>",
        "id": 237256076,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620092119
    },
    {
        "content": "<p>I would just use <code>EvalsTo</code> in the theorem name if there is a name clash like that</p>",
        "id": 237256121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092159
    },
    {
        "content": "<p>I think it's fine to just use that as a backup plan</p>",
        "id": 237256168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092177
    },
    {
        "content": "<p>there are quite a few backup plans in the mathlib naming convention</p>",
        "id": 237256190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092194
    },
    {
        "content": "<p>What about lowercasing <code>Prop</code>-valued types?</p>",
        "id": 237256238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237255922\">said</a>:</p>\n<blockquote>\n<p>The fact that <code>true</code> is blue and <code>True</code> isn't seems like it implicitly prefers <code>true</code>, which probably isn't the right default for mathematics</p>\n</blockquote>\n<p>Neither are blue for me. Is that a VSCode thing? What does blue mean?</p>",
        "id": 237256240,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620092249
    },
    {
        "content": "<p>keyword I guess</p>",
        "id": 237256249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092259
    },
    {
        "content": "<p>even though it's not a keyword</p>",
        "id": 237256258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092273
    },
    {
        "content": "<p>Could be easy to just make <code>True</code> and <code>true</code> blue then</p>",
        "id": 237256322,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620092306
    },
    {
        "content": "<p><code>true</code> is apparently in the <code>constant.language.lean4</code> textmate scope</p>",
        "id": 237256357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092346
    },
    {
        "content": "<p>which is blue in my theme</p>",
        "id": 237256370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/237256238\">said</a>:</p>\n<blockquote>\n<p>What about lowercasing <code>Prop</code>-valued types?</p>\n</blockquote>\n<p>You mean <code>Prop</code>-valued inductive types?</p>",
        "id": 237256390,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620092385
    },
    {
        "content": "<p>defs too, although I guess most of them are inductive</p>",
        "id": 237256455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092410
    },
    {
        "content": "<p>someone pointed out earlier that propositions often feel more like functions than types</p>",
        "id": 237256516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092484
    },
    {
        "content": "<p>Would it be alright to take a poll? I think this is the sort of thing that deserves a decent size poll</p>",
        "id": 237256781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092723
    },
    {
        "content": "<p>Poll how?</p>",
        "id": 237256941,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1620092848
    },
    {
        "content": "<p>zulip has a poll system</p>",
        "id": 237256952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092861
    },
    {
        "content": "<p>it might not get enough people though</p>",
        "id": 237256963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620092875
    },
    {
        "content": "<p>(there may be more lurkers on this stream than you realise :-)</p>",
        "id": 237259513,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620095214
    },
    {
        "content": "<p>Here is a copy of my comment on the issue:</p>\n<blockquote>\n<p>I personally prefer option 2, but option 3 is fine as well. However, since the major problem with 2 is ugly verbs, I would suggest mixing 2 and 3. That is, I would preserve the original casing for nouns and use lower camelCase for verbs (i.e. <code>Foo_and_Bar_iff_Rig</code> instead of <code>foo_and_bar_iff_rig</code> and <code>PUnit.eq_PUnit</code> instead of <code>PUnit.eq_punit</code>). I would then have the namespace a given theorem is in dictate the meaning of verbs. That is, <code>Bool.or_true</code> means Bool <code>or</code> and root <code>Foo_and_Bar_iff_Rig</code> means Prop <code>And</code> and <code>Iff</code>.</p>\n</blockquote>\n<p>I agree with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  that namespace can help resolve some of the clashes. I, however, would also like to see casing preserved at least for nouns.</p>",
        "id": 237259651,
        "sender_full_name": "Mac",
        "timestamp": 1620095386
    },
    {
        "content": "<p>FWIW, I am biased towards more predictable and case preserving of names/types/etc, so I guess (2)?. (3) is not bad though and perhaps with namespaces adding additional clarity at times it would be quite nice.</p>\n<p>W.r.t. not liking (2), I don't think I fully understand the objections. So far I've seen</p>\n<ul>\n<li>it is not aesthetically pleasing (I guess it just doesn't bother me in what I've seen so far <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> ), and</li>\n<li>\"Option 2 ... does not abide by the rule that only values in Sort should be capitalized\" mentioned by <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> in the <a href=\"https://github.com/leanprover/lean4/issues/402#issuecomment-831715013\">GH issue</a> -- do these structures/classes in <code>Prop</code> also count as not abiding by this rule:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">intro</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">mp</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mpr</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">intro</span> <span class=\"o\">::</span> <span class=\"n\">allEq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Equivalence</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">refl</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n  <span class=\"n\">symm</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>Or am I misunderstanding the naming rule w.r.t. values in <code>Sort</code> and <code>Prop</code>?</p>",
        "id": 237347114,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1620142401
    },
    {
        "content": "<p>What part do you mean, the class/structure names?</p>",
        "id": 237347722,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620142592
    },
    {
        "content": "<p>Recall that <code>Prop == Sort 0</code> :)</p>",
        "id": 237347760,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620142614
    },
    {
        "content": "<p>Yes, the structure/class names was what I was referring to. I suppose I don't have an intuition clicking in my head yet for when the aforementioned rule that (2) violates applies in practice as I'm skimming Lean files and how option 2 relates.</p>",
        "id": 237348431,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1620142890
    },
    {
        "content": "<p>Said otherwise, the rule is that declarations that are types (not just <code>Type</code>s but also <code>Prop</code>s) should be capitalized. <code>Ne_Eq</code> is not a type.</p>",
        "id": 237348791,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620143023
    },
    {
        "content": "<p>I guess my vote is for (3) then <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 237359052,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1620146591
    },
    {
        "content": "<p>There seems to be consensus for (3). Anyone have any lingering concerns/suggestions before we merge?</p>",
        "id": 240110250,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621889540
    },
    {
        "content": "<p>I've mentioned this in private messages (and briefly above), but just to put it out there more formally and gauge interest: I'd like to propose a variant of (3) in which types that are propositions (i.e. of type <code>Prop</code> or <code>... -&gt; Prop</code>, but not necessarily types defeq to that like <code>Set A</code>) are lowercase camel-cased, including in particular <code>eq</code>, <code>or</code>, <code>and</code>, <code>true</code>, <code>false</code>.</p>\n<ul>\n<li>We can tell at a glance whether a type is a type or a prop, which is important information due to the effects of proof irrelevance. Currently mathlib indicates this inconsistently using the <code>is_</code> prefix.</li>\n<li>It avoids the issue with <code>eq</code> in theorems being capitalized differently than the type <code>Eq</code>.</li>\n<li>It doesn't differ significantly from the current Haskell-ish convention for programming uses, where all the data types are actual types and so get the uppercase camel case style. In particular <code>Nat</code>, <code>Int</code> and such are still capitalized.</li>\n<li>This does lead to a clash with <code>Bool.true</code>. Personally I'd be fine with returning to <code>Bool.tt</code> but I don't think this is a particularly important issue and would hate for the whole naming convention to get blocked for a reason like this.</li>\n</ul>\n<p>We can use this post as a <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <span aria-label=\"-1\" class=\"emoji emoji-1f44e\" role=\"img\" title=\"-1\">:-1:</span> mini-poll, where <span aria-label=\"-1\" class=\"emoji emoji-1f44e\" role=\"img\" title=\"-1\">:-1:</span> means option (3) as originally written.</p>",
        "id": 240134052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621907211
    },
    {
        "content": "<p>Based on other off-channel discussions, I think <code>tt</code>/<code>ff</code> is widely considered unacceptable for programming and a non-starter. At some point, you proposed weird names for <code>Prop</code> <code>true</code>/<code>false</code> and always using notation for them.</p>",
        "id": 240134668,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621907986
    },
    {
        "content": "<p>FWIW I don't think your first two points are that strong, since (a) you still don't know at a glance due to defeq, and (b) we will still have e.g. <code>Nat</code> referred to as <code>nat</code> in proof names. Also, this proposal would break the namespace/filename symmetry, since presumably filenames will still be capitalized but here there would be lowercase namespaces, e.g. <code>prime</code>.</p>",
        "id": 240134866,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621908182
    },
    {
        "content": "<p>If <code>Bool.tt</code> isn't acceptable, using <code>True</code> for the prop is close enough for me. We might be able to use top and bot symbols but I expect that these will be overloaded for lattices, so for core lean just <code>True</code> and <code>False</code> for the props should do.</p>\n<blockquote>\n<p>(a) you still don't know at a glance due to defeq</p>\n</blockquote>\n<p>I still don't really follow this point. Just because two types are defeq doesn't mean they act the same; in lean 3 it makes quite a difference and there are many redefinitions of <code>quot.mk</code> for particular quotient types specifically so that they have a different syntactic type. The only thing that matters is the syntactic type, and for the edge cases we can leave it as a judgment call beyond the broad strokes of the naming convention.</p>",
        "id": 240135531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621909024
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>: When using option (3) it doesn't matter that much whether <code>Eq</code> is capitalized or not, right? We don't write <code>Eq</code>, since we use the infix notation <code>=</code>. And in all theorem names <code>..._eq...</code> will not be capitalized. <br>\nSo the main differences I see will be <code>namespace Eq</code> vs <code>namespace eq</code> and if we have to refer to a full name for some reason (<code>Eq.refl</code> vs <code>eq.refl</code>).<br>\nIf those are the main changes, I don't really care that much about this distinction. Maybe some full names are more common (<code>Or.elim</code>?) though.</p>",
        "id": 240135552,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1621909072
    },
    {
        "content": "<blockquote>\n<p>(b) we will still have e.g. Nat referred to as nat in proof names.</p>\n</blockquote>\n<p>It's pretty rare for <code>Nat</code> to show up in the name of a theorem; it usually appears in the namespace of the theorem when the theorem is about a definition in the <code>Nat</code> namespace. I consider the exceptions rare enough to be acceptable.</p>\n<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Yes, the main place this shows up is in things like <code>Or.inl</code> and <code>Eq.symm</code>, although I think it will become more common as we start to get deeper into mathlib and encounter predicates and relations and prop-classes that have no notation</p>",
        "id": 240135704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621909267
    },
    {
        "content": "<p>Here is another argument in favor of <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>'s proposal: many functions returning <code>Prop</code> are decidable and used in programming in lieu of <code>Bool</code>s. Currently we have an exception in the naming conventions for these, e.g. <code>isValidChar</code>.</p>",
        "id": 240136200,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621909891
    },
    {
        "content": "<p>FWIW I don't think <code>eq.refl</code> vs <code>Eq.refl</code> matters much though, and would probably rather <code>Eq.refl</code> for uniformity (e.g. making all namespaces and filenames PascalCase)</p>",
        "id": 240136363,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621910109
    },
    {
        "content": "<p>If the type is called <code>eq</code> I think we should make the theorems <code>eq.refl</code> as well, because otherwise we will end up with inconsistency when using dot notation (unless the mechanism for dot notation is changed so that it doesn't depend on naming in this way). Note that it is already not the case that all namespaces are uppercase - internal definitions will use the name of the main definition with an additional name segment like <code>Namespace.mainDef.internalDef</code></p>",
        "id": 240136549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621910326
    },
    {
        "content": "<p>Regarding file names, I don't think we need to change anything - file/module names have never been related in any direct way to type names</p>",
        "id": 240136670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621910472
    },
    {
        "content": "<p>To clarify: I didn't mean <code>eq</code> together with <code>Eq.refl</code>, they should definitely agree.</p>",
        "id": 240136754,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621910562
    },
    {
        "content": "<p>I'm not really sure whether project names (e.g. in the repo name and/or the <code>name = ...</code> in the toml) need to be capitalized though. Personally I would like these to be lowercase and unrelated to lean module names, but I'm not sure if leanpkg wants some agreement here</p>",
        "id": 240136850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621910693
    },
    {
        "content": "<blockquote>\n<p>Note that it is already not the case that all namespaces are uppercase - internal definitions will use the name of the main definition with an additional name segment like <code>Namespace.mainDef.internalDef</code></p>\n</blockquote>\n<p>While these are namespaces in the technical sense, I think we should distinguish between these uses of namespaces for grouping vs namespaces for indicating that one definition/theorem is about the one with the parent name. The former kind of namespace is somewhat rare in mathlib but there are some like <code>category_theory</code> and these should be pascal case, and the latter kind of namespace should just follow the casing of the parent definition</p>",
        "id": 240137091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621911029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240136200\">said</a>:</p>\n<blockquote>\n<p>Here is another argument in favor of <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>'s proposal: many functions returning <code>Prop</code> are decidable and used in programming in lieu of <code>Bool</code>s. Currently we have an exception in the naming conventions for these, e.g. <code>isValidChar</code>.</p>\n</blockquote>\n<p>I think that is a pretty strong argument in favor of Mario's proposal. And this exception could be drawn much further (<code>True</code> is definitely decidable, and <code>And</code> preserves decidability). In that case it seems simplest to make all propositions <code>camelCase</code>.</p>",
        "id": 240137209,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1621911236
    },
    {
        "content": "<p>Another solution to <code>True</code>/<code>true</code> that just occurred to me: we can have a notation <code>true</code> with a type-dependent elaborator that elaborates to <code>True</code> when the target type is <code>Prop</code> and <code>Bool.true</code> or its coercion otherwise. Lean 3 already makes it fairly transparent to use <code>true</code> for <code>tt</code> or vice versa, but the coercion that sneaks in bothers me and so I try to always use the right one. A type dependent elaborator would let me use <code>true</code> always with a good conscience</p>",
        "id": 240137446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621911586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240137209\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240136200\">said</a>:</p>\n<blockquote>\n<p>Here is another argument in favor of <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>'s proposal: many functions returning <code>Prop</code> are decidable and used in programming in lieu of <code>Bool</code>s. Currently we have an exception in the naming conventions for these, e.g. <code>isValidChar</code>.</p>\n</blockquote>\n<p>I think that is a pretty strong argument in favor of Mario's proposal. And this exception could be drawn much further (<code>True</code> is definitely decidable, and <code>And</code> preserves decidability). In that case it seems simplest to make all propositions <code>camelCase</code>.</p>\n</blockquote>\n<p>Do you also agree with Mario's proposal that this should only extend to identifiers that syntactically return <code>Prop</code> and not to ones that return e.g. <code>Set</code>s? So it would be \"bad style\" to declare <code>isValidChar : Set Nat</code> and then use it as a boolean?</p>",
        "id": 240138488,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621912936
    },
    {
        "content": "<p>It's already bad style in mathlib to write <code>isValidChar x</code> if <code>isValidChar : Set Nat</code>. You would instead have <code>validChars : Set Nat</code> and <code>x \\in validChars</code> to express that. (EDIT: <code>validChars</code> should be lowercase because it's not a type)</p>",
        "id": 240139061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621913748
    },
    {
        "content": "<p>I don't know if we have a linter for that but we should</p>",
        "id": 240139113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621913791
    },
    {
        "content": "<p>Huh? I thought you were specifically proposing <code>ValidChars : Set Nat</code>, i.e. you only camelCase things that syntactically return <code>Prop</code>.</p>",
        "id": 240139244,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621913996
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> That last example has me wondering whether we need another exception to the rule to capitalize things of type <code>Set A</code> since they are \"like\" types even though they aren't, technically.</p>",
        "id": 240139296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914032
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> The rule is to capitalize things of type <code>Sort u</code> or <code>Type u</code> but not <code>Prop</code> or <code>OtherType</code>. Absent another exception that means that sets should be lowercase</p>",
        "id": 240139361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914129
    },
    {
        "content": "<p>Wasn't that exception in your proposal?</p>\n<blockquote>\n<p>I'd like to propose a variant of (3) in which types that are propositions (i.e. of type Prop or ... -&gt; Prop, but not necessarily types defeq to that like Set A) are lowercase camel-cased</p>\n</blockquote>",
        "id": 240139365,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621914141
    },
    {
        "content": "<p>I think using <code>Set A</code> in that example was not a good choice, because if we \"see though\" the abbreviation then it has type <code>A -&gt; Prop</code> so it should be lowercase, and if we don't then it has type <code>Set A</code> which is not a universe so it should also be lowercase</p>",
        "id": 240139451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914310
    },
    {
        "content": "<p>what I meant to say by that example is that the naming convention does not \"see through\" abbreviations</p>",
        "id": 240139466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914340
    },
    {
        "content": "<p>Ah, thanks for clarifying. I understand now.</p>",
        "id": 240139530,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621914439
    },
    {
        "content": "<p>Slippery slope: if we were to capitalize things of type <code>Set A</code> since they are like types, wouldn't we also want to capitalize things of type <code>Submodule R M</code>, etc, since they are just as much like types?</p>",
        "id": 240139587,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621914500
    },
    {
        "content": "<p><del>What about capitalizing things that syntactically return something capitalized besides <code>Prop</code>?</del></p>",
        "id": 240139592,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621914521
    },
    {
        "content": "<p>that would include <code>Nat.add</code></p>",
        "id": 240139603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914551
    },
    {
        "content": "<p>Re: slippery slope, we could extend the rule (whatever it is) to things with a coe to sort</p>",
        "id": 240139614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240139361\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> The rule is to capitalize things of type <code>Sort u</code> or <code>Type u</code> but not <code>Prop</code> or <code>OtherType</code>. Absent another exception that means that sets should be lowercase</p>\n</blockquote>\n<p>I don't yet see a major problem with this. We can simplify the wording as <em>only capitalize things that syntactically return <code>Sort u</code> or <code>Type u</code></em>.</p>",
        "id": 240139723,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621914727
    },
    {
        "content": "<p>I don't have a well formed opinion on sets, submodules etc. Maybe lowercase is fine</p>",
        "id": 240139726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914751
    },
    {
        "content": "<p>I think it would be <em>a priori</em> reasonable to use decidable <code>Set</code>s in programming, i.e. <code>n \\in validChars</code>.</p>",
        "id": 240139755,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621914834
    },
    {
        "content": "<p>I don't think that resolves the question though. Both capital and lowercase seem reasonable in that position</p>",
        "id": 240139802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914880
    },
    {
        "content": "<p>It would be behaving like a datastructure though (which would normally be camelCase), similar to how <code>isValidChar</code> would be behaving like a <code>Bool</code>-valued function.</p>",
        "id": 240139827,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621914935
    },
    {
        "content": "<p>One argument for the slippery slope version: if there is a coe to sort, then you can write <code>n: validChars</code> and with the lowercasing rule for props this makes <code>n</code> look like a proof of a proposition</p>",
        "id": 240139877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621914980
    },
    {
        "content": "<p>So to more formally state the slippery slope version: Only capitalize things that either syntactically return <code>Sort u</code> or <code>Type u</code>, or types that coerce to <code>Sort u</code> or <code>Type u</code>.</p>",
        "id": 240139940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621915084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240137446\">said</a>:</p>\n<blockquote>\n<p>Another solution to <code>True</code>/<code>true</code> that just occurred to me: we can have a notation <code>true</code> with a type-dependent elaborator that elaborates to <code>True</code> when the target type is <code>Prop</code> and <code>Bool.true</code> or its coercion otherwise. Lean 3 already makes it fairly transparent to use <code>true</code> for <code>tt</code> or vice versa, but the coercion that sneaks in bothers me and so I try to always use the right one. A type dependent elaborator would let me use <code>true</code> always with a good conscience</p>\n</blockquote>\n<p>What is wrong with following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">class</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"kd\">class</span> <span class=\"n\">False</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span> <span class=\"n\">False</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Bool.true</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Bool.false</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kt\">Prop</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kt\">Prop</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>(I am not sure whether Prop's should be a default instance, but the idea in general seems sound).</p>",
        "id": 240145702,
        "sender_full_name": "Mac",
        "timestamp": 1621922630
    },
    {
        "content": "<p>The issue is that we want the result to be syntactically either <code>True</code> or <code>Bool.true</code> depending on the context. Since there are coercions in both directions you can still use either one in the wrong context and get something equivalent to the right result, but it is syntactically incorrect (if you use <code>true : Prop</code> you get <code>true = true</code> and if you use <code>True : Bool</code> you get <code>decide True</code>)</p>",
        "id": 240145871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621922796
    },
    {
        "content": "<p>How does that relate to my class example?</p>",
        "id": 240145963,
        "sender_full_name": "Mac",
        "timestamp": 1621922891
    },
    {
        "content": "<p>With an instance you would end up with the wrong answer in both cases, namely <code>@True.true Prop instTrueProp</code> and <code>@True.true Bool instTrueBool</code> instead of <code>True</code> and <code>Bool.true</code> respectively</p>",
        "id": 240145991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621922938
    },
    {
        "content": "<p>Is that a problem?</p>",
        "id": 240146088,
        "sender_full_name": "Mac",
        "timestamp": 1621923016
    },
    {
        "content": "<p>They can be proved equivalent, right?</p>",
        "id": 240146099,
        "sender_full_name": "Mac",
        "timestamp": 1621923035
    },
    {
        "content": "<p>ex. <code>example : true = Prop.true := rfl</code> or <code>example : true = Bool.true := rfl</code></p>",
        "id": 240146122,
        "sender_full_name": "Mac",
        "timestamp": 1621923080
    },
    {
        "content": "<p>Furthemore, this seems to fit with the way Lean generally handles shared syntax (ex. the type classes for <code>Add</code>, <code>Mul</code>, etc.)</p>",
        "id": 240146720,
        "sender_full_name": "Mac",
        "timestamp": 1621923738
    },
    {
        "content": "<p>Yes, it causes problems for simp, rw and other tactics that look at the syntax of a term in order to decide what to do</p>",
        "id": 240146781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621923817
    },
    {
        "content": "<p>I don't think the way to solve the issue of two ways to write <code>true</code> is to make four ways to write <code>true</code></p>",
        "id": 240146831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621923858
    },
    {
        "content": "<p>Why isn't that also a sticking point for the math operators (and natural literals) then?</p>",
        "id": 240146832,
        "sender_full_name": "Mac",
        "timestamp": 1621923862
    },
    {
        "content": "<p>Sure you could make \"true\"/\"false\" custom syntax and do type-dependent elaboration as you said. But as Lean doesn't do that other syntax, but instead use type classes, it seems reasonable to use type classes here.</p>",
        "id": 240146894,
        "sender_full_name": "Mac",
        "timestamp": 1621923945
    },
    {
        "content": "<p>This is getting off topic for this thread</p>",
        "id": 240146947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621923965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240146831\">said</a>:</p>\n<blockquote>\n<p>I don't think the way to solve the issue of two ways to write <code>true</code> is to make four ways to write <code>true</code></p>\n</blockquote>\n<p>No, now there is really one way -- everything would just use the <code>true</code> from the type class. Just like everything uses the <code>hAdd</code> from <code>HAdd</code> when doing addition.</p>",
        "id": 240146957,
        "sender_full_name": "Mac",
        "timestamp": 1621923986
    },
    {
        "content": "<p>However, I am not denying there may be issues with that, it just seems reasonable to remain consistent with how this  kind of polymorphism is done elsewhere.</p>",
        "id": 240147019,
        "sender_full_name": "Mac",
        "timestamp": 1621924066
    },
    {
        "content": "<p>Any solution to this issue will be in mathlib anyway, lean core doesn't have to care</p>",
        "id": 240147066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924103
    },
    {
        "content": "<p>lean can just define <code>True</code> and <code>Bool.true</code></p>",
        "id": 240147072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924123
    },
    {
        "content": "<p><code>true</code> isn't notation (in lean core) so it doesn't make sense to have a notation typeclass for it (in lean core)</p>",
        "id": 240147095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924155
    },
    {
        "content": "<p>isn't the theorem names rfc about Lean core, though? so this will effect core.</p>",
        "id": 240147096,
        "sender_full_name": "Mac",
        "timestamp": 1621924156
    },
    {
        "content": "<p>This is not an rfc about typeclass true</p>",
        "id": 240147114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924179
    },
    {
        "content": "<p>I am simply suggesting that this would be one way to resolve the <code>true</code>/<code>True</code> and <code>false</code>/<code>False</code> problem that came up as a sticking point for option (3). This would unify them into a single <code>true</code>/<code>false</code> thus removing the clash.</p>",
        "id": 240147205,
        "sender_full_name": "Mac",
        "timestamp": 1621924243
    },
    {
        "content": "<p>your proposal is a lot more than a name change though, it needs separate discussion and this isn't the place for it</p>",
        "id": 240147257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924303
    },
    {
        "content": "<p>k, if you say so</p>",
        "id": 240147347,
        "sender_full_name": "Mac",
        "timestamp": 1621924393
    },
    {
        "content": "<p>regardless of the existence of alternate typeclasses, you would still need a name for <code>Prop.true</code> and <code>Bool.true</code>. We don't use <code>Prop</code> as a namespace elsewhere</p>",
        "id": 240147353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924403
    },
    {
        "content": "<p>current frontrunner seems to be <code>True</code> and <code>Bool.true</code></p>",
        "id": 240147373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924435
    },
    {
        "content": "<p>Personally, I do think that using <code>Prop</code> as a namespace would be a good idea and help mitigate a lot of these naming clashes.</p>",
        "id": 240147441,
        "sender_full_name": "Mac",
        "timestamp": 1621924483
    },
    {
        "content": "<p>As theorems that clash between <code>Bool</code> and <code>Prop</code> could go into their separate namespaces.</p>",
        "id": 240147461,
        "sender_full_name": "Mac",
        "timestamp": 1621924504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240147373\">said</a>:</p>\n<blockquote>\n<p>current frontrunner seems to be <code>True</code> and <code>Bool.true</code></p>\n</blockquote>\n<p>Well, yeah, because that is currently how it is set up and thus it is easiest to keep it that way.</p>",
        "id": 240147527,
        "sender_full_name": "Mac",
        "timestamp": 1621924565
    },
    {
        "content": "<p>Note that <code>true</code> and <code>Bool.true</code> aren't an option not because they clash directly, but because they clash when <code>Bool.true</code> is exported. That's why we're considering separate names like <code>true/tt</code> or <code>True/true</code>. <code>Prop.true</code>/<code>Bool.true</code> would similarly cause clashing exported names</p>",
        "id": 240147658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621924704
    },
    {
        "content": "<p>I concur largely with what you said earlier, I think that since <code>Prop</code> \"types\" follow proof irrelevance it makes sense for them to be lower camelCase like objects instead of upper camelCase like types (and this is already some followed with things like <code>isValidChar</code>).</p>",
        "id": 240147663,
        "sender_full_name": "Mac",
        "timestamp": 1621924715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240147658\">said</a>:</p>\n<blockquote>\n<p>Note that <code>true</code> and <code>Bool.true</code> aren't an option not because they clash directly, but because they clash when <code>Bool.true</code> is exported. That's why we're considering separate names like <code>true/tt</code> or <code>True/true</code>. <code>Prop.true</code>/<code>Bool.true</code> would similarly cause clashing exported names</p>\n</blockquote>\n<p>Yes but if you had something like a type class to unify them you <em>wouldn't need to export them</em>.</p>",
        "id": 240147699,
        "sender_full_name": "Mac",
        "timestamp": 1621924771
    },
    {
        "content": "<p>Just like you don't need to export <code>Nat.add</code> or <code>Int.add</code> because <code>Add</code> unifies them.</p>",
        "id": 240147723,
        "sender_full_name": "Mac",
        "timestamp": 1621924799
    },
    {
        "content": "<p>In fact, if they used namespace, you could potentially solve the syntactic problem by having <code>true : A</code> and <code>false : A</code> be elaborated to <code>A.true</code>/ <code>A.false</code> (ex. <code>Prop.true</code>/<code>Bool.true</code>).</p>",
        "id": 240147977,
        "sender_full_name": "Mac",
        "timestamp": 1621925029
    },
    {
        "content": "<p>I have to say I like the current naming convention with capitalizing propositions for teaching. Using the same naming convention really drives home the whole \"propositions are just types\", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. I'd like to hear whether <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> and <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> agree.</p>",
        "id": 240158750,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621932645
    },
    {
        "content": "<p>I agree that using <code>IsValidChar</code> in a conditional would probably look weird. On the other hand,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Char</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span>   <span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n  <span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"n\">val.isValidChar</span>\n</code></pre></div>\n<p>also looks quite weird to me, with a camelcase ident right of <code>:</code>! I haven't really made up my mind about this yet.</p>",
        "id": 240158977,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621932776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158977\">said</a>:</p>\n<blockquote>\n<p>also looks quite weird to me, with a camelcase ident right of <code>:</code>!</p>\n</blockquote>\n<p>It's also going to be lowercase if <code>Char.isValidChar : Char → Bool</code> is a Boolean.  This is only consistent.</p>",
        "id": 240159219,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621932950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158750\">said</a>:</p>\n<blockquote>\n<p>Using the same naming convention really drives home the whole \"propositions are just types\", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. I'd like to hear whether <span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> and <span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> agree.</p>\n</blockquote>\n<p>I'm not sure if students will really remember this any better if the naming convention mirrors it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <br>\nOne thing I've also noticed during the lab is that students sometimes confuse <code>False</code> with <code>false</code> and <code>True</code> with <code>true</code>. Not necessarily because they missunderstand the difference between <code>Bool</code> and <code>Prop</code>, but because they forget the exact name and write down the first thing that comes to their mind.</p>",
        "id": 240160122,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1621933464
    },
    {
        "content": "<p>Almost makes you wonder if we do need both <code>true</code> and <code>True</code> to begin with. We could have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">true.intro</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">def</span> <span class=\"n\">false.elim</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nomatch</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>and together with pretty-printing away <code>= true</code> usage would basically stay the same. For efficiency and indexing reasons we might want to instead use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bool.asProp</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">asProp</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>but that would really be an implementation detail.</p>",
        "id": 240161960,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621934725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240161960\">said</a>:</p>\n<blockquote>\n<p>Almost makes you wonder if we do need both <code>true</code> and <code>True</code> to begin with. </p>\n</blockquote>\n<p>Yeah I'd be behind that proposal. My students never use <code>Bool</code>, we could just scrap it completely.</p>",
        "id": 240162579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621935165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Or perhaps <code>Bool.AsProp</code>...</p>",
        "id": 240169958,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1621940054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240161960\">said</a>:</p>\n<blockquote>\n<p>Almost makes you wonder if we do need both <em>[<code>false</code> and <code>False</code>]</em> to begin with. </p>\n</blockquote>\n<p>For <code>False</code>, it is convenient to have dot-notation, i.e. <code>(not_lt_of_le h1 h2).elim</code> which wouldn't work out-of-the-box with a coercion from Bool.  But maybe there's a way to make dot-notation see through <code>Bool.asProp</code>.</p>",
        "id": 240170770,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621940631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> wouldn't <code>(not_lt_of_le h1 h2).asProp.elim</code> work?</p>",
        "id": 240171054,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621940815
    },
    {
        "content": "<p>No? With the proposal, <code>not_lt_of_le h1 h2</code> would have the type <code>Bool.asProp false</code> (pretty-printed as <code>false</code>).  Dot-notation would then look for a declaration called <code>Bool.asProp.elim</code>.</p>",
        "id": 240171302,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621940956
    },
    {
        "content": "<p>ah, gotcha</p>",
        "id": 240171325,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621940981
    },
    {
        "content": "<p><code>elim</code> could potentially be a type class, but I guess that's completely besides the point.</p>",
        "id": 240171457,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621941043
    },
    {
        "content": "<p>Why would it look for <code>Bool.elim</code>? This currently works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bool.asProp</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">asProp</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">Bool.asProp</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.noConfusion</span> <span class=\"n\">h</span>\n\n<span class=\"k\">#reduce</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">recOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"o\">:=</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">Empty</span>\n<span class=\"c1\">-- 0 = 1 → Bool.asProp.rec Empty (_ : Nat.noConfusionType (Bool.asProp false) 0 1)</span>\n</code></pre></div>",
        "id": 240172167,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1621941484
    },
    {
        "content": "<p>Ah sorry, it would look for <em><code>Bool.asProp.elim</code></em> of course.  But that's still not helpful for false.elim (even if you manage to reuse the recursor) , since you need to provide lots of extra arguments to the recursor.</p>",
        "id": 240172710,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621941846
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bool.asProp</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">asProp</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">Bool.asProp</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.noConfusion</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Bool.asProp.elim</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">false.asProp</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nomatch</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n</code></pre></div>",
        "id": 240173872,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1621942612
    },
    {
        "content": "<p>Calling it <code>elim</code> is a bit weird when it's not applicable to all <code>asProp</code>s. How about <code>exfalso</code>? Doesn't that make the proof script even more readable than before?</p>",
        "id": 240174413,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621942969
    },
    {
        "content": "<p>Or <code>elimFalse</code> or...</p>",
        "id": 240174481,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621943009
    },
    {
        "content": "<p><code>exfalso</code>'s actually a good name.  Although I'd still prefer dot-notation to see through the asProp.</p>",
        "id": 240174507,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621943023
    },
    {
        "content": "<p>There was some discussion about a <code>[parent]</code> attribute that could be applied to structure fields for this, but it would need to be even more general in this case...</p>",
        "id": 240174886,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621943252
    },
    {
        "content": "<p>Speaking of names: the constructor <code>Bool.asProp.true</code> should be protected or perhaps renamed <code>Bool.asProp.trivial</code>.</p>",
        "id": 240176204,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1621944018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158750\">said</a>:</p>\n<blockquote>\n<p>I have to say I like the current naming convention with capitalizing propositions for teaching. Using the same naming convention really drives home the whole \"propositions are just types\", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. </p>\n</blockquote>\n<p>For me this is a really strong argument against this naming convention. I try very hard to completely hide the whole \"propositions are just types\" crazyness to my students.</p>",
        "id": 240207269,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1621957365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240207269\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240158750\">said</a>:</p>\n<blockquote>\n<p>I have to say I like the current naming convention with capitalizing propositions for teaching. Using the same naming convention really drives home the whole \"propositions are just types\", which, yes, students are quick to forget about again even if it's the very first and central thing you tell them. </p>\n</blockquote>\n<p>For me this is a really strong argument against this naming convention. I try very hard to completely hide the whole \"propositions are just types\" crazyness to my students.</p>\n</blockquote>\n<p>One example that came up in the course was that students proved properties about the natural numbers and then had to define monoids and instantiate Nat as a monoid.<br>\nWe explained that propositions are types (in the sense that we can use the same language to work with them) and showed examples of propositions and regular structures which only contain data.<br>\nGiven that information, we expected them to figure out that you can declare the monoid rules as fields of the structure as part of the exercise.<br>\nIs that crazy, or would you instead not mention \"propositions as types\" at all and always introduce all Lean features separately, once for propositions and once for types, even if they are used in very similar ways?<br>\nEDIT: I realize this is a bit off-topic <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 240210516,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1621958510
    },
    {
        "content": "<p>I'd like to cast a vote in favor of (at least trying out) the current proposal to reserve upper case for datatypes (and types like <code>Set</code> that are thought of as mathematical data). Teaching and constructive ideology aside, propositions aren't datatypes. Conflating them is confusing, and in practice it is often useful to be able to distinguish them easily. </p>\n<p>As Patrick's remark indicates, mathematicians feel strongly about this. But it is also useful for computer scientists to distinguish between programming and verification, and to be able to tell at a glance whether they are dealing with a piece of code or a specification.</p>\n<p>I don't know the best way to mediate between Prop and Bool. Sometimes <code>x &lt; y</code> is a branching condition and sometimes it is used as a specification. But whatever we do to finesse that, I think it is helpful to be mindful of the distinction.</p>",
        "id": 240210678,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1621958565
    },
    {
        "content": "<p>P.S. I have no problem with propositions as types -- it is useful as an analogy, and explaining commonalities in Lean syntax when writing code and proving theorems. All I am saying is that it is often helpful to distinguish them as well.</p>",
        "id": 240211213,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1621958783
    },
    {
        "content": "<p>Am I right in thinking that propositions _aren't_ types in Isabelle/HOL?</p>\n<p>\"define monoids\" would be something that people in my course would find easy, because I define lots of structures very early on -- mathematics is full of structures. My students have probably never seen the <code>inductive</code> keyword though.</p>",
        "id": 240214965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621960423
    },
    {
        "content": "<blockquote>\n<p>Am I right in thinking that propositions _aren't_ types in Isabelle/HOL?</p>\n</blockquote>\n<p>That's correct. In ZFC or HOL based systems (Isabelle/HOL, HOL Light, Mizar, Metamath) propositions are in a separate class from data / objects in the domain of discourse and you can't conflate them. Only DTT based systems (Coq, Agda, Lean) have propositions as types.</p>",
        "id": 240217043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621961338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240160122\">said</a>:</p>\n<blockquote>\n<p>One thing I've also noticed during the lab is that students sometimes confuse <code>False</code> with <code>false</code> and <code>True</code> with <code>true</code>. Not necessarily because they missunderstand the difference between <code>Bool</code> and <code>Prop</code>, but because they forget the exact name and write down the first thing that comes to their mind.</p>\n</blockquote>\n<p>This is the audience I'm trying to address with the proposal for a type dependent elaborator for the notation <code>true</code>. It doesn't come with an unexpander so it will still be printed as <code>True</code> (maybe this is debatable), but it's easier to do the right thing when you can just always write <code>true</code> and lean just inserts the right one.</p>",
        "id": 240217950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621961713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240217043\">said</a>:</p>\n<blockquote>\n<p>In ZFC or HOL based systems (Isabelle/HOL, HOL Light, Mizar, Metamath) propositions are in a separate class from data / objects in the domain of discourse and you can't conflate them.</p>\n</blockquote>\n<p>Which is not entirely true.  In the HOL systems, there is only a distinction between terms and types.  The Booleans are a type, and e.g. true has the type Boolean.  Just like the natural numbers are a type, and 0 has the type natural number.  And propositions are just terms of type Boolean.  (In metamath these are indeed different categories though.)</p>",
        "id": 240218270,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621961863
    },
    {
        "content": "<p>Another category is proofs: these are completely separate in all non-DTT systems that I know of.</p>",
        "id": 240218407,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621961914
    },
    {
        "content": "<p>ah, you are right. In HOL propositions are objects in the domain of discourse, but proofs are not</p>",
        "id": 240218433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621961930
    },
    {
        "content": "<p>Actually maybe I should say that propositions are like data but they have a different type (namely <code>Boolean</code> in HOL and <code>wff</code> in metamath). This is more surprising in metamath since there are only a handful of types, but it's approximately the same distinction</p>",
        "id": 240218824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621962122
    },
    {
        "content": "<p>In my teaching using Lean students don't define define anything. They don't even state lemmas. It's all about proofs (what else?).</p>",
        "id": 240219409,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1621962375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240219409\">said</a>:</p>\n<blockquote>\n<p>In my teaching using Lean students don't define define anything. They don't even state lemmas. It's all about proofs (what else?).</p>\n</blockquote>\n<p>But that's only half the fun! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 240219558,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1621962450
    },
    {
        "content": "<p>My course is really using Lean as a tool towards learning how to write correct proofs on paper.</p>",
        "id": 240219684,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1621962506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240210678\">said</a>:</p>\n<blockquote>\n<p>But it is also useful for computer scientists to distinguish between programming and verification, and to be able to tell at a glance whether they are dealing with a piece of code or a specification.</p>\n</blockquote>\n<p>This is in fact nicely demonstrated at <code>Char</code>, where one really wants the information that the second field is erased and thus the entire structure is unboxed. So I suppose I just have to get used to it.</p>",
        "id": 240220027,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621962696
    },
    {
        "content": "<p>Summary so far:</p>\n<ul>\n<li>Their seems to be consensus for the original (3), which is independent of the capitalization scheme for types/props.</li>\n<li>There seems to be consensus to (a) capitalize definitions that syntactically return <code>Sort u</code> or <code>Type u</code> and (b) not to capitalize definitions that syntactically return <code>Prop</code>. One of the main benefits of the latter is that we are already lower-casing many of these anyway as special-cases, since decidable <code>Prop</code>s are frequently used like <code>Bool</code>s.</li>\n<li>There does not seem to be consensus yet whether to capitalize definitions that return other types, which includes both defs that are def-eq to something returning <code>Prop</code> (e.g. <code>def mySet : Set Nat</code>) and ones that are not (e.g. <code>def MapToType α := α → Type; def foo : MapToType Nat</code>). Mario proposed the \"slippery slope\" addendum: <em>also capitalize defs that return types that coerce to <code>Sort u</code> or <code>Type u</code></em>. Another obvious candidate is the \"semantic\" approach of removing the \"syntactic\" qualifier from the original proposal. Note that these two proposal have the opposite behavior on the two examples above.</li>\n<li>There are a few ways to deal with <code>true</code>, the simplest being to just capitalize the <code>Prop</code> versions. I think other variants could probably be considered separately from this issue.</li>\n</ul>",
        "id": 240345212,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1622043647
    },
    {
        "content": "<p>Downside to slippery slope proposal: the presence of a coercion isn't as binary/definitive as either the syntactic or semantic checks. Somebody could add a <code>CoeSort</code> in some other file much later, or as a local instance, etc.</p>",
        "id": 240346958,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1622044437
    },
    {
        "content": "<blockquote>\n<p>Somebody could add a CoeSort in some other file much later, or as a local instance, etc.</p>\n</blockquote>\n<p>I don't think these are very important considerations. The vast majority of the time whether something has a coe to sort or not is relatively integral to the type's expression and use. If <code>CoeSort</code> is added in a file much later, that's bad style, unless for whatever reason it is very difficult to set up the coercion in which case the whole file should be written with that in mind. If it's a local instance, then it doesn't count.</p>",
        "id": 240381716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622058913
    },
    {
        "content": "<p>Since we're talking about a naming convention here it's okay to have a solution for 90% of cases and leave the rest as judgment calls</p>",
        "id": 240381833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622058959
    },
    {
        "content": "<p>I agree this is unlikely to be an issue. I think I would still rather <code>foo : MapToType Nat</code> to be <code>Foo</code> though. How about slippery-slope + semantic, since they seem to be compatible. The rule would be <em>caps if it semantically returns <code>Sort u</code> or <code>Type u</code>, or if it coe-to-sorts to something that does</em>.</p>",
        "id": 240384717,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1622060157
    },
    {
        "content": "<p>The main issues I see with the semantic approach:</p>\n<ul>\n<li>Definitions can be arbitrarily stacked, so it can be unobvious and sometimes even surprising to discover that something, <em>ultimately</em>, boils down to a function to Type/Prop. This is well known as the \"apply bug\" in lean 3, where the <code>apply</code> tactic uses the number of pi types in the fully unfolded type of the applied lemma even though most of them are hidden to the user (and in some cases even explicitly marked as opaque using <code>@[irreducible]</code>). The purpose of definitions is to encapsulate complexity and we shouldn't be peeking behind the curtain.</li>\n<li>Besides this, it can actually just be <em>difficult</em> to determine \"at a glance\" whether a type is such a definition, which means that people will be tempted to use a lower cost approximation to the naming convention, leading to inconsistency.</li>\n<li>For abbreviations, there is a stronger argument for unfolding since the user is explicitly indicating that it should be unfolded. However that's a directive to lean, not to readers, and I would still be inclined to default to not unfolding in this case with exceptions added on a case-by-case basis.</li>\n</ul>",
        "id": 240386374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622060878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240386374\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Definitions can be arbitrarily stacked, so it can be unobvious and sometimes even surprising to discover that something, <em>ultimately</em>, boils down to a function to Type/Prop.</li>\n</ul>\n</blockquote>\n<p>Can you please clarify why this wouldn't be compositional? Why couldn't you just look at the capitalization of the syntactic return type?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo0</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo1</span> <span class=\"o\">:</span> <span class=\"n\">Foo0</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kt\">Type</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo2</span> <span class=\"o\">:</span> <span class=\"n\">Foo1</span> <span class=\"mi\">0</span>   <span class=\"o\">:=</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo3</span> <span class=\"o\">:</span> <span class=\"n\">Foo2</span>     <span class=\"o\">:=</span> <span class=\"kt\">Type</span>\n</code></pre></div>",
        "id": 240417551,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1622087006
    },
    {
        "content": "<p><code>Foo2</code> is capitalized the same as <code>Nat</code> but <code>def foo3 : Nat</code> and <code>def Foo3 : Foo2</code> have different capitalization</p>",
        "id": 240418302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622087989
    },
    {
        "content": "<p>To determine how <code>Foo3</code> needs to be capitalized you have to look at the definition (value) of <code>Foo2</code> and unfold everything there (your example is just <code>Type 1</code> so no additional unfolding is necessary)</p>",
        "id": 240418393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622088082
    },
    {
        "content": "<p>A bad case would be something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo0</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Foo0</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Foo1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo1</span>\n<span class=\"kd\">def</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo2</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>to determine that <code>Bar</code> should be capitalized you need to look at the definition of <code>Foo0</code>, <code>Foo1</code> and <code>Foo2</code>, and none of the capitalization there helps</p>",
        "id": 240418516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622088253
    },
    {
        "content": "<p>Whoops, I confused myself. Thanks for clarifying. In that case I agree with the syntax + slippery-slope proposal. I will summarize it on the GitHub issue.</p>",
        "id": 240418596,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1622088397
    },
    {
        "content": "<p>Question: If we are proposing to capitalize any identifier that is syntactically in <code>Sort u</code> or <code>Type u</code>, wouldn't it make sense for <a href=\"https://leanprover.github.io/lean4/doc/autobound.html\">auto bound implicit arguments</a> to auto bind single <strong>upper case</strong> letters as <code>Sort u</code>/<code>Type u</code> rather than single <strong>lower case</strong> letters (as having a lower case identifier syntactically in <code>Sort u</code>/<code>Type u</code> violates this style guide)?</p>",
        "id": 240446334,
        "sender_full_name": "Mac",
        "timestamp": 1622111676
    },
    {
        "content": "<p>This RFC is about naming declarations. I haven't seen any proposals for changing our parameter naming scheme, which is to always use lowercase names, mostly Greek ones for type parameters.</p>",
        "id": 240446789,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622111989
    },
    {
        "content": "<p>It's not exactly what we do in mathlib, where our style guide contains: \"α, β, γ, ... for generic types. Types with a mathematical content are expressed with the usual mathematical notation, often with an upper case letter (G for a group, R for a ring, K or 𝕜 for a field, E for a vector space, ...)\". </p>\n<p>But it's arguably a mathlib thing, so none of the concern of core.</p>",
        "id": 240447153,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1622112225
    },
    {
        "content": "<p>It just seems a little odd to me to auto bind lower case ASCII letters as <code>Type u</code>/<code>Sort u</code> when every other instance of (syntactic) <code>Type u</code>/<code>Sort u</code> is going to be upper case (or a greek letter / unicode identifier).</p>",
        "id": 240447235,
        "sender_full_name": "Mac",
        "timestamp": 1622112262
    },
    {
        "content": "<p>It feels inconsistent and symmetry breaking.</p>",
        "id": 240447281,
        "sender_full_name": "Mac",
        "timestamp": 1622112300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240447153\">said</a>:</p>\n<blockquote>\n<p>But it's arguably a mathlib thing, so none of the concern of core.</p>\n</blockquote>\n<p>It is, insofar as <code>isValidAutoBoundImplicitName</code> cannot be overriden and rejects <code>K</code> as a valid name.</p>",
        "id": 240447626,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1622112507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240447235\">said</a>:</p>\n<blockquote>\n<p>It just seems a little odd to me to auto bind lower case ASCII letters as <code>Type u</code>/<code>Sort u</code> when every other instance of (syntactic) <code>Type u</code>/<code>Sort u</code> is going to be upper case (or a greek letter / unicode identifier).</p>\n</blockquote>\n<p>FWIW Haskell / ML also have this split: Type parameters are lowercase letters but types and type constructors are uppercase camel-case, as in <a href=\"https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Sequence.html\"><code>Seq a</code></a> or <a href=\"https://ocaml.org/api/Seq.html\"><code>'a Seq.t</code></a></p>",
        "id": 240542438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622156453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240542438\">said</a>:</p>\n<blockquote>\n<p>FWIW Haskell / ML also have this split: Type parameters are lowercase letters but types and type constructors are uppercase camel-case, as in <a href=\"https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Sequence.html\"><code>Seq a</code></a> or <a href=\"https://ocaml.org/api/Seq.html\"><code>'a Seq.t</code></a></p>\n</blockquote>\n<p>Yes, but, in Haskell, there is a split between the type and term namespaces. Type and term variables cannot clash or overshadow one another, making such usage more natural. As a result, one can (and many times does) have type specifications like <code>k :: k</code> (ala <code>k : k</code> in Lean), which is not possible in a dependently typed language like Lean.</p>",
        "id": 240551032,
        "sender_full_name": "Mac",
        "timestamp": 1622164196
    },
    {
        "content": "<p>In fact, Haskell makes heavy use of this split in its <code>DataKinds</code> extension, where every term constructor <code>Foo</code> (in the term namespace) gets an automatically promoted type constructor also named <code>Foo</code> (in the type namespace).</p>",
        "id": 240551251,
        "sender_full_name": "Mac",
        "timestamp": 1622164427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/rfc.3A.20theorem.20names/near/240161960\">said</a>:</p>\n<blockquote>\n<p>For efficiency and indexing reasons we might want to instead use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bool.asProp</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">asProp</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>but that would really be an implementation detail.</p>\n</blockquote>\n<p>Is there a reason why it is not currently implemented this way? My impression is that this coercion would be easier to use than <code>= true</code>, in general.</p>",
        "id": 241511513,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1622799485
    },
    {
        "content": "<p>We have a lot of tools for dealing with equality, and this inductive type is the same as what you would get by inlining the definition of <code>Eq true</code> as an inductive type, so I'm not sure there is much to be gained except maybe some visual brevity (which we can also address by using unexpanders)</p>",
        "id": 241513631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622800694
    },
    {
        "content": "<p>in particular, the main ways to interact with this would be to prove it when it's true via <code>⟨⟩</code> and eliminate it when it's false via <code>nomatch h</code> and that would work with either representation (and Eq also has another compact spelling for the first case, <code>rfl</code>)</p>",
        "id": 241513853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622800825
    }
]
[
    {
        "content": "<p>I'm trying to write a thin wrapper around <code>aesop</code>, that always includes a particular rule set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_aesop_rule_sets</span> <span class=\"o\">[</span><span class=\"n\">CategoryTheory</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A thin wrapper for `aesop`, which adds the `CategoryTheory` rule set. -/</span>\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">aesop_cat</span><span class=\"o\">)</span> <span class=\"s2\">\"aesop_cat\"</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Aesop.tactic_clause</span><span class=\"bp\">*</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">aesop</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"n\">CategoryTheory</span><span class=\"o\">]))</span>\n</code></pre></div>\n<p>However with <code>set_option trace.Elab.step true</code>, I can see that <code>aesop_cat</code> is expanding to <code>aesop (rule_sets [CategoryTheory✝])</code>, i.e. <code>CategoryTheory</code> is not referring to the \"real\" one.</p>\n<p>How do I refer to the one I've just declared?</p>",
        "id": 313556764,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670004054
    },
    {
        "content": "<p>That's normal.  The <code>CategoryTheory✝</code> means that it can refer to a local variable bound inside the quotation <em>in addition to</em> the global name.</p>",
        "id": 313558176,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1670004379
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Aesop</span>\n\n<span class=\"n\">declare_aesop_rule_sets</span> <span class=\"o\">[</span><span class=\"n\">ExtraRules</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A thin wrapper for `aesop`, which adds the `ExtraRules` rule set. -/</span>\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">aesop_extra</span><span class=\"o\">)</span> <span class=\"s2\">\"aesop_extra\"</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Aesop.tactic_clause</span><span class=\"bp\">*</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">aesop</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"n\">ExtraRules</span><span class=\"o\">]))</span>\n\n<span class=\"c1\">-- We turn on `funext` inside `aesop_extra`.</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">aesop</span> <span class=\"n\">safe</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"n\">ExtraRules</span><span class=\"o\">])]</span> <span class=\"n\">funext</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Check `aesop` can't do it.</span>\n  <span class=\"n\">aesop</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">safe</span> <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"n\">ExtraRules</span><span class=\"o\">])</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop_extra</span>\n  <span class=\"c1\">-- Should be solved now, but isn't.</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 313558573,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670004502
    },
    {
        "content": "<p><code>set_option hygiene false in</code> works, but I feel dirty. :-)</p>",
        "id": 313559981,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670004917
    },
    {
        "content": "<p>If <code>ExtraRules</code> is not an actual declaration name in the environment, Aesop is probably missing an <code>eraseMacroScopes</code> somewhere</p>",
        "id": 313565086,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1670006453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, pinging to see if you know where this might be.</p>",
        "id": 313568368,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670007553
    },
    {
        "content": "<p>I can <code>eraseMacroScopes</code> wherever I handle rule set names, but at least in principle it could be valid to have a hygienic rule set name (e.g. coming from a macro that defines a rule set). Alternatively, you can explicitly circumvent hygiene from within the macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">aesop_extra</span><span class=\"o\">)</span> <span class=\"s2\">\"aesop_extra\"</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Aesop.tactic_clause</span><span class=\"bp\">*</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">aesop</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">ExtraRules</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">]))</span>\n</code></pre></div>",
        "id": 313588807,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1670015036
    },
    {
        "content": "<p>The hygiene system needs to be aware of scopes to function correctly. The only global scopes it is aware of are the environment and section variables.</p>",
        "id": 313589843,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1670015447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/hygiene.20question.3F/near/313588807\">said</a>:</p>\n<blockquote>\n<p>I can <code>eraseMacroScopes</code> wherever I handle rule set names, but at least in principle it could be valid to have a hygienic rule set name (e.g. coming from a macro that defines a rule set). Alternatively, you can explicitly circumvent hygiene from within the macro:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">aesop_extra</span><span class=\"o\">)</span> <span class=\"s2\">\"aesop_extra\"</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Aesop.tactic_clause</span><span class=\"bp\">*</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">aesop</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">ExtraRules</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">]))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>(Ignore me if this has been resolved, although on newest mathlib4 the <code>hygiene false</code> still seems to be needed.)</p>\n<p>What Gabriel is saying above, I think, is that hygienic names such as <code>Foo✝</code> refer <em>both</em> to <code>Foo</code> and <code>Foo✝</code>. This is so that we can write macros like this one</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span>\n  <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which will elaborate to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span><span class=\"bp\">✝</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"bp\">✝</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>where <code>foo✝</code> will refer to the value introduced by the macro, but <code>Nat✝</code> will refer to the real <code>Nat</code>. The transformation <code>Name ↦ Name✝</code> essentially makes all inaccessible names introduced in the current macro scope accessible; but it shouldn't make global names inaccessible. Thus the burden falls on all tactic code to <code>eraseMacroScopes</code> when resolving names..</p>\n<blockquote>\n<p>at least in principle it could be valid to have a hygienic rule set name (e.g. coming from a macro that defines a rule set)</p>\n</blockquote>\n<p>..but this is a valid point. Here is an example to demonstrate the issue.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"#resolve\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">nm</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstWithInfos</span> <span class=\"n\">n</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"resolve: {nm}\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#resolveEMS\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">nm</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstWithInfos</span> <span class=\"o\">(</span><span class=\"n\">mkIdentFrom</span> <span class=\"n\">n</span> <span class=\"n\">n.getId.eraseMacroScopes</span><span class=\"o\">)</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"resolveEMS: {nm}\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#test\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n    <span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n    <span class=\"bp\">#</span><span class=\"n\">resolve</span> <span class=\"n\">bar</span>\n    <span class=\"bp\">#</span><span class=\"n\">resolveEMS</span> <span class=\"n\">bar</span><span class=\"o\">)</span>\n  <span class=\"n\">elabCommand</span> <span class=\"n\">stx</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> resolve: [bar._@.Mathlib.CategoryTheory.Category.Basic._hyg.661] -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> (from resolveEMS) unknown constant 'bar' -/</span>\n<span class=\"bp\">#</span><span class=\"n\">test</span>\n</code></pre></div>\n<p>Does this means that tactics should always try to resolve both <code>n</code> and <code>n.eraseMacroScopes</code>? I am not sure if there is a canonical way to do it. (CC <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>)</p>",
        "id": 321295910,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1673666845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/hygiene.20question.3F/near/321295910\">said</a>:</p>\n<blockquote>\n<p>What Gabriel is saying above, I think, is that hygienic names such as <code>Foo✝</code> refer <em>both</em> to <code>Foo</code> and <code>Foo✝</code></p>\n</blockquote>\n<p>Whether that is true depends on the exact scopes stored in the identifier. If <code>Foo</code> was in the global scope at the point of the syntax quotation, any identifier <code>Foo</code> inside of the quotation will get a corresponding global scope tag and can resolve to it. If <code>Foo</code> was not in the scope at the point of declaration, then any reference will not and should not refer to it, no. So a tactic should use <code>eraseMacroScopes</code> <strong>iff</strong> an identifier is not meant to be a Lean declaration reference.</p>\n<p>The capture of scopes in quoted identifiers is a non-extensible <a href=\"https://github.com/leanprover/lean4/blob/5349a089e5bb6905eaca1a09e2b587488f8e4715/src/Lean/Elab/Quotation.lean#L129-L131\">part</a> of the quotation elaborator, though we recently moved a little towards extensibility by acknowledging that <a href=\"https://github.com/leanprover/lean4/blob/5349a089e5bb6905eaca1a09e2b587488f8e4715/src/Init/Prelude.lean#L3543-L3547\">different kinds of scopes exist</a>.</p>",
        "id": 321601443,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1673863416
    },
    {
        "content": "<p>Long story short, the simplest way to ensure that rule set references are hygienic would be to make rule sets actual Lean declarations. That doesn't necessarily mean that their information must be stored in the declarations too, they could simply be stubs.</p>",
        "id": 321601703,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1673863494
    }
]
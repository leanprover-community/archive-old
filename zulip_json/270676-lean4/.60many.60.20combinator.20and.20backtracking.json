[
    {
        "content": "<p>Using the <code>many</code> (and <code>many1</code>) combinator(s), I found a behavior that I found unintuitive, it seems it won't backtrack if it's already started parsing one of the options, and fail instead. Here's an MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">foo</span>\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">bar</span>\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">foobar</span>\n<span class=\"n\">syntax</span> <span class=\"n\">num</span> <span class=\"s2\">\"f\"</span> <span class=\"o\">:</span> <span class=\"n\">foo</span>\n<span class=\"n\">syntax</span> <span class=\"n\">num</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">:</span> <span class=\"n\">bar</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[foobars|\"</span> <span class=\"n\">foo</span><span class=\"bp\">+</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[foobars|\"</span> <span class=\"n\">bar</span><span class=\"bp\">+</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[foobars|\"</span> <span class=\"n\">foo</span><span class=\"bp\">+</span> <span class=\"n\">bar</span><span class=\"bp\">+</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">foobars</span><span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"n\">f</span><span class=\"o\">]</span>  <span class=\"c1\">-- parses fine (no elaborator error)</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">foobars</span><span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">b</span> <span class=\"mi\">2</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"c1\">-- parses fine (no elaborator error)</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">foobars</span><span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"c1\">-- expected 'f'</span>\n</code></pre></div>\n<p>I would expect intuitively from the grammar that the third option would parse as well, it does fit the common description of + (as a Kleene star with one instance first). Indeed, if I transform this into a more explicit construction, it works as I'd expect it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">foos</span>\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">bars</span>\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">foobar2</span>\n<span class=\"n\">syntax</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">foos</span>\n<span class=\"n\">syntax</span> <span class=\"n\">foo</span> <span class=\"n\">foos</span> <span class=\"o\">:</span> <span class=\"n\">foos</span>\n<span class=\"n\">syntax</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">bars</span>\n<span class=\"n\">syntax</span> <span class=\"n\">bar</span> <span class=\"n\">bars</span> <span class=\"o\">:</span> <span class=\"n\">bars</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[foobars2|\"</span> <span class=\"n\">foos</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[foobars2|\"</span> <span class=\"n\">bars</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[foobars2|\"</span> <span class=\"n\">foos</span> <span class=\"n\">bars</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">foobars2</span><span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">foobars2</span><span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">b</span> <span class=\"mi\">2</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">foobars2</span><span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"c1\">-- now it works</span>\n</code></pre></div>\n<p>Is this a bug or a feature <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> ?</p>",
        "id": 309477764,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1668359002
    },
    {
        "content": "<p>Backtracking at this point looks like a great way to drive parser performance into the ground :) . The only time the Lean parser backtracks is between overlapping parsers in the same syntax category.</p>",
        "id": 309482990,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1668362121
    },
    {
        "content": "<p>The shorter answer is that <code>&lt;|&gt;</code>, <code>many</code> etc. behave (mostly) like in Parsec</p>",
        "id": 309483133,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1668362180
    }
]
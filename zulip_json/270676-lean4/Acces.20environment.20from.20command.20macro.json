[
    {
        "content": "<p>If I want to write a user command using <code>macro</code>, is it possible to access the current environment (at macro execution time, not macro writing time)?</p>",
        "id": 292137283,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659696854
    },
    {
        "content": "<p>No, that's the point where you should switch to <code>elab</code></p>",
        "id": 292137613,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1659697114
    },
    {
        "content": "<p>Is there a nice example of doing that?</p>",
        "id": 292138000,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659697376
    },
    {
        "content": "<p><code>#find</code> perhaps? <a href=\"https://github.com/leanprover-community/mathlib4/blob/876d9cc42ccbfea023752e40e6edb7279d9c6b5a/Mathlib/Tactic/Find.lean#L67\">https://github.com/leanprover-community/mathlib4/blob/876d9cc42ccbfea023752e40e6edb7279d9c6b5a/Mathlib/Tactic/Find.lean#L67</a><br>\nThere's a <em>lot</em> of other stuff about matching types happening there of course</p>",
        "id": 292138730,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1659697831
    },
    {
        "content": "<p>Depending on what information you need, you probably don't need the <code>liftTermElabM</code></p>",
        "id": 292138805,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1659697896
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 292138969,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659697978
    },
    {
        "content": "<p>I'm still stuck because I don't know how to mix macro style and elab style. Say I want my custom namespace command where part of the created name comes from the environment. I can do the easy case where that part is actually hard-coded.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">Name.str</span> <span class=\"bp\">`</span><span class=\"n\">hard_coded</span> <span class=\"o\">(</span><span class=\"s2\">\"bar\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">n.getNat</span><span class=\"o\">)))</span>\n\n<span class=\"n\">foo</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">hard_coded.bar1</span>\n</code></pre></div>\n<p>Now I would like to replace <code>hard_coded in the above macro by the value of </code>head` taken from the environment at command running time. The naive version is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">Name.str</span> <span class=\"bp\">$</span><span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"s2\">\"bar\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">n.getNat</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>which doesn't work at all. Then I tried something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"foo'\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">Environment</span> <span class=\"bp\">←</span> <span class=\"n\">liftMacroM</span> <span class=\"bp\">$</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"bp\">`</span><span class=\"n\">head</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">Name.str</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">decl.name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"bar\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">n.getNat</span><span class=\"o\">)))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failed\"</span>\n</code></pre></div>\n<p>which doesn't make any sense.</p>",
        "id": 292143808,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659700922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> What is \"head\" in this example? Is it a global definition? What does the user side code look like?</p>",
        "id": 292144350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659701243
    },
    {
        "content": "<p>it sounds like you might want to resolve <code>head</code> at elab time, in which case you would call <code>resolveName</code> or one of its friends</p>",
        "id": 292144461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659701294
    },
    {
        "content": "<p>The user code would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">head</span> <span class=\"o\">:=</span> <span class=\"s2\">\"no_hard_coded\"</span>\n<span class=\"n\">foo'</span> <span class=\"mi\">2</span>\n<span class=\"kd\">end</span> <span class=\"n\">not_hard_coded.bar2</span>\n</code></pre></div>",
        "id": 292145262,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659701776
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.TermUnsafe</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">[(</span><span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)]</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalName</span> <span class=\"bp\">`</span><span class=\"n\">head</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"head not found or overloaded\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">head</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe</span> <span class=\"n\">evalConstCheck</span> <span class=\"n\">Name</span> <span class=\"bp\">``</span><span class=\"n\">Name</span> <span class=\"n\">head</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">Name.str</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"s2\">\"bar\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">n.getNat</span><span class=\"o\">))))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">not_hard_coded</span>\n\n<span class=\"n\">foo</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"kd\">end</span> <span class=\"n\">not_hard_coded.bar1</span>\n</code></pre></div>",
        "id": 292145620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659701968
    },
    {
        "content": "<p><code>resolveGlobalName</code> is not the most convenient function to call, there should be a better one somewhere</p>",
        "id": 292145713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659702012
    },
    {
        "content": "<p>Thanks! What needs mathlib here?</p>",
        "id": 292145823,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659702073
    },
    {
        "content": "<p>The <code>unsafe</code> term macro</p>",
        "id": 292145864,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1659702104
    },
    {
        "content": "<p>I just fixed it</p>",
        "id": 292145873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659702112
    },
    {
        "content": "<p>I want to PR that to core, it comes up all the time</p>",
        "id": 292145927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659702125
    },
    {
        "content": "<p>I was also missing <code>elabCommand</code>. I searched for it but couldn't find it.</p>",
        "id": 292146213,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659702268
    },
    {
        "content": "<p>as you can see, using <code>elabCommand</code> makes it easy to turn a macro into an elab</p>",
        "id": 292146466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659702395
    },
    {
        "content": "<p>same thing for <code>elabTactic</code> or <code>elabTerm</code></p>",
        "id": 292146501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659702420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> You should probably be using <code>withMacroExpansion</code> in your example to make sure the macro stack is setup properly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">[(</span><span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)]</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalName</span> <span class=\"bp\">`</span><span class=\"n\">head</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"head not found or overloaded\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">head</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe</span> <span class=\"n\">evalConstCheck</span> <span class=\"n\">Name</span> <span class=\"bp\">``</span><span class=\"n\">Name</span> <span class=\"n\">head</span>\n  <span class=\"k\">let</span> <span class=\"n\">cmd</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">Name.str</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"s2\">\"bar\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">n.getNat</span><span class=\"o\">)))</span>\n  <span class=\"n\">withMacroExpansion</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span> <span class=\"n\">cmd</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">elabCommand</span> <span class=\"n\">cmd</span>\n</code></pre></div>",
        "id": 292187583,
        "sender_full_name": "Mac",
        "timestamp": 1659722111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292145927\">said</a>:</p>\n<blockquote>\n<p>I want to PR that to core, it comes up all the time</p>\n</blockquote>\n<p>I think the major problem is that <code>evalConst</code> does not do the usual <code>unsafe</code>/<code>implementedBy</code> split done by most other unsafe code. It unsafety being hidden behind an opaque is always the behavior I want in any of my use cases.</p>",
        "id": 292187871,
        "sender_full_name": "Mac",
        "timestamp": 1659722259
    },
    {
        "content": "<p>I'm not sure what you mean. <code>evalConst</code> should definitely be an <code>unsafe</code> function, it directly causes unsafety if you call it wrong</p>",
        "id": 292192486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659724735
    },
    {
        "content": "<p>A safe interface for <code>evalConst</code> would be great; I think it could be an <code>elab</code> that checks the expected type and synthesizes the expr version to ensure no discrepancy</p>",
        "id": 292192659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659724807
    },
    {
        "content": "<p>In any case, the thing that I want to PR is term-mode <code>unsafe</code> - evalConst is not specifically the motivator here, but rather the <code>unsafe</code>/<code>implementedBy</code> trick that comes up many dozens of times in the lean 4 codebase</p>",
        "id": 292192876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659724965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292192486\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what you mean. <code>evalConst</code> should definitely be an <code>unsafe</code> function, it directly causes unsafety if you call it wrong</p>\n</blockquote>\n<p>Yes, but it should be an the unsafe version should be <code>unsafeEvalConst</code> with the user <code>evalConst</code> being an standard  <code>implementedBy</code> wrapper. At least, that is always what I want when I use it.</p>",
        "id": 292194300,
        "sender_full_name": "Mac",
        "timestamp": 1659725528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292192876\">said</a>:</p>\n<blockquote>\n<p>In any case, the thing that I want to PR is term-mode <code>unsafe</code> - evalConst is not specifically the motivator here, but rather the <code>unsafe</code>/<code>implementedBy</code> trick that comes up many dozens of times in the lean 4 codebase</p>\n</blockquote>\n<p>I know, and I agree. However, I think <code>evalConst</code> is unique in that it is one of the few places the unsafety bleeds into user code in burdensome manner. Most other usages in the Lean core utilize the <code>unsafe</code>/<code>implementedBy</code> trick to make this more convenient for the end-user (and not require them write dozens of such tricks themselves).</p>",
        "id": 292194559,
        "sender_full_name": "Mac",
        "timestamp": 1659725674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292194300\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292192486\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what you mean. <code>evalConst</code> should definitely be an <code>unsafe</code> function, it directly causes unsafety if you call it wrong</p>\n</blockquote>\n<p>Yes, but it should be an the unsafe version should be <code>unsafeEvalConst</code> with the user <code>evalConst</code> being an standard  <code>implementedBy</code> wrapper. At least, that is always what I want when I use it.</p>\n</blockquote>\n<p>What I'm saying is that there can't be a safe version of <code>evalConst</code>, that would just be unsound</p>",
        "id": 292194602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659725710
    },
    {
        "content": "<p>at least, not with the signature it has</p>",
        "id": 292194726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659725773
    },
    {
        "content": "<p>the safe version, as I said, would have to be part-macro in order to ensure that the expected type actually matches the provided <code>Expr</code></p>",
        "id": 292194796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659725834
    },
    {
        "content": "<p>even <code>evalConstCheck</code> is only \"slightly less unsafe\", because it fundamentally can't check this as a regular function</p>",
        "id": 292194923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659725892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292194602\">said</a>:</p>\n<blockquote>\n<p>that would just be unsound</p>\n</blockquote>\n<p>It would not be unsound, the <code>implementedBy</code> prohibits that already, it would be memory unsafe, though. But that's fine, one naturally is assuming the value is of the expected type to do the evaluation in most use cases.</p>",
        "id": 292196284,
        "sender_full_name": "Mac",
        "timestamp": 1659726627
    },
    {
        "content": "<p>As your example demonstrate, we generally discard this potentially unsafety in use cases.</p>",
        "id": 292196519,
        "sender_full_name": "Mac",
        "timestamp": 1659726712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292196284\">said</a>:</p>\n<blockquote>\n<p>It would not be unsound, the <code>implementedBy</code> prohibits that already, it would be memory unsafe, though.</p>\n</blockquote>\n<p>Yes, that's what I mean by unsound. <code>unsafe</code> isn't just line noise, it has meaning and you shouldn't just be wrapping it with a safe wrapper unless you are preventing the memory safety issue from leaking</p>",
        "id": 292196847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659726926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292196519\">said</a>:</p>\n<blockquote>\n<p>As your example demonstrate, we generally discard this potentially unsafety in use cases.</p>\n</blockquote>\n<p>In use cases, we can confirm that the unsafety is encapsulated. In my example we can see that it is safe because I used <code>Name</code> and <code> ``Name</code> as parameters</p>",
        "id": 292196971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659727005
    },
    {
        "content": "<p>so the <code>unsafe</code> is exactly where it should be in this example</p>",
        "id": 292197058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659727054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292196971\">said</a>:</p>\n<blockquote>\n<p>In use cases, we can confirm that the unsafety is encapsulated. In my example we can see that it is safe because I used <code>Name</code> and <code> ``Name</code> as parameters</p>\n</blockquote>\n<p>Note that this is not true, (as mentioned in the documentation for <code>evalConst</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">This</span> <span class=\"n\">function</span> <span class=\"n\">is</span> <span class=\"n\">only</span> <span class=\"n\">safe</span> <span class=\"n\">to</span> <span class=\"n\">use</span> <span class=\"k\">if</span> <span class=\"n\">the</span> <span class=\"n\">type</span> <span class=\"n\">matches</span> <span class=\"n\">the</span> <span class=\"n\">declaration's</span> <span class=\"n\">type</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">environment</span>\n<span class=\"n\">and</span> <span class=\"k\">if</span> <span class=\"bp\">`</span><span class=\"n\">enableInitializersExecution</span><span class=\"bp\">`</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">used</span> <span class=\"n\">before</span> <span class=\"n\">importing</span> <span class=\"n\">any</span> <span class=\"n\">modules</span>\n</code></pre></div>\n<p>The key here is \"if the type matches the declaration's type <strong>in the [provided] environment</strong>\" . In your example, there is no fool-proof guarantee that the type <code>Name</code> in the environment (which is arbitrary environment accepted at the run time of the command) matches that of the type <code>Name</code> mentioned at the use site (which is fixed to the Name of compile time elaboration environment). For example, if this elab command was used as a pluign in a <code>prelude</code> module with a different definition for <code>Lean.Name</code>, it could cause memory unsafety. Or, if the olean was used with a different Lean version where the name definition changed (as it recently did), it could also cause memory unsafety.</p>\n<p>In summary, the safety guarantee for <code>evalConst</code> is essentially unmeetable. Every practical use of its still introduces the possibility of memory unsafety.</p>",
        "id": 292198151,
        "sender_full_name": "Mac",
        "timestamp": 1659727724
    },
    {
        "content": "<blockquote>\n<p>In your example, there is no fool-proof guarantee that the type Name in the environment (which is arbitrary environment accepted at the run time of the command) matches that of the type Name mentioned at the use site (which is fixed to the Name of compile time elaboration environment).</p>\n</blockquote>\n<p>The environment has to be an extension of the current compile time environment in order to call this function.</p>",
        "id": 292200267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659728933
    },
    {
        "content": "<p>If the oleans don't match, then you are already in UB territory. Lean provides no guarantees in this case</p>",
        "id": 292200481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292200267\">said</a>:</p>\n<blockquote>\n<p>The environment has to be an extension of the current compile time environment in order to call this function.</p>\n</blockquote>\n<p>No it does not (at least with the use of plugins). Just like one can use (and does use) builtin Lean elaborates without importing all of Lean. Furthermore, even an extension of the environment could modify the meaning of <code>Name</code> (that would be extremely hacky and probably break other things, but it is still possible).</p>",
        "id": 292200574,
        "sender_full_name": "Mac",
        "timestamp": 1659729129
    },
    {
        "content": "<blockquote>\n<p>Furthermore, even an extension of the environment could modify the meaning of Name (that would be extremely hacky and probably break other things, but it is still possible).</p>\n</blockquote>\n<p>You can't remove or change definitions in the environment, that is something the kernel itself prevents</p>",
        "id": 292200607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729161
    },
    {
        "content": "<p>As for plugins, I would call that an <code>unsafe</code> feature. You have to abide by certain rules when using plugins to avoid memory unsafety</p>",
        "id": 292200789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729304
    },
    {
        "content": "<p>you can get all sorts of link errors that way</p>",
        "id": 292200816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> The environment's constants are just stored in an <code>SMap</code>, they are perfectly modifiable (though I don't doubt that would cause major problems elsewhere).</p>",
        "id": 292200846,
        "sender_full_name": "Mac",
        "timestamp": 1659729350
    },
    {
        "content": "<p>Actually, based on <a href=\"https://github.com/leanprover/lean4/blob/deafc315c783ac8069508f72b2815f2713d06f6a/src/Lean/Data/SMap.lean#L25-L27\">this comment</a> in <code>SMap</code>, supporting deletions would not be that hard. So maybe it wouldn't break tons of things elsewhere.</p>",
        "id": 292201331,
        "sender_full_name": "Mac",
        "timestamp": 1659729634
    },
    {
        "content": "<p>the comment says that it would require changing the definition of the map to have <code>Option</code> keys</p>",
        "id": 292201370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729664
    },
    {
        "content": "<p>in other words, they aren't really being deleted, only hidden from the frontend</p>",
        "id": 292201403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> yes, to properly efficiently support them in the core. You could still overwrite the whole map to do so if you wanted.</p>",
        "id": 292201428,
        "sender_full_name": "Mac",
        "timestamp": 1659729704
    },
    {
        "content": "<p>I still wouldn't put the blame for this on <code>evalConst</code>, those are some unsafe operations you are doing</p>",
        "id": 292201519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292201403\">said</a>:</p>\n<blockquote>\n<p>in other words, they aren't really being deleted, only hidden from the frontend</p>\n</blockquote>\n<p>That second map is for local declarations, it is then compacted into the first map on a import. So, after an import, I think it would be deleted?</p>",
        "id": 292201538,
        "sender_full_name": "Mac",
        "timestamp": 1659729774
    },
    {
        "content": "<p>it's not implemented so it's difficult to speculate on what exactly it would do</p>",
        "id": 292201690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729863
    },
    {
        "content": "<p>like, you can also just add things to the environment without calling the kernel too</p>",
        "id": 292201792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729935
    },
    {
        "content": "<p>or you could override the toplevel to play tetris instead</p>",
        "id": 292201870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659729974
    },
    {
        "content": "<p>at some point you aren't really using lean anymore</p>",
        "id": 292201911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730009
    },
    {
        "content": "<p>and if you get into trouble it's on you</p>",
        "id": 292201953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292201519\">said</a>:</p>\n<blockquote>\n<p>I still wouldn't put the blame for this on <code>evalConst</code>, those are some unsafe operations you are doing</p>\n</blockquote>\n<p>Since you didn't like my reasonable (imo) example of plugins and my hacky example of an environment modifications, here is another one: running the elaborator on a external environment. For instance, if we are in the process of elaborating an external file (ala <code>runFrontend</code>) and wish to execute this elaborator (or a set of elaborators in general including this one) on some synthetic syntax related to the file (and thus in its environment) the eval would also break.</p>",
        "id": 292201964,
        "sender_full_name": "Mac",
        "timestamp": 1659730050
    },
    {
        "content": "<p>This command and many others like it do not support that use case</p>",
        "id": 292202120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730177
    },
    {
        "content": "<p>if you try to use it anyway that's on you</p>",
        "id": 292202131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730191
    },
    {
        "content": "<p><code>unsafe</code> is a way of saying \"don't come to me if your hacks don't work\"</p>",
        "id": 292202190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730209
    },
    {
        "content": "<p>UB in certain use cases is generally what \"unsafe\" means.</p>",
        "id": 292202192,
        "sender_full_name": "Mac",
        "timestamp": 1659730210
    },
    {
        "content": "<p><code>importModules</code> is <code>unsafe</code> for this reason</p>",
        "id": 292202194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730229
    },
    {
        "content": "<p><code>importModules</code> is not <code>unsafe</code>?</p>",
        "id": 292202234,
        "sender_full_name": "Mac",
        "timestamp": 1659730269
    },
    {
        "content": "<p><code>withImportModules</code></p>",
        "id": 292202248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730281
    },
    {
        "content": "<p>which is not generally used directly when augmenting the frontend?</p>",
        "id": 292202273,
        "sender_full_name": "Mac",
        "timestamp": 1659730304
    },
    {
        "content": "<p>lean isn't very bulletproof esp. if you try writing your own prelude</p>",
        "id": 292202473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730437
    },
    {
        "content": "<p>time being finite and all that</p>",
        "id": 292202524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730454
    },
    {
        "content": "<p>but the notion of what is <code>unsafe</code> or not for the purpose of \"blame assignment\" is fairly well trodden in e.g. rust, and lean is trying to follow the same patterns</p>",
        "id": 292202614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659730513
    },
    {
        "content": "<p>Regardless, my general point, is that by bypassing the unsafe in your example, what the user is stating that they don't care about the edge cases where the behavior may still be unsafe, not that they have reasonably verified that any such case is now impossible. Which is fine, but is an important distinction in guarentees.</p>",
        "id": 292202724,
        "sender_full_name": "Mac",
        "timestamp": 1659730577
    },
    {
        "content": "<p>In that vein, I am not sure what the <code>unsafe</code> adds in that code, it is essentially silently introducing an equivalent to the common <code>unsafe</code>/<code>implementedBy</code> trick for every use case of the <code>evalConst*</code> without preforming additional verification to ensure it is less unsafe. I don't understand how that would be more useful than just do that trick at the definition of <code>evalConst</code> (or <code>evalConstCheck</code>) since that is generally always the way it will be used.</p>\n<p>That isn't to say I think the term level <code>unsafe</code> is useless in general (it is a great idea that removes a lot of burdensome boilerplate). I just think the <code>evalConst</code> is one place where the unsafe should be hidden away and mentioned in the docstring, as it will be just be hidden away at all its use sites otherwise.</p>",
        "id": 292203347,
        "sender_full_name": "Mac",
        "timestamp": 1659731030
    },
    {
        "content": "<p>Though, I guess that last comment is more relevant now without the term-level unsafe in the Lean core, than once it is there. Because currently hiding it away takes a lot of boilerplate. With the <code>unsafe</code> macro, it just takes one keyword (which admittedly does nicely documented to the read of the code that the function being used is introducing unsafety).</p>",
        "id": 292203600,
        "sender_full_name": "Mac",
        "timestamp": 1659731209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292203347\">said</a>:</p>\n<blockquote>\n<p>In that vein, I am not sure what the <code>unsafe</code> adds in that code, it is essentially silently introducing an equivalent to the common <code>unsafe</code>/<code>implementedBy</code> trick for every use case of the <code>evalConst*</code> without preforming additional verification to ensure it is less unsafe.</p>\n</blockquote>\n<p>This is rust-style verification: you read the code carefully and convince yourself that it is correct. The <code>unsafe</code> alerts you to the possibility that something that requires additional scrutiny is going on. Lean-style verification would have proof side conditions and for most memory safety issues in lean that's not an option because the side conditions cannot be expressed in the lean logic.</p>\n<blockquote>\n<p>I don't understand how that would be more useful than just do that trick at the definition of <code>evalConst</code> (or <code>evalConstCheck</code>) since that is generally always the way it will be used.</p>\n</blockquote>\n<p>Of course, if the trick could be done in the definition of <code>evalConst</code> it should be placed there, but the point is that it can't be because the type is generic in <code>evalConst</code> and it is not generic in the user code.</p>",
        "id": 292205670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659732465
    },
    {
        "content": "<p>Like I said, I think it <em>can</em> be done in general but you would need to use a macro to automate the matching of type to expr, or possibly a typeclass like the <code>reflect</code> typeclass that did it in lean 3</p>",
        "id": 292206142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659732716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292206142\">said</a>:</p>\n<blockquote>\n<p>Like I said, I think it <em>can</em> be done in general</p>\n</blockquote>\n<p>Assuming that you are okay disregarding cases like plugins, elaborators, and environment changes that I mentioned above. One reason I point this out is that this is the case for Lake which uses <code>evalConst</code> extensively in such a scenario (on a separately elaborated environment -- that of the configuration file).</p>",
        "id": 292208582,
        "sender_full_name": "Mac",
        "timestamp": 1659734219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292206142\">said</a>:</p>\n<blockquote>\n<p>or possibly a typeclass like the <code>reflect</code> typeclass that did it in lean 3</p>\n</blockquote>\n<p>You could use the <code>toTypeExpr</code> of the <code>ToExpr</code> class for this (I have done this is some places).</p>",
        "id": 292208645,
        "sender_full_name": "Mac",
        "timestamp": 1659734279
    },
    {
        "content": "<p>Though, for cases like this, it might be best to separate <code>toTypeExpr</code> from <code>ToExpr</code>, since there are many cases where a type of a value is reflectable even if the value is not.</p>",
        "id": 292208756,
        "sender_full_name": "Mac",
        "timestamp": 1659734330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292205670\">said</a>:</p>\n<blockquote>\n<p>Of course, if the trick could be done in the definition of <code>evalConst</code> it should be placed there, but the point is that it can't be because the type is generic in <code>evalConst</code> and it is not generic in the user code.</p>\n</blockquote>\n<p>Huh, yes it can? The following definitions compile just fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[implementedBy Lean.Environment.evalConst]</span> <span class=\"n\">opaque</span> <span class=\"n\">evalConst'</span>\n<span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opts</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Options</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Except</span> <span class=\"n\">String</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">@[implementedBy Lean.Environment.evalConstCheck]</span> <span class=\"n\">opaque</span> <span class=\"n\">evalConstCheck'</span>\n<span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">Environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opts</span> <span class=\"o\">:</span> <span class=\"n\">Options</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ExceptT</span> <span class=\"n\">String</span> <span class=\"n\">Id</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 292209307,
        "sender_full_name": "Mac",
        "timestamp": 1659734680
    },
    {
        "content": "<p>That's not made it any safer though, so taking the <code>unsafe</code> off is not correct</p>",
        "id": 292221802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659745605
    },
    {
        "content": "<p>if you can make it safer then you can take the <code>unsafe</code> off</p>",
        "id": 292221814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659745624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292208645\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292206142\">said</a>:</p>\n<blockquote>\n<p>or possibly a typeclass like the <code>reflect</code> typeclass that did it in lean 3</p>\n</blockquote>\n<p>You could use the <code>toTypeExpr</code> of the <code>ToExpr</code> class for this (I have done this is some places).</p>\n</blockquote>\n<p>This is just as unsafe as calling evalConst directly, since you can safely construct any (unlawful) ToExpr instance.</p>",
        "id": 292240556,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1659772235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Acces.20environment.20from.20command.20macro/near/292208582\">said</a>:</p>\n<blockquote>\n<p>One reason I point this out is that this is the case for Lake which uses <code>evalConst</code> extensively in such a scenario (on a separately elaborated environment -- that of the configuration file).</p>\n</blockquote>\n<p>This is a interesting case though since you're probably not concerned about alternative implementations of those imports in Lake. So you could check whether the imports are resolved to the olean files you expect them to.</p>",
        "id": 292241287,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1659773384
    },
    {
        "content": "<p>For the general case I don't see a better safe solution than comparing deep hashes of the type's structure. It's the same problem as how to detect .olean structure incompatibilities.</p>",
        "id": 292241410,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1659773564
    }
]
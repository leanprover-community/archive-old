[
    {
        "content": "<p>As I understand it, <code>aesop</code> uses the <code>cases</code> rule builder to perform proofs by cases on inductive types, which can be further calibrated using the <code>patterns</code> option. Is there currently a way to perform cases on type that is not an inductive type, or will there be support for this in the future?</p>\n<p>For context, I am currently dealing with the type <code>Fin 2 × Fin 2</code>, which I would like <code>aesop</code> to learn to split into the four cases <code>(0, 0)</code>, <code>(0, 1)</code>, <code>(1, 0)</code> and <code>(1, 1)</code>.</p>",
        "id": 321370359,
        "sender_full_name": "Anand Rao",
        "timestamp": 1673708614
    },
    {
        "content": "<p>Maybe something roughly like this will work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[aesop safe forward]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">fin2_split</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"n\">x</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">\\</span><span class=\"n\">or</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">\\</span><span class=\"n\">or</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">\\</span><span class=\"n\">or</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then Aesop should split the new hyp into the four cases and substitute the equations.</p>\n<p>If this doesn't work, I may need to implement general elimination rules after all...</p>",
        "id": 321377262,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1673711715
    },
    {
        "content": "<p>Thanks a lot for the suggestion! It seems to work perfectly on the test example below. It is failing for the use case that I have in mind, but I think that is only because of my overall configuration of parameters - the error message suggests that the case splitting has already occurred and the error is elsewhere downstream. I do not need this feature crucially in my code, it is just to trim a couple of lines of case matching and delegate the entire proof to <code>aesop</code>. I think that with some experimentation I should be able to get it to work for my main code as it did for the test example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Aesop</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Prod</span>\n\n<span class=\"n\">declare_aesop_rule_sets</span> <span class=\"o\">[</span><span class=\"n\">Q</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The Klein Four group. -/</span>\n<span class=\"kd\">@[aesop safe (rule_sets [Q]</span><span class=\"o\">)]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Q</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! The elements of the Klein Four group `Q`. -/</span>\n\n<span class=\"sd\">/-- The identity element of `Q`. -/</span>\n<span class=\"kd\">@[aesop norm unfold (rule_sets [Q]</span><span class=\"o\">),</span> <span class=\"n\">match_pattern</span><span class=\"o\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"o\">(⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩)</span>\n<span class=\"sd\">/-- The first generator of `Q`. -/</span>\n<span class=\"kd\">@[aesop norm unfold (rule_sets [Q]</span><span class=\"o\">),</span> <span class=\"n\">match_pattern</span><span class=\"o\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩)</span>\n<span class=\"sd\">/-- The second generator of `Q`. -/</span>\n<span class=\"kd\">@[aesop norm unfold (rule_sets [Q]</span><span class=\"o\">),</span> <span class=\"n\">match_pattern</span><span class=\"o\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"o\">(⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩)</span>\n<span class=\"sd\">/-- The product of the generators of `Q`. -/</span>\n<span class=\"kd\">@[aesop norm unfold (rule_sets [Q]</span><span class=\"o\">),</span> <span class=\"n\">match_pattern</span><span class=\"o\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">@[aesop safe forward (rule_sets [Q]</span><span class=\"o\">)]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">split</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">e</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">c</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Q</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">+</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"n\">Q.e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"n\">Q</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 321384634,
        "sender_full_name": "Anand Rao",
        "timestamp": 1673715233
    }
]
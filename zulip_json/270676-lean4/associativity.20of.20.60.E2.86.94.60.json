[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"c1\">-- error</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">P ↔ P : Prop</span>\n<span class=\"cm\">expected command</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Because I still don't understand how to check binding power of notation I can't figure out whether <code>↔</code> is supposed to be left or right associative, but the parser doesn't seem to fancy either choice here; it consumes <code>P ↔ P</code> and then decides it's all over.</p>",
        "id": 236758486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619736144
    },
    {
        "content": "<p><code>infix:20 \" ↔ \"   =&gt; Iff</code></p>",
        "id": 236759112,
        "sender_full_name": "Julian Berman",
        "timestamp": 1619736575
    },
    {
        "content": "<p>(from <a href=\"https://github.com/leanprover/lean4/blob/292bab5a11dc05e019068a579a42eac251bf587f/src/Init/Core.lean#L45\">https://github.com/leanprover/lean4/blob/292bab5a11dc05e019068a579a42eac251bf587f/src/Init/Core.lean#L45</a> )</p>",
        "id": 236759134,
        "sender_full_name": "Julian Berman",
        "timestamp": 1619736591
    },
    {
        "content": "<p>Incidentally, <code>↔</code> is associative, although that's a classical theorem, not intuitionistic</p>",
        "id": 236759983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737072
    },
    {
        "content": "<p>It appears that lean 4 has a new command <code>infix</code> which means non-associative (in lean 3 this is a synonym for <code>infixl</code> meaning left-associative)</p>",
        "id": 236760269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737213
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- fine</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- unknown identifier `P`</span>\n</code></pre></div>\n<p>I think it's specific to <code>P</code>!</p>",
        "id": 236760394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737269
    },
    {
        "content": "<p>I can't replicate</p>",
        "id": 236760682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737416
    },
    {
        "content": "<p>I'm on today's nightly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- fails on third A</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles?!</span>\n</code></pre></div>",
        "id": 236760712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737436
    },
    {
        "content": "<p>although this yields a very surprising result for me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>",
        "id": 236760792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737474
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>buzzard@ebony:~/lean-projects/mathlib4_experiments$ lean --version\nLean <span class=\"o\">(</span>version <span class=\"m\">4</span>.0.0-nightly-2021-04-29, commit 40b17bc364dd, Release<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236760837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737510
    },
    {
        "content": "<p>just updated to that, still unchanged</p>",
        "id": 236760981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737605
    },
    {
        "content": "<p>oh wait it's different in a clean file</p>",
        "id": 236761006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737629
    },
    {
        "content": "<p>oh I see I had a variable P</p>",
        "id": 236761031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737649
    },
    {
        "content": "<p>this should work for you</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>",
        "id": 236761047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737663
    },
    {
        "content": "<p>I can replicate <code>(∀ (P : Prop), P ↔ P) ↔ P</code></p>",
        "id": 236761048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737664
    },
    {
        "content": "<p>and it makes sense why you would get unknown identifier with that parse</p>",
        "id": 236761115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737689
    },
    {
        "content": "<p>on the other hand</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>doesn't parse at all, the second <code>↔</code> seems to have ultra low precedence</p>",
        "id": 236761241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737790
    },
    {
        "content": "<p>I don't think this is non-associativity after all</p>",
        "id": 236761307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236760712\">said</a>:</p>\n<blockquote>\n<p>I'm on today's nightly.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- fails on third A</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles?!</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is because it is being parsed as <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>  showed and then the unbound lowercase latin letters are being auto bound as specified in <a href=\"https://leanprover.github.io/lean4/doc/autobound.html\">https://leanprover.github.io/lean4/doc/autobound.html</a></p>",
        "id": 236761867,
        "sender_full_name": "Mac",
        "timestamp": 1619738166
    },
    {
        "content": "<p>To quote from the page: \"When Lean processes the header of a declaration, any unbound identifier is automatically added as an implicit argument if it is a single lower case or greek letter.\"</p>",
        "id": 236761933,
        "sender_full_name": "Mac",
        "timestamp": 1619738222
    },
    {
        "content": "<p>I can confirm that <code>infix</code> is to blame:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" # \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>\n<p>changing <code>infix</code> for <code>infixl</code> or <code>infixr</code> causes the expected parse</p>",
        "id": 236761942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619738226
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> -- I had remembered the Greek letters but forgotten that it also worked with lower case</p>",
        "id": 236762119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619738330
    },
    {
        "content": "<p>Probably has to do with the fixity of the universal quantifier</p>",
        "id": 236762120,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619738331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236761942\">said</a>:</p>\n<blockquote>\n<p>I can confirm that <code>infix</code> is to blame:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" # \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>\n<p>changing <code>infix</code> for <code>infixl</code> or <code>infixr</code> causes the expected parse</p>\n</blockquote>\n<p>Recall that <code>infix:50 \" # \" =&gt; Eq</code> really means <code>notation:50 lhs:51 \" # \" rhs:51 =&gt; Eq lhs rhs</code> (<a href=\"https://leanprover.github.io/lean4/doc/syntax.html\">https://leanprover.github.io/lean4/doc/syntax.html</a>). As both sides have greater (numerical) precedence, neither side can now have <code>a # b</code> at all. So what happens is it falls down the precedence scale until reaches the universal quantifier, but then the precedence level resets inside the binder.</p>",
        "id": 236762444,
        "sender_full_name": "Mac",
        "timestamp": 1619738526
    },
    {
        "content": "<p>Though all this confusion is somewhat expected considering that <code>P ↔ Q ↔ R</code> is not a particularly well-formed statement in intuitionistic logic in the first place (using the binary biconditional). Neither associative approach, i.e. <code>P ↔ (Q ↔ R)</code> or <code>(P ↔ Q) ↔ R</code>, is generally desired. What you might want is a variadic biconditional that expands <code>P ↔ Q ↔ R</code> to <code>P ↔ Q /\\ Q ↔ R</code>, which could be done in a manner similar to the tuple notation.</p>",
        "id": 236762852,
        "sender_full_name": "Mac",
        "timestamp": 1619738846
    },
    {
        "content": "<p>Actually I think a better way to parse non-associative operators is to allow them, say, as left associative, but then throw an explicit error during macro expansion</p>",
        "id": 236763162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619739072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763162\">said</a>:</p>\n<blockquote>\n<p>Actually I think a better way to parse non-associative operators is to allow them, say, as left associative, but then throw an explicit error during macro expansion</p>\n</blockquote>\n<p>That is certainly another option. Though I personally prefer that option that gives it meaning rather than one that deprives it of any. However, I do agree that, in the absence of a variadic version, an error is generally much more preferable than a cryptic parse.</p>",
        "id": 236763560,
        "sender_full_name": "Mac",
        "timestamp": 1619739334
    },
    {
        "content": "<p>The only reason all this started was that I was porting a Lean 3 file which used <code>P \\iff P \\iff true</code></p>",
        "id": 236763569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619739342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763569\">said</a>:</p>\n<blockquote>\n<p>The only reason all this started was that I was porting a Lean 3 file which used <code>P \\iff P \\iff true</code></p>\n</blockquote>\n<p>Lol. This is why explicit parentheses are sometimes a very good thing. :)</p>",
        "id": 236763707,
        "sender_full_name": "Mac",
        "timestamp": 1619739480
    },
    {
        "content": "<p>But in lean 3 I just look up the associativity of the operator and then I know how to parse. I still haven't really understood why this isn't going on in lean 4 although I do understand what's happening now you flagged the lower case issue</p>",
        "id": 236763797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619739566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763797\">said</a>:</p>\n<blockquote>\n<p>But in lean 3 I just look up the associativity of the operator and then I know how to parse.</p>\n</blockquote>\n<p>As far as I am aware, the same thing is true in Lean 4? Look up the definition of the notation and from there you can tell the precedence (the #) and the associativity, be it left (<code>infixl</code>), right (<code>infixr</code>) or none (<code>infix</code>).</p>",
        "id": 236764516,
        "sender_full_name": "Mac",
        "timestamp": 1619740084
    },
    {
        "content": "<p>My understanding of lean 3 was that you only had two options depending on whether the binding power of the second variable was equal to the first or one less</p>",
        "id": 236764630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619740174
    },
    {
        "content": "<p>Ah, yeah, Lean 4 has expanded upon that.</p>",
        "id": 236765494,
        "sender_full_name": "Mac",
        "timestamp": 1619740764
    },
    {
        "content": "<p>The point of non-associative operators is to <em>force</em> people to write the parentheses one way or another, exactly for cases like these where it's hard to guess</p>",
        "id": 236766476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619741355
    },
    {
        "content": "<p>which is why depriving that combination of operators of meaning is exactly the point. It's certainly better than the current behavior which is way outside what anyone would reasonably guess</p>",
        "id": 236766607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619741435
    },
    {
        "content": "<p>True. I was just saying variadic operators would be nice alternative too.</p>",
        "id": 236768502,
        "sender_full_name": "Mac",
        "timestamp": 1619742843
    },
    {
        "content": "<p>Has a conscious choice been made by lean4 to not allow <code>x rel y rel z</code> (eg <code>0 ≤ i ≤ j &lt; n</code>) as a shorthand for <code>x rel y \\and y rel z</code> like python, or is that still something that might be considered in future?</p>",
        "id": 236798289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619768985
    },
    {
        "content": "<p>Or can such a feature be built easily with a macro?</p>",
        "id": 236798427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619769067
    },
    {
        "content": "<p>It is definitely not the right semantics for all operators - <code>a \\ne b \\ne c</code> is usually meant to also imply <code>a \\ne c</code>, for example. So I think we will leave such extensions to the community.</p>",
        "id": 236799132,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619769487
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" = \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 236799145,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619769492
    },
    {
        "content": "<p>Personally I get annoyed by people writing <code>a \\ne b \\ne c</code> to also imply <code>a \\ne c</code> because I can't ever understand the logic which is supposed to let me deduce this, but I agree that I've seen this convention used in the wild.</p>",
        "id": 236799435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619769649
    },
    {
        "content": "<p>I would rather have <code>a = b = c = d</code> expand to <code>tfae [a, b, c, d]</code>. In any case, my point was only for the default handling of <code>infix</code>. For specific operators it is possible to provide an alternative macro interpretation, especially if the normal one is explicitly declaiming responsibility.</p>",
        "id": 236819096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619781219
    },
    {
        "content": "<p>I think I like this idea that <code>infix</code> and <code>infixl</code> and <code>infixr</code> are three different things. Not everything has to parse, and I have had issues with students being confused when doing group theory from scratch because I state associativity as <code>(a * b) * c = a * (b * c)</code> and Lean prints it as <code>a * b * c = a * (b * c)</code>. I <em>think</em> that in Lean 3 there was no way of making the prettyprinter print the thing which all the maths books would write when explaining associativity, and now one could do this temporarily and then actively switch it off later when you're sick of it, and the students will understand better.</p>",
        "id": 236821947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619782973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236821947\">said</a>:</p>\n<blockquote>\n<p>I think I like this idea that <code>infix</code> and <code>infixl</code> and <code>infixr</code> are three different things. Not everything has to parse, and I have had issues with students being confused when doing group theory from scratch because I state associativity as <code>(a * b) * c = a * (b * c)</code> and Lean prints it as <code>a * b * c = a * (b * c)</code>. I <em>think</em> that in Lean 3 there was no way of making the prettyprinter print the thing which all the maths books would write when explaining associativity, and now one could do this temporarily and then actively switch it off later when you're sick of it, and the students will understand better.</p>\n</blockquote>\n<p>This actually precisely why I like the variadic operator approach for things like addition and multiplication. It makes <code>(a * b * c)</code> distinct from <code>(a * b) * c</code> and <code>a * (b * c)</code> so the pretty printer will keep them all separate.</p>",
        "id": 236925373,
        "sender_full_name": "Mac",
        "timestamp": 1619833352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236799435\">said</a>:</p>\n<blockquote>\n<p>Personally I get annoyed by people writing <code>a \\ne b \\ne c</code> to also imply <code>a \\ne c</code> because I can't ever understand the logic which is supposed to let me deduce this, but I agree that I've seen this convention used in the wild.</p>\n</blockquote>\n<p>Unfortunately, I am in camp <code>a \\ne b \\ne c</code> implies <code>a \\ne c</code>. To me, the variadic <code>\\ne</code> means mutual distinction, just as the variadic <code>=</code> means mutual equality.</p>",
        "id": 236925475,
        "sender_full_name": "Mac",
        "timestamp": 1619833473
    },
    {
        "content": "<p>Variadic <code>ne</code> is just weird. I don't think I've ever seen it in a paper!</p>",
        "id": 236927762,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619835563
    },
    {
        "content": "<p>I am in the camp that says <code>ne</code> is <code>infix</code> and <code>a \\ne b \\ne c</code> is ambiguous and should be avoided</p>",
        "id": 236929397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619836955
    },
    {
        "content": "<p>I might not have seen it in a paper but I've seen it on a blackboard (and winced)</p>",
        "id": 236949463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619857444
    },
    {
        "content": "<p>I mentally add an extra <code>\\ne a</code>, for my mental sanity, when I see it...</p>",
        "id": 236950580,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619858558
    },
    {
        "content": "<p><a href=\"https://xkcd.com/859/\">https://xkcd.com/859/</a></p>",
        "id": 236951525,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619859669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236950580\">said</a>:</p>\n<blockquote>\n<p>I mentally add an extra <code>\\ne a</code>, for my mental sanity, when I see it...</p>\n</blockquote>\n<p>That only works for three variables, though. With four variables you can at least still draw a graph with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo mathvariant=\"normal\">≠</mo></mrow><annotation encoding=\"application/x-tex\"> \\neq </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span></span></span></span>-edges on the blackboard, with five variables, that graph isn't planar anymore ;)</p>",
        "id": 237043239,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1619950902
    },
    {
        "content": "<p>Now that's just planar silly</p>",
        "id": 237043394,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619951065
    },
    {
        "content": "<p>Just do <code>a ≠ b ≠ c ≠ a ≠ d ≠ c ≠ d ≠ b</code>...</p>",
        "id": 237044497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619952455
    },
    {
        "content": "<p>Any path through the graph covering every edge is fine!</p>",
        "id": 237044601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619952538
    },
    {
        "content": "<p>You can't do that without repeating yourself somewhere for even n &gt; 2</p>",
        "id": 237046990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619955471
    },
    {
        "content": "<p>Yeah, I meant that as a joke</p>",
        "id": 237047854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619956482
    },
    {
        "content": "<p>I tend to write <code>a \\ne b, c</code>, i feel like that's less ambiguous</p>",
        "id": 237051387,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1619960415
    },
    {
        "content": "<p>Unless <code>b \\ne c</code> is also part of it</p>",
        "id": 237051446,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1619960480
    },
    {
        "content": "<p>I've seen profs write <code>a \\ne b \\ne c</code> before and I don't like it</p>",
        "id": 237051464,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1619960508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237043239\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236950580\">said</a>:</p>\n<blockquote>\n<p>I mentally add an extra <code>\\ne a</code>, for my mental sanity, when I see it...</p>\n</blockquote>\n<p>That only works for three variables, though. With four variables you can at least still draw a graph with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo mathvariant=\"normal\">≠</mo></mrow><annotation encoding=\"application/x-tex\"> \\neq </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span></span></span></span>-edges on the blackboard, with five variables, that graph isn't planar anymore ;)</p>\n</blockquote>\n<p>This actually why I like this definition of variadic <code>≠</code>, it means that <code>a ≠ b ≠ c ≠ d ≠ e</code> is shorthand for a much longer set of <code>≠</code>s. In fact, if I remember my math right, an <code>≠</code> of arity N is equal to <code>N choose 2</code> manually written <code>≠</code>s, which is some nice space savings. :)</p>",
        "id": 237064760,
        "sender_full_name": "Mac",
        "timestamp": 1619973441
    },
    {
        "content": "<p>Probably you want <code>list.pairwise ne [a,b,c,d]</code> at that point though, or similar</p>",
        "id": 237064831,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619973506
    },
    {
        "content": "<p>Else actually constructing or dissecting the terms would be awful</p>",
        "id": 237064860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619973558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237064831\">said</a>:</p>\n<blockquote>\n<p>Probably you want <code>list.pairwise ne [a,b,c,d]</code> at that point though, or similar</p>\n</blockquote>\n<p>Well, yeah, that would be the logical expansion, yes. Just like <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  mentioned that <code>a = b = c = d</code> could be expanded to <code>tfae [a,b,c,d]</code>, <code>a ≠ b ≠ c ≠ d</code> could be expanded to <code>list.pairwise ne [a,b,c,d]</code></p>",
        "id": 237065064,
        "sender_full_name": "Mac",
        "timestamp": 1619973776
    },
    {
        "content": "<p>I think the notation itself is problematic though</p>",
        "id": 237065082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973806
    },
    {
        "content": "<p>It <em>could</em> be expanded to that, yes. I don't think it's a good idea</p>",
        "id": 237065093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973821
    },
    {
        "content": "<p>if you want pairwise ne then say so</p>",
        "id": 237065102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973838
    },
    {
        "content": "<p>When I read <code>a ≠ b ≠ c ≠ d</code> that is what I expect (pairwise ne) and that is also the way I would prefer pairwise ne to be denoted. I guess this just a place where we disagree on style.</p>",
        "id": 237065170,
        "sender_full_name": "Mac",
        "timestamp": 1619973896
    },
    {
        "content": "<p>For one thing, if it is expanded that way, then it won't be obvious that you should be looking in the <code>pairwise</code> namespace for lemmas about <code>a ≠ b ≠ c ≠ d</code></p>",
        "id": 237065183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973911
    },
    {
        "content": "<p>unless there are just two things in which case you should look at <code>ne</code></p>",
        "id": 237065211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973952
    },
    {
        "content": "<p>that kind of clever expansion seems like it would confuse more than help</p>",
        "id": 237065267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237065183\">said</a>:</p>\n<blockquote>\n<p>For one thing, if it is expanded that way, then it won't be obvious that you should be looking in the <code>pairwise</code> namespace for lemmas about <code>a ≠ b ≠ c ≠ d</code></p>\n</blockquote>\n<p>I would probably define something like <code>def mutual_distinction := list.pairwise ne</code> and have it expand to <code>mutual_distinction</code> instead (and have theorems on <code>mutual_distinction</code></p>",
        "id": 237065277,
        "sender_full_name": "Mac",
        "timestamp": 1619973994
    },
    {
        "content": "<p>sure, same difference</p>",
        "id": 237065289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974008
    },
    {
        "content": "<p>the notation doesn't say <code>mutual_distinction</code> so how will you know to look there?</p>",
        "id": 237065305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974028
    },
    {
        "content": "<p>That's what I would assume <code>a ≠ b ≠ c ≠ d</code> means</p>",
        "id": 237065341,
        "sender_full_name": "Mac",
        "timestamp": 1619974055
    },
    {
        "content": "<p>I mean the words \"mutual distinction\" appear nowhere</p>",
        "id": 237065350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974070
    },
    {
        "content": "<p>In fact I would argue that is also what <code>a ≠ b</code> means</p>",
        "id": 237065353,
        "sender_full_name": "Mac",
        "timestamp": 1619974077
    },
    {
        "content": "<p>this is a non-discoverable bit of magic syntax</p>",
        "id": 237065399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974098
    },
    {
        "content": "<p>In the same vein: how do I know that <code>≠</code> means <code>ne</code>, where is that written in the notation?</p>",
        "id": 237065422,
        "sender_full_name": "Mac",
        "timestamp": 1619974125
    },
    {
        "content": "<p>If <code>a ≠ b</code> means <code>mutual_distinction [a, b]</code>, then how do you say <code>ne a b</code>?</p>",
        "id": 237065433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974144
    },
    {
        "content": "<p><code>mutual_distinction [a, b]</code> and <code>ne [a, b]</code> are defeq in my book..</p>",
        "id": 237065448,
        "sender_full_name": "Mac",
        "timestamp": 1619974176
    },
    {
        "content": "<p><code>ne</code> is a binary operator defined as <code>a = b -&gt; false</code></p>",
        "id": 237065456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974193
    },
    {
        "content": "<p>which exists regardless of whether <code>mutual_distinction</code> exists</p>",
        "id": 237065510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974215
    },
    {
        "content": "<p>Same thing with <code>eq a b</code>, we can't have everything be n-ary</p>",
        "id": 237065549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974257
    },
    {
        "content": "<p>If you are going by the current Lean Core, yes? This is about alternative definitions (as Lean doesn't currently have a variadic <code>ne</code>)</p>",
        "id": 237065554,
        "sender_full_name": "Mac",
        "timestamp": 1619974266
    },
    {
        "content": "<p>No, I'm talking about what it could/should be</p>",
        "id": 237065571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974294
    },
    {
        "content": "<p>It would be very disruptive if <code>Eq</code> was not a binary operator</p>",
        "id": 237065584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974318
    },
    {
        "content": "<p>Well then I don't agree that <code>ne</code> should actually always be defined as <code>a = b -&gt; false</code></p>",
        "id": 237065627,
        "sender_full_name": "Mac",
        "timestamp": 1619974332
    },
    {
        "content": "<p>Okay, so when I want <code>a = b -&gt; false</code> what do I write?</p>",
        "id": 237065651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974353
    },
    {
        "content": "<p>that?</p>",
        "id": 237065666,
        "sender_full_name": "Mac",
        "timestamp": 1619974382
    },
    {
        "content": "<p>I submit that the vast majority of the time when ne is used it is binary and means that</p>",
        "id": 237065686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974402
    },
    {
        "content": "<p>adding an indirection through <code>mutual_distinction</code> would make things worse for the majority of applications</p>",
        "id": 237065699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974436
    },
    {
        "content": "<p>I disagree, there are entire logics where <code>a = b -&gt; false</code> is not a valid construction (and yet ne exists)</p>",
        "id": 237065700,
        "sender_full_name": "Mac",
        "timestamp": 1619974438
    },
    {
        "content": "<p>?</p>",
        "id": 237065740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974446
    },
    {
        "content": "<p>We're talking about lean, yes?</p>",
        "id": 237065767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974466
    },
    {
        "content": "<p>Yes, and you can construct alternative logics in Lean.</p>",
        "id": 237065801,
        "sender_full_name": "Mac",
        "timestamp": 1619974510
    },
    {
        "content": "<p>If you want to make not not mean <code>p -&gt; false</code> that is considerably more disruptive</p>",
        "id": 237065802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974511
    },
    {
        "content": "<p>Yes, true, but sometimes that is desired.</p>",
        "id": 237065830,
        "sender_full_name": "Mac",
        "timestamp": 1619974553
    },
    {
        "content": "<p>Okay but in an alternative logic the notations are not my business</p>",
        "id": 237065833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974557
    },
    {
        "content": "<p>I'm talking about general mathematics a la mathlib</p>",
        "id": 237065885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974579
    },
    {
        "content": "<p>Well, in my opinion, it is just like <code>+</code>, <code>=</code> and <code>≠</code> should just be defined based on classes that are defined differently for different types</p>",
        "id": 237065907,
        "sender_full_name": "Mac",
        "timestamp": 1619974619
    },
    {
        "content": "<p><code>Eq</code> is a typeclass now? Equality is a core concept of DTT, you can't get away from it and lean isn't really set up for that</p>",
        "id": 237066004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974730
    },
    {
        "content": "<p>I would define them something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ne</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ne</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>This definition, afaik, is entirely compatible with the current definition of the two in Lean.</p>",
        "id": 237066008,
        "sender_full_name": "Mac",
        "timestamp": 1619974737
    },
    {
        "content": "<p><code>Eq</code> is heq, no?</p>",
        "id": 237066029,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619974779
    },
    {
        "content": "<p>No, <code>HEq</code> is heq</p>",
        "id": 237066037,
        "sender_full_name": "Mac",
        "timestamp": 1619974793
    },
    {
        "content": "<p>One issue with that definition is that you can't write <code>h : a = b</code> because <code>a = b</code>  isn't necessarily a type</p>",
        "id": 237066175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974885
    },
    {
        "content": "<p>The Prop instances (their current definitions) would look like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[defaultInstance low]</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}:</span> <span class=\"n\">Eq</span> <span class=\"kt\">Prop</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span><span class=\"o\">}</span>\n<span class=\"kd\">@[defaultInstance low]</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}:</span> <span class=\"n\">Ne</span> <span class=\"kt\">Prop</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">ne</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 237066195,
        "sender_full_name": "Mac",
        "timestamp": 1619974921
    },
    {
        "content": "<p>Is <code>P</code> an outparam? I think it needs to be if you don't want lots of inference issues</p>",
        "id": 237066264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974969
    },
    {
        "content": "<p>The defaulting will resolve that (afaik)</p>",
        "id": 237066300,
        "sender_full_name": "Mac",
        "timestamp": 1619974991
    },
    {
        "content": "<p>(same reason you don't get all kinds of issues with inference with Nat literals)</p>",
        "id": 237066377,
        "sender_full_name": "Mac",
        "timestamp": 1619975056
    },
    {
        "content": "<p>What is the advantage of doing this? It won't make <code>Eq</code> the inductive type go away</p>",
        "id": 237066379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975056
    },
    {
        "content": "<p>I makes Lean's core (and the notation) more general, allowing it to be used more easily in alternative use cases (such as mine).</p>",
        "id": 237066398,
        "sender_full_name": "Mac",
        "timestamp": 1619975102
    },
    {
        "content": "<p>What is your use case?</p>",
        "id": 237066424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975122
    },
    {
        "content": "<p>I am writing a metalogic in Lean 4.</p>",
        "id": 237066443,
        "sender_full_name": "Mac",
        "timestamp": 1619975158
    },
    {
        "content": "<p>Each logic thus has its own <code>Prop</code> type (and thus possibly its own definition of equality).</p>",
        "id": 237066487,
        "sender_full_name": "Mac",
        "timestamp": 1619975176
    },
    {
        "content": "<p>Okay, that's been done in lean 3 and it doesn't require eliminating <code>=</code></p>",
        "id": 237066495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975180
    },
    {
        "content": "<p>You can overload the syntax if you really want to, but I wouldn't recommend it</p>",
        "id": 237066525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975222
    },
    {
        "content": "<p>because you need that equality for metatheory reasoning</p>",
        "id": 237066541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975234
    },
    {
        "content": "<p>So what, you want to always write <code>L |- eq a b</code> instead of the cleaner <code>L |- a = b</code>?</p>",
        "id": 237066551,
        "sender_full_name": "Mac",
        "timestamp": 1619975253
    },
    {
        "content": "<p>no, I would use some other = like symbol</p>",
        "id": 237066558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975267
    },
    {
        "content": "<p>I think flypitch used <code>\\simeq</code></p>",
        "id": 237066568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975281
    },
    {
        "content": "<p>But, <em>it is</em> equality?</p>",
        "id": 237066606,
        "sender_full_name": "Mac",
        "timestamp": 1619975287
    },
    {
        "content": "<p>No it's not equality</p>",
        "id": 237066617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975294
    },
    {
        "content": "<p>it's provable equivalence in the theory</p>",
        "id": 237066622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975302
    },
    {
        "content": "<p>equality is equality of terms which is something else</p>",
        "id": 237066659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975319
    },
    {
        "content": "<p>Which is what Lean's <code>Eq</code> is: provable equivalence in Lean's theory?</p>",
        "id": 237066668,
        "sender_full_name": "Mac",
        "timestamp": 1619975333
    },
    {
        "content": "<p>Lean is the metatheory</p>",
        "id": 237066683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975349
    },
    {
        "content": "<p>your logic is the theory</p>",
        "id": 237066687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975354
    },
    {
        "content": "<p>I am aware?</p>",
        "id": 237066696,
        "sender_full_name": "Mac",
        "timestamp": 1619975382
    },
    {
        "content": "<p>You can only say that <code>Eq</code> is not true equality if you can step outside lean, which only works inside tactics and such</p>",
        "id": 237066697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975383
    },
    {
        "content": "<p>if you are doing mathematics in lean then <code>Eq</code> is equality</p>",
        "id": 237066709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975402
    },
    {
        "content": "<p>Maybe you and I have different ideas of what qualifies as \"true equality\"</p>",
        "id": 237066753,
        "sender_full_name": "Mac",
        "timestamp": 1619975418
    },
    {
        "content": "<p>It depends on the metalogic we are working in</p>",
        "id": 237066774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975436
    },
    {
        "content": "<p>Honestly, I am not even sure I agree that there is a \"true equality\" (except maybe identity -- and Lean's equality is most certainly not that)</p>",
        "id": 237066783,
        "sender_full_name": "Mac",
        "timestamp": 1619975454
    },
    {
        "content": "<p>identity is just another word for equality</p>",
        "id": 237066795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975477
    },
    {
        "content": "<p>I disagree?</p>",
        "id": 237066809,
        "sender_full_name": "Mac",
        "timestamp": 1619975493
    },
    {
        "content": "<p>Lean's equality is equality in the mathematical sense, provided we are not doing lean metatheory</p>",
        "id": 237066812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975506
    },
    {
        "content": "<p>No its not? Considering that defeq and Eq are not synonymous?</p>",
        "id": 237066863,
        "sender_full_name": "Mac",
        "timestamp": 1619975528
    },
    {
        "content": "<p>if we are using lean as a metatheory for another logic then that logic has provable equivalence and lean has equality</p>",
        "id": 237066866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975529
    },
    {
        "content": "<p>defeq is a metatheoretic notion</p>",
        "id": 237066881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975538
    },
    {
        "content": "<p>But as a result Lean's <code>Eq</code> does not satisfying the axioms of logical equality over Lean programs</p>",
        "id": 237066910,
        "sender_full_name": "Mac",
        "timestamp": 1619975588
    },
    {
        "content": "<p>Huh?</p>",
        "id": 237066920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975599
    },
    {
        "content": "<p><code>Eq</code> certainly does satisfy the axioms of equality</p>",
        "id": 237066925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975622
    },
    {
        "content": "<p>because we axiomatize it to be so</p>",
        "id": 237066934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975633
    },
    {
        "content": "<p>within proofs, yes, but not within Lean as a whole.</p>",
        "id": 237066997,
        "sender_full_name": "Mac",
        "timestamp": 1619975681
    },
    {
        "content": "<p>I'm not sure what that means. In lean's logic, Eq is equality</p>",
        "id": 237067018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975705
    },
    {
        "content": "<p>A theory with logical equality should not be able (within the theory) to distinguish between two equal terms</p>",
        "id": 237067027,
        "sender_full_name": "Mac",
        "timestamp": 1619975714
    },
    {
        "content": "<p>Lean can, thus its <code>Eq</code> is not exactly true equality -- but I think you are said that when you were talking about tactics.</p>",
        "id": 237067057,
        "sender_full_name": "Mac",
        "timestamp": 1619975749
    },
    {
        "content": "<p>How can it?</p>",
        "id": 237067097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975764
    },
    {
        "content": "<p>tactics can distinguish between defeq and Eq terms?</p>",
        "id": 237067124,
        "sender_full_name": "Mac",
        "timestamp": 1619975794
    },
    {
        "content": "<p>I feel like we are going very deep on a tangent that I am not sure is that important.</p>",
        "id": 237067147,
        "sender_full_name": "Mac",
        "timestamp": 1619975820
    },
    {
        "content": "<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>",
        "id": 237067165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067165\">said</a>:</p>\n<blockquote>\n<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>\n</blockquote>\n<p>What do you consider to be Lean? I would certainly consider tactics part of Lean.</p>",
        "id": 237067248,
        "sender_full_name": "Mac",
        "timestamp": 1619975910
    },
    {
        "content": "<p>I mean the lean logic</p>",
        "id": 237067256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975919
    },
    {
        "content": "<p>After all, you can prove things about them within Lean.</p>",
        "id": 237067259,
        "sender_full_name": "Mac",
        "timestamp": 1619975925
    },
    {
        "content": "<p>So there are two Lean logics then in your view? The Lean metalogic (used in tactics) and the Lean logic (where <code>Eq</code> is logical equality)?</p>",
        "id": 237067280,
        "sender_full_name": "Mac",
        "timestamp": 1619975953
    },
    {
        "content": "<p>Eh, things get complicated if you do that. It's true that lean's tactics are expressed in lean's logic, but there are unverified bits performing the reflection, compilation and such</p>",
        "id": 237067301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975999
    },
    {
        "content": "<p>It's certainly easiest to view them as entirely separate systems</p>",
        "id": 237067376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976037
    },
    {
        "content": "<p>Yes, but in Lean 4, all that is now writing in Lean, and can be dealt with in Lean proper.</p>",
        "id": 237067380,
        "sender_full_name": "Mac",
        "timestamp": 1619976040
    },
    {
        "content": "<p>The fact that lean 4 is implemented in lean is incidental to this discussion</p>",
        "id": 237067383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976053
    },
    {
        "content": "<p>In fact isn't one of the main long-term goals of Lean 4 to verify Lean's parser/compiler  in Lean?</p>",
        "id": 237067418,
        "sender_full_name": "Mac",
        "timestamp": 1619976079
    },
    {
        "content": "<p>The lean kernel is not implemented in lean (yet)</p>",
        "id": 237067419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976080
    },
    {
        "content": "<p>I don't know about that... I've suggested as much before but it seems that the developers have no intention of doing that themselves (although I think they would be fine with someone else doing it)</p>",
        "id": 237067500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976145
    },
    {
        "content": "<p>Certainly <code>partial</code> is one roadblock to doing that in today's lean 4</p>",
        "id": 237067526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976178
    },
    {
        "content": "<p>Well yes, but that is partly due to the limitations of well-founded recursion in current Lean 4.</p>",
        "id": 237067543,
        "sender_full_name": "Mac",
        "timestamp": 1619976208
    },
    {
        "content": "<p>Also, so is the Lean logic (in your view) that which is verified by the kernel? Though, aren't tactics verified by the kernel too? After all, it verifies proofs.</p>",
        "id": 237067552,
        "sender_full_name": "Mac",
        "timestamp": 1619976220
    },
    {
        "content": "<p>Yes, and yes (although calling tactics \"verified by the kernel\" is a bit of a stretch - they are typechecked)</p>",
        "id": 237067616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976265
    },
    {
        "content": "<p>As an analogue, perhaps it helps to consider that peano arithmetic is a logic that is capable of talking about other logics, including peano arithmetic. It can serve as its own metalogic</p>",
        "id": 237067713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976371
    },
    {
        "content": "<p>lean is doing something similar when you talk about lean tactics being objects in lean's logic</p>",
        "id": 237067725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976391
    },
    {
        "content": "<p>But it is best to keep them separate, name them PA(meta) and PA(object) if you need to</p>",
        "id": 237067743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976439
    },
    {
        "content": "<p>Perhaps \"identity\" and \"equality\" for you mean meta-<code>=</code> vs object-<code>=</code></p>",
        "id": 237067805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976497
    },
    {
        "content": "<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>",
        "id": 237067845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976592
    },
    {
        "content": "<p>\"identity\" for me means syntactic equality, but that is a fair alternative definition,</p>",
        "id": 237067866,
        "sender_full_name": "Mac",
        "timestamp": 1619976603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067845\">said</a>:</p>\n<blockquote>\n<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>\n</blockquote>\n<p>That is a fair approach. It is simply not mine.</p>",
        "id": 237067932,
        "sender_full_name": "Mac",
        "timestamp": 1619976641
    },
    {
        "content": "<p>When doing metamathematics in lean, it gets one step more complicated because we also get theory T and lean(object) is the metatheory for T</p>",
        "id": 237067959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976695
    },
    {
        "content": "<p>I treat Lean more as the basic system by which to express my notions. I actually try to avoid Lean <code>Eq</code> as it destroys syntactic equality which is what I want to try to keep as my background equality.</p>",
        "id": 237067972,
        "sender_full_name": "Mac",
        "timestamp": 1619976723
    },
    {
        "content": "<p>For example, one place where <code>Eq</code> would come up when doing metamathematics is in defining substitution, which is an operation on terms</p>",
        "id": 237068042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976769
    },
    {
        "content": "<p>you might have a theorem that says <code>(P x)[a -&gt; b] = P[a -&gt; b] x[a -&gt; b]</code> where <code>=</code> is lean's <code>=</code></p>",
        "id": 237068094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976800
    },
    {
        "content": "<p>Equality comes up in a few places when defining proof rules. For example modus ponens, <code>|- P =&gt; |- P -&gt; Q =&gt; |- Q</code>, is asserting equality between the two instances of <code>P</code></p>",
        "id": 237068230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976920
    },
    {
        "content": "<p>not equality in the theory, \"syntactic equality\", which since lean is the metatheory means <code>Eq</code></p>",
        "id": 237068250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237068250\">said</a>:</p>\n<blockquote>\n<p>not equality in the theory, \"syntactic equality\", which since lean is the metatheory means <code>Eq</code></p>\n</blockquote>\n<p>With all the macros and parsers, this is no longer entirely true.</p>",
        "id": 237068316,
        "sender_full_name": "Mac",
        "timestamp": 1619976997
    },
    {
        "content": "<p>the macros and parsers don't matter for this</p>",
        "id": 237068325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977010
    },
    {
        "content": "<p>they are all meta-lean</p>",
        "id": 237068326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977015
    },
    {
        "content": "<p>we're using lean to write the proof theory for some axiom system T here</p>",
        "id": 237068352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977043
    },
    {
        "content": "<p>meta-lean is only there to help us automate the construction of the inductive types defining provability and so on</p>",
        "id": 237068371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977081
    },
    {
        "content": "<p>Also how does \" For example modus ponens, |- P =&gt; |- P -&gt; Q =&gt; |- Q, is asserting equality between the two instances of P\" hold. Modus Ponens is not symmetric, equality is.</p>",
        "id": 237068410,
        "sender_full_name": "Mac",
        "timestamp": 1619977093
    },
    {
        "content": "<p>Modus Ponens is a rewrite/reduction rule, not an equivalence rule.</p>",
        "id": 237068438,
        "sender_full_name": "Mac",
        "timestamp": 1619977135
    },
    {
        "content": "<p>I'm saying that <code>MP(h, h2)</code> is a proof of <code>|- Q</code> provided <code>h</code> proves <code>|- P</code>, <code>h2</code> proves <code>|- P' -&gt; Q</code>, and <code>P = P'</code> where <code>=</code> is <code>@Eq term</code></p>",
        "id": 237068454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977172
    },
    {
        "content": "<p>Ah</p>",
        "id": 237068519,
        "sender_full_name": "Mac",
        "timestamp": 1619977215
    },
    {
        "content": "<p>as a rough sketch, that might look like this in lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Terms of theory T -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"sd\">/-- Provable terms in theory T -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mp</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">imp</span> <span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"n\">Q</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">P'</span> <span class=\"n\">Q</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">imp</span> <span class=\"n\">P'</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">P'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">proof.mp</span> <span class=\"n\">h</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 237068672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977391
    },
    {
        "content": "<p>That looks pretty familiar to me! XD <br>\nConsidering that I am writing  a metalogic in Lean, I have a definition very similar to this already.</p>",
        "id": 237068781,
        "sender_full_name": "Mac",
        "timestamp": 1619977510
    },
    {
        "content": "<p>The observation I want to make here is that the <code>=</code> in <code>e</code> is lean's interpretation of \"syntactic equality\"</p>",
        "id": 237068816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977550
    },
    {
        "content": "<p>if you step up a metalevel you will say \"that's not syntactic equality! <em>This</em> is syntactic equality!\" but you can keep playing that game</p>",
        "id": 237068899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977604
    },
    {
        "content": "<p>at every level there is some <code>=</code> relation that the logic thinks is equality and is valid up to the rules of the logic</p>",
        "id": 237068958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977647
    },
    {
        "content": "<p>Well then there is also just real syntactic equality? What you are describing is what I would call logical equality.</p>",
        "id": 237068961,
        "sender_full_name": "Mac",
        "timestamp": 1619977649
    },
    {
        "content": "<p>Again, one person's syntactic equality is another's logical equality</p>",
        "id": 237069067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977739
    },
    {
        "content": "<p>what meta-lean thinks is syntactic equality is just logical equality in meta-meta-lean</p>",
        "id": 237069095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977776
    },
    {
        "content": "<p>No? Syntactically equality is equality of strings \"a\" = \"a\", \"a\" ne \"b\"?</p>",
        "id": 237069102,
        "sender_full_name": "Mac",
        "timestamp": 1619977787
    },
    {
        "content": "<p>That looks exactly like the way logical equality of strings is defined</p>",
        "id": 237069160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977816
    },
    {
        "content": "<p>Yes within a logic</p>",
        "id": 237069183,
        "sender_full_name": "Mac",
        "timestamp": 1619977837
    },
    {
        "content": "<p>Syntactic equality is formal language concept, not a logical concept</p>",
        "id": 237069196,
        "sender_full_name": "Mac",
        "timestamp": 1619977860
    },
    {
        "content": "<p>At least in my view.</p>",
        "id": 237069208,
        "sender_full_name": "Mac",
        "timestamp": 1619977886
    },
    {
        "content": "<blockquote>\n<p>Syntactic equality is formal language concept</p>\n</blockquote>\n<p>Yes, that formal concept being equality, within the logic of the formalism itself</p>",
        "id": 237069225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977921
    },
    {
        "content": "<p>A logic can define an equality that does or does not mirror syntactic equality on the language, but that is different</p>",
        "id": 237069270,
        "sender_full_name": "Mac",
        "timestamp": 1619977931
    },
    {
        "content": "<p>I am curious, what is your position the philosophy of mathematics, are you a formalist or logicist (or something else)?</p>",
        "id": 237069331,
        "sender_full_name": "Mac",
        "timestamp": 1619977988
    },
    {
        "content": "<p>Formalist, of course <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 237069343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978001
    },
    {
        "content": "<p>? Well that makes me confused.</p>",
        "id": 237069367,
        "sender_full_name": "Mac",
        "timestamp": 1619978042
    },
    {
        "content": "<p>Because, afaik, formalism generally asserts that the notion of strings (and their identity) comes first before logic.</p>",
        "id": 237069424,
        "sender_full_name": "Mac",
        "timestamp": 1619978075
    },
    {
        "content": "<p>Which is my position</p>",
        "id": 237069427,
        "sender_full_name": "Mac",
        "timestamp": 1619978087
    },
    {
        "content": "<p>Whenever you look at a logical system from a meta-perspective, all the things that used to look like \"actual equality\" become \"equality in the theory\" or what you call \"logical equality\", and you gain access to another more precise \"actual equality\", which you might call \"syntactic equality\"</p>",
        "id": 237069465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978121
    },
    {
        "content": "<p>But any formal system can be meta-ified</p>",
        "id": 237069484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978142
    },
    {
        "content": "<p>My point is that there exists (imo) a notion of equality that lies outside of logic.</p>",
        "id": 237069547,
        "sender_full_name": "Mac",
        "timestamp": 1619978182
    },
    {
        "content": "<p>Sure, there is some philosophical notion of equality but I would not generally admit something like \"a\" = \"a\" under that because the two a's have different positions in space</p>",
        "id": 237069573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978227
    },
    {
        "content": "<p>This notion may or may not be the concept which a given logic chooses to formalize as \"equality\"</p>",
        "id": 237069576,
        "sender_full_name": "Mac",
        "timestamp": 1619978229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069573\">said</a>:</p>\n<blockquote>\n<p>Sure, there is some philosophical notion of equality but I would not generally admit something like \"a\" = \"a\" under that because the two a's have different positions in space</p>\n</blockquote>\n<p>Which is why the abstraction of characters and strings is need, only then can the philosophical notion bet applied. Neither of these, however, requires formal logic. At least from my formalist perspective. In fact, in my view, formal logic can only defined after these notions are grasped.</p>",
        "id": 237069685,
        "sender_full_name": "Mac",
        "timestamp": 1619978332
    },
    {
        "content": "<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>",
        "id": 237069712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978377
    },
    {
        "content": "<p>Formal logics can then, of course, formalize these notions within themselves.</p>",
        "id": 237069716,
        "sender_full_name": "Mac",
        "timestamp": 1619978379
    },
    {
        "content": "<p>and since formal logic can be applied to any mathematical field, including itself, you get this meta business</p>",
        "id": 237069807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069712\">said</a>:</p>\n<blockquote>\n<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>\n</blockquote>\n<p>That strikes me more as a statement of Logicism <a href=\"https://en.wikipedia.org/wiki/Logicism\">https://en.wikipedia.org/wiki/Logicism</a> than Formalism <a href=\"https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)\">https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)</a></p>",
        "id": 237069814,
        "sender_full_name": "Mac",
        "timestamp": 1619978430
    },
    {
        "content": "<p>To quote from the page \"In the philosophy of mathematics, formalism is the view that holds that statements of mathematics and <strong>logic</strong> can be considered to be statements about the consequences of the manipulation of strings (alphanumeric sequences of symbols, usually as equations) using established manipulation rules.\" (Emphasis mine)</p>",
        "id": 237069854,
        "sender_full_name": "Mac",
        "timestamp": 1619978461
    },
    {
        "content": "<p>I don't disagree with that</p>",
        "id": 237069905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978516
    },
    {
        "content": "<p>Mathematics is a game of symbols on a page</p>",
        "id": 237069964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978548
    },
    {
        "content": "<p>or in the computer, as it were</p>",
        "id": 237069975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978560
    },
    {
        "content": "<p>As someone who considers myself a formalist more than a logicism (by these definitions) I would thus disagree with your definition of Logic.</p>",
        "id": 237069978,
        "sender_full_name": "Mac",
        "timestamp": 1619978561
    },
    {
        "content": "<p>Though I would also somewhat agree.</p>",
        "id": 237069989,
        "sender_full_name": "Mac",
        "timestamp": 1619978577
    },
    {
        "content": "<p>For me, \"Reason\" is closer to what you defined to be \"Logic\" and \"Logic\" is the manipulation of strings.</p>",
        "id": 237070054,
        "sender_full_name": "Mac",
        "timestamp": 1619978629
    },
    {
        "content": "<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>",
        "id": 237070059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978638
    },
    {
        "content": "<p>However, a fair alternative definition is \"Logic\" as you defined and \"Formal Logic\" as I have defined.</p>",
        "id": 237070115,
        "sender_full_name": "Mac",
        "timestamp": 1619978657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070059\">said</a>:</p>\n<blockquote>\n<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>\n</blockquote>\n<p>Logicism just claims that everything <em>in mathematics</em> reduces to logic (not everything in general). Do you disagree with that?</p>",
        "id": 237070175,
        "sender_full_name": "Mac",
        "timestamp": 1619978727
    },
    {
        "content": "<p>depends on what \"reduces to\" means</p>",
        "id": 237070189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978749
    },
    {
        "content": "<p>limiting to mathematics seems prudent</p>",
        "id": 237070204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070189\">said</a>:</p>\n<blockquote>\n<p>depends on what \"reduces to\" means</p>\n</blockquote>\n<p>Hence why the Wikipedia article phrases it 3 different ways: \"mathematics is an extension of logic, some or all of mathematics is reducible to logic, or some or all of mathematics may be modelled in logic\" XD</p>",
        "id": 237070277,
        "sender_full_name": "Mac",
        "timestamp": 1619978832
    },
    {
        "content": "<p>If you rephrase something enough times it's hard to disagree with</p>",
        "id": 237070395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978924
    },
    {
        "content": "<p>Lol!</p>",
        "id": 237070399,
        "sender_full_name": "Mac",
        "timestamp": 1619978940
    },
    {
        "content": "<p>I think the key thrust of my point is this: I consider that abstraction of characters and strings and their identity (which I term \"syntactic equality\" or \"identity\")  to be a more fundamental concept than \"logic\".</p>",
        "id": 237070547,
        "sender_full_name": "Mac",
        "timestamp": 1619979087
    },
    {
        "content": "<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>",
        "id": 237070604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979131
    },
    {
        "content": "<p>\"logic\"s can (and may or may not) model these concepts but they exist (and can be conceived of) without them</p>",
        "id": 237070622,
        "sender_full_name": "Mac",
        "timestamp": 1619979144
    },
    {
        "content": "<p>When viewing lean itself as a logic it is not</p>",
        "id": 237070631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070604\">said</a>:</p>\n<blockquote>\n<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>\n</blockquote>\n<p>No. In fact <code>Eq</code> to a certain extent prevents the true notion of \"syntactic equality\" from being modelled (in my view).</p>",
        "id": 237070691,
        "sender_full_name": "Mac",
        "timestamp": 1619979244
    },
    {
        "content": "<p>As syntactically distinct things such as '1 + 1' and '2' can be considered <code>Eq</code> and can be substituted with one another in proofs (prohibiting distinction)</p>",
        "id": 237070748,
        "sender_full_name": "Mac",
        "timestamp": 1619979305
    },
    {
        "content": "<p>1+1 is just a way to denote 2, says lean</p>",
        "id": 237070788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979337
    },
    {
        "content": "<p>Logical equality undermines syntactic equality.</p>",
        "id": 237070789,
        "sender_full_name": "Mac",
        "timestamp": 1619979337
    },
    {
        "content": "<p>if you want 1+1 in the logic you would use <code>term.add term.one term.one</code></p>",
        "id": 237070803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979352
    },
    {
        "content": "<p>and lean will agree that this is not <code>term.two</code></p>",
        "id": 237070847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070788\">said</a>:</p>\n<blockquote>\n<p>1+1 is just a way to denote 2, says lean</p>\n</blockquote>\n<p>Exactly! Thus Lean does not preserve syntactic equality (within itself).</p>",
        "id": 237070869,
        "sender_full_name": "Mac",
        "timestamp": 1619979393
    },
    {
        "content": "<p>but the logic will agree that <code>proof (prop.eq (term.add term.one term.one) term.two)</code></p>",
        "id": 237070883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979407
    },
    {
        "content": "<p>However, with the new metaprogramming capabilities this can be resolved by cheating in many cases.</p>",
        "id": 237070893,
        "sender_full_name": "Mac",
        "timestamp": 1619979418
    },
    {
        "content": "<p>I feel like you are missing the point of mathematics, 1+1=2 is how it's supposed to work</p>",
        "id": 237070938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979466
    },
    {
        "content": "<p>those two are the same number</p>",
        "id": 237070988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979490
    },
    {
        "content": "<p>they aren't terms, they are two ways to write the same natural number</p>",
        "id": 237071015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979515
    },
    {
        "content": "<p>That's fine, in mathematics.</p>",
        "id": 237071018,
        "sender_full_name": "Mac",
        "timestamp": 1619979519
    },
    {
        "content": "<p>yes, and lean is \"mathematics\" here</p>",
        "id": 237071025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979527
    },
    {
        "content": "<p>and theory T is \"the logic under study\"</p>",
        "id": 237071039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979542
    },
    {
        "content": "<p>No, Lean can be much more general than that.</p>",
        "id": 237071040,
        "sender_full_name": "Mac",
        "timestamp": 1619979543
    },
    {
        "content": "<p>After all, it is now a general purpose programming language.</p>",
        "id": 237071056,
        "sender_full_name": "Mac",
        "timestamp": 1619979559
    },
    {
        "content": "<p>But we're using it to do mathematics</p>",
        "id": 237071065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979578
    },
    {
        "content": "<p>My system is a metalogic and it needs to be able to represent logics where <code>1 + 1</code> is not exactly <code>2</code></p>",
        "id": 237071072,
        "sender_full_name": "Mac",
        "timestamp": 1619979588
    },
    {
        "content": "<p>They may be mathematically equal, but not equal in other ways.</p>",
        "id": 237071132,
        "sender_full_name": "Mac",
        "timestamp": 1619979616
    },
    {
        "content": "<p>That requires that you use the language of the theory under study</p>",
        "id": 237071149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979624
    },
    {
        "content": "<p>Like in general programming.</p>",
        "id": 237071150,
        "sender_full_name": "Mac",
        "timestamp": 1619979625
    },
    {
        "content": "<p>don't use <code>Nat</code> if you want that</p>",
        "id": 237071158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979630
    },
    {
        "content": "<p>Which I am not.</p>",
        "id": 237071178,
        "sender_full_name": "Mac",
        "timestamp": 1619979643
    },
    {
        "content": "<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>",
        "id": 237071221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979677
    },
    {
        "content": "<p>In computer science <code>1 + 1</code> is generally not <strong>logically</strong> equal to <code>2</code> (as one is a computation and one is a constant)</p>",
        "id": 237071225,
        "sender_full_name": "Mac",
        "timestamp": 1619979690
    },
    {
        "content": "<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>",
        "id": 237071295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071221\">said</a>:</p>\n<blockquote>\n<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>\n</blockquote>\n<p>Yeah, and I do do something like this.</p>",
        "id": 237071299,
        "sender_full_name": "Mac",
        "timestamp": 1619979747
    },
    {
        "content": "<p>Certainly compilers seem to think that <code>1 + 1</code> is interchangeable with <code>2</code></p>",
        "id": 237071357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071295\">said</a>:</p>\n<blockquote>\n<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>\n</blockquote>\n<p>Yes, but when it comes to compiling/optimizing they are initially distinct.</p>",
        "id": 237071369,
        "sender_full_name": "Mac",
        "timestamp": 1619979829
    },
    {
        "content": "<p>they are logically equal but syntactically different, in the language from earlier</p>",
        "id": 237071427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979864
    },
    {
        "content": "<p>The point of optimization is to pick the computational representation of two logically equivalent expressions that is more efficient (faster/less space), which requires you to be able to distinguish two logically equivalent terns.</p>",
        "id": 237071456,
        "sender_full_name": "Mac",
        "timestamp": 1619979910
    },
    {
        "content": "<p>right, which works because compilers work at the meta-level with respect to the program logic</p>",
        "id": 237071502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979953
    },
    {
        "content": "<p>Correct, though, you can also do the same within a single logic by reducing the scope of equality.</p>",
        "id": 237071570,
        "sender_full_name": "Mac",
        "timestamp": 1619980001
    },
    {
        "content": "<p>i.e. by making mathematical equality not identical to logical equality.</p>",
        "id": 237071593,
        "sender_full_name": "Mac",
        "timestamp": 1619980062
    },
    {
        "content": "<p>There are issues that crop up when you use a logic as its own metalogic. I think if the object-<code>=</code> and meta-<code>=</code> coincide it would have to be a fairly trivial logic</p>",
        "id": 237071600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980081
    },
    {
        "content": "<p>I disagree. In fact, I don't think equality is all that significant of a concept in the first place (to computation). For example, Peano arithmetic can be defined without it (or with just partial equality -- symmetric and transitive with no substitution).</p>",
        "id": 237071749,
        "sender_full_name": "Mac",
        "timestamp": 1619980226
    },
    {
        "content": "<p>peano arithmetic at least lets you prove 1+1=2</p>",
        "id": 237071781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980251
    },
    {
        "content": "<p>that theorem would fail if logical equality is exactly syntactic equality</p>",
        "id": 237071796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980272
    },
    {
        "content": "<p>For some definition of equality.</p>",
        "id": 237071801,
        "sender_full_name": "Mac",
        "timestamp": 1619980277
    },
    {
        "content": "<p>for a very useful definition of equality</p>",
        "id": 237071806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980289
    },
    {
        "content": "<p>Peano equality is actually not logical equality (it does not have predicate substitution as one of its axioms).</p>",
        "id": 237071813,
        "sender_full_name": "Mac",
        "timestamp": 1619980314
    },
    {
        "content": "<p>It is only reflexive, transitive, and symmetric (and only for natural numbers).</p>",
        "id": 237071856,
        "sender_full_name": "Mac",
        "timestamp": 1619980335
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Peano_axioms\">https://en.wikipedia.org/wiki/Peano_axioms</a></p>",
        "id": 237071874,
        "sender_full_name": "Mac",
        "timestamp": 1619980349
    },
    {
        "content": "<p>It's closure property for nats is also not symmetric.</p>",
        "id": 237071880,
        "sender_full_name": "Mac",
        "timestamp": 1619980365
    },
    {
        "content": "<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>",
        "id": 237071932,
        "sender_full_name": "Mac",
        "timestamp": 1619980397
    },
    {
        "content": "<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>",
        "id": 237072001,
        "sender_full_name": "Mac",
        "timestamp": 1619980447
    },
    {
        "content": "<p>In fact, the lack of symmetry is why Peano arithmetic is so popular in computer science. Because its definitions really don't need symmetry.</p>",
        "id": 237072080,
        "sender_full_name": "Mac",
        "timestamp": 1619980555
    },
    {
        "content": "<p>They only need rewrite and joinability.</p>",
        "id": 237072128,
        "sender_full_name": "Mac",
        "timestamp": 1619980573
    },
    {
        "content": "<p>PA builds on FOL, which generally has the substitution property either built in or derivable</p>",
        "id": 237072129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980574
    },
    {
        "content": "<p><strong>Modern</strong> PA builds on FOL, <strong>original</strong> PA does not.</p>",
        "id": 237072153,
        "sender_full_name": "Mac",
        "timestamp": 1619980596
    },
    {
        "content": "<p>In fact, original PA is second-order.</p>",
        "id": 237072171,
        "sender_full_name": "Mac",
        "timestamp": 1619980627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071932\">said</a>:</p>\n<blockquote>\n<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>\n</blockquote>\n<p>This one is listed as number 5 on wiki</p>",
        "id": 237072178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980630
    },
    {
        "content": "<p>number 5 is the converse</p>",
        "id": 237072194,
        "sender_full_name": "Mac",
        "timestamp": 1619980649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237072001\">said</a>:</p>\n<blockquote>\n<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>\n</blockquote>",
        "id": 237072207,
        "sender_full_name": "Mac",
        "timestamp": 1619980675
    },
    {
        "content": "<p>equality is symmetric</p>",
        "id": 237072218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980680
    },
    {
        "content": "<p>Only for nats in PA.</p>",
        "id": 237072265,
        "sender_full_name": "Mac",
        "timestamp": 1619980698
    },
    {
        "content": "<p>number 3: \"For all <strong>natural numbers</strong> x and y, if x = y, then y = x.\"</p>",
        "id": 237072278,
        "sender_full_name": "Mac",
        "timestamp": 1619980717
    },
    {
        "content": "<p>If b is unknown you can't use symmetry.</p>",
        "id": 237072282,
        "sender_full_name": "Mac",
        "timestamp": 1619980729
    },
    {
        "content": "<p>You first have prove that both sides are natural before you can use symmetry.</p>",
        "id": 237072304,
        "sender_full_name": "Mac",
        "timestamp": 1619980756
    },
    {
        "content": "<p>That seems like a typo or oversight in the presentation</p>",
        "id": 237072319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980773
    },
    {
        "content": "<p>I wrote proofs of all these things to test my metalogic.</p>",
        "id": 237072340,
        "sender_full_name": "Mac",
        "timestamp": 1619980803
    },
    {
        "content": "<p>It works as formulated on the Wiki page.</p>",
        "id": 237072377,
        "sender_full_name": "Mac",
        "timestamp": 1619980815
    },
    {
        "content": "<p>In formal treatments of this usually \"is a natural number\" isn't even a thing</p>",
        "id": 237072386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980822
    },
    {
        "content": "<p>you just have all things be natural numbers</p>",
        "id": 237072412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980848
    },
    {
        "content": "<p>true, but some interesting prosperities emerge if you do it like written.</p>",
        "id": 237072425,
        "sender_full_name": "Mac",
        "timestamp": 1619980863
    },
    {
        "content": "<p>It also probably because PA is generally embedded in other logics rather than used on its own.</p>",
        "id": 237072491,
        "sender_full_name": "Mac",
        "timestamp": 1619980924
    },
    {
        "content": "<p>Incidentally, I have been working for a while on a formal library which is based on PA; I don't know of any larger practical formal development using PA as the basis</p>",
        "id": 237072534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980985
    },
    {
        "content": "<p>Nat in Lean (and  most other functional languages) is  a embedding of (modern) PA?</p>",
        "id": 237072564,
        "sender_full_name": "Mac",
        "timestamp": 1619981031
    },
    {
        "content": "<p>DTT is way stronger than PA</p>",
        "id": 237072605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981047
    },
    {
        "content": "<p>Yes, true</p>",
        "id": 237072619,
        "sender_full_name": "Mac",
        "timestamp": 1619981067
    },
    {
        "content": "<p>I mean a formalization of the axiom system PA and its consequences</p>",
        "id": 237072627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981093
    },
    {
        "content": "<p>yes, you can do this in lean (in principle)</p>",
        "id": 237072655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981113
    },
    {
        "content": "<p>as far as I know no one has worked out a significant amount of mathematics in that setting</p>",
        "id": 237072684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981152
    },
    {
        "content": "<p>Well, now its done in practice.:)</p>",
        "id": 237072685,
        "sender_full_name": "Mac",
        "timestamp": 1619981152
    },
    {
        "content": "<p>I mostly just did it as a test of my system. I did find a lot of (what I consider to be) interesting results though.</p>",
        "id": 237072744,
        "sender_full_name": "Mac",
        "timestamp": 1619981189
    },
    {
        "content": "<p>It's one thing to write the axioms and quite another to construct finite set theory in it, recursive functions, provability, and some CS stuff</p>",
        "id": 237072797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981248
    },
    {
        "content": "<p>Well yeah</p>",
        "id": 237072861,
        "sender_full_name": "Mac",
        "timestamp": 1619981291
    },
    {
        "content": "<p>I would like lean 4 to get to the point that writing extended formal developments in embedded languages is easy; in lean 3 it's a pretty big ergonomic step down from regular lean proofs</p>",
        "id": 237072882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981322
    },
    {
        "content": "<p>What do you mean by an \"embedded language\"?</p>",
        "id": 237072905,
        "sender_full_name": "Mac",
        "timestamp": 1619981368
    },
    {
        "content": "<p>like, <em>in principle</em> you can write tactics and things to work on the embedded language but for the most part you are starting from scratch</p>",
        "id": 237072913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981384
    },
    {
        "content": "<p>I mean \"theory T\" that you are defining in lean</p>",
        "id": 237072921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981400
    },
    {
        "content": "<p>like if you define the language and proof theory of PA and then want to prove a bazillion theorems in it because you want to prove godel incompleteness</p>",
        "id": 237072994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981448
    },
    {
        "content": "<p>the reason for writing it in lean is so that you can also prove theorems <em>about</em> the system, but theorems <em>in</em> the system are also important</p>",
        "id": 237073010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981498
    },
    {
        "content": "<p>I think my approach is rather ergonomic to a degree. I don't know what others would think of it though. It is also in super super alpha.</p>",
        "id": 237073015,
        "sender_full_name": "Mac",
        "timestamp": 1619981508
    },
    {
        "content": "<p>You can more or less create one-for-one tactics.</p>",
        "id": 237073065,
        "sender_full_name": "Mac",
        "timestamp": 1619981536
    },
    {
        "content": "<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>",
        "id": 237073081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981549
    },
    {
        "content": "<p>I think the most annoying thing to work with though would be linear logic as you <strong>cannot</strong> reduce most things to functions any more.</p>",
        "id": 237073089,
        "sender_full_name": "Mac",
        "timestamp": 1619981570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073081\">said</a>:</p>\n<blockquote>\n<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>\n</blockquote>\n<p>Ah, then no, you would probably not like my approach then. I avoid those two commands like the plague.</p>",
        "id": 237073116,
        "sender_full_name": "Mac",
        "timestamp": 1619981621
    },
    {
        "content": "<p>Hm, makes me wonder about porting Iris to lean 4</p>",
        "id": 237073118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981627
    },
    {
        "content": "<p>why are you avoiding them?</p>",
        "id": 237073175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981650
    },
    {
        "content": "<p>I dislike <code>rw</code> and <code>simp</code> because they hide what rules/theorems you are actually using.</p>",
        "id": 237073190,
        "sender_full_name": "Mac",
        "timestamp": 1619981657
    },
    {
        "content": "<p>if you are just trying to establish provability that's usually not a big deal</p>",
        "id": 237073215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981703
    },
    {
        "content": "<p>I want my proofs to be clear (and <code>go to definition</code> able)</p>",
        "id": 237073223,
        "sender_full_name": "Mac",
        "timestamp": 1619981713
    },
    {
        "content": "<p>plus you can use <code>simp only</code> or only mark things as simp lemmas that you want to elide</p>",
        "id": 237073239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073215\">said</a>:</p>\n<blockquote>\n<p>if you are just trying to establish provability that's usually not a big deal</p>\n</blockquote>\n<p>True, but that is rarely my goal.</p>",
        "id": 237073242,
        "sender_full_name": "Mac",
        "timestamp": 1619981740
    },
    {
        "content": "<p>I am more interested in reverse mathematics.</p>",
        "id": 237073260,
        "sender_full_name": "Mac",
        "timestamp": 1619981755
    },
    {
        "content": "<p>i.e. I want to know exactly what assumptions were made to get to a given proof.</p>",
        "id": 237073318,
        "sender_full_name": "Mac",
        "timestamp": 1619981781
    },
    {
        "content": "<p>And  I want to minimize them.</p>",
        "id": 237073326,
        "sender_full_name": "Mac",
        "timestamp": 1619981793
    },
    {
        "content": "<p>That's what <code>#print axioms</code> is for</p>",
        "id": 237073327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981796
    },
    {
        "content": "<p>well, you have more refined mechanisms for that in a deep embedding</p>",
        "id": 237073340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981816
    },
    {
        "content": "<p>You can literally define a function on proofs that will tell you if you used only such and such assumptions</p>",
        "id": 237073382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981868
    },
    {
        "content": "<p>I like that stuff to be explicit. Also, print axioms only works for Lean axioms not other kinds of assumptions.</p>",
        "id": 237073387,
        "sender_full_name": "Mac",
        "timestamp": 1619981878
    },
    {
        "content": "<p>I also would like them to be readable in isolation from the source code.</p>",
        "id": 237073449,
        "sender_full_name": "Mac",
        "timestamp": 1619981907
    },
    {
        "content": "<p>If you don't want to assume something, don't assume it</p>",
        "id": 237073455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981917
    },
    {
        "content": "<p>I want my lean proofs to more-or-less work (and be readable) in a vacuum.</p>",
        "id": 237073497,
        "sender_full_name": "Mac",
        "timestamp": 1619981982
    },
    {
        "content": "<p>And I am pretty happy with what I have gotten working in that regard.</p>",
        "id": 237073557,
        "sender_full_name": "Mac",
        "timestamp": 1619982015
    },
    {
        "content": "<p>Those are not words I would use to describe lean</p>",
        "id": 237073560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982017
    },
    {
        "content": "<p>there are quite a lot of things that go into turning lean text into a theorem/assertion</p>",
        "id": 237073739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982167
    },
    {
        "content": "<p>Here is my proof of commutativity of PA addition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">addNatCommProof</span>\n<span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Logic</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span> <span class=\"n\">P</span> <span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">SEq</span> <span class=\"n\">P</span> <span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SAdd</span> <span class=\"n\">T</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">I</span>   <span class=\"o\">:</span> <span class=\"n\">NatInductionRight</span> <span class=\"n\">L</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">NS</span>  <span class=\"o\">:</span> <span class=\"n\">NatSuccNat</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">NA</span>  <span class=\"o\">:</span> <span class=\"n\">NatAddNat</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">QEL</span> <span class=\"o\">:</span> <span class=\"n\">EqNatLeftEuc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">QtS</span> <span class=\"o\">:</span> <span class=\"n\">EqNatToEqSucc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">A0C</span> <span class=\"o\">:</span> <span class=\"n\">AddNatZeroComm</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">A</span> <span class=\"n\">N.toZero</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ASn</span> <span class=\"o\">:</span> <span class=\"n\">AddSuccNatEqSucc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">A</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">AnS</span> <span class=\"o\">:</span> <span class=\"n\">AddNatSuccEqSucc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">A</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">natInductionRight</span> <span class=\"bp\">?</span><span class=\"n\">f0</span> <span class=\"bp\">?</span><span class=\"n\">fS</span>\n  <span class=\"n\">case</span> <span class=\"n\">f0</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">Na</span>\n    <span class=\"n\">exact</span> <span class=\"n\">addNatZeroComm</span> <span class=\"n\">Na</span>\n  <span class=\"n\">case</span> <span class=\"n\">fS</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">Nb</span> <span class=\"n\">Anb_eq_Abn</span> <span class=\"n\">a</span> <span class=\"n\">Na</span>\n    <span class=\"k\">have</span> <span class=\"n\">NSb</span> <span class=\"o\">:=</span> <span class=\"n\">natS</span> <span class=\"n\">Nb</span>\n    <span class=\"k\">have</span> <span class=\"n\">NAab</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">Na</span> <span class=\"n\">Nb</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">NSAab</span> <span class=\"o\">:=</span> <span class=\"n\">natS</span> <span class=\"n\">NAab</span><span class=\"bp\">;</span>\n    <span class=\"k\">have</span> <span class=\"n\">NAba</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">Nb</span> <span class=\"n\">Na</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">NSAba</span> <span class=\"o\">:=</span> <span class=\"n\">natS</span> <span class=\"n\">NAba</span>\n    <span class=\"k\">have</span> <span class=\"n\">NASba</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">NSb</span> <span class=\"n\">Na</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">NASab</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">Na</span> <span class=\"n\">NSb</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eqNatLeftEuc</span> <span class=\"n\">NSAab</span> <span class=\"n\">NASab</span> <span class=\"n\">NASba</span>\n    <span class=\"n\">exact</span> <span class=\"n\">addNatSuccEqSucc</span> <span class=\"n\">Na</span> <span class=\"n\">Nb</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eqNatLeftEuc</span> <span class=\"n\">NSAba</span> <span class=\"n\">NASba</span> <span class=\"n\">NSAab</span>\n    <span class=\"n\">exact</span> <span class=\"n\">addSuccNatEqSucc</span> <span class=\"n\">Nb</span> <span class=\"n\">Na</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eqNatToEqSucc</span> <span class=\"n\">NAab</span> <span class=\"n\">NAba</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Anb_eq_Abn</span> <span class=\"n\">a</span> <span class=\"n\">Na</span>\n</code></pre></div>\n<p>I still think it needs some refinement, but I like the general structure (and notation).</p>",
        "id": 237073744,
        "sender_full_name": "Mac",
        "timestamp": 1619982172
    },
    {
        "content": "<p>I do want to try to automate the <code>nat</code> proofs though.</p>",
        "id": 237073809,
        "sender_full_name": "Mac",
        "timestamp": 1619982220
    },
    {
        "content": "<p>I'm not so sure about \"readable in a vaccum\" from this end</p>",
        "id": 237073911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982314
    },
    {
        "content": "<p>have/apply/exact is not a great recipe for proofs that can be read offline</p>",
        "id": 237073947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982351
    },
    {
        "content": "<p>True</p>",
        "id": 237073997,
        "sender_full_name": "Mac",
        "timestamp": 1619982377
    },
    {
        "content": "<p>I do think my current orientation is more for reading in an editor sadly (with the goal info view).</p>",
        "id": 237074013,
        "sender_full_name": "Mac",
        "timestamp": 1619982409
    },
    {
        "content": "<p>My point here was mostly to demonstrate what I mean by making assumption/inference rules explicit</p>",
        "id": 237074068,
        "sender_full_name": "Mac",
        "timestamp": 1619982476
    },
    {
        "content": "<p>I think that part at least is readable in a vacuum.</p>",
        "id": 237074148,
        "sender_full_name": "Mac",
        "timestamp": 1619982504
    },
    {
        "content": "<p>I would have preferred to see the actual statements rather than <code>AddNatZeroComm</code></p>",
        "id": 237074175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982532
    },
    {
        "content": "<p>That's fair. My approach to that is one of things I want to fine. Though the actual statement approach can get a little verbose, and makes synthesizing derivative statements impossible (the reason they are written like this is to make them type classes).</p>",
        "id": 237074469,
        "sender_full_name": "Mac",
        "timestamp": 1619982729
    },
    {
        "content": "<p>why aren't they in square brackets then?</p>",
        "id": 237074515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982769
    },
    {
        "content": "<p>Because they aren't being synthesized.</p>",
        "id": 237074590,
        "sender_full_name": "Mac",
        "timestamp": 1619982832
    },
    {
        "content": "<p>I think that it would be better to just have a <code>#print axioms</code> like approach here, since listing the axioms on every theorem will get repetitive (for you and your readers)</p>",
        "id": 237074661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982862
    },
    {
        "content": "<p>just add the ability to query the axioms used by any theorem</p>",
        "id": 237074681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982874
    },
    {
        "content": "<p>That's fair. I just personally don't like that approach myself (though I will admit adding the axioms to every theorem can be tiresome).</p>",
        "id": 237074789,
        "sender_full_name": "Mac",
        "timestamp": 1619982953
    },
    {
        "content": "<p>For example, this <a href=\"http://us.metamath.org/mpeuni/ancom.html\">metamath theorem</a> is a proof of commutativity of and, and in the axiom list it says it depends on ax-1, ax-2, ax-3, ax-mp, and definitions df-bi, df-an</p>",
        "id": 237074853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982976
    },
    {
        "content": "<p>Though, also, I am not sure how I would do that.</p>",
        "id": 237074856,
        "sender_full_name": "Mac",
        "timestamp": 1619982976
    },
    {
        "content": "<p>it's much easier for the computer to collect and organize this information, and it doesn't prevent the proof author from optimizing it</p>",
        "id": 237074907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983015
    },
    {
        "content": "<p>In principle <code>#print axioms</code> does the same thing but because most of the DTT axioms aren't listed it has limited usefulness</p>",
        "id": 237074958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983073
    },
    {
        "content": "<p>I don't think Lean has a way of automatically inferring hypotheses though?</p>",
        "id": 237075044,
        "sender_full_name": "Mac",
        "timestamp": 1619983119
    },
    {
        "content": "<p>No, they aren't hypotheses here, just axioms/theorems</p>",
        "id": 237075066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983145
    },
    {
        "content": "<p>They are hypotheses.</p>",
        "id": 237075082,
        "sender_full_name": "Mac",
        "timestamp": 1619983159
    },
    {
        "content": "<p>In your version they are, but they can be set up as axioms</p>",
        "id": 237075098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983177
    },
    {
        "content": "<p>and then you can track the usage of those axioms</p>",
        "id": 237075108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983186
    },
    {
        "content": "<p>How so?</p>",
        "id": 237075120,
        "sender_full_name": "Mac",
        "timestamp": 1619983198
    },
    {
        "content": "<p>They are attached to a specific logic.</p>",
        "id": 237075165,
        "sender_full_name": "Mac",
        "timestamp": 1619983209
    },
    {
        "content": "<p>They don't hold in a vacuum</p>",
        "id": 237075191,
        "sender_full_name": "Mac",
        "timestamp": 1619983224
    },
    {
        "content": "<p>Yeah, the logic contains constructors for all the axioms</p>",
        "id": 237075194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983226
    },
    {
        "content": "<p>like the <code>proof</code> inductive I showed earlier</p>",
        "id": 237075205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983236
    },
    {
        "content": "<p>no it does not</p>",
        "id": 237075208,
        "sender_full_name": "Mac",
        "timestamp": 1619983238
    },
    {
        "content": "<p>Not in my system</p>",
        "id": 237075217,
        "sender_full_name": "Mac",
        "timestamp": 1619983246
    },
    {
        "content": "<p>which has a constructor for <code>mp</code></p>",
        "id": 237075218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983247
    },
    {
        "content": "<p>In fact, many of the inference rules I have cannot be written DTT.</p>",
        "id": 237075236,
        "sender_full_name": "Mac",
        "timestamp": 1619983270
    },
    {
        "content": "<p>??</p>",
        "id": 237075242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983277
    },
    {
        "content": "<p>as part of an inductive type</p>",
        "id": 237075247,
        "sender_full_name": "Mac",
        "timestamp": 1619983282
    },
    {
        "content": "<p>I don't believe you :P</p>",
        "id": 237075276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983294
    },
    {
        "content": "<p>For example by conditional proof, <code>((L |- p) -&gt; (L |- q)) -&gt; (L |- p -&gt; q)</code></p>",
        "id": 237075301,
        "sender_full_name": "Mac",
        "timestamp": 1619983315
    },
    {
        "content": "<p>That's fine</p>",
        "id": 237075306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983322
    },
    {
        "content": "<p>If L was an inductive type this could not be written like that.</p>",
        "id": 237075352,
        "sender_full_name": "Mac",
        "timestamp": 1619983335
    },
    {
        "content": "<p>well, actually it won't have the right effect</p>",
        "id": 237075359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983336
    },
    {
        "content": "<p>that's not how imp introduction works</p>",
        "id": 237075376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983359
    },
    {
        "content": "<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>",
        "id": 237075417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983402
    },
    {
        "content": "<p>Yes that is how conditional proof works (the mp was a typo).</p>",
        "id": 237075422,
        "sender_full_name": "Mac",
        "timestamp": 1619983406
    },
    {
        "content": "<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>",
        "id": 237075493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983449
    },
    {
        "content": "<p>basically you need the context to be an explicit part of the provability judgment</p>",
        "id": 237075510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983464
    },
    {
        "content": "<p>at least, if you want gentzen style imp introduction rules</p>",
        "id": 237075534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075417\">said</a>:</p>\n<blockquote>\n<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 237075539,
        "sender_full_name": "Mac",
        "timestamp": 1619983493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493\">said</a>:</p>\n<blockquote>\n<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>\n</blockquote>\n<p>I also don't know what that notation is meant to say.</p>",
        "id": 237075568,
        "sender_full_name": "Mac",
        "timestamp": 1619983519
    },
    {
        "content": "<p>Suppose <code>p</code> is neither provable nor disprovable. Then <code>L |- p</code> is false, so <code>L |- p -&gt; L |- false</code> is true, so <code>L |- (p -&gt; false)</code> by your proof rule and so <code>p</code> is provably false. Thus every statement is provable or disprovable in the logic</p>",
        "id": 237075647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983575
    },
    {
        "content": "<p>\"Suppose <code> p</code> is neither provable nor disprovable.\" That would mean that neither <code>L |- p</code> or <code>(L |- p) -&gt; False</code> hold.</p>",
        "id": 237075722,
        "sender_full_name": "Mac",
        "timestamp": 1619983661
    },
    {
        "content": "<p>No, It means that <code>not (L |- p)</code> and <code>not (L |- not p)</code></p>",
        "id": 237075803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983723
    },
    {
        "content": "<p><code>L |- P</code> is not (necessarily) a Prop</p>",
        "id": 237075830,
        "sender_full_name": "Mac",
        "timestamp": 1619983749
    },
    {
        "content": "<p>doesn't really matter, use -&gt; False if you like</p>",
        "id": 237075846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983777
    },
    {
        "content": "<p><code>L |- not p</code> is not (necessarily) well-formed</p>",
        "id": 237075848,
        "sender_full_name": "Mac",
        "timestamp": 1619983779
    },
    {
        "content": "<p>That requires the language of L to have a <code>not</code></p>",
        "id": 237075860,
        "sender_full_name": "Mac",
        "timestamp": 1619983792
    },
    {
        "content": "<p>Okay... I am indeed making some bare minimum assumptions on the logic here</p>",
        "id": 237075927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983814
    },
    {
        "content": "<p>if the logic doesn't have a false then perhaps it's not inconsistent if only because you can't express it</p>",
        "id": 237075966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983841
    },
    {
        "content": "<p>The logic is initially devoid of any rules and the prop is initially devoid of any syntax.</p>",
        "id": 237075983,
        "sender_full_name": "Mac",
        "timestamp": 1619983857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075568\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493\">said</a>:</p>\n<blockquote>\n<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>\n</blockquote>\n<p>I also don't know what that notation is meant to say.</p>\n</blockquote>\n<p>I'm not sure what L is, so let's add a context <code>G</code>, which is a list or set of formulas. The proof inductive is <code>L, G |- p</code>, and means that if we assume the formulas <code>G</code> then <code>p</code> follows. So in particular <code>L, G |- p</code> if <code>p \\in G</code>. Then, the implication introduction rule is <code>(L, p::G |- q) -&gt; (L, G |- p -&gt; q)</code></p>",
        "id": 237076106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983955
    },
    {
        "content": "<p>But yes with conditional proof, if I have <code>(L |- p) -&gt; False</code> then <code>L |- p -&gt; q</code> for all <code>q</code>. I don't see why that is a problem.</p>",
        "id": 237076182,
        "sender_full_name": "Mac",
        "timestamp": 1619984010
    },
    {
        "content": "<p>Because you are lifting metalogical falsity into the logic</p>",
        "id": 237076212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984043
    },
    {
        "content": "<p>That says \"if p is not provable then p is disprovable\"</p>",
        "id": 237076286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984059
    },
    {
        "content": "<p>which is a very strong assumption</p>",
        "id": 237076299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984077
    },
    {
        "content": "<p>in particular it is false for PA and ZFC and every other reasonable first order logic</p>",
        "id": 237076351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984127
    },
    {
        "content": "<p>If one wants a weaker assumption, feel free to use a weaker rule. But that, at least, is how I view the conditional proof rule to work.</p>",
        "id": 237076358,
        "sender_full_name": "Mac",
        "timestamp": 1619984137
    },
    {
        "content": "<p>If I can prove that (L |- p) does not hold, I can with the law of excluded middle, prove (L |- ~p) in most FO logic.</p>",
        "id": 237076705,
        "sender_full_name": "Mac",
        "timestamp": 1619984478
    },
    {
        "content": "<p>The proof that L |- p does not hold is happening in the metalogic here</p>",
        "id": 237076723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984511
    },
    {
        "content": "<p>for example, Godel's unprovable sentence</p>",
        "id": 237076758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984524
    },
    {
        "content": "<p>It's not that the logic proves <code>not p</code></p>",
        "id": 237076777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984545
    },
    {
        "content": "<p>it is that the metalogic proves that <code>L |- p</code> is false, i.e. axiom system L does not prove p</p>",
        "id": 237076807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984577
    },
    {
        "content": "<p>the law of excluded middle says <code>L |- (p \\/ ~p)</code></p>",
        "id": 237076826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984601
    },
    {
        "content": "<p>Incompleteness would be ((L |- p) \\/ (L |- ~p) -&gt; False), right? Not for a given p, (L |- p) -&gt; False, correct?</p>",
        "id": 237076832,
        "sender_full_name": "Mac",
        "timestamp": 1619984608
    },
    {
        "content": "<p>Yes. The first one says <code>p</code> is independent, and the second one says that <code>p</code> is not provable</p>",
        "id": 237076911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984668
    },
    {
        "content": "<p>independent just means that neither <code>p</code> nor <code>not p</code> is provable</p>",
        "id": 237076923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984688
    },
    {
        "content": "<p>but your axiom is essentially declaring that there are no independent sentences, which is also known as (syntactic) completeness</p>",
        "id": 237076962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984722
    },
    {
        "content": "<p>So it is saying that it implies that independence implies inconsistency, right?</p>",
        "id": 237077079,
        "sender_full_name": "Mac",
        "timestamp": 1619984823
    },
    {
        "content": "<p>and Godel proved that such a system is inconsistent if it can handle basic arithmetic</p>",
        "id": 237077082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984827
    },
    {
        "content": "<p>Well, that is only true if the logical also includes FOL</p>",
        "id": 237077124,
        "sender_full_name": "Mac",
        "timestamp": 1619984847
    },
    {
        "content": "<p>yes</p>",
        "id": 237077130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984851
    },
    {
        "content": "<p>If the metalogic is FOL (or DTT i.e. Lean), and the logic is just arithmatic that does not hold.</p>",
        "id": 237077146,
        "sender_full_name": "Mac",
        "timestamp": 1619984876
    },
    {
        "content": "<p>there are complete axiom systems that are not strong enough for basic arithmetic</p>",
        "id": 237077188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984889
    },
    {
        "content": "<p>but if it is strong enough to run godel's argument then it is inconsistent</p>",
        "id": 237077213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984920
    },
    {
        "content": "<p>take a look at <a href=\"https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem\">https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem</a> to see whether your logic is weak enough; as long as it doesn't have FOL quantifiers or multiplication isn't total or something like that you might be able to get out of the issue</p>",
        "id": 237077348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985065
    },
    {
        "content": "<p>My point is that if you split the logic you can avoid that in many cases. For example, my fragment of PA is complete because only the equations and nat membership are statements in the logic. (It lacks quantifiers and propositional logical.)</p>",
        "id": 237077356,
        "sender_full_name": "Mac",
        "timestamp": 1619985071
    },
    {
        "content": "<p>Because all that is handled by the metalogic.</p>",
        "id": 237077369,
        "sender_full_name": "Mac",
        "timestamp": 1619985100
    },
    {
        "content": "<p>If there are no quantifiers, then just have \"all true sentences\" as your axiom system and this is complete (and decidable)</p>",
        "id": 237077388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985123
    },
    {
        "content": "<p>Exactly</p>",
        "id": 237077449,
        "sender_full_name": "Mac",
        "timestamp": 1619985165
    },
    {
        "content": "<p>in that case the <code>L |- </code> is just window dressing though</p>",
        "id": 237077487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985220
    },
    {
        "content": "<p>How so?</p>",
        "id": 237077509,
        "sender_full_name": "Mac",
        "timestamp": 1619985242
    },
    {
        "content": "<p>you can prove <code>L |- x = y &lt;-&gt; eval x = eval y</code> more or less</p>",
        "id": 237077550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985252
    },
    {
        "content": "<p>Well I might not be able to evaluate x and y in the metalogic though by default.</p>",
        "id": 237077595,
        "sender_full_name": "Mac",
        "timestamp": 1619985307
    },
    {
        "content": "<p>that's what I mean when I say it's decidable</p>",
        "id": 237077620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985333
    },
    {
        "content": "<p>you can just lift the expressions into the metalogic</p>",
        "id": 237077628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985344
    },
    {
        "content": "<p>you need some assumptions about plus and times</p>",
        "id": 237077654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985364
    },
    {
        "content": "<p>but the ones in your sample proof should be close to all you need</p>",
        "id": 237077687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985381
    },
    {
        "content": "<p>Wait, but L is only a subset of the things provable in the metalogic.</p>",
        "id": 237077729,
        "sender_full_name": "Mac",
        "timestamp": 1619985446
    },
    {
        "content": "<p>You will need to assume L is consistent for the reverse implication</p>",
        "id": 237077741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985468
    },
    {
        "content": "<p>like if I have (L |- 3 = 2) that does not mean that 3 = 2 in the metalogic.</p>",
        "id": 237077788,
        "sender_full_name": "Mac",
        "timestamp": 1619985486
    },
    {
        "content": "<p>It does, if L is consistent</p>",
        "id": 237077792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985494
    },
    {
        "content": "<p>no it doesn't</p>",
        "id": 237077809,
        "sender_full_name": "Mac",
        "timestamp": 1619985511
    },
    {
        "content": "<p>you might need something equivalent to not equal or less than in the logic</p>",
        "id": 237077817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985534
    },
    {
        "content": "<p>If I literally I have one axiom in I L, i.e L |- 3 = 2, that does not prove anything about 3 = 2 in the metalogic.</p>",
        "id": 237077820,
        "sender_full_name": "Mac",
        "timestamp": 1619985538
    },
    {
        "content": "<p>normally you would be able to combine that with other axioms of L to prove L is inconsistent</p>",
        "id": 237077836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985563
    },
    {
        "content": "<p>so if L is consistent then 3 = 2</p>",
        "id": 237077841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985572
    },
    {
        "content": "<p>consistency does not prove anything about the metalogic.</p>",
        "id": 237077851,
        "sender_full_name": "Mac",
        "timestamp": 1619985594
    },
    {
        "content": "<p>All consistency says is the ((p : P) -&gt; (L |- p) /\\ (L |- ~p)  -&gt; False)</p>",
        "id": 237077933,
        "sender_full_name": "Mac",
        "timestamp": 1619985630
    },
    {
        "content": "<p>If L is consistent, and L |- 3 = 2, then (by using other axioms) L |- False and so L is inconsistent, contradiction, thus 3 = 2</p>",
        "id": 237077990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985675
    },
    {
        "content": "<p>I'm assuming here that L is enough like PA that we can prove that L |- 3 != 2</p>",
        "id": 237078016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985715
    },
    {
        "content": "<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>",
        "id": 237078031,
        "sender_full_name": "Mac",
        "timestamp": 1619985723
    },
    {
        "content": "<p>You can use PA's other axioms to prove that 3 != 2</p>",
        "id": 237078144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985787
    },
    {
        "content": "<p>I am not talking about PA, I am just talking about some  random logic L</p>",
        "id": 237078180,
        "sender_full_name": "Mac",
        "timestamp": 1619985824
    },
    {
        "content": "<p>I'm talking about a random logic L with enough structure to run these arguments</p>",
        "id": 237078196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985841
    },
    {
        "content": "<p>That is sufficient structure.</p>",
        "id": 237078257,
        "sender_full_name": "Mac",
        "timestamp": 1619985869
    },
    {
        "content": "<p>A logic can be empty, it does not need proposition or rules.</p>",
        "id": 237078263,
        "sender_full_name": "Mac",
        "timestamp": 1619985884
    },
    {
        "content": "<p>Okay but then you can't prove anything about it</p>",
        "id": 237078277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985904
    },
    {
        "content": "<p>your earlier example had loads of assumptions about the logic</p>",
        "id": 237078293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985923
    },
    {
        "content": "<p>I'm using those assumptions, more or less</p>",
        "id": 237078305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078031\">said</a>:</p>\n<blockquote>\n<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>\n</blockquote>\n<p>The logic here is a valid logic with 2 propositions and 1 axiom and is complete and consistent.</p>",
        "id": 237078308,
        "sender_full_name": "Mac",
        "timestamp": 1619985934
    },
    {
        "content": "<p>yes</p>",
        "id": 237078311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985939
    },
    {
        "content": "<p>I'm talking about a logic with at least <code>x + 0 = x</code> and <code>x + s y = s (x+y)</code></p>",
        "id": 237078377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985964
    },
    {
        "content": "<p>Yeah but the PA fragment used to prove the semiring properities doesn't even need negation.</p>",
        "id": 237078384,
        "sender_full_name": "Mac",
        "timestamp": 1619985970
    },
    {
        "content": "<p>So it is trivially consistent</p>",
        "id": 237078395,
        "sender_full_name": "Mac",
        "timestamp": 1619985978
    },
    {
        "content": "<p>If you add 3 = 2 to such a theory then you will get <code>x = y</code> for all x, y</p>",
        "id": 237078413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986003
    },
    {
        "content": "<p>which is the nearest equivalent to inconsistency</p>",
        "id": 237078421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986016
    },
    {
        "content": "<p>Yes, if you add that to axiom list</p>",
        "id": 237078469,
        "sender_full_name": "Mac",
        "timestamp": 1619986071
    },
    {
        "content": "<p>so if we assume that it is not inconsistent in that sense, then we will indeed have <code>L |- x = y -&gt; eval x = eval y</code></p>",
        "id": 237078470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986072
    },
    {
        "content": "<p>and the converse is trivial by reflexivity</p>",
        "id": 237078531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986097
    },
    {
        "content": "<p>actually no, L |- S 0 = 1 in PA, but S 0 = 1 is not true in the metalogic (Lean).</p>",
        "id": 237078572,
        "sender_full_name": "Mac",
        "timestamp": 1619986118
    },
    {
        "content": "<p><code>eval x = eval y</code></p>",
        "id": 237078581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986130
    },
    {
        "content": "<p>there is no eval (S 0) in the metalogic.</p>",
        "id": 237078598,
        "sender_full_name": "Mac",
        "timestamp": 1619986152
    },
    {
        "content": "<p>the right side equality is equality in <code>Nat</code></p>",
        "id": 237078599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986155
    },
    {
        "content": "<p>there is, it's pretty easy to define</p>",
        "id": 237078605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986171
    },
    {
        "content": "<p>Yes, if I define S and 0 and 1 as there Nat counterparts true.</p>",
        "id": 237078613,
        "sender_full_name": "Mac",
        "timestamp": 1619986180
    },
    {
        "content": "<p>but if I define them all as separate terms, then no.</p>",
        "id": 237078668,
        "sender_full_name": "Mac",
        "timestamp": 1619986215
    },
    {
        "content": "<p>the idea here is to turn any provability question <code>L |- x = y</code> into a statement <code>eval x = eval y</code> that we can just evaluate in lean</p>",
        "id": 237078672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986218
    },
    {
        "content": "<p>i.e.</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>inductive term\n| zero : term\n| one  : term\n| succ : term -&gt; term\n</code></pre></div>",
        "id": 237078702,
        "sender_full_name": "Mac",
        "timestamp": 1619986242
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">term.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">term.one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">term.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 237078728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986286
    },
    {
        "content": "<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>",
        "id": 237078789,
        "sender_full_name": "Mac",
        "timestamp": 1619986336
    },
    {
        "content": "<p>Mario, your <code>eval</code> is not injective</p>",
        "id": 237078812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619986355
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> to <a class=\"stream-topic\" data-stream-id=\"236446\" href=\"/#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204\">#Type theory &gt; Metamathematics in lean 4</a></p>",
        "id": 237082713,
        "sender_full_name": "Notification Bot",
        "timestamp": 1619989322
    }
]
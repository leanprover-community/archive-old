[
    {
        "content": "<p>I was playing around with Agda-style definitions for algebraic properties, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">Op₂</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsCommutative</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">Op₂</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">CommMagma</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"n\">IsCommutative</span> <span class=\"n\">mul</span>\n</code></pre></div>\n<p>However, <code>mul_comm</code> cannot be used to rewrite because <code>Mul.mul a b</code> doesn't match <code>a * b</code>. A standalone minimal repro of the issue is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Mul.mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Replacing the function with <code>HMul.hMul</code> does work; even in the full class example. I think the problem is that <code>Mul.mul</code> is not definitionally equal to <code>HMul.hMul</code>, and/or that the instance for <code>Nat</code> isn't reducible, or maybe the definition isn't reducible, idk.</p>\n<p>Is there any solution for this other than redefining the operators to use the <code>Mul</code> typeclass? In particular what I want to get working is to be able to refer to the operation as <code>mul</code> (or some other short term that correctly supplies the <code>α</code> needed by the elaborator) in the class field types, but have this still rewrite the symbolic operator.</p>",
        "id": 288583991,
        "sender_full_name": "David A",
        "timestamp": 1657050666
    },
    {
        "content": "<p><code>a * b</code> is always implemented as <code>HMul</code> as you noticed correctly, however usually we have a default instance that uses <code>Mul.mul</code> instead so what you can do is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Mul.mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">HMul.hMul</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 288584323,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657050853
    },
    {
        "content": "<p>Unfortunately that would not be very practical in more complex situations.</p>\n<p>I found an interesting minimal pair for this issue. This rewrite fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsCommutative</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">Op₂</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Magma</span> <span class=\"kd\">extends</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Magma.mul</span> <span class=\"o\">[</span><span class=\"n\">Magma</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Magma.toHMul.1</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">CommMagma</span> <span class=\"kd\">extends</span> <span class=\"n\">Magma</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"n\">IsCommutative</span> <span class=\"n\">toMagma.mul</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">CommMagma</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">CommMagma.mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But if I inline the abbrev, the rewrite succeeds:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"n\">IsCommutative</span> <span class=\"n\">toMagma.toHMul.hMul</span>\n</code></pre></div>\n<p>That is very counter-intuitive to me as I thought rewrites should not be sensitive to the presence of reducible names.</p>",
        "id": 288705137,
        "sender_full_name": "David A",
        "timestamp": 1657129225
    },
    {
        "content": "<p>I don't think rewrites will (or should) automatically unfold definitions when they are searching for the pattern to apply their theorem to? The point of  rewrite to me has always been that you can explicitly control such stuff.</p>",
        "id": 288706986,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657130125
    }
]
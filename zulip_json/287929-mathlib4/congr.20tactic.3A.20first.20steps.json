[
    {
        "content": "<p>I have made my first attempts at <code>congr</code> tactic. It does cover the two examples at <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#congr\">https://leanprover-community.github.io/mathlib_docs/tactics.html#congr</a> (including the <code>congr'</code> example).  It is verbose however, and does not cover the <code>rcasesPat</code> part. I am sharing below for comments.</p>\n<p>Also, can someone point me to docs/examples for the <code>rcasesPat</code> part (I have no idea what that is).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">congrStep</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">closeOnly</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)(</span><span class=\"n\">mvar</span><span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span>  <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Eq.refl</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span>\n    <span class=\"k\">if</span> <span class=\"n\">res.isEmpty</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span>  <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Subsingleton.intro</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span>\n    <span class=\"k\">if</span> <span class=\"n\">res.isEmpty</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"n\">closeOnly</span> <span class=\"k\">then</span>\n    <span class=\"n\">try</span>\n      <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span>  <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">congr</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">])</span>\n      <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"n\">res</span>\n    <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">pure</span> <span class=\"n\">none</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">recCongr</span><span class=\"o\">(</span><span class=\"n\">maxDepth</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">mvar</span><span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">closeOnly</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">maxDepth</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≤</span>  <span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">false</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">congrStep</span><span class=\"bp\">?</span> <span class=\"n\">closeOnly</span> <span class=\"n\">mvar</span>\n  <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">depth</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">maxDepth</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">groups</span> <span class=\"bp\">←</span> <span class=\"n\">xs.mapM</span> <span class=\"o\">(</span><span class=\"n\">recCongr</span> <span class=\"n\">depth</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"n\">groups.bind</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvar</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Meta.congr</span><span class=\"o\">(</span><span class=\"n\">maxDepth</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">mvar</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n    <span class=\"k\">let</span> <span class=\"n\">xs</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">congr</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">])</span>\n    <span class=\"k\">let</span> <span class=\"n\">groups</span> <span class=\"bp\">←</span> <span class=\"n\">xs.mapM</span> <span class=\"o\">(</span><span class=\"n\">recCongr</span> <span class=\"n\">maxDepth</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"n\">groups.bind</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">congr</span> <span class=\"n\">mvar</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"congr tactic failed\"</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Tactic</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">congrTactic</span><span class=\"o\">)</span> <span class=\"s2\">\"congr\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"o\">(</span><span class=\"n\">colGt</span> <span class=\"n\">num</span><span class=\"o\">))</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">@[tactic congrTactic]</span> <span class=\"kd\">def</span> <span class=\"n\">congrTacticImpl</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n<span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">congr</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">card</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Syntax.isNatLit</span><span class=\"bp\">?</span> <span class=\"n\">card</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n    <span class=\"n\">liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">Meta.congr</span> <span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwIllFormedSyntax</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">exact</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span> <span class=\"mi\">2</span> <span class=\"c1\">-- goal remaining : x + y = y + x</span>\n  <span class=\"n\">skip</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">exact</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 276046156,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647867556
    },
    {
        "content": "<p><code>rcasesPat</code> is declared (and expanded) <a href=\"https://github.com/leanprover-community/mathlib4/blob/ead320ed6c371c3fe2a693e800e72bbb006f5055/Mathlib/Tactic/RCases.lean#L59\">here</a></p>",
        "id": 276051884,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647870179
    },
    {
        "content": "<p>Thanks. What would it mean to have such a pattern in the <code>congr</code> tactic?</p>",
        "id": 276061651,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647874271
    },
    {
        "content": "<p>I don't know :D<br>\nBut I think Mario or Gabriel will be able to explain</p>",
        "id": 276062662,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647874581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Can I ask what it means to say <code>congr with (x, y)</code> or some other such pattern? Should one try to match both sides of an equality to the pattern, or the full proposition? Is it done before, after, or instead of function application?<br>\nOr is it something entirely different?</p>",
        "id": 276063014,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647874724
    },
    {
        "content": "<p>In lean 3 it's just that <code>rcases</code> is being applied to the introduced variable(s) with that pattern (or <code>rintro</code>)</p>",
        "id": 276065319,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1647875512
    },
    {
        "content": "<p>I see. <br>\nDoes this mean that after each iteration of <code>apply congr</code> I should call <code>rcases</code> on the returned variables? With a failure not being an error, but just not decomposing further?</p>",
        "id": 276067365,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647876164
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.congr'/src\">src#tactic.interactive.congr'</a></p>",
        "id": 276098207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647888826
    },
    {
        "content": "<p>the two parts are not intermingled, and you can probably just write it as a macro tactic. It does <code>(congr n with pats) := focus (congr n &lt;;&gt; ext pats)</code></p>",
        "id": 276098587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647889011
    },
    {
        "content": "<p>(For this kind of tactic implementation I do recommend reading the source of the original tactic to get the control flow right)</p>",
        "id": 276098664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647889060
    },
    {
        "content": "<p>Thanks. Indeed I should look at lean 3 mathlib and the already implemented tactics more. <br>\nIn this case:</p>\n<ul>\n<li>there is non <code>congr</code> (yet?) in lean 4, and the syntax seems to be for a single <code>congr</code> tactic covering various cases; so stuff does not directly translate.</li>\n<li>I see at <a href=\"https://github.com/leanprover-community/mathlib4/blob/226f899cb18cb76990f480dd8b79b6d341e44797/Mathlib/Tactic/Ext.lean#L145\">https://github.com/leanprover-community/mathlib4/blob/226f899cb18cb76990f480dd8b79b6d341e44797/Mathlib/Tactic/Ext.lean#L145</a> that the case of <code>ext</code> that must be called is not ready yet (and when ready it seems easy enough to call).</li>\n</ul>\n<p>So it seems the best I can do now is do what <code>congr</code> and <code>congr'</code> did in mathlib for lean 3. I will try to streamline my code, and any suggestions to improve it are very welcome.</p>",
        "id": 276147492,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647929858
    },
    {
        "content": "<p>Apologies  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  : I see that <code>lean 3</code> docs clearly say <code>ext</code> is used with given pattern. I will read these with care in the future.</p>",
        "id": 276156020,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647937823
    },
    {
        "content": "<p>I mean the source specifically, not just the docs. Sometimes the docs are vague about what happens in such and such edge case, but you can find out by reading the source and/or doing some unit testing of the tactic</p>",
        "id": 276156110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647937905
    },
    {
        "content": "<p>I believe that <code>congr</code> should exist in lean 4 for the same reason it existed in lean 3: it was originally written as an internal mechanism for <code>simp</code> to be able to traverse inside terms, and it was later exposed as a standalone tactic</p>",
        "id": 276156251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647937990
    },
    {
        "content": "<p>I realized that, but it is more egregious to miss something in the docs. As I started using lean 4 without using lean 3 more than a tiny amount, I have not gotten the habit of looking at the lean 3 sources (while learning most things by trawling the lean 4 source).</p>\n<p>I see meanwhile that <code>ext</code> now supports the <code>rintro</code> syntax. I will try to cover that case too.</p>",
        "id": 276157000,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647938470
    },
    {
        "content": "<p>Specific question: <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  and <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> : the (unimplemented) syntax of <code>congr</code> uses <code>rcasesPat</code> while the syntax of <code>ext</code>uses <code>rintroPat</code>. On the other hand a TODO in <code>ext</code> mentioned <code>rcasesPat</code> as intended syntax.</p>\n<p>My question: is this a result of everything being in a transient state, or is the intention that <code>ext</code> is called after relating the two types of patterns (I can see that they are related)?</p>",
        "id": 276158463,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647939458
    },
    {
        "content": "<p>The lean 4 tactics are intended to be an exact match (or possibly a superset) for the corresponding lean 3 tactics. So the source of truth here is whatever is in mathlib</p>",
        "id": 276158625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647939562
    },
    {
        "content": "<p>For tactics that do a list of name introductions with pattern matching, <code>rintroPat</code> makes more sense. Note that <code>rintroPat</code> is a superset of <code>rcasesPat</code>, which supports binders like <code>(a b c : Nat)</code> that would not make sense as a cases/obtain pattern e.g. <code>obtain (a b c: Nat) := foo</code></p>",
        "id": 276159152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647939842
    },
    {
        "content": "<p>So IMO both <code>congr</code> and <code>ext</code> should use  <code>rintroPat</code></p>",
        "id": 276159202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647939895
    },
    {
        "content": "<p>I have made a pull request at <a href=\"https://github.com/leanprover-community/mathlib4/pull/247\">https://github.com/leanprover-community/mathlib4/pull/247</a>. As far as I can tell this is correct in the basic cases. I could not test the case with patterns.</p>\n<p>If there is something I should change to fit in with the porting plans (or because it is wrong) please let me know. I plan to try implementing <code>symm</code>, <code>trans</code> and <code>rfl'</code> next (modeled on the <code>ext</code> implementation).</p>",
        "id": 276179117,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647951297
    },
    {
        "content": "<p>Incidentally, <code>ext</code> gives a confusing error message when the tactic fails, saying <strong>incorrect syntax</strong> and including a whole block (maybe it is trying to parse the whole block as a tactic).</p>",
        "id": 276179289,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647951403
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 276182868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647953326
    },
    {
        "content": "<p>That sounds like a bug in the parser or the input, so what does the input look like?</p>",
        "id": 276182943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647953361
    },
    {
        "content": "<p>Modified from the test file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 276185245,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647954418
    },
    {
        "content": "<p>Since <code>ext x</code> is perfectly valid syntax which works elsewhere, I would expect a failed tactic, but we get <strong>incorrect syntax</strong>.<br>\nI get a similar error elsewhere, but that could be my mistake.</p>",
        "id": 276185765,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647954643
    },
    {
        "content": "<p>I guess the above was not self-contained, so here is a fuller example (the above is <code>ext.lean</code> modified).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Ext</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Logic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 276185938,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647954735
    },
    {
        "content": "<p>The <code>ext</code> attribute before the example is throwing several index out of bounds errors</p>",
        "id": 276186009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647954790
    },
    {
        "content": "<p>I see that too. Had not noticed.</p>",
        "id": 276186214,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647954891
    },
    {
        "content": "<p>Note that one way tactics can \"throw an error\" is <code>throwUnsupportedSyntax</code> which is usually used to allow overlapping syntaxes to take a shot at interpreting the input. I guess this is what it looks like if nothing is found</p>",
        "id": 276186305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647954945
    },
    {
        "content": "<p>I checked in mathlib4 and all cases I see of <code>throwUnsupportedSyntax</code> are the fallback case in a pattern match.</p>",
        "id": 276186793,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647955168
    },
    {
        "content": "<p>I am puzzled by this being triggered in a context dependent way, i.e., not just the syntactic context.</p>",
        "id": 276186857,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647955200
    },
    {
        "content": "<p>it's also used by things like <code>macro_rules</code> and <code>elab_rules</code> as the implicit fallback</p>",
        "id": 276186903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647955205
    },
    {
        "content": "<p>I don't see evidence that this is not simply a syntactic issue</p>",
        "id": 276186960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647955235
    },
    {
        "content": "<p>In the same file, the following is valid</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>but the following is not</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 276187534,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647955511
    },
    {
        "content": "<p>I think <code>rintro</code> is throwing the exception</p>",
        "id": 276187567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647955529
    },
    {
        "content": "<p>because <code>ext x</code> expands to <code>apply_ext_lemma; rintro x; skip</code></p>",
        "id": 276187674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647955566
    },
    {
        "content": "<p>I see. My main concern is somewhere else where I have seemingly identical code which works if entered by hand but not by macros. I feel this may be related.</p>",
        "id": 276187904,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647955678
    },
    {
        "content": "<p>I think it's a precedence issue in <code>rintroPat</code></p>",
        "id": 276187970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647955694
    },
    {
        "content": "<p>Here is the full code (the macro is based on what you said).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Meta</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Mathport.Syntax</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Ext</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Tactic.Congr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"sd\">/-- try to close goal using reflexivity and subsingletons -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">tryCloseGoal</span> <span class=\"o\">(</span><span class=\"n\">mvar</span><span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span>  <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">Eq.refl</span><span class=\"o\">)</span>\n    <span class=\"n\">unless</span> <span class=\"n\">res.isEmpty</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"failed to close goal\"</span>\n    <span class=\"n\">pure</span> <span class=\"n\">true</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span>  <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">Subsingleton.intro</span><span class=\"o\">)</span>\n    <span class=\"n\">unless</span> <span class=\"n\">res.isEmpty</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"failed to close goal\"</span>\n    <span class=\"n\">pure</span> <span class=\"n\">true</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">pure</span> <span class=\"n\">false</span>\n\n<span class=\"sd\">/-- apply `congr` after trying to close goal, optionally return result if successful -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">congrStep</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mvar</span><span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">closed</span>  <span class=\"bp\">←</span> <span class=\"n\">tryCloseGoal</span> <span class=\"n\">mvar</span>\n  <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"n\">closed</span> <span class=\"k\">then</span>\n    <span class=\"n\">try</span>\n      <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span>  <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">congr</span><span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"n\">res</span>\n    <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">pure</span> <span class=\"n\">none</span>\n\n<span class=\"sd\">/-- recursively apply congr and try to close goals, not an error if tactics fail -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">recCongr</span><span class=\"o\">(</span><span class=\"n\">maxDepth</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">mvar</span><span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">closeOnly</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">maxDepth</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≤</span>  <span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">false</span>\n  <span class=\"k\">if</span> <span class=\"n\">closeOnly</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span>  <span class=\"n\">chk</span> <span class=\"bp\">←</span> <span class=\"n\">tryCloseGoal</span> <span class=\"n\">mvar</span>\n    <span class=\"k\">if</span> <span class=\"n\">chk</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvar</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">congrStep</span><span class=\"bp\">?</span> <span class=\"n\">mvar</span>\n  <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">depth</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">maxDepth</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">groups</span> <span class=\"bp\">←</span> <span class=\"n\">xs.mapM</span> <span class=\"o\">(</span><span class=\"n\">recCongr</span> <span class=\"n\">depth</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"n\">groups.bind</span> <span class=\"n\">id</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvar</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- apply `congr` and then continue recursively; error if first application fails -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Meta.congr</span><span class=\"o\">(</span><span class=\"n\">maxDepth</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">mvar</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n    <span class=\"k\">let</span> <span class=\"n\">xs</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.apply</span> <span class=\"n\">mvar</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">congr</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">])</span>\n    <span class=\"k\">let</span> <span class=\"n\">groups</span> <span class=\"bp\">←</span> <span class=\"n\">xs.mapM</span> <span class=\"o\">(</span><span class=\"n\">recCongr</span> <span class=\"n\">maxDepth</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"n\">groups.bind</span> <span class=\"n\">id</span>\n  <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">congr</span> <span class=\"n\">mvar</span> <span class=\"n\">e.toMessageData</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Tactic</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">congrBase</span><span class=\"o\">)</span> <span class=\"s2\">\"congr_base\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"o\">(</span><span class=\"n\">colGt</span> <span class=\"n\">num</span><span class=\"o\">))</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `congr` tactic attempts to identify both sides of an equality goal `A = B`, leaving as new goals the subterms of `A` and `B` which are not definitionally equal. Example: suppose the goal is `x * f y = g w * f z`. Then congr will produce two goals: `x = g w` and `y = z`.</span>\n\n<span class=\"sd\">If `x y : t`, and an instance subsingleton t is in scope, then any goals of the form `x = y` are solved automatically.</span>\n\n<span class=\"sd\">The `congr` tactic, but takes an optional argument which gives</span>\n<span class=\"sd\">the depth of recursive applications.</span>\n<span class=\"sd\">* This is useful when `congr` without a depth bound is too aggressive in breaking down the goal.</span>\n<span class=\"sd\">* For example, given `⊢ f (g (x + y)) = f (g (y + x))`, `congr'` produces the goals `⊢ x = y`</span>\n<span class=\"sd\">  and `⊢ y = x`, while `congr' 2` produces the intended `⊢ x + y = y + x`.</span>\n<span class=\"sd\">* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[tactic congrBase]</span> <span class=\"kd\">def</span> <span class=\"n\">congrTacticImpl</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n<span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">congr_base</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">card</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Syntax.isNatLit</span><span class=\"bp\">?</span> <span class=\"n\">card</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n    <span class=\"n\">liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">Meta.congr</span> <span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwIllFormedSyntax</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">congr</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">congr_base</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">congr</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">congr_base</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?;</span> <span class=\"n\">ext</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">assumption</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span> <span class=\"mi\">2</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">assumption</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- congr 2 with x</span>\n  <span class=\"n\">congr_base</span> <span class=\"mi\">2</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"gr\">admit</span>\n  <span class=\"gr\">admit</span>\n  <span class=\"gr\">admit</span>\n</code></pre></div>",
        "id": 276188049,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647955729
    },
    {
        "content": "<p>If I uncomment the commented line close to the end and comment the next, I get the error <strong>unexpected syntax</strong> with the block just like that inserted by hand giving an error. <br>\nI don't understand macros well, so assumed it was my error. But I see the behaviour that I at least do not expect elsewhere, and suspect these  are related.</p>",
        "id": 276188431,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647955908
    },
    {
        "content": "<p>I minimized the issue to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"fails\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"nope\"</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">fails</span><span class=\"bp\">;</span> <span class=\"n\">skip</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">foo</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 276193249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647957925
    },
    {
        "content": "<p>The problem seems to be that when a macro has multiple <code>macro_rules</code> definitions, if all of the definitions fail (in any way, not just by <code>throwUnsupportedSyntax</code>) then it throws a syntax error instead of the result of the (first? last?) tactic</p>",
        "id": 276193543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647958054
    },
    {
        "content": "<p>which makes me think that it is best not used as a control flow mechanism in nontrivial cases</p>",
        "id": 276193695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647958114
    },
    {
        "content": "<p>the macro in question is <code>ext_or_simp</code> btw</p>",
        "id": 276193889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647958203
    },
    {
        "content": "<p>and this syntax error is going to bubble up to <code>ext</code> and <code>congr</code> that call this tactic internally</p>",
        "id": 276193952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647958231
    },
    {
        "content": "<p>A lot of the lean 4 tactics seem to be implemented at Meta/Elab level and chained that way.</p>",
        "id": 276196443,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647959283
    },
    {
        "content": "<p>Perhaps that is the most robust approach.</p>",
        "id": 276196488,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647959299
    },
    {
        "content": "<p>Call things as functions, rather than manipulate syntax.</p>",
        "id": 276196546,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647959322
    },
    {
        "content": "<p>I am very biased by being much more comfortable with the non-syntactic style.</p>",
        "id": 276196606,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647959347
    },
    {
        "content": "<p>I also think that <code>elab</code> tactics are superior: you have more control, less overhead, and a reasonable programming language to work in</p>",
        "id": 276203956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962055
    },
    {
        "content": "<p>I would only prefer macro tactics for trivial syntactic manipulations. Even something like <code>repeat</code> is a bit of a stretch to do as a recursive macro expansion</p>",
        "id": 276204135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962124
    },
    {
        "content": "<p>What has happened here is that I had to go to a syntactic level as the tactics to use are at macro level. Best may be to move to something else for now without this problem (e.g. an attempt at <code>symm</code>).</p>",
        "id": 276205261,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647962522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/congr.20tactic.3A.20first.20steps/near/276203956\">said</a>:</p>\n<blockquote>\n<p>less overhead</p>\n</blockquote>\n<p>Why do <code>elab</code> tactics have less overhead? I thought it was more expensive to lift a <code>TacticM</code> monad</p>",
        "id": 276205719,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647962674
    },
    {
        "content": "<p>lifting is usually negative work: there is some small overhead to prepare the input and output but most of the execution is now happening in a smaller monad which means less things to pass around on every step</p>",
        "id": 276206107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962827
    },
    {
        "content": "<p>the thing that makes macro tactics expensive is that you are constantly parsing and reinterpreting syntax into expressions</p>",
        "id": 276206229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962873
    },
    {
        "content": "<p>if you use <code>repeat</code> to execute <code>exact foo</code> a bunch of times it has to parse and elaborate the syntax <code>foo</code> into an expression many times</p>",
        "id": 276206361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962910
    },
    {
        "content": "<p>whereas if you have a MetaM tactic <code>foo</code> will usually be an <code>Expr</code> already</p>",
        "id": 276206440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962940
    },
    {
        "content": "<p>Got it. And then calling <code>evalTactic ⋯</code> inside <code>TacticM</code> is even more expensive I presume?</p>",
        "id": 276206515,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647962973
    },
    {
        "content": "<p>it's about the same cost as a macro tactic</p>",
        "id": 276206566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647962995
    },
    {
        "content": "<p>probably a bit less since you aren't calling <code>expandMacros</code> too</p>",
        "id": 276206656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647963018
    },
    {
        "content": "<p>On the other hand, interactive tactics do a lot of things for you and when you take it into your own hands you have to make sure to do all the side stuff</p>",
        "id": 276206791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647963080
    },
    {
        "content": "<p>for example <a href=\"https://github.com/leanprover-community/mathlib4/blob/b59f265dafebcca990e5710ae008691a4b549ea6/Mathlib/Tactic/Have.lean#L52\">this</a> is needed for getting go-to-definition on a binder to work</p>",
        "id": 276206994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647963170
    },
    {
        "content": "<p>eventually we will reimplement these things enough times that the common utilities will naturally be discovered</p>",
        "id": 276207126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647963224
    },
    {
        "content": "<p>Some updates: now I cover the <code>ext</code> case as well at least in a basic example. I had to struggle a bit to pass around the syntax, and things worked when - as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> said should be the case - I changed <code>rcasesPat</code> to <code>rintroPat</code>in the syntax for <code>congr</code> (otherwise when the syntax was passed around it was no longer recognized).</p>\n<p>Can I request a review <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> ? This looks to me like a largely correct implementation, and before trying more implementations I want to understand how this matches with the maintainers expectations.</p>",
        "id": 276287629,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1648010303
    },
    {
        "content": "<p>I suspect that just calling <code>apply congr</code> isn't going to work in dependent situations. Did you take a look at how <code>simp</code> is currently doing congruence and whether you can reuse that backend?</p>",
        "id": 276287994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648010760
    },
    {
        "content": "<p>You should try porting the lean 3 tests for <code>congr</code> if there are any; you need more dependent function and subsingleton tests, for example congruence of <code>if</code> expressions</p>",
        "id": 276288131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648010909
    },
    {
        "content": "<p>I think you should look into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.CongrTheorem#src\">src4#Lean.Meta.CongrTheorem</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.congr/src\">src#tactic.congr</a></p>",
        "id": 276288590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648011466
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> - I will read the sources you mention and look for tests.</p>",
        "id": 276289336,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1648012177
    },
    {
        "content": "<p>the main logic is in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.simp#src\">src4#Lean.Meta.Simp.simp</a> which clearly has a congruence component, but it's not clear how extractable it is from the simp core</p>",
        "id": 276289422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648012257
    },
    {
        "content": "<p>I think you want to adapt <code>tryAutoCongrTheorem?</code> to do something similar but call <code>congr</code> instead of <code>simp</code> recursively</p>",
        "id": 276289627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648012485
    },
    {
        "content": "<p>Yes, it does look like much of the work is done there. On the other hand, I believe <code>simp</code> will not resolve <code>f x = g y</code> to goals <code>f = g</code> and <code>x = y</code>, as <code>congr</code> should. I will digest the code and then get back to trying to implement a better <code>congr</code>.</p>\n<p>I should also follow the same <code>congr_core</code> pattern as the lean implementation (with updated syntax).</p>",
        "id": 276290144,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1648013051
    },
    {
        "content": "<p>We aren't using <code>simp</code> directly here, so the question is closer to whether <code>simp</code> is capable of performing simplifications when they are available in both <code>f</code> and <code>x</code>. And it looks like it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 276291634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648014941
    },
    {
        "content": "<p><code>congr</code> uses the same steps as <code>simp</code>, it just does the subgoal management differently</p>",
        "id": 276291699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648015004
    },
    {
        "content": "<p>Shouldn't <code>congr</code> break up <code>f x = g y</code> into <code>f = g</code> and <code>x = y</code>, as <code>apply congr</code> will? I agree with your point that most (perhaps all) of the non-trivial stuff done will overlap with <code>simp</code>, and indeed the code for <code>simp</code> shows this.</p>",
        "id": 276293728,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1648017622
    },
    {
        "content": "<p>Okay, I see from the lean 3 code that one matches for a (heterogeneous) equality, then looks if the lhs is a function application and if it is uses the same stuff as in simplification.</p>",
        "id": 276294258,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1648018245
    },
    {
        "content": "<p>In lean 4 there are methods <code>Expr.eq?</code> and <code>Expr.heq?</code> which do the matching (I have used the former a fair bit). So one can glue these with appropriately extracted code from <code>simp</code> (which I have to digest further to know what is the appropriate code).</p>",
        "id": 276294365,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1648018368
    }
]
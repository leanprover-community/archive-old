[
    {
        "content": "<p>I'm currently about 1/3 of the way through porting <code>Data.Fin.Basic</code> and I ran into an interesting problem. I tried to minimize it, but I can maybe take it further if need be. The problem is that some variables were declared at the beginning of the file, and in one declaration they were not used, but Lean still assumed that they were, so they were included in the type signature. In Lean 3 if this sort of problem came up we could use <code>omit</code>, but that's not an option anymore. (EDIT: ignore the mwe and look at the message with <code>foo</code> below)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>mwe</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.WithZero</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.RelIso.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"c1\">-- everything is fine until the last declaration!</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Fin</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_injective</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Fin.val</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Fin.eq_of_veq</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">val_injective</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">LinearOrder.lift</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">max</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">max_rec'</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x.2</span> <span class=\"n\">y.2</span><span class=\"o\">⟩⟩</span>\n    <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">min</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">min_rec'</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x.2</span> <span class=\"n\">y.2</span><span class=\"o\">⟩⟩</span> <span class=\"n\">Fin.val</span> <span class=\"n\">Fin.val_injective</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n    <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Fin.instLinearOrderFin</span>\n\n<span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">valEmbedding</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">↪</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">val_injective</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">valEmbedding</span>\n\n<span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">valOrderEmbedding</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">↪</span><span class=\"n\">o</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">valEmbedding</span><span class=\"o\">,</span> <span class=\"n\">Iff.rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">valOrderEmbedding</span>\n\n<span class=\"sd\">/-- The ordering on `Fin n` is a well order. -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Lt.isWellOrder</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsWellOrder</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">OrderEmbedding.isWellOrder</span> <span class=\"o\">(</span><span class=\"n\">valOrderEmbedding</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Lt.isWellOrder</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">one_pos</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Nat.succ_pos</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">one_pos</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_ne_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ne_of_lt</span> <span class=\"n\">one_pos</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">zero_ne_one</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_eq_one_iff</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">False.elim</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">zero_ne_one</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">zero_eq_one_iff</span>\n<span class=\"c1\">-- @zero_eq_one_iff : ∀ {n : ℕ} {a b : Fin n}, 0 = 1 ↔ n = 0</span>\n</code></pre></div>\n</div></div>",
        "id": 316359757,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671224739
    },
    {
        "content": "<p>I think the reason this might be happening is that the proof does <code>cases n</code> and <code>a b : Fin n</code>, so these are affected by the cases, which makes Lean think these variables were used.</p>",
        "id": 316359911,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671224794
    },
    {
        "content": "<p>Confirmed. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">foo</span>\n<span class=\"c1\">-- @foo : ∀ {n : Nat} {a : Fin n} (c : Fin n), c = c</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">bar</span>\n<span class=\"c1\">-- @bar : ∀ {n : Nat} (c : Fin n), c = c</span>\n</code></pre></div>",
        "id": 316360423,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671225016
    },
    {
        "content": "<p>One short-term workaround is to do <code>clear a</code> before <code>cases</code>, but that seems really gross. This feels like a bug to me, but I'll wait for someone with more knowledge to weigh in.</p>",
        "id": 316361275,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671225349
    },
    {
        "content": "<p>Oh that's interesting! I've seen tactic states which are randomly full of variables you're not using, but I had the impression that the actual signature of the declaration didn't mention them. But here clearly <code>a</code> should not be involved, and yet is.</p>",
        "id": 316361742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671225518
    },
    {
        "content": "<p>Right, I think what happens is that it looks through the proof to see if you used them and if you didn't, then it omits them, but if you did then they are included. In this case, I think it's getting confused because when you do <code>cases n</code> then you get (in the first case) <code>a : Fin Nat.zero</code> in the tactic state. I assume then that the term being produced includes this modification to <code>a</code> somehow, even though it wasn't necessary, and then Lean includes it in the type signature.</p>",
        "id": 316362304,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671225749
    },
    {
        "content": "<p>For me this is a Lean 4 bug. I don't recall it happening in Lean 3.</p>",
        "id": 316365131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671226761
    },
    {
        "content": "<p>Yeah, i've considered posting it in <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a>, but I wasn't sure.</p>",
        "id": 316365311,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671226826
    },
    {
        "content": "<p>Yeah you've minimised it, go for it!</p>",
        "id": 316365893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671227069
    },
    {
        "content": "<p>crossposted: <a href=\"#narrow/stream/270676-lean4/topic/bug.20in.20included.20variables\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/bug.20in.20included.20variables</a></p>",
        "id": 316366198,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1671227197
    }
]
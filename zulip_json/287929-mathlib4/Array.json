[
    {
        "content": "<p><code>Array</code> in Lean 4 is not <code>array</code> in Lean 3; the easiest way to see this is the observation that <code>array</code> eats a nat and <code>Array</code> doesn't (the nat can be extracted from the array but it's not part of the input). </p>\n<p>OK so right now I feel morally obliged to port <code>data.list.defs</code> because I want to have lines 751 to 754 of it in mathlib4, but on line 66 there is <code>list.to_array</code> which is flagged as a dubious translation because Array and array don't match. The declaration is used in exotic files such as <code>data.buffer.basic</code> and also in <code>data.array.lemmas</code>. What are we doing with this array mismatch? Are we making <code>Array'</code> which is aligned with Lean 3 <code>array</code>?</p>",
        "id": 313101165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1669826269
    },
    {
        "content": "<p>I'm inclined to say to not port <code>array</code> and just leave a porting note that you've deleted it. I don't think <code>array</code> was used in anything with mathematical content. It's used in <code>hash_map</code>, but that file is nowhere imported.</p>",
        "id": 313108239,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669828112
    },
    {
        "content": "<p>Don't duplicate work with <span class=\"user-mention\" data-user-id=\"542196\">@Arien Malec</span>, though (see <a href=\"#narrow/stream/287929-mathlib4/topic/list.2Etraverse\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/list.2Etraverse</a> )</p>",
        "id": 313108439,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669828179
    },
    {
        "content": "<p>It seems to me that <code>Array</code> is missing a lot of basic lemmas.  Am I looking in the wrong place, or should I try implementing them myself?</p>\n<p>Examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">++</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">toArray</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">l</span>\n<span class=\"o\">(</span><span class=\"n\">a.push</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 320120966,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673213508
    },
    {
        "content": "<p>I think <code>Array</code> is new in lean4 - any lemmas in mathlib would be about <code>List</code></p>",
        "id": 320121095,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1673213635
    },
    {
        "content": "<p>There are a bunch of lemmas in Mathlib4 about Array (eg: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/Array/Lemmas.html\">https://leanprover-community.github.io/mathlib4_docs/Std/Data/Array/Lemmas.html</a>) but it seems like still many are missing to me.</p>",
        "id": 320121224,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673213756
    },
    {
        "content": "<p>Those lemmas are in the <code>Std</code> namespace, not <code>Mathlib</code>. I think these are maintained by Lean's core team.</p>",
        "id": 320121314,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673213816
    },
    {
        "content": "<p>Ok, I see the distinction, <code>Mathlib</code> only has a single lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Array/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Array/Basic.html</a></p>",
        "id": 320121480,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673213937
    },
    {
        "content": "<p>Ok, so I should just move this discussion to the lean4 stream?</p>",
        "id": 320121525,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673213976
    },
    {
        "content": "<p>I think you can use things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.data_toArray#doc\">docs4#Array.data_toArray</a> to transport lemmas about <code>List</code> into lemmas about <code>Array</code>.</p>",
        "id": 320121610,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673214033
    },
    {
        "content": "<p>I think most <code>Array</code> operations are missing an equivalence proof to the corresponding <code>List</code> operation.</p>",
        "id": 320121856,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673214296
    },
    {
        "content": "<p>Ah, that sounds like something you'd have to do manually.</p>",
        "id": 320121900,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673214329
    },
    {
        "content": "<p>Yeah, is this something that would be good as a contribution to <code>Std</code>?</p>",
        "id": 320121915,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673214359
    },
    {
        "content": "<p>I'm not the person to ask unfortunately, but it sounds useful.</p>",
        "id": 320121973,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673214384
    },
    {
        "content": "<p>Well maybe <code>Array</code> shouldn't have lemmas written about it, but I don't know.</p>",
        "id": 320122139,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673214555
    },
    {
        "content": "<p>I think the existence of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.data_toArray#doc\">docs4#Array.data_toArray</a> is an indication that they want these lemmas though.</p>",
        "id": 320122165,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673214598
    },
    {
        "content": "<p>I think you need lemmas about <code>Array</code> to prove things about practical programs.  But maybe there is an alternative I am missing?</p>",
        "id": 320122295,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673214719
    },
    {
        "content": "<p>That sounds reasonable to me. This chat is mostly focused on the maths that we can do from within Lean, so most people here probably aren't as interested in that part of the language.</p>",
        "id": 320122468,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673214829
    },
    {
        "content": "<p>Mathlib doesn't really seem like the place for Array lemmas, is my point.</p>",
        "id": 320122554,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673214872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320121314\">said</a>:</p>\n<blockquote>\n<p>Those lemmas are in the <code>Std</code> namespace, not <code>Mathlib</code>. I think these are maintained by Lean's core team.</p>\n</blockquote>\n<p>std4 team != core team but they do have intersection</p>\n<p><span class=\"user-mention silent\" data-user-id=\"571451\">Jeremy Salwen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320121856\">said</a>:</p>\n<blockquote>\n<p>I think most <code>Array</code> operations are missing an equivalence proof to the corresponding <code>List</code> operation.</p>\n</blockquote>\n<p>Yes this is because <code>Array</code> is a different data structure in memory than <code>List</code>. It is merely represented as a <code>List</code> in the Lean 4 type system but the runtime has special support for it so the proofs aren't all trivial.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"571451\">Jeremy Salwen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320121915\">said</a>:</p>\n<blockquote>\n<p>Yeah, is this something that would be good as a contribution to <code>Std</code>?</p>\n</blockquote>\n<p>There is an issue on std4 for this: <a href=\"https://github.com/leanprover/std4/issues/24\">https://github.com/leanprover/std4/issues/24</a></p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320122139\">said</a>:</p>\n<blockquote>\n<p>Well maybe <code>Array</code> shouldn't have lemmas written about it, but I don't know.</p>\n</blockquote>\n<p>Array should definitely have proofs written about it, it is in the majority of cases the more performant datastructure to use compared to lists so computer scientists doing verification of Lean programs will want to use it.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320122165\">said</a>:</p>\n<blockquote>\n<p>I think the existence of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.data_toArray#doc\">docs4#Array.data_toArray</a> is an indication that they want these lemmas though.</p>\n</blockquote>\n<p>Due to the inherent difference in the operations of Array operations and List operations this lemma is not actually as useful as it might seem (but it and other lemmas that show similarities between List and Array operations are still helpful none the less). A few examples for why we might want to write algorithms on Arrays inherently different from List ones:</p>\n<ul>\n<li>You can easily add to the front of a <code>List</code> with a cons but you never want to do that with a slice of memory since it requires a full copy</li>\n<li>You can easily share a <code>List</code> but you never want to do that with an Array since it requires a full copy upon access, as long as the array is uniquely referenced it is in fact updated in place</li>\n<li>You don't actually want to use the <code>Array.data</code> function in practical code (unless that code is merely a facade for <code>@[extern]</code>) because turning a runtime <code>Array</code> into a <code>List</code> is O(n). What you usually want to do is write your algorithm in terms of indices like you would with regular arrays so you end up with completely different patterns. </li>\n</ul>\n<p>That being said if you can express your algorithm in terms of primitive operations that are implemented on both <code>Array</code> and <code>List</code> (fold, map, filter ...) it does still help to have equalities between them to apply list lemmas in verification.</p>",
        "id": 320125685,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673217686
    },
    {
        "content": "<p>To my mind, mathlib should have theorems about…math. Theorems about the soundness or correctness of general purpose data types or APIs probably belong upstream (core or std), again IMHO.</p>",
        "id": 320126668,
        "sender_full_name": "Arien Malec",
        "timestamp": 1673218586
    },
    {
        "content": "<p>mathlib4 is always going to have a lower barrier to entry than std4. So even if the \"right place\" for a lemma (e.g. about <code>Array</code>) is in std4, we shouldn't hesitate at all about putting it in mathlib4 in the meantime. Once it has seen some use / been refactored a few times / Mario says it's time for it to be in std, it is easy to migrate it down in std4.</p>",
        "id": 320141484,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1673232003
    },
    {
        "content": "<p>This sounds like there is probably a niche for some container typeclasses so that we don't have to write the same lemmas about array and list</p>",
        "id": 320309253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673291705
    },
    {
        "content": "<p>That too is in the works on the std4 side.</p>",
        "id": 320318768,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673294268
    },
    {
        "content": "<p>I found myself looking for these array lemmas occasionally too, and I think in those cases they would have been pretty useful.</p>\n<p>There are two reasons I think they're not terribly out of place in mathlib4 per se:</p>\n<ul>\n<li>sometimes you need to reason about a mathematical definition which is implemented behind the scenes in a performant way, and this exposes some <code>Array</code> stuff—this doesn't <em>usually</em> happen but it does sometimes happen</li>\n<li>sometimes you as a mathematician do want to write performant code! Especially if you're doing, say, some kind of explicit combinatorics or computational homology or something, where collections of things can get large and need speedy operations.</li>\n</ul>\n<p>So, in addition to the reasons mentioned above, I don't think the perceived \"unmathiness\" of these lemmas, so to speak, should prevent them from being in mathlib4 immediately. :)</p>",
        "id": 320337699,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673301072
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> point is that if you want to prove things about arrays, you can just unfold the array definitions and then use the list proofs</p>",
        "id": 320340651,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673302218
    },
    {
        "content": "<p>Which needs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n^2 + 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span> lemmas instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n^2 + 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span>, where n is the size of the list api</p>",
        "id": 320340802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673302285
    },
    {
        "content": "<p>So I have done a few proofs about <code>Array</code>, and I have tried to do them the suggested way of converting to <code>List</code> operations.</p>\n<p>If I am proving an equality of two <code>Array</code> expressions, for the most part, <code>apply Array.exp'; simp</code> will solve it.  However, sometimes when the expressions are more complex, this will not completely simplify away the expression.  Here is an example where it  took two passes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.data.list.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Array.modifyHead</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Array.modify</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Array.modifyHead_data</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">Array.modifyHead</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">data</span> <span class=\"bp\">=</span> <span class=\"n\">List.modifyHead</span> <span class=\"n\">f</span> <span class=\"n\">a.data</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">examp</span> <span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Array.push</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"n\">acc</span> <span class=\"bp\">=</span> <span class=\"n\">Array.modifyHead</span> <span class=\"o\">(</span><span class=\"n\">Array.append</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Array.push</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">#</span><span class=\"o\">[]):=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Array.ext'</span>\n  <span class=\"n\">simp</span>\n  <span class=\"c1\">-- We still have the goal acc = acc ++ #[], so we need to do it again</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Array.ext'</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Additionally, this only works if my goal is directly an equality of <code>Array</code> expressions.  A lot of the time, you will have <code>Array</code> subexpressions nested in some larger expression, and you'd like to just <code>simp</code> everything away, but you need to rewrite each <code>Array</code> subexpression one by one using this technique.</p>\n<p>Both of these limitations make my approach feel like a bit of a hack. If <code>Array</code> lemmas were added to mathlib, then <code>simp</code> would just handle all these issue gracefully.  But if we don't add all the <code>Array</code> lemmas, it still seems like  it should be possible to write a smarter tactic that can act <em>as if</em> all these lemmas were present, by intelligently using the isomorphism to <code>List</code>.</p>",
        "id": 320526184,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673378216
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.modify#doc\">docs4#Array.modify</a> is unusual because it's not implemented in terms of <code>list.modify</code></p>",
        "id": 320526560,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673378335
    },
    {
        "content": "<p>But actually, the difficulty here is that you're working with an <code>Array</code> of <code>Array</code>s; so it's not surprising that you have to use <code>ext</code> at each level</p>",
        "id": 320527069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673378479
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Array.ext_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">bs</span> <span class=\"bp\">↔</span> <span class=\"n\">as.data</span> <span class=\"bp\">=</span> <span class=\"n\">bs.data</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">examp</span> <span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Array.push</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"n\">acc</span> <span class=\"bp\">=</span> <span class=\"n\">Array.modifyHead</span> <span class=\"o\">(</span><span class=\"n\">Array.append</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Array.push</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">#</span><span class=\"o\">[]):=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Array.ext_iff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 320527362,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673378576
    },
    {
        "content": "<p>Very cool! That fixes all my issues with having to apply <code>Array.ext'</code> twice.  However, it still doesn't fix the issue where simp will handle <code>List</code> subepxressions, but <code>simp Array.ext_iff</code> won't handle <code>Array</code> Subexpressions.  Here is a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.data.list.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Array.ext_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">bs</span> <span class=\"bp\">↔</span> <span class=\"n\">as.data</span> <span class=\"bp\">=</span> <span class=\"n\">bs.data</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo_array</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)):</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">examp_array</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">rest</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)):</span>\n <span class=\"n\">foo_array</span> <span class=\"o\">(</span><span class=\"n\">Array.push</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"n\">foo_array</span> <span class=\"o\">(</span><span class=\"n\">Array.push</span> <span class=\"n\">rest</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Array.ext_iff</span><span class=\"o\">]</span>\n <span class=\"c1\">-- Array subexpressions are not normalized!</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo_list</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)):</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">examp_list</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">rest</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)):</span>\n <span class=\"n\">foo_list</span> <span class=\"o\">(</span><span class=\"n\">List.concat</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"n\">foo_list</span> <span class=\"o\">(</span><span class=\"n\">List.concat</span> <span class=\"n\">rest</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">simp</span>\n <span class=\"c1\">-- List subexpressions are normalized!</span>\n</code></pre></div>",
        "id": 320537984,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673382258
    },
    {
        "content": "<p>The argument here would be that this is hard because you didn't prove anything about <code>(foo_array a).to_list</code></p>",
        "id": 320538955,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673382533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320340802\">said</a>:</p>\n<blockquote>\n<p>Which needs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n^2 + 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span> lemmas instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n^2 + 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span>, where n is the size of the list api</p>\n</blockquote>\n<p>The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span> lemmas here are the ones about <code>Array.toList</code> and <code>List.toArray</code>, combined with the list operations</p>",
        "id": 320539023,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673382566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320538955\">said</a>:</p>\n<blockquote>\n<p>The argument here would be that this is hard because you didn't prove anything about <code>(foo_array a).to_list</code></p>\n</blockquote>\n<p>I agree that's <em>why</em> it's hard, but the question is why does it <em>have</em> to be hard.  Simplifying expressions involving <code>Array</code>s seems like a common and reasonable thing to do while proving things about <code>Arrays</code>.  Why wouldn't we want to have some sort of tactic to do that?</p>",
        "id": 320540841,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673383333
    },
    {
        "content": "<p>It would be possible, but probably not worth the effort.</p>",
        "id": 320540941,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673383380
    },
    {
        "content": "<p>Look, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset\">docs#finset</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set\">docs#set</a> are basically two of the biggest APIs in mathlib, and we still don't have a tactic to transfer results from one to the other.</p>",
        "id": 320541057,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673383428
    },
    {
        "content": "<p>By no means am I trying to discourage someone to work on such a tactic, I'm just saying that if you don't take the matter in hands, then likely nobody will.</p>",
        "id": 320541234,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673383488
    },
    {
        "content": "<p>Regarding <code>set</code> and <code>finset</code>, I found that <code>coe_inj.2 $ by { norm_cast, exact set.some_lemma }</code> (or the <code>coe_subset</code> version thereof) was a reliable way of proving <code>finset.some_lemma</code>. By now, there are many lemmas in mathlib I proved that way. So I think it is a sensible heuristic for implementing such a tactic.</p>",
        "id": 320541677,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673383682
    },
    {
        "content": "<p>I would give it a shot, I am just not sure which approach would be right.  I can imagine a few ways it could be implemented: generating new lemmas, configuring simp to handle things better, preprocessing and passing to simp, or walking the expression tree directly.</p>",
        "id": 320541907,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673383764
    },
    {
        "content": "<p>Note that the way such a tactic would likely work is:</p>\n<ol>\n<li>Prove everything we want about lists (the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> lemmas I talked about before)</li>\n<li>Prove the links between the lists and array definitions (the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span> lemmas)</li>\n<li>Write a tactic to generate the other <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> lemmas</li>\n</ol>\n<p>The thing is, once you do the first two steps, you can already get what you want with <code>simp</code></p>",
        "id": 320542242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673383871
    },
    {
        "content": "<p>But I also think there's something more general to get out of this, because such a tactic could likely replace <code>to_additive</code>'s current fragile implementation: Instead of regenerating the proof term every time, apply transfer lemmas then the original theorem.</p>",
        "id": 320542432,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673383931
    },
    {
        "content": "<p>I suspect <span class=\"user-mention\" data-user-id=\"571451\">@Jeremy Salwen</span> is asking this question because they want to write proofs about arrays in terms of other lemmas about arrays; but if you enable this workflow then the list API falls behind the array API instead.</p>",
        "id": 320542574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673383986
    },
    {
        "content": "<p>If you're not careful you end up in a mess where some lemmas are transferred forwards and others backwards and now you have horrible import cycles.</p>",
        "id": 320542667,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673384022
    },
    {
        "content": "<p>Not sure I'm following. How does this workflow favor one over the other?</p>",
        "id": 320542755,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673384047
    },
    {
        "content": "<p>If you have lemmas about Array available then you're tempted into writing more complex lemmas about arrays</p>",
        "id": 320542870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673384108
    },
    {
        "content": "<p>Ah yeah I see what you mean.</p>",
        "id": 320542894,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673384119
    },
    {
        "content": "<p>If you have only list lemmas available, then you always write the list lemma first</p>",
        "id": 320542916,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673384127
    },
    {
        "content": "<p>My tactic suggestion would kind of prevent that, as we would only allow translation one way.</p>",
        "id": 320542999,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673384162
    },
    {
        "content": "<p>You'd stil need to tell everyone PRing an array proof \"please write the list proof instead\". But I guess this already happens with <code>to_additive</code>.</p>",
        "id": 320543087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673384184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320542574\">said</a>:</p>\n<blockquote>\n<p>I suspect <span class=\"user-mention silent\" data-user-id=\"571451\">Jeremy Salwen</span> is asking this question because they want to write proofs about arrays in terms of other lemmas about arrays; but if you enable this workflow then the list API falls behind the array API instead.</p>\n</blockquote>\n<p>Mostly this is coming from writing proofs about programs.  To write a proof by induction about a function operating on Arrays, you end up with the induction hypothesis as a \"lemma about arrays\".</p>",
        "id": 320543149,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673384214
    },
    {
        "content": "<p>Yeah but if all lemmas in the <code>Array</code> files are proved with <code>by translate</code>, I won't need to shout that loud to make myself understood.</p>",
        "id": 320543241,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673384259
    },
    {
        "content": "<p>If there was a version of <code>simp</code> that understood these isomorphisms that would be cool.  It would know for certain types that it should simplify by first translating them to the canonical type and simplifying them there, and translating back.</p>",
        "id": 320544197,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1673384576
    },
    {
        "content": "<p>19 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/A.20translate.20tactic\">#mathlib4 &gt; A translate tactic</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 320551839,
        "sender_full_name": "Notification Bot",
        "timestamp": 1673387480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Array/near/320541677\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>set</code> and <code>finset</code>, I found that <code>coe_inj.2 $ by { norm_cast, exact set.some_lemma }</code> (or the <code>coe_subset</code> version thereof) was a reliable way of proving <code>finset.some_lemma</code>. By now, there are many lemmas in mathlib I proved that way. So I think it is a sensible heuristic for implementing such a tactic.</p>\n</blockquote>\n<p>This is basically what the <code>norm_cast</code> tactic does, so I would say the tactic to do this already exists</p>",
        "id": 320576366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673400448
    }
]
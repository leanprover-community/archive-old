[
    {
        "content": "<p>I've <a href=\"#narrow/stream/287929-mathlib4/topic/toBool/near/305294428\">heard a rumour</a> that there is still no final decision made on casing in mathlib4 theorem names. My belief right now is that when we have ported a bunch of these grimy low-level files which have few tactics available then the manual porting job is going to get much easier and in particular more people will be able to get involved, so I see porting these low-level files as a high priority task (in fact there are several reasons why I believe this). Let me talk about the beginning of <code>data.bool.basic</code>, a file so low-level in mathlib3 that it has no imports at all, meaning that you don't even get a tada emoji when you finish a tactic proof, although this is not really an issue because there is only one <code>begin end</code> block in the entire file anyway.</p>\n<p>The block below is referring to naming of the first few theorems in <code>data.bool.basic</code>. The format of the block is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mathlib3_name</span> <span class=\"o\">:</span> <span class=\"n\">mathlib3_statement</span>\n<span class=\"n\">mathlib3port</span> <span class=\"n\">auto</span><span class=\"bp\">-</span><span class=\"n\">gen</span> <span class=\"n\">name</span>\n<span class=\"n\">my</span> <span class=\"n\">proposed</span> <span class=\"n\">mathlib4_name</span> <span class=\"o\">:</span> <span class=\"n\">mathlib4_statement</span>\n</code></pre></div>\n<p>Note that mathlib3's <code>tt : bool</code> is mathlib4's <code>true : Bool</code>, mathlib3's <code>to_bool</code> is mathlib4's <code>decide</code>, mathlib3's <code>coe_sort</code> is mathlib4's <code>CoeSort.coe</code>. Note also that I am not speaking from a position of authority when it comes to mathlib4 naming -- in fact I am speaking from a position of complete cluelessness. On the other hand I'm thoroughly enjoying porting <code>data.bool.basic</code> even though it's turning out to be very hard work (I'm still only a quarter of the way through -- I work on it when I'm on my commute). Any advice as to what these things should be called would be welcome -- even if the advice is \"quit changing the mathlib3port names\".  [note added in proof: I just realised that mathlib3port is not changing the names at all!]</p>\n<p>If names get changed, my understanding is that I should do <code>#align mathlib3_name mathlib4_name</code> after the proof of the theorem. Is that right? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">coe_sort_tt</span> <span class=\"o\">:</span> <span class=\"n\">coe_sort.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">tt</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe_sort_tt</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CoeSort_coe_true</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↥</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">coe_sort_ff</span> <span class=\"o\">:</span> <span class=\"n\">coe_sort.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">ff</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe_sort_ff</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CoeSort_coe_false</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↥</span> <span class=\"n\">false</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">to_bool_true</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">to_bool</span> <span class=\"n\">true</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"n\">to_bool_true</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">decide_True</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">True</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">to_bool_false</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">to_bool</span> <span class=\"n\">false</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span>\n<span class=\"n\">to_bool_false</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">decide_False</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">False</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">to_bool_coe</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">to_bool</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">to_bool_coe</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">decide_coe</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">coe_to_bool</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">to_bool</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe_to_bool</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">coe_decide</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_to_bool_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">to_bool</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">of_to_bool_iff</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">of_decide_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tt_eq_to_bool_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">tt</span> <span class=\"bp\">=</span> <span class=\"n\">to_bool</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">tt_eq_to_bool_iff</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">true_eq_decide_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ff_eq_to_bool_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ff</span> <span class=\"bp\">=</span> <span class=\"n\">to_bool</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">ff_eq_to_bool_iff</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">false_eq_decide_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 305316676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1666346234
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">CoeSort_coe_true</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↥</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>This one is actually <code>true_eq_true_eq_True</code> if you actually look at the statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CoeSort_coe_true</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>Theorems about coercions are going to be misleading like this, and most likely they should just be removed and all applications of the theorem should use something else.</p>",
        "id": 305319789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666347450
    },
    {
        "content": "<p>The standard way of coercing a bool to a prop is currently <code>b = true</code>, so we should probably come up with some naming convention for this that doesn't require spelling out the <code>eq_true</code> all the time</p>",
        "id": 305319944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666347523
    },
    {
        "content": "<p>Since <code>coe</code> doesn't actually show up in any of the statements of the lemmas, I would avoid names that contain <code>coe</code>. Other suggestions: <code>to_bool_coe -&gt; decide_bool</code>, <code>coe_to_bool -&gt; decide_eq_true</code>, <code>of_to_bool_iff -&gt;</code> isn't this the same theorem?, <code>tt_eq_to_bool_iff -&gt; true_eq_decide</code>, <code>ff_eq_to_bool_iff -&gt; false_eq_decide</code></p>",
        "id": 305320371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666347711
    },
    {
        "content": "<p>Re mentions of <code>coe</code>, what's the mathlib4 equivalent of a lemma that has the following statement?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">cases_on'_none_coe</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">casesOn'</span> <span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">coe</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">o</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>What do we put now instead of <code>coe</code>?</p>",
        "id": 305722208,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1666567701
    },
    {
        "content": "<p><code>(↑)</code></p>",
        "id": 305740991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666582560
    },
    {
        "content": "<p>Thanks! Can one do explicit <code>((a : α) : Option α)</code> as well?</p>",
        "id": 305741519,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1666583045
    },
    {
        "content": "<p>When I tried to use a coercion (in this case <code>\\-|u</code> or whatever order you put those three characters in)  it was automatically unfolded in the statement I was using it in. Is this normal?</p>",
        "id": 305752324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1666591638
    },
    {
        "content": "<p>yes, this is a significant difference from lean 3</p>",
        "id": 305754889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666593117
    },
    {
        "content": "<p>The function <code>coe</code> basically never shows up in statements anymore, coercions are now unfolded at elaboration time</p>",
        "id": 305755007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666593163
    },
    {
        "content": "<p>(I'm not sure what anagram of those characters you mean, I usually just use <code>\\u</code>)</p>",
        "id": 305755058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666593194
    },
    {
        "content": "<p>(I was coe'ing to sort)</p>",
        "id": 305758829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1666595223
    },
    {
        "content": "<p>So... what is the casing rule for things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lift_rel_subrelation_lex</span> <span class=\"o\">:</span> <span class=\"n\">Subrelation</span> <span class=\"o\">(</span><span class=\"n\">LiftRel</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Lex</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">LiftRel.lex</span>\n</code></pre></div>\n<p>?</p>\n<ol>\n<li>Leave as is, to avoid having to write lots of #align statements, and potentially do a big rename after the port?</li>\n<li>Rename to <code>LiftRel_Subrelation_Lex</code>, and add lots of #align statements.</li>\n</ol>\n<p>I think I prefer 1., however much that leaves lemma names unpredictable for now.</p>",
        "id": 305785765,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1666606402
    },
    {
        "content": "<p>I think it is better to take advantage of our heavy work on tool-assisted renaming now rather than postponing what could be thousands of renames into the future</p>",
        "id": 305786118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666606548
    },
    {
        "content": "<p>I've been reviewing diffs of lean3port and it's really looking a lot better than before</p>",
        "id": 305786297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666606608
    },
    {
        "content": "<p>Personally, the way I've been leaning toward combining our snake-casing theorem convention with capitalized definition names is to lowercase the definitions <em>without</em> going full snake case so that name components stay together. So your example would be rendered as <code>liftRel_subrelation_lex</code></p>",
        "id": 305787339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666607093
    },
    {
        "content": "<p>Name components in a theorem would only stay capitalized when this is needed to work around a name conflict, as in <code>And_assoc</code>, although even here I'm inclined to use <code>and_assoc</code> for associativity of <code>And</code> and <code>Bool.and_assoc</code> for associativity of <code>and</code></p>",
        "id": 305787616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666607206
    },
    {
        "content": "<p>For this subrel example, we rename explicitly in a manual way in the file correct? Is there any align we need to define here?</p>",
        "id": 305809344,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1666614962
    },
    {
        "content": "<p>If the name is not the one that mathport would have already generated, you need to add an <code>#align</code> directive with the original lean 3 name and the new lean 4 name.</p>",
        "id": 305815520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666617056
    },
    {
        "content": "<p>I suggest putting it immediately after the theorem</p>",
        "id": 305815562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666617074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/305787616\">said</a>:</p>\n<blockquote>\n<p>Name components in a theorem would only stay capitalized when this is needed to work around a name conflict, as in <code>And_assoc</code>, although even here I'm inclined to use <code>and_assoc</code> for associativity of <code>And</code> and <code>Bool.and_assoc</code> for associativity of <code>and</code></p>\n</blockquote>\n<p>If you need so many exceptions (some of which, like this one, are even non-local), isn't that a sign that the naming convention is not good? Throughout all these discussions, I've never understood what's wrong with taking the 'components' of a theorem's type, with whatever case they have, and putting underscores between them. So <code>And_assoc</code> because it's about <code>And</code>, <code>Subrelation</code> because it's about <code>Subrelation</code>.</p>",
        "id": 305854158,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666627531
    },
    {
        "content": "<p>Well, <code>LE_Iff_Eq_Or_LT</code> didn't play well with the focus groups</p>",
        "id": 305864765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666630777
    },
    {
        "content": "<p>The naming conflict in this case could be solved if <code>and</code> was an <code>export</code> of <code>Bool.and</code></p>",
        "id": 305865052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666630852
    },
    {
        "content": "<p>I don't mind <code>LE_Iff_Eq_Or_LT</code> at all and I think people would get used to it very quickly. So if there's still a chance to go in this direction, I think this should be reconsidered. But I realise I'm quite late.</p>",
        "id": 305876113,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666631678
    },
    {
        "content": "<p>Stuff like <code>inv_Eq_Iff_inv_Eq</code> just looks (and is) very random</p>",
        "id": 305878218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666632376
    },
    {
        "content": "<p>It looks a bit funny maybe, but it's perfectly straightforward and predictable. More so than a convention that requires case-folding with exceptions. And the funny looks are not a long-term concern imo. Two months with any naming convention and it'll feel perfectly natural.</p>",
        "id": 305881878,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666633655
    },
    {
        "content": "<p>well I'm arguing for case folding (almost) without exceptions. I won't say there are no exceptions but honestly I think that a good naming convention should always allow for exceptions lest you get <a href=\"https://leanprover-community.github.io/mathlib_docs/geometry/euclidean/triangle.html#euclidean_geometry.dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle\">absurd examples</a>. Naming conventions are for humans, not machines.</p>",
        "id": 305888578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666635908
    },
    {
        "content": "<p>Anyway the naming convention was the source of a long discussion so I don't want to diverge too much from what we are using today</p>",
        "id": 305889044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666636079
    },
    {
        "content": "<p>All right. Doesn't matter too much at the end of the day.</p>",
        "id": 305908223,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666643204
    },
    {
        "content": "<p>Not trying to bikeshed, just get clarity on guidelines... for this instance<br>\n<code>instance lift_or_get_is_left_id (f : α → α → α) : IsLeftId (Option α) (liftOrGet f) none :=</code><br>\nshould that be <code>liftOrGet_isLeftId</code>? Does it not matter because it is an <code>instance</code>?</p>",
        "id": 305940819,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1666660289
    },
    {
        "content": "<p>Wouldn't that be <code>IsLeftId_liftOrGet</code>?</p>",
        "id": 305971760,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1666683309
    },
    {
        "content": "<p>cf. the example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lift_rel_subrelation_lex</span> <span class=\"o\">:</span> <span class=\"n\">Subrelation</span> <span class=\"o\">(</span><span class=\"n\">LiftRel</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Lex</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">LiftRel.lex</span>\n</code></pre></div>\n<p>above, which I think we decided to case as <code>liftRel_subrelation_lex</code>. Each CamelCased chunk had its initial capital lowered when forming the theorem name.</p>",
        "id": 305972605,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1666683679
    },
    {
        "content": "<p>Remind me, why does <code>subrelation</code> go in the middle here? Because we're to imagine it as an infix operator?</p>",
        "id": 305972956,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1666683812
    },
    {
        "content": "<p>I guess so. I've never had strong opinions about word order in theorem names...</p>",
        "id": 305973938,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1666684224
    },
    {
        "content": "<p>Is there a file where these naming conventions are written down? Seems like <a href=\"https://github.com/leanprover-community/mathlib4/wiki\">https://github.com/leanprover-community/mathlib4/wiki</a> would be a good place.</p>",
        "id": 307747271,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1667487136
    },
    {
        "content": "<p>Should <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cmp_le\">docs#cmp_le</a> be <code>CmpLe</code> or <code>CmpLE</code>? How should <code>cmp_le_swap</code> be spelled? <code>cmpLe_swap</code>?<br>\nMathlib3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cmp_le</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">decidable_rel</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ordering</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 308712908,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667967277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/305940819\">said</a>:</p>\n<blockquote>\n<p>Not trying to bikeshed, just get clarity on guidelines... for this instance<br>\n<code>instance lift_or_get_is_left_id (f : α → α → α) : IsLeftId (Option α) (liftOrGet f) none :=</code><br>\nshould that be <code>liftOrGet_isLeftId</code>? Does it not matter because it is an <code>instance</code>?</p>\n</blockquote>\n<p>Did we get to the bottom of this? I think I have a similar question. Is the below code following the naming convention?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- `ReflGen r`: reflexive closure of `r` -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">ReflGen</span> <span class=\"c1\">-- @ReflGen : {α : Type u_1} → (α → α → Prop) → α → α → Prop</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">refl_gen_iff</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ReflGen</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm still very much getting used to the idea that the concept of \"ReflGen\" might manifest itself as both <code>ReflGen</code> and <code>refl_gen</code> in names of declarations. Or have I misunderstood?</p>",
        "id": 308744019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667984970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/305787339\">said</a>:</p>\n<blockquote>\n<p>Personally, the way I've been leaning toward combining our snake-casing theorem convention with capitalized definition names is to lowercase the definitions <em>without</em> going full snake case so that name components stay together. So your example would be rendered as <code>liftRel_subrelation_lex</code></p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/305864765\">said</a>:</p>\n<blockquote>\n<p>Well, <code>LE_Iff_Eq_Or_LT</code> didn't play well with the focus groups</p>\n</blockquote>\n<p>Doesn't your rule above advocate <code>lE_iff_eq_or_lT</code>, which feels worse?</p>",
        "id": 308749139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667986790
    },
    {
        "content": "<p>Because you're mentioning focus groups let me stress that I have no opinion about the naming convention; Mario's earlier comment that basically everyone will just learn it and get on with it once it's established struck me as probably the truth. My issue is simply that I currently don't <em>understand</em> the naming convention and so struggle to conform to it!</p>",
        "id": 308750764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667987351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/308712908\">said</a>:</p>\n<blockquote>\n<p>Should <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cmp_le\">docs#cmp_le</a> be <code>CmpLe</code> or <code>CmpLE</code>? How should <code>cmp_le_swap</code> be spelled? <code>cmpLe_swap</code>?<br>\nMathlib3:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cmp_le</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">decidable_rel</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ordering</span> <span class=\"o\">:=</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>For acronym name components, I prefer to capitalize / lowercase them as a group, although I think that this has been used inconsistently for <code>LE</code>. That is, this approach would suggest the names <code>CmpLE</code> and <code>cmpLE_swap</code>. Although, I've <a href=\"https://github.com/leanprover/std4/blob/main/Std/Data/RBMap/Basic.lean#L186\">already violated this rule</a> it seems...</p>",
        "id": 308777791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667997556
    },
    {
        "content": "<p>(Another fun thing about this example is that it is exactly the opposite of your example - it derives <code>LE</code> from an <code>Ordering</code> function rather than the other way around.)</p>",
        "id": 308778117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667997650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/308749139\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/305864765\">said</a>:</p>\n<blockquote>\n<p>Well, <code>LE_Iff_Eq_Or_LT</code> didn't play well with the focus groups</p>\n</blockquote>\n<p>Doesn't your rule above advocate <code>lE_iff_eq_or_lT</code>, which feels worse?</p>\n</blockquote>\n<p>As another example, the acronym naming convention would use <code>le_iff_eq_or_lt</code> in this example, this is what I mean by lowercasing as a group.</p>",
        "id": 308778580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667997810
    },
    {
        "content": "<p>But also, it's totally fine to challenge these conventions! I'm just making stuff up here trying to get something that is mostly deterministic, doesn't look too weird, and still has some room for the author's own tastes</p>",
        "id": 308778891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667997923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/308744019\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/305940819\">said</a>:</p>\n<blockquote>\n<p>Not trying to bikeshed, just get clarity on guidelines... for this instance<br>\n<code>instance lift_or_get_is_left_id (f : α → α → α) : IsLeftId (Option α) (liftOrGet f) none :=</code><br>\nshould that be <code>liftOrGet_isLeftId</code>? Does it not matter because it is an <code>instance</code>?</p>\n</blockquote>\n<p>Did we get to the bottom of this? I think I have a similar question. Is the below code following the naming convention?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- `ReflGen r`: reflexive closure of `r` -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">ReflGen</span> <span class=\"c1\">-- @ReflGen : {α : Type u_1} → (α → α → Prop) → α → α → Prop</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">refl_gen_iff</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ReflGen</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm still very much getting used to the idea that the concept of \"ReflGen\" might manifest itself as both <code>ReflGen</code> and <code>refl_gen</code> in names of declarations. Or have I misunderstood?</p>\n</blockquote>\n<p>no, those should be <code>liftOrGet_isLeftId</code> and <code>reflGen_iff</code> respectively</p>",
        "id": 308779242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667998074
    },
    {
        "content": "<p>By the way, I've been avoiding this question for instance names by making instances anonymous.</p>",
        "id": 308779490,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667998162
    },
    {
        "content": "<p>For the cmp_le, I also ended up with CmpLE in my PR, so I think we deterministic-ed in the same way.</p>",
        "id": 308779656,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667998213
    },
    {
        "content": "<p>One thing that I may or may not have mentioned before: I think instances should be named either like theorems, or using something similar to the automatic lean 4 naming system which is basically <code>inst</code> + the conclusion mashed together into one word, at the author's discretion. In particular I don't think we should use <code>Of</code> ever, which mathport sometimes gets wrong</p>",
        "id": 308784510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667999915
    },
    {
        "content": "<p>When making instances anonymous, make sure to hover on the word \"instance\" to double check that the autogenerated name is not terribly ambiguous. If the original is named you might also want to <code>#align</code> it (I usually don't align instances unless I think it is being referred to directly for some reason)</p>",
        "id": 308785322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000182
    },
    {
        "content": "<p>For a lot of the base files, it's hard to know if named instances will be referred to, since that reference usually comes much later in the import tree</p>",
        "id": 308786780,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1668000666
    },
    {
        "content": "<p>I usually do a text search in mathlib to get a ballpark estimate</p>",
        "id": 308786870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000702
    },
    {
        "content": "<p>Some lean 3 instances are named only because the original name was ambiguous and it was causing a duplicate definition error</p>",
        "id": 308787183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000790
    },
    {
        "content": "<p>Would it be alright to defer the aligns until the later files are ported? Because sometimes, names are only used because of shorthand, and in those places, an inferInstanceAs can fill in</p>",
        "id": 308787207,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1668000799
    },
    {
        "content": "<p>That sounds fine</p>",
        "id": 308787262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000821
    },
    {
        "content": "<p>Basically, not explicitly naming instances might help with hygiene?</p>",
        "id": 308787268,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1668000824
    },
    {
        "content": "<p>Instance names are not hygienic, they used to be but this is actually not as great as it sounds on paper because it totally breaks pp.all reprinting</p>",
        "id": 308787521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000904
    },
    {
        "content": "<p>I think it is better to think of them as part of the public surface of the API, even though they are usually heuristically named and usually don't need to be referred to explicitly</p>",
        "id": 308787744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000969
    },
    {
        "content": "<p><code>to_additive</code> does something similar</p>",
        "id": 308787773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668000980
    },
    {
        "content": "<p>I don't get the current naming convention yet, but if I understand this thread and Scott's comment on my PR correctly, then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=is_empty_pi#doc\">docs4#is_empty_pi</a> should be <code>isEmpty_pi</code>, right? Reason is that I looked at that file and thought I was doing the right thing by not changing the alignment..</p>",
        "id": 309107082,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668125604
    },
    {
        "content": "<p>i.e., type names are firstLowerCamelCase if they appear in lemmas</p>",
        "id": 309107227,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668125671
    },
    {
        "content": "<p>That's my understanding.</p>",
        "id": 309116564,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668131333
    },
    {
        "content": "<p>I think we should be permissive about where it is appropriate to fix naming in earlier files. If you feel like making a separate PR, do that, but I think it's fine to include naming issues in PRs that are mostly about porting a later file.</p>",
        "id": 309116680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668131404
    },
    {
        "content": "<p>This isn't ideal from a history/reviewing point of view, but I <em>think</em> worthwhile for efficiency.</p>",
        "id": 309116710,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668131436
    },
    {
        "content": "<p>I can make a PR for renaming the lemmas in that file, mainly as an easy exercise for myself to learn the naming convention.</p>",
        "id": 309116847,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668131544
    },
    {
        "content": "<p>I would like to add a section in the wiki for the naming convention.</p>",
        "id": 309116891,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668131609
    },
    {
        "content": "<p>I thought they are <code>lower_case_snake_case</code> if they are <code>LowerCaseSnakeCase : Prop</code> though.</p>",
        "id": 309118204,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1668132570
    },
    {
        "content": "<p>theorems are mostly snake case, but individual name components coming from <code>MyFoo : Prop</code> definitions appear as <code>myFoo_is_bar</code> in theorems, i.e. you don't introduce a <code>_</code> in the middle of the name</p>",
        "id": 309126262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668139797
    },
    {
        "content": "<p>Is there a written documentation / community wiki on the new naming conventions?</p>",
        "id": 309128166,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1668141308
    },
    {
        "content": "<p>why do we have <code>has_rightInverse</code>? this should be <code>hasRightInverse</code> or not?</p>",
        "id": 309145107,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668153848
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 309145379,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668153993
    },
    {
        "content": "<p>oh still wrong  - it should be <code>HasRightInverse</code></p>",
        "id": 309147549,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668155192
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/wiki#naming-convention\">https://github.com/leanprover-community/mathlib4/wiki#naming-convention</a> comments and improvements are very welcome</p>",
        "id": 309154798,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668158506
    },
    {
        "content": "<p>We'll get there. :-)</p>",
        "id": 309161886,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668161343
    },
    {
        "content": "<p>Why is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cmp#doc\">docs4#Cmp</a> in upper camel case? I think it is defining a term?</p>",
        "id": 309168282,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1668163968
    },
    {
        "content": "<p>we also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem#doc\">docs4#Set.mem</a> which does also not conform to the convention, before doing more edits I would like to hear from someone with more to say on these matters (aka Mario) that what I wrote is correct and if that is the case then we can go ahead and fix everything we find.</p>",
        "id": 309172871,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668165863
    },
    {
        "content": "<p>Also what Yakov mentioned in the morning might become more important: in definition-heavy files the amount of manual aligns is too high and we have to figure out some way to optimize the names that mathport generates. Something along the lines of \"get all types of the variables, and if a conversion to snake case matches part of the lemma name then replace that part by camel case\".</p>",
        "id": 309173455,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668166111
    },
    {
        "content": "<p>Regarding Cmp, I totally accept that I could have misunderstood the guidelines for it.</p>",
        "id": 309176442,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1668167363
    },
    {
        "content": "<p><code>Cmp</code> should be <code>cmp</code>, <code>CmpUsing</code> should be <code>cmpUsing</code>, <code>Set.mem</code> should be <code>Set.Mem</code></p>",
        "id": 309189032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668171883
    },
    {
        "content": "<p>I think that the type searching heuristic is doable, it just needs some elbow grease</p>",
        "id": 309189382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668172015
    },
    {
        "content": "<p>Is there a decision on what to do with the distinction between e.g. <code>inf</code> and <code>Inf</code>?</p>",
        "id": 309199987,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1668175992
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lattice\">docs#lattice</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Lattice\">docs#Lattice</a>?</p>",
        "id": 309204226,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668177397
    },
    {
        "content": "<p>well, a <code>Set A</code> is actually a function returning a <code>Prop</code>, so there is an argument to be made that <code>Inf</code> is following the new convention already</p>",
        "id": 309204227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177397
    },
    {
        "content": "<p>I'm not sure we came to a final consensus on what to do about functions returning sets</p>",
        "id": 309204315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177431
    },
    {
        "content": "<p>If we want to name them as functions I think <code>inf</code>, <code>infi</code>, <code>sInf</code>, <code>bInf</code> is as good as any</p>",
        "id": 309204568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177503
    },
    {
        "content": "<p>For <code>lattice</code> vs <code>Lattice</code> the naming convention that mathport implements is to suffix categories with <code>Cat</code>, so they would become <code>Lattice</code> and <code>LatticeCat</code> respectively</p>",
        "id": 309204723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/309204227\">said</a>:</p>\n<blockquote>\n<p>well, a <code>Set A</code> is actually a function returning a <code>Prop</code>, so there is an argument to be made that <code>Inf</code> is following the new convention already</p>\n</blockquote>\n<p>Can you make that argument more explicitly please?</p>",
        "id": 309205269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668177749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/309204568\">said</a>:</p>\n<blockquote>\n<p>If we want to name them as functions I think <code>inf</code>, <code>infi</code>, <code>sInf</code>, <code>bInf</code> is as good as any</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/infi\">docs#infi</a> is already a thing; are you proposing renaming <code>Inf</code> to <code>infi</code> and <code>infi</code> to ...?</p>",
        "id": 309205352,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668177785
    },
    {
        "content": "<p>no I meant keeping <code>infi</code> as is</p>",
        "id": 309205397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177811
    },
    {
        "content": "<p>I'm not a big fan of appending 3 letters to the names of the numerous categories we have in order theory. Some lemma names are already stupidly long.</p>",
        "id": 309205439,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668177831
    },
    {
        "content": "<p><code>Inf</code> would become <code>sInf</code> there</p>",
        "id": 309205443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177831
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 309205528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177848
    },
    {
        "content": "<p>What is the <code>bInf</code> of your proposal?</p>",
        "id": 309205559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668177860
    },
    {
        "content": "<p>infimum bounded by a set; it isn't an actual definition but it shows up in lots of lemmas</p>",
        "id": 309205627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177889
    },
    {
        "content": "<p>What we call <code>binfi</code> right now (because it's about <code>infi</code> not <code>Inf</code>)</p>",
        "id": 309205682,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668177908
    },
    {
        "content": "<p>oh, that's a name change I hadn't noticed</p>",
        "id": 309205756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177940
    },
    {
        "content": "<p><code>bInfi</code> works too</p>",
        "id": 309205881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668177982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/309204315\">said</a>:</p>\n<blockquote>\n<p>I'm not sure we came to a final consensus on what to do about functions returning sets</p>\n</blockquote>\n<p>Maybe you're referring to something else, but <code>Inf</code> isn't a function returning a set, it's a function consuming a set</p>",
        "id": 309205889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668177984
    },
    {
        "content": "<p>oh right, I was thinking about set big union</p>",
        "id": 309205934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668178005
    },
    {
        "content": "<p>I think we should go for lowercased names for all of these then</p>",
        "id": 309206039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668178057
    },
    {
        "content": "<p>We should definitely respect capitalisation between <code>Inf</code> and <code>Union</code>. They are genuinely the same function.</p>",
        "id": 309206045,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668178059
    },
    {
        "content": "<p>No they're not, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.Union\">docs#set.Union</a> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/infi\">docs#infi</a></p>",
        "id": 309206115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668178082
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.sUnion\">docs#set.sUnion</a> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Inf\">docs#Inf</a></p>",
        "id": 309206225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668178107
    },
    {
        "content": "<p>So I think renaming <code>Inf</code> to <code>sInf</code> is very reasonable (along with <code>cInf</code> to <code>csInf</code>?)</p>",
        "id": 309206253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668178118
    },
    {
        "content": "<p>Aah, of course I meant <code>sUnion</code></p>",
        "id": 309206263,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668178121
    },
    {
        "content": "<p>I think <code>cInf</code> can stay as is in this scheme.</p>",
        "id": 309206385,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668178161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/309206045\">said</a>:</p>\n<blockquote>\n<p>They are genuinely the same function.</p>\n</blockquote>\n<p>You mean aside from the fact that the union of no sets is empty and the infimum of no sets is the universe, and the functions are morally opposites?</p>",
        "id": 309206493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668178198
    },
    {
        "content": "<p>The argument I alluded to before <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is that when determining whether a definition returns \"data\" or \"a proposition\", it depends on whether we unfold the type (up to reducibles, up to semireducibles?). In the case of <code>Set A := A -&gt; Prop</code> that would mean that anything that returns a <code>Set A</code> should be cased like a proposition, i.e. capital camel case</p>",
        "id": 309206575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668178211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>: which in this case doesn't actually apply to <code>Inf</code> due to the confusion above, but does apply to <code>set.sUnion</code></p>",
        "id": 309206708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668178259
    },
    {
        "content": "<p>Personally I am not a fan of this, I think we should just take the declaration as is without unfolding and hence something returning <code>Set A</code> \"returns data\" and hence is lowercased</p>",
        "id": 309206722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668178264
    },
    {
        "content": "<p>It definitely shouldn't include unfolding, because then we have to rename everything if we change <code>Set</code> to a structure</p>",
        "id": 309206850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668178312
    },
    {
        "content": "<p>Sorry, I meant <code>sUnion</code> and <code>Sup</code>, and <code>sInter</code> and <code>Inf</code></p>",
        "id": 309216176,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668181282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/308777791\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/308712908\">said</a>:</p>\n<blockquote>\n<p>Should <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cmp_le\">docs#cmp_le</a> be <code>CmpLe</code> or <code>CmpLE</code>? How should <code>cmp_le_swap</code> be spelled? <code>cmpLe_swap</code>?<br>\nMathlib3:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cmp_le</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">decidable_rel</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ordering</span> <span class=\"o\">:=</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>For acronym name components, I prefer to capitalize / lowercase them as a group, although I think that this has been used inconsistently for <code>LE</code>. That is, this approach would suggest the names <code>CmpLE</code> and <code>cmpLE_swap</code>. Although, I've <a href=\"https://github.com/leanprover/std4/blob/main/Std/Data/RBMap/Basic.lean#L186\">already violated this rule</a> it seems...</p>\n</blockquote>\n<p>I am very sorry for pulling this out again, but I was just trying to port <code>zero_le_one</code> and are we really sure that this file should be named <code>zeroLEOne</code>? It looks wrong to me (I read it as <code>zero_leo_ne</code>) and I then realized that nobody complained that we have (and this is my fault as well and I even took that as an example <span aria-label=\"silence\" class=\"emoji emoji-1f910\" role=\"img\" title=\"silence\">:silence:</span> ) <code>NeZero</code>..</p>",
        "id": 311131937,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668946821
    },
    {
        "content": "<p>it would be <code>zero_le_one</code></p>",
        "id": 311132730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947178
    },
    {
        "content": "<p>because it combines <code>zero</code>, <code>LE</code> and <code>one</code> and they all get lowercased and snake-case strung together</p>",
        "id": 311132780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947210
    },
    {
        "content": "<p>Doesn't the current naming convention advocate for <code>NEZero</code> instead, for <code>NE</code> being an acronym?</p>",
        "id": 311132802,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1668947222
    },
    {
        "content": "<p>that's a good point</p>",
        "id": 311132841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/311132730\">said</a>:</p>\n<blockquote>\n<p>it would be <code>zero_le_one</code></p>\n</blockquote>\n<p>It is a file</p>",
        "id": 311132879,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668947259
    },
    {
        "content": "<p>I'm inclined to make an exception because <code>Ne</code> already exists in core with that spelling</p>",
        "id": 311132894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947265
    },
    {
        "content": "<p>Andrew that is exactly my point</p>",
        "id": 311132908,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668947270
    },
    {
        "content": "<p>There's a file called zero_le_one?</p>",
        "id": 311133039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947332
    },
    {
        "content": "<p>there is.. what is the world coming to</p>",
        "id": 311133066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947349
    },
    {
        "content": "<p><code>algebra.order.zero_le_one</code></p>",
        "id": 311133073,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668947357
    },
    {
        "content": "<p><code>ZeroLEOne</code></p>",
        "id": 311133099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947373
    },
    {
        "content": "<p>alright. does <code>#align</code> also work for filenames?</p>",
        "id": 311133320,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668947444
    },
    {
        "content": "<p>Unsure</p>",
        "id": 311133347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947455
    },
    {
        "content": "<p>probably not</p>",
        "id": 311133371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947464
    },
    {
        "content": "<p>there are a few other consumers of the file rename map as well, like <code>leanproject --port-progress</code>, so I think we will have to live with the misalignment</p>",
        "id": 311133442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668947514
    },
    {
        "content": "<p>probably not a big problem, since that file is probably not imported too often</p>",
        "id": 311133502,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668947525
    },
    {
        "content": "<p>Now that we are on this, shouldn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSmul#doc\">docs4#HasSmul</a> be <code>HasSMul</code> or even <code>SMul</code> according to the <a href=\"https://leanprover.github.io/lean4/doc/lean3changes.html#style-changes\">Lean4 manual</a>?</p>",
        "id": 311134172,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1668947855
    },
    {
        "content": "<p><code>SMul</code></p>",
        "id": 311134644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1668948071
    },
    {
        "content": "<p>I've proposed this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/606\">mathlib4#606</a></p>",
        "id": 311134700,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1668948116
    },
    {
        "content": "<p>But feel free to open another PR for that, I can just merge master in my PR</p>",
        "id": 311134770,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1668948141
    },
    {
        "content": "<p>I think we can just merge <code>algebra.order.zero_le_one</code> with <code>algebra.order.monoid.defs</code>. None imports one but not the other.</p>",
        "id": 311147151,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668954648
    },
    {
        "content": "<p>yes, but let's please do that later. I already have <a href=\"https://github.com/leanprover-community/mathlib4/pull/664\">mathlib4#664</a></p>",
        "id": 311147805,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668955021
    },
    {
        "content": "<p>No need to hasten. We can do things right: <a href=\"https://github.com/leanprover-community/mathlib/pull/17646\">#17646</a></p>",
        "id": 311149794,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668956186
    },
    {
        "content": "<p>I edited the porting wiki to make the naming rules clearer &amp; added more examples. Please review for accuracy...</p>",
        "id": 311158422,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668961085
    },
    {
        "content": "<p>While we are on it, I'm not at all clear why <code>Ne</code> is UpperCamelCase and isn't treated like <code>LT</code> -- is this to follow <code>Eq</code>?</p>",
        "id": 311158641,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668961215
    },
    {
        "content": "<p>nevermind -- I see this discussion above.</p>",
        "id": 311161023,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668962679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span>, I agree with <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> here that <a href=\"https://github.com/leanprover-community/mathlib/pull/17646\">#17646</a> is worth doing first.</p>",
        "id": 311183600,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977191
    },
    {
        "content": "<p>But we should avoid doing this too much, it is costly in time. However in this case it detangles some imports, and I think is valuable.</p>",
        "id": 311183666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, could you keep an eye on that PR and merge as soon as CI completes? I'm going to be offline for a while.</p>",
        "id": 311183766,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977327
    },
    {
        "content": "<p>No sorry I locked myself in the library for the next 4 jours <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 311183810,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668977362
    },
    {
        "content": "<p>CI is broken, in fact, but I can push a fix</p>",
        "id": 311183826,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668977383
    },
    {
        "content": "<p>Okay :-)</p>",
        "id": 311183830,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977384
    },
    {
        "content": "<p>But I welcome anyone to keep an eye on it</p>",
        "id": 311183836,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668977390
    },
    {
        "content": "<p>Good luck with exams!!</p>",
        "id": 311183839,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977392
    },
    {
        "content": "<p>Thanks Ruben!</p>",
        "id": 311183893,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668977405
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>, I just fixed it, but have limited internet and can't push. :-)</p>",
        "id": 311183907,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977414
    },
    {
        "content": "<p>I seem to be allowed to use http, but not ssh, on this network. What fun.</p>",
        "id": 311183936,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977442
    },
    {
        "content": "<p>Then I guess I unfairly beat you to it :)</p>",
        "id": 311183976,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668977475
    },
    {
        "content": "<p>Exams are far still. The only thing I am preparing to beat up is myself.</p>",
        "id": 311184055,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668977524
    },
    {
        "content": "<p>I've added a https remote, and will be ready for the next one. I guess I actually need a VPN.</p>",
        "id": 311184095,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>, could you double check you got the right imports there? I think you imported more than necessary.</p>",
        "id": 311184603,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668977986
    },
    {
        "content": "<p>The error was missing <code>linear_ordered_comm_monoid_with_zero</code>, which grep tells me is declared in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">algebra</span><span class=\"bp\">/</span><span class=\"n\">order</span><span class=\"bp\">/</span><span class=\"n\">monoid</span><span class=\"bp\">/</span><span class=\"n\">with_zero.lean</span><span class=\"o\">:</span><span class=\"kd\">class</span> <span class=\"n\">linear_ordered_comm_monoid_with_zero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so I think it's right?</p>",
        "id": 311184803,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668978120
    },
    {
        "content": "<p>Oh, hmm. Maybe <code>order.hom.basic</code> is not required now, as it's transitively imported? But that doesn't matter. Sorry for the noise.</p>",
        "id": 311185058,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668978287
    },
    {
        "content": "<p>There's another failure now.</p>",
        "id": 311185108,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668978320
    },
    {
        "content": "<p>Want me to take a look at this one too?</p>",
        "id": 311185243,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668978441
    },
    {
        "content": "<p>Could you? I'm getting confused by not having ssh access and sorting out alternate remotes. :-(</p>",
        "id": 311185275,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668978479
    },
    {
        "content": "<p>Sure</p>",
        "id": 311185353,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1668978524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/311183666\">said</a>:</p>\n<blockquote>\n<p>But we should avoid doing this too much, it is costly in time. However in this case it detangles some imports, and I think is valuable.</p>\n</blockquote>\n<p>I am sorry, I did not look at the PR and thought it was just doing the merging, not the other cleanup.<br>\nIf the process of untangling imports causes delays in the porting then I am not so sure whether it is a good idea to do it before porting. We have to port all files anyways and moving things around in mathlib3 makes the port only faster if the number of files to port is the bottleneck. Of course these refactors are worthwhile in their own right.</p>",
        "id": 311198644,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1668989818
    },
    {
        "content": "<p>Are we changing <code>coe</code> in names to the name of the function they unfold to?</p>",
        "id": 311480065,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669067086
    },
    {
        "content": "<p>I think we should</p>",
        "id": 311480234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669067167
    },
    {
        "content": "<p>that's what I thought, good.</p>",
        "id": 311480280,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669067190
    },
    {
        "content": "<p>I mean, the function itself might be named <code>coe</code>, maybe we should use that name more consistently for coe-registered functions</p>",
        "id": 311480352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669067232
    },
    {
        "content": "<p>e.g. <code>Nat.cast</code> -&gt; <code>Nat.coe</code></p>",
        "id": 311480386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669067261
    },
    {
        "content": "<p>What about <code>Units.val</code>? Moreover, what if there is more than one coercion on a given type (e.g., <code>ℝ≥0</code> coerces to both <code>ℝ</code> and <code>ℝ≥0∞</code>)?</p>",
        "id": 311480824,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669067513
    },
    {
        "content": "<p>if the function has a better name then that's fine</p>",
        "id": 311480924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669067551
    },
    {
        "content": "<p>I would not use the name <code>coe</code> in either of those examples</p>",
        "id": 311480939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669067564
    },
    {
        "content": "<p>I assume we don't want to write <code>toFun</code> in lemma names.</p>",
        "id": 311494887,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669074441
    },
    {
        "content": "<p>that one does sound like a function we should call <code>coe</code></p>",
        "id": 311495295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669074697
    },
    {
        "content": "<p>Shouldn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSmul#doc\">docs4#HasSmul</a> just be called <code>Smul</code>?</p>",
        "id": 311759379,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669183263
    },
    {
        "content": "<p>there is a PR that does that rename</p>",
        "id": 311760732,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1669184356
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/606\">mathlib4#606</a></p>",
        "id": 311760817,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1669184407
    },
    {
        "content": "<p>aha, thanks.</p>",
        "id": 311761039,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669184577
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">IsBot.is_min</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsBot</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsMin</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Should this be <code>IsBot.isMin</code>?</p>",
        "id": 312004750,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1669293098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/312004750\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">IsBot.is_min</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsBot</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsMin</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Should this be <code>IsBot.isMin</code>?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/713\">https://github.com/leanprover-community/mathlib4/pull/713</a></p>",
        "id": 312031184,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1669301162
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Make a ring homomorphism from an additive group homomorphism from a commutative ring to an</span>\n<span class=\"sd\">integral domain that commutes with self multiplication, assumes that two is nonzero and `1` is sent</span>\n<span class=\"sd\">to `1`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mkRingHomOfMulSelfOfTwoNeZero</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_two</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h_one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→+*</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>Could / should this be <code>mkRingHom_of_mul_self_of_two_ne_zero</code>?</p>",
        "id": 315558410,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670928427
    },
    {
        "content": "<p>This is the last question remaining on <a href=\"https://github.com/leanprover-community/mathlib4/pull/958\">mathlib4#958</a>, so probably I'll merge as is.</p>",
        "id": 315558996,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670928624
    },
    {
        "content": "<p>Maybe it’s not aesthetically pleasing, but I don’t see this as any worse than the super long auto generated instance names</p>",
        "id": 315559206,
        "sender_full_name": "Winston Yin",
        "timestamp": 1670928691
    },
    {
        "content": "<p>Well you're not really supposed to need to refer to instances by name, while you do refer to defs by name.</p>",
        "id": 315559346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670928732
    },
    {
        "content": "<p>the current naming convention says no, but I am certainly sympathetic to wanting to snake case this</p>",
        "id": 315562482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670929678
    },
    {
        "content": "<p>but it could also get a shorter name which is less about symbol reading</p>",
        "id": 315562668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670929736
    },
    {
        "content": "<p>I don't think we need to block on this for that PR, I just though I should raise it for future consideration</p>",
        "id": 315566532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670930934
    },
    {
        "content": "<p>Perhaps something like \"Switch to snake case for trailing <code>prop</code> arguments\"</p>",
        "id": 315566577,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670930951
    },
    {
        "content": "<p>Just found an interesting capitalisation error. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Disjoint.comm#doc\">docs4#Disjoint.comm</a> should be <code>disjoint.comm</code> because it's a lemma name and dot notation doesn't apply, but clearly the weird name threw off whoever ported it.</p>",
        "id": 320116931,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210225
    },
    {
        "content": "<p>Should it not be <code>disjoint_comm</code> to match with things like <code>disjoint_self</code> and <code>disjoint_bot_left</code>?</p>",
        "id": 320117062,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210330
    },
    {
        "content": "<p>Presumably this should apply to the original mathlib3 name too.</p>",
        "id": 320117078,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210342
    },
    {
        "content": "<p>Yes, I am renaming it to <code>disjoint_comm</code>. We could backport the change, but also the <code>#align</code> will take care of it for us so we can avoid the fuss.</p>",
        "id": 320117110,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210379
    },
    {
        "content": "<p>Ah, nice.</p>",
        "id": 320117123,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210387
    },
    {
        "content": "<p>I don't think <code>disjoint.comm</code>would be correct</p>",
        "id": 320117129,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673210393
    },
    {
        "content": "<p>Yeah, there's no <code>disjoint</code> namespace.</p>",
        "id": 320117183,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210408
    },
    {
        "content": "<p>Or rather, there shouldn't be.</p>",
        "id": 320117190,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210414
    },
    {
        "content": "<p>I didn't want to throw people off by suggesting removing the namespace, but I guess we agree <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 320117214,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210443
    },
    {
        "content": "<p>I guess this is a good reason to get rid of the weird <a href=\"https://leanprover-community.github.io/mathlib_docs/find/and.comm\">docs#and.comm</a> and friends</p>",
        "id": 320117257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210502
    },
    {
        "content": "<p>The names of those lemmas do look pretty weird.</p>",
        "id": 320117319,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210532
    },
    {
        "content": "<p>I wonder if this is a lint that can be made? If there is a definition/theorem where its namespace is capitalised, it must refer to an item in the environment?</p>",
        "id": 320117380,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210595
    },
    {
        "content": "<p>...and dot notation should apply.</p>",
        "id": 320117388,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210607
    },
    {
        "content": "<p>Or phrased another way; never have two namespaces which are case-insensitively the same?</p>",
        "id": 320117429,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673210642
    },
    {
        "content": "<p>Ah, in fact this is a much wider problem than I originally thought. There are some predicates that have corresponding namespaces, and all the basic API about them is dumped into that namespace even when there is no dot notation possible.</p>",
        "id": 320117481,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210653
    },
    {
        "content": "<p>Consider <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Commute#doc\">docs4#Commute</a></p>",
        "id": 320117491,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210666
    },
    {
        "content": "<p>I don't think we need to worry about this too much in the port</p>",
        "id": 320117495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673210673
    },
    {
        "content": "<p>It's already inconsistent in mathlib 3</p>",
        "id": 320117528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673210699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/320117429\">said</a>:</p>\n<blockquote>\n<p>Or phrased another way; never have two namespaces which are case-insensitively the same?</p>\n</blockquote>\n<p>This wouldn't fix the original issue, because the namespace was translated to <code>Disjoint</code>.</p>",
        "id": 320117536,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210702
    },
    {
        "content": "<p>The thing is that our new naming convention makes it matter <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 320117568,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210735
    },
    {
        "content": "<blockquote>\n<p>This wouldn't fix the original issue, because the namespace was translated to Disjoint.</p>\n</blockquote>\n<p>That's correct though?</p>",
        "id": 320117581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673210755
    },
    {
        "content": "<p>I think we're talking about different things, I was suggesting that a linter deny the use of the <code>Disjoint</code> namespace when dot notation can't be used, like in <code>Disjoint.comm</code>.</p>",
        "id": 320117666,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210793
    },
    {
        "content": "<p>I could very easily be misunderstanding though</p>",
        "id": 320117678,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/naming.20conventions/near/320117568\">said</a>:</p>\n<blockquote>\n<p>The thing is that our new naming convention makes it matter <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>\n</blockquote>\n<p>At least from my perspective it's just making assumptions visible that we didn't realise we were making</p>",
        "id": 320117719,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210840
    },
    {
        "content": "<p>The thing is that we want to allow lemmas such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add_le_add#doc\">docs4#Nat.add_le_add</a>...</p>",
        "id": 320117732,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210852
    },
    {
        "content": "<p>That makes sense, so my suggestion for a lint rule would absolutely not work.</p>",
        "id": 320117807,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210891
    },
    {
        "content": "<p>But then again, that implies <code>Disjoint.comm</code> is a reasonable spelling.</p>",
        "id": 320117834,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210915
    },
    {
        "content": "<p>In this context, <code>disjoint_comm</code> is clearer, but I can't really tell why I think that.</p>",
        "id": 320117847,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210933
    },
    {
        "content": "<p>I think your linter is reasonable so long as it only runs on namespaces associated to predicates.</p>",
        "id": 320117854,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210942
    },
    {
        "content": "<p>In fact, this is the same dichotomy I am making to decide whether a given lemma should be protected (see for example <a href=\"https://github.com/leanprover-community/mathlib/pull/18076\">#18076</a>)</p>",
        "id": 320117894,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673210987
    },
    {
        "content": "<p>I think I'd need to see more examples to convince myself it's a good idea.</p>",
        "id": 320117896,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673210990
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>, because we're talking about the linter I made you write</p>",
        "id": 320117960,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673211018
    },
    {
        "content": "<p>Empirically, we open namespaces associated to structures, and we don't open namespaces associated to predicates.</p>",
        "id": 320118026,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673211066
    },
    {
        "content": "<p>(ignore)</p>",
        "id": 320118072,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673211114
    },
    {
        "content": "<p>The best dichotomy would be to see whether a given namespace is ever opened, but that sounds like a terrible idea <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 320118152,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673211150
    },
    {
        "content": "<p>The problem I see with <code>Disjoint.comm</code> is that</p>\n<ul>\n<li>opening the namespace is bad because you end up with the badly named <code>comm</code></li>\n<li>not opening the namespace is bad because you have to write <code>Disjoint.comm</code> every time, so you should have named it <code>disjoint_comm</code> instead</li>\n</ul>",
        "id": 320118474,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673211366
    },
    {
        "content": "<blockquote>\n<ul>\n<li>opening the namespace is bad because you end up with the badly named <code>comm</code></li>\n</ul>\n</blockquote>\n<p>I don't see how this is any worse than opening the namespace and getting <code>symm</code></p>",
        "id": 320119723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673212436
    },
    {
        "content": "<p>I agree, opening that namespace is just generally bad.</p>",
        "id": 320119787,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673212467
    },
    {
        "content": "<p>I think that's true of a very large number of namespaces</p>",
        "id": 320119795,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673212487
    },
    {
        "content": "<p>It is definitely annoying that in lean 3 you could try <code>foo_bar.baz</code> and <code>foo_bar_baz</code> when looking for a lemma, but in Lean 4 you have to try <code>FooBar.bar</code> and <code>fooBar_baz</code> which is more than one character different</p>",
        "id": 320119937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673212604
    },
    {
        "content": "<p>Is it possible for the LSP to just know that those mean the same thing?</p>",
        "id": 320119985,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673212638
    },
    {
        "content": "<p>It could certainly offer to autocorrect the wrong one to the right one</p>",
        "id": 320120057,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673212683
    },
    {
        "content": "<p>Am I right in saying that we have a rule that functions in Prop (such as <code>Disjoint</code>) should be <code>UpperCamelCase</code>? If so, why do <code>Nonempty.intro</code> and <code>LE.le</code> not follow this rule?</p>",
        "id": 320920839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673525086
    },
    {
        "content": "<p>Because it's in core. I had a conversation with Leo about this; one of the points he disagrees with on the current style guide is that structure fields being capitalized is too weird (examples given include <code>Membership.mem</code> and <code>LE.le</code>). I've been putting off what to do about this situation, but there is an open PR <a href=\"https://github.com/leanprover/lean4/pull/1897\">lean4#1897</a> about it. Leo has indicated that he doesn't want to lose hair in naming convention discussions, which I totally understand. I'm not really sure how best to approach the situation, but it would be good if we could find a compromise which isn't just special casing these classes.</p>",
        "id": 320927863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673527305
    },
    {
        "content": "<p>If we want a compromise rule that includes these cases, how about:</p>\n<blockquote>\n<p>Structure fields which are not exported and which would otherwise be UpperCamelCase are instead lowerCamelCase.</p>\n</blockquote>",
        "id": 321091598,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673592331
    },
    {
        "content": "<p>The carve-out for exported things makes naming a bit more subtle, but has the benefit of making usage and reading more consistent.</p>\n<p>The “real” rule that this implements is just “if it follows a dot, it starts with a lowercase letter” (otherwise it’s named normally)</p>",
        "id": 321091631,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673592354
    },
    {
        "content": "<p>I'm still confused. Is this right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ndinter_eq_zero_iff_disjoint</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ndinter</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>or should <code>disjoint</code> in the name be <code>Disjoint</code>?</p>",
        "id": 321231955,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1673635583
    },
    {
        "content": "<p>It should be <code>disjoint</code> because of <code>lowerCamelCase</code></p>",
        "id": 321232078,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673635616
    }
]
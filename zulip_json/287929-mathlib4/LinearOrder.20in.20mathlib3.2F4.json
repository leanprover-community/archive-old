[
    {
        "content": "<p>Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">,</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">decidable_le</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">decidable_eq</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">max</span> <span class=\"o\">:=</span> <span class=\"n\">bor</span><span class=\"o\">,</span>\n  <span class=\"n\">max_def</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">funext</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">},</span>\n  <span class=\"n\">min</span> <span class=\"o\">:=</span> <span class=\"n\">band</span><span class=\"o\">,</span>\n  <span class=\"n\">min_def</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">funext</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">LE.le</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">LE.le</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">LE.le</span> <span class=\"n\">Preorder.toLE</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n  <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">LE.le</span> <span class=\"n\">Preorder.toLE</span> <span class=\"n\">PartialOrder.toPreorder</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n  <span class=\"n\">decidable_le</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">LE.le</span> <span class=\"n\">Preorder.toLE</span> <span class=\"n\">PartialOrder.toPreorder</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inferInstance</span>\n  <span class=\"n\">decidable_eq</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n  <span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Iff.rfl</span>\n</code></pre></div>\n<p>Three differences: <br>\n1) Fields of structures are not seen through with <code>decide</code>, whereas they were with <code>dec_trivial</code> (and because structures extend other structures one has to unfold more and more as we go on)<br>\n2) <code>lt_iff_not_le</code> had <code>. order_laws_tac</code> in mathlib3. Does this tactic exist in mathlib4?<br>\n3) <code>max</code> and <code>min</code> are bundled into the definition in mathlib3, not in mathlib4. </p>\n<p>Should I worry about any of these?</p>",
        "id": 305410433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1666374013
    },
    {
        "content": "<p>(3) is <a href=\"https://github.com/leanprover-community/mathlib4/issues/369\">https://github.com/leanprover-community/mathlib4/issues/369</a></p>",
        "id": 305411216,
        "sender_full_name": "David Renshaw",
        "timestamp": 1666374290
    },
    {
        "content": "<p>(added a comment there to elaborate a bit)</p>",
        "id": 305412970,
        "sender_full_name": "David Renshaw",
        "timestamp": 1666374917
    },
    {
        "content": "<p>IIRC <code>order_laws_tac</code> is an extremely simple tactic, something like <code>intros; refl</code>. So <code>:= by intros; rfl</code> is a reasonable replacement</p>",
        "id": 305441399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666385789
    },
    {
        "content": "<p>(In lean 3 there was the restriction that auto params had to be just a name, which names a global definition containing the actual tactic, so even really trivial tactics had to be wrapped up like this. In lean 4 this process is automatic)</p>",
        "id": 305441588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666385869
    },
    {
        "content": "<p>although I guess mathport can do this alignment too</p>",
        "id": 305441667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666385892
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/blob/fc13c8c72a15dab71a2c2b31410c2cadc3526bd7/library/init/meta/tactic.lean#L1879\">https://github.com/leanprover-community/lean/blob/fc13c8c72a15dab71a2c2b31410c2cadc3526bd7/library/init/meta/tactic.lean#L1879</a></p>",
        "id": 305442300,
        "sender_full_name": "David Renshaw",
        "timestamp": 1666386125
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">order_laws_tac</span> <span class=\"o\">:=</span> <span class=\"n\">whnf_target</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">intros</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">to_expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">iff.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">exact</span>\n</code></pre></div>",
        "id": 305442335,
        "sender_full_name": "David Renshaw",
        "timestamp": 1666386139
    },
    {
        "content": "<p>I can't tell whether that's actually equivalent to <code>intros; rfl</code>.</p>",
        "id": 305442494,
        "sender_full_name": "David Renshaw",
        "timestamp": 1666386205
    },
    {
        "content": "<p>that's <code>intros; exact iff.rfl</code></p>",
        "id": 305446984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666388229
    },
    {
        "content": "<p>If I try to put that in the <code>class Preorder</code> declaration in mathlib4, I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">auto</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">identifier</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">allowed</span>\n</code></pre></div>",
        "id": 305447332,
        "sender_full_name": "David Renshaw",
        "timestamp": 1666388380
    },
    {
        "content": "<p>I've added the <code>:= by intros; rfl</code> to <code>Preorder</code> as part of <a href=\"https://github.com/leanprover-community/mathlib4/pull/534\">mathlib4#534</a>, where @kbuzzard needed it.</p>",
        "id": 308227602,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667724294
    },
    {
        "content": "<p>Regarding Kevin's point 1) above, here is a standalone example.</p>\n<p>In Lean 3, we can:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">forall_bool</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"n\">false</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">decidable_of_decidable_of_iff</span> <span class=\"n\">infer_instance</span> <span class=\"n\">forall_bool.symm</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n  <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"c1\">-- No unfolding necessary.</span>\n</code></pre></div>\n<p>while in Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">LE</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">forall_bool</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"n\">false</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">decidable_of_decidable_of_iff</span> <span class=\"n\">forall_bool.symm</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n  <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">LE.le</span><span class=\"bp\">;</span> <span class=\"n\">decide</span> <span class=\"c1\">-- how do we do this without the unfold?</span>\n</code></pre></div>",
        "id": 308228493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667725035
    },
    {
        "content": "<p>I've merged the PR, leaving a link to this discussion.</p>",
        "id": 308321921,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667792533
    }
]
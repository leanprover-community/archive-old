[
    {
        "content": "<p>I am porting <code>Mathlib.Order.Copy</code>. In mathlib3 there is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bounded_order.copy</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">bounded_order</span> <span class=\"n\">α</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_top</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">bounded_order.top</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_bot</span> <span class=\"o\">:</span> <span class=\"n\">bot</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">bounded_order.bot</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">le_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">has_le.le</span> <span class=\"n\">α</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">bounded_order</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">top</span> <span class=\"o\">:=</span> <span class=\"n\">top</span><span class=\"o\">,</span> <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"n\">bot</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">abstract</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">casesI</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">simp_rw</span> <span class=\"n\">le_eq</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Let's forget that <code>abstract</code> is not ported, this is not a problem.</p>\n<p>First of all <code>@BoundedOrder.top α _ c</code> does not exist, I changed it to <code>(@BoundedOrder.toOrderTop α _ c).top</code>, I don't know if there is a shorter version.</p>\n<p>Secondly, if I try something like (that more or less follows the mathlib3 proof)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">refine'</span>\n    <span class=\"o\">{</span> <span class=\"n\">top</span> <span class=\"o\">:=</span> <span class=\"n\">top</span><span class=\"o\">,</span>\n      <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"n\">bot</span><span class=\"o\">,</span>\n      <span class=\"n\">le_top</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"n\">bot_le</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">h'</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">h</span>\n</code></pre></div>\n<p>so it seems Lean4 is not smart enough to understand it is supposed to use <code>h</code>, but Lean3 was. A working proof is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BoundedOrder.copy</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">α</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">eq_top</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">BoundedOrder.toOrderTop</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">top</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">eq_bot</span> <span class=\"o\">:</span> <span class=\"n\">bot</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">BoundedOrder.toOrderBot</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bot</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">le_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE.le</span> <span class=\"n\">α</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">BoundedOrder.mk</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OrderTop.mk</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"o\">{</span> <span class=\"n\">top</span> <span class=\"o\">:=</span> <span class=\"n\">top</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eq_top</span><span class=\"o\">,</span> <span class=\"n\">le_eq</span><span class=\"o\">]))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OrderBot.mk</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"o\">{</span> <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"n\">bot</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eq_bot</span><span class=\"o\">,</span> <span class=\"n\">le_eq</span><span class=\"o\">]))</span>\n</code></pre></div>\n<p>Is there a nicer way?</p>",
        "id": 317713595,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1671883234
    },
    {
        "content": "<p>Something that also works is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BoundedOrder.copy</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">α</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">eq_top</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">Top</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">top</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">eq_bot</span> <span class=\"o\">:</span> <span class=\"n\">bot</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">Bot</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bot</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">le_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE.le</span> <span class=\"n\">α</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">α</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>I am a little surprised that <code>infer_instance</code> finds <code>Top α</code>, since <code>c</code> is not in square brackets...</p>",
        "id": 317716438,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1671884479
    },
    {
        "content": "<p>The square bracket thing is just for other functions using your function, it doesn't affect how your function elaborates. If it's before the colon and a typeclass it goes in the instance cache regardless of what brackets you use. This is the same in lean 3 and it surprised me when I discovered it too!</p>",
        "id": 317717927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671885161
    },
    {
        "content": "<p>Good to know!</p>",
        "id": 317718191,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1671885273
    },
    {
        "content": "<p>This has come up repeatedly, <a href=\"#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.60.28_.29.60.20vs.20.60_.60.20syntax</a> is related</p>",
        "id": 317740911,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1671895866
    },
    {
        "content": "<p>As I understand it, It's not Lean4 is not smart enough; it's that it's decided that the spelling you wanted to use isn't allowed any more</p>",
        "id": 317741172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1671896021
    },
    {
        "content": "<p>The solution is to use <code>@bounded_order.mk</code> with <code>(_)</code> in place of the typeclass arguments</p>",
        "id": 317741246,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1671896066
    },
    {
        "content": "<p>That is, you can replace <code>h</code> with <code>(_)</code> in the proof</p>",
        "id": 317741285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1671896101
    }
]
[
    {
        "content": "<p>Is the definition of <code>IsRat</code> correct? Currently it seems to posit (given mouseovers and <code>pp.all true</code>) that <code>denom</code> is <code>Invertible</code> in <code>Nat</code>, which won't ever happen. (Or does it?)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">IsRat</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">denom</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The denominator is invertible. -/</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">Invertible</span> <span class=\"n\">denom</span>\n  <span class=\"sd\">/-- The element is equal to the fraction with the specified numerator and denominator. -/</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">num</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"n\">denom</span>\n</code></pre></div>",
        "id": 320354059,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673308604
    },
    {
        "content": "<p>I think it is supposed to mean that <code>Invertible (denom : \\alpha)</code>.</p>",
        "id": 320354273,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1673308739
    },
    {
        "content": "<p>That works, afaict; nice. I was also wondering, though, if this is an artifact of some earlier time in the port, and if <code>isRat</code> should be rewritten to <code>IsRat [Ring α] (a : α) (q : ℚ)</code>.</p>",
        "id": 320354664,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673308908
    },
    {
        "content": "<p>Why is that? Ah, right, Mario wanted to have it all be passing around <code>ℚ</code></p>",
        "id": 320354791,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1673308963
    },
    {
        "content": "<p>Neat, I'll change it. :)</p>",
        "id": 320354918,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673309036
    },
    {
        "content": "<p>Oops, I mean <code>IsRat [DivisionRing α] (a : α) (q : ℚ)</code>.</p>",
        "id": 320355117,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673309153
    },
    {
        "content": "<p>New question: what's the \"right\" way to write rationals in terms of numerators and denominators? Say I want to construct the most \"general\" form of a rational for use in e.g. matching.</p>\n<p>Is it<code>/</code>? It seems a little high-level, but maybe it gets elaborated away or something. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">IsRat.to_isNat</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span>\n    <span class=\"n\">IsRat</span> <span class=\"n\">a</span> <span class=\"o\">((</span><span class=\"n\">Int.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IsNat</span> <span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p><em>works</em>, but feels heavy-handed.</p>",
        "id": 320356604,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673309957
    },
    {
        "content": "<p>Should I go down to the structure level (<code>{ num := n, den := 1, den_nz := ... }</code>)? (<code>/.</code> syntax rings a bell, too, but I don't seem to have access to it in this file/know where it is.)</p>",
        "id": 320356743,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673310022
    },
    {
        "content": "<p>Yes, I'd use <code>/</code>.  And don't use <code>Int.ofNat</code>.  Use coercions (or <code>Int.cast</code>) directly.</p>",
        "id": 320356859,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673310106
    },
    {
        "content": "<p>In this case you should be able to write <code>IsRat a n</code>.</p>",
        "id": 320356932,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673310132
    },
    {
        "content": "<p>Ah, okay, great, thanks.</p>",
        "id": 320357027,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673310202
    },
    {
        "content": "<p>Btw, I was patterning the <code>ofNat</code> bit off of the pre-existing <code>IsInt.to_isNat</code> above—is the use of <code>ofNat</code> there still okay, or should it be similarly changed?</p>",
        "id": 320357058,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673310228
    },
    {
        "content": "<p>Yes, I'd avoid <code>Int.ofNat</code> where possible.</p>",
        "id": 320357384,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673310380
    },
    {
        "content": "<p>Hmm, just to be sure before I change the whole file: was it written this way because it has something to do with using literals in this context? All of the functions here in <code>norm_num</code> are meant to be passing around literals, I think, and I have a small note from a little while back written down saying \"ofNat is for literals that lean uses; Nat.cast is for variables\". Have things changed since this file was written such that casting is now preferred everywhere?</p>",
        "id": 320358686,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673311163
    },
    {
        "content": "<p><code>OfNat.ofNat</code> is something entirely different.  It's only for numeric literals.  (and the argument should always be a nat_lit)  <code>OfNat.ofNat</code> is ok.</p>",
        "id": 320358813,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673311215
    },
    {
        "content": "<p><code>Int.ofNat</code> is the one that shouldn't be there imho.</p>",
        "id": 320358827,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1673311226
    },
    {
        "content": "<p>Interesting...that clarifies things a bit, thanks.</p>",
        "id": 320358857,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673311251
    },
    {
        "content": "<p>The purpose of the <code>IsNat</code> and <code>IsInt</code> functions is to say <code>a = n</code> where <code>n</code> is a <code>Nat</code> or <code>Int</code>, but written using as few expr operators as possible: <code>n</code> is \"raw\" here. In the case of <code>Nat</code>, it's a raw nat literal, and in the case of <code>Int</code> it is a \"raw int literal\", which means a raw nat literal wrapped in <code>Int.ofNat</code> or <code>Int.negOfNat</code>. With <code>IsRat</code> the idea was to have a \"raw rat literal\" be represented as a numerator and denominator in separate arguments, where the numerator is a raw int literal and the denominator is a raw nat literal. This is the form that norm_num uses internally for subproofs to avoid the overhead of building all the typeclass arguments associated with numeral construction.</p>\n<p>There are two ways to get out of this representation, depending on how it is being used.</p>\n<ul>\n<li>Some tactics are still using numbers internally but can't deal with <code>IsNat</code> at the head, they want it to be <code>=</code> there so they can put the resulting expression in a subterm. In that case we apply <code>Result.toRawEq</code> , which produces a \"raw nat cast expression\" which is like an <code>OfNat.ofNat</code> application but with simplified typeclass arguments.</li>\n<li>For the final result of the tactic to be seen by end-users, such as the result of <code>norm_num</code> after it has done normalization but has not closed the goal, we want to produce \"canonical\" numeral terms using the same constructors as users would normally use. This is done by the <code>Result.toSimpResult</code> function, which constructs a <code>OfNat.ofNat</code> term with the right typeclass arguments. For negative numbers, it applies <code>-</code> to an <code>ofNat</code>, and for rationals it uses <code>/</code> applied to two numerals. The result is expressions like <code>2</code>, <code>-2</code>, <code>0</code>, <code>1 / 2</code> and <code>-(2 / 3)</code> exactly like what you would get if you wrote those in a lean file (where the expected type is <code>α</code>).</li>\n</ul>",
        "id": 320368752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673318503
    },
    {
        "content": "<p>I don't think we need to change the definition of <code>IsRat</code>, except to fix the bug you noted about <code>Invertible (denom : α)</code>. It does not take a <code>Rat</code> and this is intentional. Since the invertibility assumption is inside the structure, it doesn't affect most theorem statements: you can prove that you can add and multiply <code>IsRat</code> terms without assuming anything beyond <code>Ring α</code>. The only time you need a division ring assumption is to prove that the denominator is invertible, and if we search directly for <code>Invertible denom</code> in that case, with a fallback using <code>DivisionRing α</code> if it doesn't already work out of the box, then we get the ability to work in characteristic-n rings almost for free. (There is a bit more work to make the division operator work without assuming <code>DivisionRing</code>, so I'm fine if v1 just assumes <code>DivisionRing</code> in this lemma and doesn't bother with the invertible stuff.)</p>",
        "id": 320369592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319331
    },
    {
        "content": "<p>Ohhkay, cool! So, just so I can get a better picture of things:</p>\n<ol>\n<li>what’s the underlying motivation for trying to reduce the number of expr operators? (performance somehow?)</li>\n<li>what counts as an expr operator? casting counts, I’m guessing, from context…but in general, what’s that mean? (elaboration-stage manipulation?)</li>\n</ol>\n<p>As for how to proceed:</p>\n<ol start=\"3\">\n<li>I won’t change the <code>ofNat</code>s, I’m guessing—just want to confirm we’re sticking with the original general approach.</li>\n<li>Likewise, should we stick with the original <code>isRat</code>? This is less clear to me—having a <code>Rat</code> guarantees the arguments are well-formed, and the literals seem like they’re still “there”.</li>\n</ol>\n<p>However…I’m wondering if the previous-ish method of <code>Invertible (d : α)</code> ensured that the cast to <code>α</code>works for division rings that aren’t char zero, and this feels like it might be important.</p>",
        "id": 320369594,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319335
    },
    {
        "content": "<p>Oops, sent at the same time, let me read that.</p>",
        "id": 320369608,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319351
    },
    {
        "content": "<blockquote>\n<p>what’s the underlying motivation for trying to reduce the number of expr operators? (performance somehow?)</p>\n</blockquote>\n<p>Yes, performance. The expr construction is the main bottleneck when constructing huge norm_num proofs (and the performance of norm_num is quite often the limiting factor on numerical proofs like proving the first n digits of pi correct).</p>",
        "id": 320369718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319443
    },
    {
        "content": "<blockquote>\n<p>what counts as an expr operator? casting counts, I’m guessing, from context…but in general, what’s that mean? (elaboration-stage manipulation?)</p>\n</blockquote>\n<p>There is no elaboration-stage manipulation here, these terms are handed directly to the kernel. I'm talking about the number of calls to <code>Expr.app</code> and friends.</p>",
        "id": 320369815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319525
    },
    {
        "content": "<p>It is essentially the size of the expression you would see if you <code>pp.all</code> the term, except long names mostly don't count against you because they are shared.</p>",
        "id": 320369870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319595
    },
    {
        "content": "<p>Ahh, ok, gotcha!</p>",
        "id": 320369931,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319621
    },
    {
        "content": "<p><code>OfNat.ofNat</code> has the big problem that <code>OfNat</code> is dependent, which means you need a different typeclass argument for every single number so they can't be shared. This basically doubles the number of terms we have to construct</p>",
        "id": 320370005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319691
    },
    {
        "content": "<p>So <code>IsNat</code> uses a <code>CommSemiring α</code> argument which is cached so it can be used in each subterm and shared</p>",
        "id": 320370105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319743
    },
    {
        "content": "<p>Hmm, ok…I’ll need to get back to my computer and look at the types of these to see where the dependence flows! Does lean cache automatically when it can?</p>",
        "id": 320370232,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319846
    },
    {
        "content": "<p>When you pass the same expr in multiple places, you construct a term with internal sharing</p>",
        "id": 320370249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319887
    },
    {
        "content": "<p>like if I do <code>(fun a =&gt; (a, a)) 17</code> there is only one <code>17</code> expr in memory and both members of the pair point to it</p>",
        "id": 320370274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319920
    },
    {
        "content": "<p>Oh, that’s great</p>",
        "id": 320370288,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319944
    },
    {
        "content": "<p>If I do <code>(17, 17)</code>  (i.e. elaborating <code>17</code> twice) there may or may not be two <code>17</code>'s in memory</p>",
        "id": 320370290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673319946
    },
    {
        "content": "<p>May not? <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 320370313,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319963
    },
    {
        "content": "<p>Like in the case where 17 is actually a generic expression, so to speak?</p>",
        "id": 320370362,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673319987
    },
    {
        "content": "<p>Lean is not hash-consed, if that's what you mean: we do not have the guarantee that identical subterms are always shared</p>",
        "id": 320370405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320039
    },
    {
        "content": "<p>so unless you do something in particular to cause the same expression to be copied around you can't rely on them being pointer-equal</p>",
        "id": 320370426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320066
    },
    {
        "content": "<p>Oh, yeah, that’s what I expected: I was wondering how they <em>could</em> wind up shared if input separately (not appearing as intermediate terms)</p>",
        "id": 320370493,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673320111
    },
    {
        "content": "<p>There is the <code>shareCommon</code> function in <code>Init</code> which will maximally deduplicate an expression, so if you gave it <code>(17, 17)</code> it would ensure that both components of the pair point to the same object</p>",
        "id": 320370497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320114
    },
    {
        "content": "<p>Lean does have a variety of elaboration caches though so it is possible for things to become shared in the course of elaboration</p>",
        "id": 320370531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320150
    },
    {
        "content": "<p>I don't think <code>shareCommon</code> is used in the elaborator</p>",
        "id": 320370542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320164
    },
    {
        "content": "<p>and it's a linear time operation so not very usable for a program like <code>norm_num</code> to run after each operation</p>",
        "id": 320370563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320198
    },
    {
        "content": "<p>I seeee, very cool…yeah, it felt possibly expensive-enough to be “opt-in only” even not knowing that it was linear-time, lol</p>",
        "id": 320370650,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673320264
    },
    {
        "content": "<p>So when we have a nat literal, there’s some magic to make it not a chain of <code>succ</code> applications, right? Assuming so, do induction proofs/definitions break that, or is there magic to deal with matching on <code>succ</code> too?</p>",
        "id": 320370959,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673320558
    },
    {
        "content": "<p>yes, raw nat literals are a concept core to lean itself, there is a constructor <code>Expr.lit</code> that has support for literal <code>Nat</code> and <code>String</code>, and the kernel uses bignum computation to do <code>Nat.add</code>/<code>Nat.mul</code>. This is really cool, it means that we don't have to do things one <code>bit0</code> at a time anymore and it's also a lot faster. So <code>norm_num</code> is now delegated to handling all the other number arithmetic that isn't special cased by the kernel, and arithmetic on other types like <code>Real</code> where the kernel will do something really stupid if you just ask it to prove it by <code>rfl</code></p>",
        "id": 320371141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673320724
    },
    {
        "content": "<p>Okay, gotcha, that is really cool! Makes sense!</p>",
        "id": 320371387,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673320937
    },
    {
        "content": "<blockquote>\n<p>Result.toRawEq , which produces a \"raw nat cast expression\" which is like an OfNat.ofNat application but with simplified typeclass arguments.</p>\n</blockquote>\n<p>So, okay...I'm trying to write the analogous <code>rawCast</code> expression for rationals. Thing is, it seems to depend on info stored in the <code>IsRat</code> structure, namely, that <code>denom</code> is invertible. Should these be instance arguments? E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">_root_.Rat.rawCast</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Invertible</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As-is, though, this fails with a \"failed to synthesize instance <code>Invertible ↑d</code>\" message which I find unusual—it's right there!</p>\n<p>Or, am I totally misinterpreting what a <code>rawCast</code> is?</p>",
        "id": 320534510,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673380888
    },
    {
        "content": "<p>Also, what's that <code>_root_</code> doing there in all these <code>rawCast</code>s?</p>",
        "id": 320534648,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673380925
    },
    {
        "content": "<p>It's to put the function in the <code>Nat</code> namespace</p>",
        "id": 320575129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673399607
    },
    {
        "content": "<p>The function should not take extra arguments, that would cause other problems. It could be a noncomputable definition, that is <code>if h : Invertible (d : A) then n * ⅟(d : α) else 0</code>, since it's only used in the middle of a proof where we don't care about computation</p>",
        "id": 320575437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673399819
    },
    {
        "content": "<p>actually it's probably best to just use <code>n / d</code> in a division ring for the definition of <code>rawCast</code>. The aforementioned expression does not have nice properties without more specific invertibility assumptions anyway. (That is, if you had two of those conditional expressions for different n,d it is not the case that <code>rawCast n1 d1 + rawCast n2 d2 = rawCast (n1 * d2 + n2 * d1) (d1 * d2)</code> without additional assumptions.)</p>",
        "id": 320575673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673399960
    },
    {
        "content": "<p>norm_num now works with rationals! <a href=\"https://github.com/leanprover-community/mathlib4/pull/1441\">mathlib4#1441</a></p>",
        "id": 321285774,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673657673
    },
    {
        "content": "<p>Mario and I spent a few hours today hammering it out; we sorried the proofs of the internal theorems given that the functionality is time-critical, but the actual tactic nonetheless now works as expected with rationals. I’ll try to respond to the just-incoming review comments asap. :)</p>",
        "id": 321286757,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673658359
    },
    {
        "content": "<p>I have a question for the mathematicians: Is it true in a ring <code>A</code> that if <code>((a : Nat) : A)</code> is invertible and <code>b</code> divides <code>a</code> then <code>((b : Nat) : A)</code> is also invertible? I think the answer is yes but there isn't anything obviously applicable from mathlib. This is needed for <code>norm_num</code> to reduce rational number expressions</p>",
        "id": 321304666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673676067
    },
    {
        "content": "<p>yes, by associativity for each side, e.g. 1 = a⁻¹a = a⁻¹(kb) = (a⁻¹k)b, yielding a⁻¹k as a left inverse and ka⁻¹ as a right one; then a⁻¹k = ka⁻¹ because natural numbers commute with everything in the ring</p>",
        "id": 321305428,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673676865
    },
    {
        "content": "<p>oh interesting, that argument doesn't need k to be nonzero</p>",
        "id": 321305686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673677176
    },
    {
        "content": "<p>so the <code>Nat.succ g</code> in our lemmas isn't needed after all</p>",
        "id": 321305747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673677208
    },
    {
        "content": "<p>well…it <em>kind</em> of does, because if k is 0, you can’t get that it times anything is equal to 1 and that first chain of equalities doesn’t work anymore 🙃 but if we’re allowing contradictory hypotheses (as might be the case with <code>g</code>, idk)…</p>",
        "id": 321306286,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673677717
    },
    {
        "content": "<p>(ok, unless you’re in the zero ring.)</p>",
        "id": 321306344,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673677771
    },
    {
        "content": "<p>sure, but that's not \"kind of works\", that is \"works\". The hypotheses are the hypotheses, the whole point is that you don't have to think about whether they are true or not since you are assuming they are</p>",
        "id": 321307036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673678488
    },
    {
        "content": "<p>the reason it doesn't result in nonsense in the norm_num application is that we have a bundled invertibility assumption which implies that all denominators are nonzero (as natural numbers), so <code>g</code> is provably nonzero even if we don't take it as an assumption</p>",
        "id": 321307168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673678599
    },
    {
        "content": "<p>yeah, absolutely—all I mean by “doesn’t work” is that if k = 0 (and A is not the zero ring) the argument blows up and you’re not in any real situation (well, we hope…)</p>",
        "id": 321308838,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673680195
    },
    {
        "content": "<p>If A is the zero ring however then k=0 is fine and the nat a doesn't have to be zero</p>",
        "id": 321316268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1673685587
    },
    {
        "content": "<p>cool, I incorporated this proof into <a href=\"https://github.com/leanprover-community/mathlib4/pull/1572\">mathlib4#1572</a> which kills all the remaining sorries</p>",
        "id": 321316382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673685653
    },
    {
        "content": "<p>probably the core pieces of those proofs should go somewhere in mathlib proper, it's a bit weird for those lemmas to actually have mathematical content beyond a library lemma</p>",
        "id": 321316552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673685749
    },
    {
        "content": "<p>I assume we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_unit_of_mul\">docs#is_unit_of_mul</a>? Edit: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_unit_of_dvd_unit\">docs#is_unit_of_dvd_unit</a></p>",
        "id": 321316981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673686036
    },
    {
        "content": "<p>Oh, this is interesting: norm_num is now unable to prove theorems like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">16</span> <span class=\"bp\">/</span> <span class=\"o\">((</span><span class=\"mi\">11</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"bp\">*</span> <span class=\"mi\">19</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">12</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">21</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">96</span><span class=\"bp\">/</span><span class=\"mi\">11</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>because the denominators are not necessarily invertible unless you assume that alpha is CharZero</p>",
        "id": 321317036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673686073
    },
    {
        "content": "<p>Speaking of <code>is_unit</code>, why do we even have <code>invertible</code> since it's basically the same thing?</p>",
        "id": 321317216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673686179
    },
    {
        "content": "<p>The latter is constructive</p>",
        "id": 321317308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673686220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321317036\">said</a>:</p>\n<blockquote>\n<p>Oh, this is interesting: norm_num is now unable to prove theorems like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">16</span> <span class=\"bp\">/</span> <span class=\"o\">((</span><span class=\"mi\">11</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"bp\">*</span> <span class=\"mi\">19</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">12</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"mi\">21</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">96</span><span class=\"bp\">/</span><span class=\"mi\">11</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>because the denominators are not necessarily invertible unless you assume that alpha is CharZero</p>\n</blockquote>\n<p>Specifically, norm_num will reduce the goal to <code>16 / (11 / 126 * 21) = 96 / 11</code> and then stop because it can't prove that <code>126</code> is invertible so it doesn't know how to clear the denominator</p>",
        "id": 321317583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673686387
    },
    {
        "content": "<p>I'm confused how this ever worked</p>",
        "id": 321317769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673686500
    },
    {
        "content": "<p>Aha, it's an issue in the translation of the test - the original lean 3 test file was assuming <code>LinearOrderedField α</code></p>",
        "id": 321318141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673686746
    },
    {
        "content": "<p>Ideally, we’d be able to look for the characteristic of the division ring, check coprimality to it, and if we have it (or if the characteristic is zero—not sure what convention is used) get an <code>Invertible</code> term, right? (I’m guessing we’d also want to normalize mod the characteristic, but I’d think this should be done in some basic evaluator way before the one for <code>/</code> if possible, and apply everywhere, not just when looking at inverses.)</p>\n<p>But, I guess this would only be possible if we had either <code>Char m α</code> (is that how we spell it?) for some literal m, <code>CharZero α</code>, or found a way to make use of assumptions about <code>m</code> in the context, like if it was some unknown prime or something (but maybe we have special ways of spelling that too?)—but I don’t know if all that searching would be performant. Though, if we could find the relevant info once and keep it, maybe it wouldn’t be too bad. Just thinking out loud.</p>",
        "id": 321323493,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673689436
    },
    {
        "content": "<p>I was thinking that (assuming there is no <code>CharZero</code> instance) you could look up and cache invertible instances for all the prime factors of the number. For the common case where you would want this kind of thing, it's always going to be 2 and/or 3 that you are searching for</p>",
        "id": 321324032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673689704
    },
    {
        "content": "<p>although I suppose for a ring of known characteristic that's less efficient than your approach if there are a lot of big primes being inverted</p>",
        "id": 321324328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673689854
    },
    {
        "content": "<p>It's basically two complementary situations you could be working in: if you have a known characteristic than everything is invertible except a fixed list of primes, or you might be working in a ring of \"any characteristic except 2 or 3\" in which case you know 2 and 3 are invertible but nothing else</p>",
        "id": 321324811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673690100
    },
    {
        "content": "<p>Oh interesting! How do we phrase that the ring has characteristic unequal to 2 or 3? Do we have some special way of writing it, or do we just have a hypothesis somewhere saying e.g. <code>m &gt; 2</code> or something? I’m wondering how we’ll tell which situation we’re in.</p>",
        "id": 321325112,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673690252
    },
    {
        "content": "<p>(Also, nitpick: everything except a fixed list of *multiples of primes! unless I’m misinterpreting?)</p>",
        "id": 321325504,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673690435
    },
    {
        "content": "<blockquote>\n<p>How do we phrase that the ring has characteristic unequal to 2 or 3?</p>\n</blockquote>\n<p><code>[Invertible (2 : R)] [Invertible (3 : R)]</code> I think</p>",
        "id": 321326932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673691040
    },
    {
        "content": "<p>That says a lot more—that it doesn’t have even characteristic/characteristic which is a multiple of 3</p>",
        "id": 321327073,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673691104
    },
    {
        "content": "<p><code>[NeZero (2 : R)]</code> <code>[NeZero (3 : R)]</code>?</p>",
        "id": 321327270,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1673691183
    },
    {
        "content": "<p>In mathlib I think this is what is used, anyways. I don't think people are overly concerned about the non-ID case</p>",
        "id": 321327323,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1673691207
    },
    {
        "content": "<p>If they aren’t already, some people will be eventually (hopefully!), so I feel like we ought to know what to do about it—it might also make other things easier indirectly if we’re able to know facts about the characteristic somehow</p>",
        "id": 321328537,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673691711
    },
    {
        "content": "<p><code>NeZero</code> is interesting! I wonder though if instead of looking for instances we can simply access outer hypotheses from within norm_num (without passing them in explicitly). Doing a single check through the context for relevant ones at one point might be useful.</p>",
        "id": 321328755,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673691809
    },
    {
        "content": "<p>I guess basically what we’d be looking for in this case are explicit inequalities constraining the characteristic or primality/divisibility facts. I can’t think of much else that would be useful for this kind of normalization…</p>",
        "id": 321330131,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673692358
    },
    {
        "content": "<p><code>ne_zero</code> is only useful in the presence of <code>is_domain</code> or whatever it's called. Then you can cancel nonzero things because ax=ay implies a(x-y)=0 so x-y=0</p>",
        "id": 321341753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1673696684
    },
    {
        "content": "<p>If you are dividing by things then they should be invertible of course.</p>",
        "id": 321347329,
        "sender_full_name": "Reid Barton",
        "timestamp": 1673698674
    },
    {
        "content": "<p>yeah I think <code>invertible</code> is superior to <code>ne_zero</code> in this situation since being zero or not is only really interesting in domains and fields, whereas invertibility is what matters for rings</p>",
        "id": 321350913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673700148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321347329\">said</a>:</p>\n<blockquote>\n<p>If you are dividing by things then they should be invertible of course.</p>\n</blockquote>\n<p>See, that’s what I thought! It’s still so weird to me that a potential divide-by-zero expression even typechecks. I get why it’s good for functions to be total and not have to take extra assumptions as arguments, but…it also seems like we’re missing out on something types are usually meant to help with, right? I feel like mathlib’s convention of having <code>x / 0 = 0</code> will somehow lead to human mistakes…</p>",
        "id": 321392179,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673719270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321350913\">said</a>:</p>\n<blockquote>\n<p>yeah I think <code>invertible</code> is superior to <code>ne_zero</code> in this situation since being zero or not is only really interesting in domains and fields, whereas invertibility is what matters for rings</p>\n</blockquote>\n<p>I think this is backwards: invertibility tells you what you need to know about the characteristic for integral domains and fields, since the characteristic is necessarily prime and therefore saying that e.g. 2 is invertible only eliminates the case that the characteristic is 2.</p>\n<p>But for rings, saying that 2 is invertible says that the characteristic is even, not that it’s not 2. If you want to make a statement about a general ring not having characteristic 2, you can’t do it with invertibility.</p>",
        "id": 321393224,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673719877
    },
    {
        "content": "<blockquote>\n<p>But for rings, saying that 2 is invertible says that the characteristic is even, not that it’s not 2. If you want to make a statement about a general ring not having characteristic 2, you can’t do it with invertibility.</p>\n</blockquote>\n<p>In this case I think the scenario would actually be even characteristic then, because the usual reason that kind of hypothesis pops up is because you want to invert 2.</p>",
        "id": 321393538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673720039
    },
    {
        "content": "<p>I'm thinking of stuff like the quadratic / cubic formula here, where you have to put 2 in the denominators of things and so you need an assumption that says that this is meaningful</p>",
        "id": 321393654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673720097
    },
    {
        "content": "<p>elliptic curve parameterization also involves a case split on the characteristic. I'm pretty sure in one of the cases we want to divide by 2 and not simply know that it is nonzero</p>",
        "id": 321393834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673720212
    },
    {
        "content": "<p>Yeah, that’s fair! Maybe knowing the characteristic is not one specific number is not really ever important for rings. All I can think of is the case where we know it’s not 2 because the ring doesn’t have some property char-2 rings have, but even then, knowing this doesn’t really help us normalize numbers.</p>",
        "id": 321393897,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673720252
    },
    {
        "content": "<p>Wow, a lot has happened in 24 hours!  Thank you so much <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>.</p>\n<p>Regarding your questions about the features of <code>norm_num</code> that I personally would like to use immediately:</p>\n<ul>\n<li>I would need it to work for <code>Real</code>, so <strong>yes</strong>, I need the functionality to assess denominators using either a <code>CharZero</code> instance or (if it's easier) a <code>LinearOrderedField</code> instance.</li>\n<li><strong>no</strong>, I will never use fields of nonzero characteristic or general rings in which certain numbers like 2 or 3 are known to be invertible</li>\n<li><strong>yes</strong>, I would need it to cope with ≤, &lt;, and ≠.</li>\n<li>since it would be used for problems assessed by an autograder, there need to be no sorries in the supporting lemmas.  But I can work on the sorries myself.</li>\n</ul>\n<p>I am still reading through the various PRs and haven't caught up yet on exactly which of this functionality you've implemented already.</p>",
        "id": 321399782,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1673723737
    },
    {
        "content": "<p>9 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/false.20alarm.20about.20norm_num\">#mathlib4 &gt; false alarm about norm_num</a> by <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>.</p>",
        "id": 321409403,
        "sender_full_name": "Notification Bot",
        "timestamp": 1673730825
    },
    {
        "content": "<p>Regarding the autograder, you could potentially add the missing theorems as axioms (and add them to your list of allowed axioms)</p>",
        "id": 321413688,
        "sender_full_name": "Reid Barton",
        "timestamp": 1673734579
    },
    {
        "content": "<p>True, although it seems unprincipled to make a change like that to mathlib for one person's purposes.  But in any case the sorries should be gone after <a href=\"https://github.com/leanprover-community/mathlib4/pull/1572\">mathlib4#1572</a>.</p>",
        "id": 321414877,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1673735572
    }
]
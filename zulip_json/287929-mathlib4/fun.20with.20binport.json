[
    {
        "content": "<p>This compiles in Lean4, importing binported oleans:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Nullstellensatz</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MvPolynomial.Playground</span>\n<span class=\"kn\">open</span> <span class=\"n\">Ideal</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">instField</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">k</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">instIAC</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgClosed</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">instF</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">σ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">vanishing_ideal_zero_locus_eq_radical</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial</span> <span class=\"n\">σ</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">vanishingIdeal</span> <span class=\"o\">(</span><span class=\"n\">ZeroLocus</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">I.radical</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">I.radical_eq_jacobson</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_Inf</span> <span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@λ</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"n\">case</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">J</span> <span class=\"o\">⟨</span><span class=\"n\">hJI</span><span class=\"o\">,</span> <span class=\"n\">hJ</span><span class=\"o\">⟩</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">is_maximal_iff_eq_vanishing_ideal_singleton</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hJ</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hx.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">vanishing_ideal_anti_mono</span> <span class=\"o\">(</span><span class=\"bp\">@λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">z</span><span class=\"o\">)</span>\n    <span class=\"n\">case</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mem_vanishing_ideal_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff.1</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">]</span>\n      <span class=\"n\">refine</span> <span class=\"n\">hJI</span> <span class=\"n\">hp</span>\n  <span class=\"n\">case</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mem_vanishing_ideal_singleton_iff</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">mem_Inf.mp</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"bp\">@</span><span class=\"n\">le_trans</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_vanishing_ideal_zero_locus</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">I</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">vanishing_ideal_anti_mono</span> <span class=\"o\">(</span><span class=\"bp\">@λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hy.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hx</span><span class=\"o\">)),</span>\n        <span class=\"n\">MvPolynomial.vanishing_ideal_singleton_is_maximal</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MvPolynomial.Playground</span>\n</code></pre></div>\n<p>It is very close to what synport would produce automatically.</p>",
        "id": 248283176,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1628025848
    },
    {
        "content": "<p>Just curious, what would synport product automatically?</p>",
        "id": 248287211,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1628028413
    },
    {
        "content": "<p>For comparison, <a href=\"https://github.com/leanprover-community/mathlib/blob/85025718208922ba937e5ec6352f04c7c90ae931/src/ring_theory/nullstellensatz.lean#L155-L170\">here</a> is the Lean 3 code.</p>",
        "id": 248287715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628028779
    },
    {
        "content": "<p>oof, it tripped on the <code>rintros</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- error: Mathport/Syntax/Translate/Basic.lean:221:16: unsupported tactic `rintros</span>\n<span class=\"sd\">/-- Main statement of the Nullstellensatz -/</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">vanishing_ideal_zero_locus_eq_radical</span>\n<span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">«</span><span class=\"n\">expr</span> <span class=\"bp\">=</span> <span class=\"bp\">»</span><span class=\"o\">(</span><span class=\"n\">vanishing_ideal</span> <span class=\"o\">(</span><span class=\"n\">zero_locus</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">I.radical</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">I.radical_eq_jacobson</span><span class=\"o\">]</span> <span class=\"o\">[],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">[</span><span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_Inf</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)],</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">[</span><span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"s2\">\"⟨\"</span><span class=\"o\">,</span> <span class=\"n\">hJI</span><span class=\"o\">,</span> <span class=\"s2\">\",\"</span><span class=\"o\">,</span> <span class=\"n\">hJ</span><span class=\"o\">,</span> <span class=\"s2\">\"⟩\"</span><span class=\"o\">],</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">[</span><span class=\"s2\">\"⟨\"</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"s2\">\",\"</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"s2\">\"⟩\"</span><span class=\"o\">,</span> <span class=\"s2\">\":=\"</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_maximal_iff_eq_vanishing_ideal_singleton</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hJ</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">[</span><span class=\"bp\">«</span><span class=\"n\">expr</span> <span class=\"bp\">▸</span> <span class=\"bp\">»</span><span class=\"o\">(</span><span class=\"n\">hx.symm</span><span class=\"o\">,</span> <span class=\"n\">vanishing_ideal_anti_mono</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">))],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"s2\">\"[\"</span><span class=\"o\">,</span> <span class=\"s2\">\"&lt;-\"</span><span class=\"o\">,</span> <span class=\"n\">mem_vanishing_ideal_singleton_iff</span><span class=\"o\">,</span> <span class=\"s2\">\",\"</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff.1</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"s2\">\",\"</span><span class=\"o\">,</span> <span class=\"s2\">\"&lt;-\"</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"s2\">\"]\"</span><span class=\"o\">]</span> <span class=\"o\">[],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">[</span><span class=\"n\">hJI</span> <span class=\"n\">hp</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"s2\">\"&lt;-\"</span><span class=\"o\">,</span> <span class=\"n\">mem_vanishing_ideal_singleton_iff</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">[</span><span class=\"n\">mem_Inf.mp</span> <span class=\"n\">hp</span> <span class=\"o\">⟨</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">le_vanishing_ideal_zero_locus</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vanishing_ideal_anti_mono</span> <span class=\"o\">(</span><span class=\"bp\">λ</span>\n        <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"bp\">«</span><span class=\"n\">expr</span> <span class=\"bp\">▸</span> <span class=\"bp\">»</span><span class=\"o\">(</span><span class=\"n\">hy.symm</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">))),</span> <span class=\"n\">mv_polynomial.vanishing_ideal_singleton_is_maximal</span><span class=\"o\">⟩]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>might be a while before we have full coverage on these proofs</p>",
        "id": 248288228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628029222
    },
    {
        "content": "<p>what you see there is the reconstructed lean 3 syntax, which is what it prints on a fatal error</p>",
        "id": 248288275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628029270
    },
    {
        "content": "<p>After adding the <code>rcases</code>/<code>rintros</code>/<code>obtain</code> parsers, synport makes it through this proof. Here's what it looks like without editing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Main statement of the Nullstellensatz -/</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">vanishing_ideal_zero_locus_eq_radical</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">«</span><span class=\"n\">expr</span> <span class=\"bp\">=</span> <span class=\"bp\">»</span> <span class=\"o\">(</span><span class=\"n\">vanishing_ideal</span> <span class=\"o\">(</span><span class=\"n\">zero_locus</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"n\">I.radical</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">I.radical_eq_jacobson</span><span class=\"o\">]</span>\n    <span class=\"n\">refine'</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_Inf</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n    <span class=\"bp\">·</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">J</span> <span class=\"o\">⟨</span><span class=\"n\">hJI</span><span class=\"o\">,</span> <span class=\"n\">hJ</span><span class=\"o\">⟩</span>\n      <span class=\"n\">obtain</span><span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">is_maximal_iff_eq_vanishing_ideal_singleton</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hJ</span>\n      <span class=\"n\">refine'</span> <span class=\"bp\">«</span><span class=\"n\">expr</span> <span class=\"bp\">▸</span> <span class=\"bp\">»</span> <span class=\"n\">hx.symm</span> <span class=\"o\">(</span><span class=\"n\">vanishing_ideal_anti_mono</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">mem_vanishing_ideal_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff.1</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n      <span class=\"n\">refine'</span> <span class=\"n\">hJI</span> <span class=\"n\">hp</span>\n    <span class=\"bp\">·</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">mem_vanishing_ideal_singleton_iff</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n      <span class=\"n\">refine'</span>\n        <span class=\"n\">mem_Inf.mp</span> <span class=\"n\">hp</span>\n          <span class=\"o\">⟨</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">le_vanishing_ideal_zero_locus</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vanishing_ideal_anti_mono</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">«</span><span class=\"n\">expr</span> <span class=\"bp\">▸</span> <span class=\"bp\">»</span> <span class=\"n\">hy.symm</span> <span class=\"n\">hx</span><span class=\"o\">),</span>\n            <span class=\"n\">mv_polynomial.vanishing_ideal_singleton_is_maximal</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 248302987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628041992
    },
    {
        "content": "<p>actually the <code>«expr = » </code> in the statement is because I'm too lazy to run this on all previous files to build up the set of notations. Daniel's been running the full builds, which should resolve those so that it appears like normal</p>",
        "id": 248303078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628042094
    },
    {
        "content": "<p>Could somebody please recommend a few Mathlib theorems for me to play with using binport that will stress-test either typeclass resolution or the simplifier?</p>",
        "id": 248308086,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1628048793
    },
    {
        "content": "<p>The old way of proving the formula for a 2x2 det:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.determinant</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.fin</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">matrix.det</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">]]</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- TODO: can we make this require less steering?</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">matrix.det_apply'</span><span class=\"o\">,</span> <span class=\"n\">finset.univ_perm_fin_succ</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">finset.univ_product_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_product</span><span class=\"o\">,</span>\n        <span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">,</span> <span class=\"n\">fin.prod_univ_succ</span><span class=\"o\">],</span>\n  <span class=\"n\">ring</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and the new way for a 3x3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n        <span class=\"n\">matrix.det</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">]]</span> <span class=\"bp\">=</span>\n          <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">matrix.det_succ_row_zero</span><span class=\"o\">,</span> <span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">],</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  Try this: simp only [det_succ_row_zero, fin.sum_univ_succ, neg_mul_eq_neg_mul_symm, cons_append,</span>\n<span class=\"cm\">  mul_one, fin.default_eq_zero, fin.coe_zero, cons_vec_bit0_eq_alt0, one_mul, cons_val_one,</span>\n<span class=\"cm\">  cons_vec_alt0, fin.succ_succ_above_one, fin.coe_succ, univ_unique, minor_apply, pow_one,</span>\n<span class=\"cm\">  fin.zero_succ_above, fin.succ_zero_eq_one, fin.succ_succ_above_zero, nat.neg_one_sq,</span>\n<span class=\"cm\">  finset.sum_singleton, cons_val_zero, cons_val_succ, det_fin_zero, head_cons, pow_zero]</span>\n<span class=\"cm\">   -/</span>\n  <span class=\"n\">ring</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 248309430,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628050839
    },
    {
        "content": "<p>For type-class inference maybe  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.is_scalar_tower'\">docs#units.is_scalar_tower'</a> (at least there are a lot of type-class assumptions)<br>\nFor simp, I mostly think of the manifold and category theory library. Maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/structure_groupoid.compatible_of_mem_maximal_atlas\">docs#structure_groupoid.compatible_of_mem_maximal_atlas</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse_obj\">docs#Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse_obj</a>.<br>\nOthers might have better suggestions.</p>",
        "id": 248309496,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1628050961
    },
    {
        "content": "<p>There are several heavy simps in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.simple_func.exists_le_lower_semicontinuous_lintegral_ge\">docs#measure_theory.simple_func.exists_le_lower_semicontinuous_lintegral_ge</a>, for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">lt_top_iff_ne_top</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">simple_func.coe_const</span><span class=\"o\">,</span> <span class=\"n\">function.const_apply</span><span class=\"o\">,</span>\n  <span class=\"n\">lintegral_const</span><span class=\"o\">,</span> <span class=\"n\">ennreal.coe_indicator</span><span class=\"o\">,</span> <span class=\"n\">set.univ_inter</span><span class=\"o\">,</span> <span class=\"n\">ennreal.coe_ne_top</span><span class=\"o\">,</span>\n  <span class=\"n\">measurable_set.univ</span><span class=\"o\">,</span> <span class=\"n\">with_top.mul_eq_top_iff</span><span class=\"o\">,</span> <span class=\"n\">simple_func.const_zero</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">,</span>\n  <span class=\"n\">lintegral_indicator</span><span class=\"o\">,</span> <span class=\"n\">ennreal.coe_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">simple_func.coe_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">set.piecewise_eq_indicator</span><span class=\"o\">,</span> <span class=\"n\">simple_func.coe_piecewise</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">restrict_apply</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 248309612,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1628051164
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_extension_norm_eq\">docs#exists_extension_norm_eq</a> has hit typeclass timeouts for me in multiple attempted refactors</p>",
        "id": 248317264,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628060926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/fun.20with.20binport/near/248317264\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_extension_norm_eq\">docs#exists_extension_norm_eq</a> has hit typeclass timeouts for me in multiple attempted refactors</p>\n</blockquote>\n<p>This is perfect, thank you. Just trying to elaborate the type exposed another issue :)</p>",
        "id": 248420238,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1628118437
    },
    {
        "content": "<p>If you want more timeouts, I have plenty of stale refactor branches that I could update to match master to get fresh timeouts on</p>",
        "id": 248420337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628118502
    },
    {
        "content": "<p>Timeouts are a luxury I rarely have yet -- there are still a lot of relatively fast elaboration errors. There are many complicated dynamics that only emerge deep in mathlib, and so we are just hitting them for the first time in lean4.</p>",
        "id": 248420638,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1628118769
    },
    {
        "content": "<p>If you want to try out a weird behavior, you can have a look at <code>measure_theory/arithmetic.lean</code>, especially the proof of the lemma <code>has_measurable_gpow</code> where Lean 3 does something crazy (there is probably a bug lurking somewhere): replacing the last line of the proof of this lemma <code>exact has_measurable_gpow_aux G</code> with the proof of the auxiliary lemma <code>has_measurable_gpow_aux</code> fails badly, for no reason I can understand. If Lean 4 could behave more properly on this one, this would be pretty nice!</p>",
        "id": 248447547,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1628149578
    },
    {
        "content": "<p>Some other weird typeclass behavior is in <a href=\"https://github.com/leanprover-community/mathlib/issues/8547\">#8547</a>. Does lean4 require this instance that PR adds in order to remove the <code>@</code>s in the other part of the PR?</p>",
        "id": 248599487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628249724
    },
    {
        "content": "<p>Good news: I added lean-liquid to the mathport pipeline and it worked fine. I will include liquid in the uploads from now on (<a href=\"https://github.com/dselsam/mathport/releases/tag/v0.0.0.0\">https://github.com/dselsam/mathport/releases/tag/v0.0.0.0</a>). There is still a long way to go before the binaries can be used effectively, but at least the proof-term porting seems very robust now.</p>",
        "id": 249642080,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1629145234
    },
    {
        "content": "<p>I had only recently internalised that porting large-ish projects which depended on mathlib like this one was on your radar. This is really good news!</p>",
        "id": 249658015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1629153874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/fun.20with.20binport/near/249658015\">said</a>:</p>\n<blockquote>\n<p>I had only recently internalised that porting large-ish projects which depended on mathlib like this one was on your radar. This is really good news!</p>\n</blockquote>\n<p>Yes, there is no obstacle to applying <code>mathport</code> to any lean3 project that depends on an up-to-date mathlib. Mathport takes a list of modules to port, e.g. <code> ./mathport config.json Lean3::all Mathlib::all Liquid::all</code>.</p>",
        "id": 249658693,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1629154325
    },
    {
        "content": "<p>No library left behind!</p>",
        "id": 249665148,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1629159999
    },
    {
        "content": "<p>The alternative take on this is that it increases moral hazard, encouraging people to do maths outside of mathlib. :-)</p>",
        "id": 249665183,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1629160039
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> If you are interested in another gruesome type-class problem, here is one that takes 8.6 to fail on yesterday's mathlib (it is supposed to fail):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--after running scripts/mk_all.sh</span>\n<span class=\"kn\">import</span> <span class=\"n\">all</span> <span class=\"c1\">-- import all files of mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m0</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">borel_space</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">second_countable_topology</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">complete_space</span> <span class=\"o\">(</span><span class=\"n\">measure_theory.Lp</span> <span class=\"n\">E</span> <span class=\"n\">p</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>I tried to port this to the binported mathlib you posted a while back.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.All</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">TopologicalSpace</span>\n\n<span class=\"c1\">-- this should succeed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m0</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Ennreal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">SecondCountableTopology</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">UniformSpace</span> <span class=\"o\">(</span><span class=\"n\">lp</span> <span class=\"n\">E</span> <span class=\"n\">p</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- this should fail</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m0</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Ennreal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">SecondCountableTopology</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">CompleteSpace</span> <span class=\"o\">(</span><span class=\"n\">lp</span> <span class=\"n\">E</span> <span class=\"n\">p</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>However, I'm getting some type-class problems, that are caused by the redefinition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/coe_trans\">docs#coe_trans</a>, which makes instances like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_units.has_coe\">docs#add_units.has_coe</a> looping. Can I disable instances locally (the equivalent of Lean 3's <code>local attribute [-instance]</code>)?</p>",
        "id": 251466613,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1630446900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Thanks for looking into this stuff. I just pushed support for temporarily disabling instances. Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">fooAdd</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x.a</span> <span class=\"bp\">+</span> <span class=\"n\">y.a</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"c1\">-- Works</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">fooAdd</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"c1\">-- Error</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"c1\">-- Works</span>\n</code></pre></div>",
        "id": 251471253,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1630449288
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 251471493,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1630449452
    }
]
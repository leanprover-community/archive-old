[
    {
        "content": "<p>With the understanding that everything is still in the feeling out phase and that core != mathlib, etc., is there a possible future in which the indexed <code>OfNat</code> in core has a more pleasant relationship with mathlib's Nat situation? The motivation for an <code>OfNat</code> that only needs to be defined on zero and/or one makes perfect sense, but after working through the new normNum my impression was that <code>OfNat</code> in the presence of <code>Numeric</code>, <code>Zero</code>, and <code>One</code> seems to cause quite a bit of paper-shuffling.</p>",
        "id": 251696420,
        "sender_full_name": "Chris B",
        "timestamp": 1630579829
    },
    {
        "content": "<p>I started rewriting <code>normNum</code> a little while ago, and I decided to not use canonical lean numerals in the inner functions anymore, because the dependent arguments lead to a lot of needless extra fluff in a performance critical area (and <code>normNum</code> doesn't work on fancy instances that only support some numbers and not others anyway)</p>",
        "id": 251712120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630588288
    },
    {
        "content": "<p>instead the basic proof object is a proof about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isNat</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 251712331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630588376
    },
    {
        "content": "<p>note that <code>n</code> here is a raw literal</p>",
        "id": 251712373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630588399
    },
    {
        "content": "<p>so for instance it would prove that <code>isNat (2 + 2) (nat_lit 4)</code></p>",
        "id": 251712508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630588455
    },
    {
        "content": "<p>and then the front end puts that back in terms of <code>ofNat</code> on the appropriate instance</p>",
        "id": 251712558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630588482
    },
    {
        "content": "<p>Thanks. Two follow-up questions related to the normNum discussion:</p>\n<ol>\n<li>\n<p>Do you know why, when the only variables are <code>(A : Type) [Semiring A]</code>, typeclass inference uses <code>@OfNat.ofNat α n (@Numeric.OfNat α n (@Semiring.toNumeric α inst))</code> for (n : A) when n &gt; 1 but uses <code>@OfNat.ofNat α 0 (@instOfNat α (@MonoidWithZero.toZero α (@instMonoidWithZero_1 α inst)))</code> for 0 and 1? Neither instance seems to be declared with higher/lower priority.</p>\n</li>\n<li>\n<p>What's the policy for naming/not naming certain instance declarations?</p>\n</li>\n</ol>",
        "id": 251739579,
        "sender_full_name": "Chris B",
        "timestamp": 1630598626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/287929-mathlib4/topic/OfNat.2FNumeric/near/251739579\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Do you know why, when the only variables are <code>(A : Type) [Semiring A]</code>, typeclass inference uses <code>@OfNat.ofNat α n (@Numeric.OfNat α n (@Semiring.toNumeric α inst))</code> for (n : A) when n &gt; 1 but uses <code>@OfNat.ofNat α 0 (@instOfNat α (@MonoidWithZero.toZero α (@instMonoidWithZero_1 α inst)))</code> for 0 and 1? Neither instance seems to be declared with higher/lower priority.</li>\n</ol>\n</blockquote>\n<p>That behavior makes sense if the <code>MonoidWithZero</code> instance is added later, since later definitions take priority over earlier ones as a tie breaker. In that case, the zero proof takes priority over the general proof, but of course the zero proof only works on zero so if the number is 2 then it will use the general proof.</p>",
        "id": 251814593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630636476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/287929-mathlib4/topic/OfNat.2FNumeric/near/251739579\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>What's the policy for naming/not naming certain instance declarations?</li>\n</ol>\n</blockquote>\n<p>Presumably the same as lean 3: use an explicit name when the autogenerated name is not good. That <code>instMonoidWithZero_1</code> instance sounds like a bad name since it's clashing with something else, so I would probably want to give it an explicit name</p>",
        "id": 251814766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630636612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/OfNat.2FNumeric/near/251814593\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/287929-mathlib4/topic/OfNat.2FNumeric/near/251739579\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Do you know why, when the only variables are <code>(A : Type) [Semiring A]</code>, typeclass inference uses <code>@OfNat.ofNat α n (@Numeric.OfNat α n (@Semiring.toNumeric α inst))</code> for (n : A) when n &gt; 1 but uses <code>@OfNat.ofNat α 0 (@instOfNat α (@MonoidWithZero.toZero α (@instMonoidWithZero_1 α inst)))</code> for 0 and 1? Neither instance seems to be declared with higher/lower priority.</li>\n</ol>\n</blockquote>\n<p>That behavior makes sense if the <code>MonoidWithZero</code> instance is added later, since later definitions take priority over earlier ones as a tie breaker. In that case, the zero proof takes priority over the general proof, but of course the zero proof only works on zero so if the number is 2 then it will use the general proof.</p>\n</blockquote>\n<p><code>MonoidWithZero</code> is declared before <code>Semiring</code> (Ring/Basic.lean imports <code>Mathlib.Algebra.GroupWithZero.Defs</code>), and normNum only imports the Ring module, but MonoidWithZero wins for 0 and 1. <br>\nI understand conceptually why 0 and 1 would in some cases be different, but it seems unintuitive that when you set up a context saying \"I want to work with [Semiring A]\" which comes with its own instance of <code>Numeric</code> -&gt; <code>OfNat</code> that 0 and 1 suddenly find this alternate instance.</p>",
        "id": 251838485,
        "sender_full_name": "Chris B",
        "timestamp": 1630656644
    },
    {
        "content": "<p>I've put the revised normNum in a PR, <a href=\"https://github.com/leanprover-community/mathlib4/issues/49\">mathlib4#49</a></p>",
        "id": 251854769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630663512
    },
    {
        "content": "<p>I'm still not sure about what causes these particular paths to appear, but I added <em>yet another</em> typeclass <code>LawfulOfNat</code> to prove that the <code>OfNat</code> instance is equal to the \"canonical\" semiring <code>OfNat</code> instance. (Fight dependent types with even dependent-er types...)</p>",
        "id": 251854966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630663601
    },
    {
        "content": "<p>That's an interesting way of resolving it. I can't seem to get priorities to work, but my first thought would have been to  just force the resolution system to always use the Semiring path if the type in question has an instance of Semiring. Is the approach of showing that the instances are equal more robust in the context of more complex hierarchies? I guess doing these proofs as they're needed is a better way of handling diamonds than trying to sort out priorities.</p>",
        "id": 251866951,
        "sender_full_name": "Chris B",
        "timestamp": 1630669510
    },
    {
        "content": "<p>I don't think we can really ensure that we always get the same instance, since there are at least some instances that won't go through the semiring instance, like the one on <code>Nat</code> which is defined prior.</p>\n<p>Also, it occurs to me that this <code>LawfulOfNat</code> approach can also potentially handle cases where the <code>OfNat</code> is partially defined but is lawful where it is defined. So for instance you could prove <code>(2 + 2 : fin 5) = 4</code></p>",
        "id": 251877066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630674538
    },
    {
        "content": "<p>Ok. I'll defer to your judgment here.</p>",
        "id": 251932808,
        "sender_full_name": "Chris B",
        "timestamp": 1630698392
    }
]
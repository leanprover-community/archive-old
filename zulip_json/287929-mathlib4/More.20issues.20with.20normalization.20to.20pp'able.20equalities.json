[
    {
        "content": "<p>Sorry for the bad subject name, but I'm not sure exactly how to describe this problem.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/1179\">mathlib4#1179</a> there are a number of theorems that fail to solve post migration, where one side of an equality is \"less reduced\" than another, with lots of bare <code>Exists</code> and such rather than expressed in forms that <code>pp</code> effectively.</p>\n<p>After thinking about this rather than sleeping last night, I decided to make the rhs of one of the simpler of these cases \"worse\" and lo and behold, I close the proof.</p>\n<p>In <code>mem_prod_lift</code>, the following that used to work in Lean 3, fails to close:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mem_prod_lift</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f.prodLift</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">y.1</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">y.2</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">trans</span> <span class=\"bp\">∃</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">hp</span> <span class=\"bp\">=</span> <span class=\"n\">y.1</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">hq</span> <span class=\"bp\">=</span> <span class=\"n\">y.2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prodLift</span><span class=\"o\">,</span> <span class=\"n\">Part.mem_mk_iff</span><span class=\"o\">,</span> <span class=\"n\">And.exists</span><span class=\"o\">,</span> <span class=\"n\">Prod.ext_iff</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_and_left</span><span class=\"o\">,</span> <span class=\"n\">exists_and_right</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>where the goal state is:</p>\n<p><code>((Exists fun x_1 ↦ Part.get (f x) (_ : (f x).Dom) = y.fst) ∧ Exists fun x_1 ↦ Part.get (g x) x_1 = y.snd) ↔\n  y.fst ∈ f x ∧ y.snd ∈ g x</code></p>\n<p>To my eye, through the relevant definitions of \\in that are being used here for partial functions, this should still close.</p>\n<p>(de-pp'd for those for whom this means something):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Iff</span>\n  <span class=\"o\">(</span><span class=\"n\">And</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Exists.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n      <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">↦</span>\n        <span class=\"bp\">@</span><span class=\"n\">Eq.</span><span class=\"o\">{</span><span class=\"n\">u_2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">β</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.get.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Iff.of_eq</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq.refl.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))))</span>\n              <span class=\"n\">x_1</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Prod.fst.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Exists.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n      <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Part.Dom.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">↦</span> <span class=\"bp\">@</span><span class=\"n\">Eq.</span><span class=\"o\">{</span><span class=\"n\">u_3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.get.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Prod.snd.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">y</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">And</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Membership.mem.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">Part.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.instMembershipPart.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Prod.fst.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Membership.mem.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"n\">Part.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Part.instMembershipPart.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Prod.snd.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>If, instead, I make the rhs worse by walking back the nice representation on the rhs, I can close the goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mem_prod_lift</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f.prodLift</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">y.1</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">y.2</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">trans</span> <span class=\"bp\">∃</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">hp</span> <span class=\"bp\">=</span> <span class=\"n\">y.1</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">hq</span> <span class=\"bp\">=</span> <span class=\"n\">y.2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prodLift</span><span class=\"o\">,</span> <span class=\"n\">Part.mem_mk_iff</span><span class=\"o\">,</span> <span class=\"n\">And.exists</span><span class=\"o\">,</span> <span class=\"n\">Prod.ext_iff</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_and_left</span><span class=\"o\">,</span> <span class=\"n\">exists_and_right</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">Part.Mem</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Before I go try this with the other proofs that don't close, I <em>think</em> the desired state is for the lhs to normalize to a point where Lean 4 believes they are equal, yes?</p>",
        "id": 317748494,
        "sender_full_name": "Arien Malec",
        "timestamp": 1671900949
    },
    {
        "content": "<p>This may also be: <a href=\"https://github.com/leanprover/lean4/issues/1937\">https://github.com/leanprover/lean4/issues/1937</a></p>",
        "id": 317757717,
        "sender_full_name": "Arien Malec",
        "timestamp": 1671909387
    },
    {
        "content": "<p>?</p>",
        "id": 317757722,
        "sender_full_name": "Arien Malec",
        "timestamp": 1671909392
    }
]
[
    {
        "content": "<p>So, I have an idea for how to port the functionality of <code>refine_struct</code>, but I'm not sure if it's a <em>good</em> idea. (it seems good to me, though!) Thought I'd suggest it here.</p>\n<p>It seems that <code>refine</code> in lean 4 relies on holes of the form <code>?_</code> or <code>?x</code> instead of <code>_</code>. So, instead of using <code>..</code> to refine structures, then, to be consistent, the lean 4 analogue of <code>..</code> in this context should be <code>?..</code>.</p>\n<p>As such...I think we might be able to avoid using <code>refine_struct</code> at all. Instead, we can define a term elaboration for any structure-like syntax that contains <code>?..</code>. This would elaborate the given syntax into one with an explicit named hole for each field. For example, given a structure with <code>x</code>, <code>y</code>, and <code>z</code> as fields, <code>{ x := 1, ?.. }</code> would elaborate to <code>{ x := 1, y := ?y, z := ?z }</code> (or some equivalent expression). We can then feed this directly to <code>refine</code> instead of using <code>refineStruct</code> at all.</p>\n<p>Given the existing use of <code>..</code> and <code>_</code>, the use of <code>?..</code> in <code>refine</code> seems like it would fill a niche in <code>refine</code>'s functionality. It might also get used more than <code>refine_struct</code> is used in mathlib3 if it's simply \"part of how <code>refine</code> works\" instead of being shelved under a separate name. (To alert people to this functionality, maybe the docstring for <code>refine</code> could be added to in mathlib? I'm not familiar with how documentation is managed yet, though, so I don't know.)</p>\n<p>As for how to implement the interaction with <code>haveField</code>, the idea would be to attach the necessary information as metadata to each of the metavariables created by <code>?..</code>. Then <code>haveField</code> could (I hope) inspect the metadata on the given goal to figure out what <code>field</code> should be.</p>\n<p>Anyway, let me know if this is a good idea (or if it would break something/is not as feasible as it seems)!</p>\n<p>(I've already started trying to implement it just to see if I can get it to work, but if it turns out we'd rather shift this functionality to an explicit <code>refineStruct</code> or a port of <code>pi_instance_derive_field</code> instead, it shouldn't be too hard.)</p>",
        "id": 306911761,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1667102743
    },
    {
        "content": "<p>Ok, so given that <code>?..</code> would be a new sigil, which is nontrivial, I want to make the case for it properly! For whenever that decision gets made, here are the reasons I think it would fit nicely. (If you're wondering why I wrote all this, it's just that I like thinking about notation. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 307835582,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1667508317
    },
    {
        "content": "<h1>The case for <code>?..</code></h1>\n<p><strong>Context</strong><br>\nWe need functionality for automatically filling unspecified fields in structures with synthetic holes, such that the holes are named by the field. For example, given a structure with two fields <code>x</code>, <code>y</code>, we need a convenient way to produce <code>{ x := ?x, y := ?y }</code>. The question is: what should the syntax be? In Lean 3, we use <code>{ .. }</code> (with <code>refine_struct</code>) to do this. In Lean 4, <code>{ .. }</code> fills the fields with natural holes. Do we rewrite StructInst.lean to make it use synthetic holes?</p>\n<p>My proposal is that we instead use the syntax <code>{ ?.. }</code> for this task. Ultimately, the idea is that it enforces a certain conceptual metaphor.</p>\n<p><strong>(see bottom for tl;dr)</strong></p>\n<p>In Lean, there’s a close relationship between <code>_</code> and <code>..</code>. <code>_</code> can be used as a discarded pattern and as a natural hole; <code>..</code> can be used as a sequence of discarded patterns and as a sequence of natural holes. Conceptually, we come to think of <code>..</code> as a variadic form of <code>_</code>.</p>\n<p>So what's the variadic form of a synthetic hole <code>?_</code>? The concept for moving from <code>_</code> to <code>?_</code> is \"prefix a blank or an ident with <code>?</code>, and it becomes synthetic instead of natural\". As such, <code>?..</code> fits into the metaphor nicely as the synthetic form of <code>..</code> and the variadic form <code>?_</code>.</p>\n<p>The distinction between synthetic and natural holes is important in general, of course, but particularly so in the context of <code>refine</code>: we demand that all new goals in <code>refine</code> be marked with <code>?</code>. Why, then, should the programmer expect that something <em>not</em> marked with <code>?</code> in <code>refine</code> should create a goal? The use of <code>?</code> as a visual marker of syntheticness becomes, in the context of <code>refine</code>, a shorthand for something else: an indicator of what goals will be produced. Using <code>..</code> for synthetic holes in <code>refine</code> would break this conceptual consistency, and might feel ad hoc. It would require \"extra knowledge\" to know that <code>..</code> would be <code>?</code>-like, whereas <code>?..</code> signals the occurrence of synthetic goals transparently. Even someone who hadn't encountered <code>?..</code> before could reasonably guess that it had something to do with <code>?_</code> and <code>?x</code>, given that this is the only use of a prefixed <code>?</code>.</p>\n<p>This is arguably more important than the bare indicator of whether something is synthetic or not: <code>?</code> indicates how a given hole will relate to the rest of our code, and, in particular, whether we need to continue to interact with it or not. We tend not to care about occurrences of <code>_</code> and <code>..</code> later on, but we <em>do</em> continue to care about occurrences of <code>?_</code> (and <code>?..</code>).</p>\n<p>To address the point that <code>..</code> is already in use within <code>refine_struct</code> in Lean 3, and so we should maintain that usage: I would argue that replacing it in these contexts with <code>?..</code> is consistent with the move from Lean 3 to Lean 4. Holes used as goals in <code>refine</code> tactics should become synthetic holes, and in so doing, acquire a <code>?</code> in Lean 4 (whether they're <code>_</code> or <code>..</code> holes).</p>\n<p>(Note: <code>refine_struct</code> should simply become <code>refine</code>—after all, there's no need for refining a structure to be a special activity!)</p>\n<p>Further, using <code>..</code> in structures currently <em>already</em> works as one would expect in Lean 4. <code>{ .. }</code> produces natural holes for unspecified fields, and can be used with <code>refine'</code> (the version that allows natural holes). (Some might find the ability to create natural holes like this useful—I'm not sure.) <code>{ ?.. }</code> would create named synthetic holes for each field, named by the given field; e.g. if we had two fields <code>x</code>, <code>y</code>, <code>{ ?.. }</code> would become <code>{ x := ?x, y := ?y }</code>.</p>\n<p>If we changed the behavior such that <code>{ .. }</code> created synthetic holes, it would in principle be possible for the programmer to deduce that <code>{ .. }</code> used in the context of <code>refine</code> is analogous to multiple <code>?_</code>s instead of multiple <code>_</code>. But the metaphor of <code>?</code> ⇔ \"synthetic hole\"/\"goal to address\" would be broken; further, the metaphor of <code>..</code> corresponding to multiple <code>_</code>'s would be broken, as sometimes <code>..</code> it would correspond to multiple <code>?_</code>'s which remain relevant while still corresponding to multiple <code>_</code>'s which get discarded in other situations.</p>\n<p>Likewise, <code>?_</code> <em>can</em> technically be used as a pattern in place of <code>_</code>—but we never do so in practice, in part because we intuitively <em>get</em> (and voluntarily enforce) the metaphor that <code>_</code> and <code>..</code> are for things we don't need to worry about, and <code>?</code> is for things we do.</p>\n<p>In general, my view is that syntax should communicate semantics and usage-roles as transparently as possible by relying on visual metaphors that are as transparent as possible—and there's some content that can be very transparently communicated by the presence of a single <code>?</code>.</p>\n<h2>So, tl;dr:</h2>\n<ul>\n<li><code>?..</code> transparently signals a synthetic quality (and a goal quality) via the presence of <code>?</code> and bolsters the analogy with <code>?_</code>/<code>?x</code>.</li>\n<li>the role of the \"synthetic <code>?_</code>\"/\"natural <code>_</code>\" distinction has an important intuitive meaning: <code>_</code> and <code>..</code> are for things we don't need to continue worry about, while <code>?_</code> (and <code>?..</code>) is for things we do. <code>?</code> signals not only a formal property of our code, but an aspect of how we think about and plan to interact with it. (Especially so in <code>refine</code>.)</li>\n<li>using <code>..</code> for synthetic holes instead would muddy the conceptual waters for <code>..</code>, as sometimes it would mean multiple <code>_</code>'s, and sometimes it would mean multiple <code>?_</code>'s; moreover, sometimes it would represent something discarded, whereas sometimes it would represent something with continued relevance.</li>\n<li><code>{ .. }</code> has an already-existing role to play by filling in unspecified fields with natural holes.</li>\n<li><code>{ .. }</code> is only ever used in refinement contexts in Lean 3; in moving to Lean 4, we should prepend all holes that we want to be goals in the context of <code>refine</code> with <code>?</code>.</li>\n</ul>",
        "id": 307835631,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1667508334
    },
    {
        "content": "<p>This should be moved to <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> as a [RFC] thread</p>",
        "id": 307850884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667514216
    }
]
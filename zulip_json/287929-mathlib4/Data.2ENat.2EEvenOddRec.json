[
    {
        "content": "<p>I noticed that <code>Nat.odd_even_rec</code> has not been taken up yet. I'd like to take it up. Is there anything I should know (for e.g. : this file being on the \"not to be ported\" list?)</p>",
        "id": 317147194,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671625878
    },
    {
        "content": "<p>Fixed:  <del>Also I don't see <code>data.nat.bits</code> and <code>init.data.nat.bitwise</code> in master yet. I thought this was already merged (see: <a href=\"https://github.com/leanprover-community/mathlib4/pull/1095\">mathlib4#1095</a></del></p>",
        "id": 317147826,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671626100
    },
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/1148\">mathlib4#1148</a></p>",
        "id": 317150349,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671626982
    },
    {
        "content": "<p>I looked at it briefly --- it uses <code>bit1</code>, <code>bit0</code> and theorems about <code>bit</code> and <code>bit0/1</code>heavily so probably wants some design thought to use a more sensible definition of parity or blaze on.</p>",
        "id": 317190263,
        "sender_full_name": "Arien Malec",
        "timestamp": 1671637934
    },
    {
        "content": "<p>Is this something that needs to be done during or after the port?</p>",
        "id": 317191074,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671638154
    },
    {
        "content": "<p>it's best to just translate as is for now; deprecate anything with <code>bit0</code>/<code>bit1</code> in the statement and put a TODO on any proofs that require referencing deprecated definitions (but otherwise translate them as normal), and do it all in a <code>section deprecated</code> where you turn off the linter (and put another TODO on that)</p>",
        "id": 317191583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671638286
    },
    {
        "content": "<p>In addition, the purpose of this file is to give users the option to avoid using <code>bit0</code> and <code>bit1</code>. So it seems like a good idea to port it. I will try to finish by tonight (CET)</p>",
        "id": 317198765,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671640386
    },
    {
        "content": "<p>So, I just started making the non-trivial fixes. In doing so there was a problem with lean not being able to fill in the implicit parameters of binary_rec_eq. So I supplied them. I got one of the strangest errors I have seen thus far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Hb</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">brecPind</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n<span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">binary_rec_eq</span> <span class=\"o\">(</span><span class=\"n\">Hb</span> <span class=\"n\">h0</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">Hb</span> <span class=\"n\">h0</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">brecPind</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">brecPind</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 317272745,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671669440
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 317272891,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671669540
    },
    {
        "content": "<p>Here's the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Data.Nat.Bitwise</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n\n\n<span class=\"kd\">@[elab_as_elim]</span>\n<span class=\"kd\">def</span> <span class=\"n\">evenOddRec</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"n\">binaryRec</span> <span class=\"n\">h0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">bit</span><span class=\"o\">,</span> <span class=\"n\">bit0_val</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h_even</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">bit</span><span class=\"o\">,</span> <span class=\"n\">bit1_val</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h_odd</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.even_odd_rec</span> <span class=\"n\">Nat.evenOddRec</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_zero</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">binary_rec_zero</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.even_odd_rec_zero</span> <span class=\"n\">Nat.even_odd_rec_zero</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_even</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">bit_val_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">bit_val</span><span class=\"o\">,</span> <span class=\"n\">cond</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"n\">bit_val_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">bit</span> <span class=\"n\">true</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val</span><span class=\"o\">,</span> <span class=\"n\">cond</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">brecPind</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">):=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_n</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span>\n    <span class=\"n\">case</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"n\">h_2n</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h_even</span> <span class=\"n\">n</span> <span class=\"n\">h_n</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_2n</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h_2n</span>\n    <span class=\"n\">case</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"n\">h_2n_1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"n\">h_n</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_2n_1</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h_2n_1</span>\n  <span class=\"k\">have</span> <span class=\"n\">Hb</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">brecPind</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">binary_rec_eq</span> <span class=\"n\">P</span> <span class=\"n\">h0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Hb</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"n\">false</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_cast_eq</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">binary_rec_eq</span> <span class=\"n\">_</span> <span class=\"n\">true</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_cast_eq</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 317273069,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671669677
    },
    {
        "content": "<p>You can see the other theorem in its pristine lean3 form for comparison. The proofs are almost entirely identical</p>",
        "id": 317273097,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671669709
    },
    {
        "content": "<p>The question is, how does this error even make sense?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">argument</span>\n  <span class=\"n\">Hb</span> <span class=\"n\">h0</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">brecPind</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">brecPind</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 317273223,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671669814
    },
    {
        "content": "<p>If you switch <code>pp.all</code> on you'll see they're different.</p>",
        "id": 317273338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671669901
    },
    {
        "content": "<p>But <code>@Eq</code> seems to suggest that all implicit parameters are already in there</p>",
        "id": 317273565,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670041
    },
    {
        "content": "<p>yeah you're right, I don't see why they can't match.</p>",
        "id": 317273647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671670086
    },
    {
        "content": "<p>Oh but pp.all shows more than just the implicit parameters -- everything has to match -- but I don't see why it won't match.</p>",
        "id": 317273678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671670119
    },
    {
        "content": "<p>Ok I think I fixed it.</p>",
        "id": 317274150,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670482
    },
    {
        "content": "<p>Nice. I would really not recommend doing what you're doing though: you're defining <code>brecPind</code> in tactic mode with <code>rw</code> so there will be random stuck <code>eq.rec</code>s in your definition and it will be hell to work with.</p>",
        "id": 317274287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671670572
    },
    {
        "content": "<p>What's the cleaner method?</p>",
        "id": 317274348,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670645
    },
    {
        "content": "<p>I don't know enough about Lean 4 to answer this :-(</p>",
        "id": 317274368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671670666
    },
    {
        "content": "<p>But this approach is not being used in the Lean 3 file. Did you have to diverge from the autoported file for some reason?</p>",
        "id": 317274472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671670767
    },
    {
        "content": "<p>Yeah<br>\nYou can see the proof of the theorem after. These two proofs are exactly identical (except true vs false)</p>",
        "id": 317274551,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670817
    },
    {
        "content": "<p><code>even_odd_rec_odd</code></p>",
        "id": 317274567,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670845
    },
    {
        "content": "<p>The error you get there is <br>\n<code>don't know how to synthesize implicit argument</code><br>\n<code>@binary_rec_eq ?m.5713 ?m.5714 ?m.5715 ?m.5716 true n</code></p>",
        "id": 317274615,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670889
    },
    {
        "content": "<p>The second one is the mathlib3 version with the minor corrections necessary for mathlib4 (tt =&gt; true, ff =&gt; false)</p>",
        "id": 317274737,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671670998
    },
    {
        "content": "<p>I would be tempted to <code>convert @binary_rec_eq _ _ _ _ true n</code> and then try and fill in the blanks</p>",
        "id": 317274827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671671044
    },
    {
        "content": "<p>Doesn't work. The first two blanks are easy to fill. This still leaves the blank for the parameter <code>f</code> which is where <code>brecPind</code> comes in</p>",
        "id": 317274908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671671144
    },
    {
        "content": "<p>Also, I am learning that unfold looks for names only in <code>_root_.</code>. It wont unfold <code>brecPind</code></p>",
        "id": 317275303,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671671486
    },
    {
        "content": "<p>yeah this sort of thing is hell, and a very long way from my area of expertise (I'm a mathematician).</p>",
        "id": 317275604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671671738
    },
    {
        "content": "<p>Here's a funny goal when I use brecPind: <code>instMulNat = { mul := Nat.add }</code></p>",
        "id": 317275689,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671671815
    },
    {
        "content": "<p>I am beginning to think lean4 believes <code>2+2 = potato</code></p>",
        "id": 317275725,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671671853
    },
    {
        "content": "<p>Lean 3 <code>convert</code> seems more powerful than Lean 4 <code>convert</code> here?</p>",
        "id": 317276374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671672458
    },
    {
        "content": "<p>or probably even broken</p>",
        "id": 317276606,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671672656
    },
    {
        "content": "<p>As far as I know this is false. In another <code>case</code> it asked me to show <code>n=2</code>, without any relevant additional hypothesis.</p>",
        "id": 317276640,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671672697
    },
    {
        "content": "<p>My limited understanding of lean tactics is that they make sound transformations</p>",
        "id": 317276740,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671672782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317275303\">said</a>:</p>\n<blockquote>\n<p>Also, I am learning that unfold looks for names only in <code>_root_.</code>. It wont unfold <code>brecPind</code></p>\n</blockquote>\n<p>You could try defining it outside the proof. In Lean 3 we use a trick called <code>eq_to_hom</code> which given a proof that <code>a = b</code> will give you a map from <code>P a</code> to <code>P b</code>, and we have a bunch of API around it.</p>",
        "id": 317276836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671672868
    },
    {
        "content": "<p>I don't think that works in this case. We will have to parametrise on the predicate <code>P</code>. This will bring us back to square one</p>",
        "id": 317276895,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671672944
    },
    {
        "content": "<p>In any case, I worked around the <code>unfold</code> limitation`</p>",
        "id": 317276946,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671672964
    },
    {
        "content": "<p><code>convert</code>'s doc-string says it is actually an improved version of <code>refine</code> which means it is less strict about providing complete terms. So it is odd that it cannot handle implicit terms that lean3's version can, or that it can produce absurd looking goals.</p>",
        "id": 317276966,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673009
    },
    {
        "content": "<p>it's not odd that <code>convert</code> will produce false goals sometimes, this usually means it has gone too deep and you need to use <code>convert ... using 1</code> or so</p>",
        "id": 317277031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673083
    },
    {
        "content": "<p>The issue is that <code>convert</code> refuses to eat <code>binary_rec_eq _ true n</code> in Lean 4 whereas it did so in Lean 3 -- the tactic fails in Lean 4.</p>",
        "id": 317277213,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671673269
    },
    {
        "content": "<p>would be nice if there was an MWE that didn't require me to pull the branch...</p>",
        "id": 317277293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673325
    },
    {
        "content": "<p>You can see the problem in the MWE posted above. Forget about the long broken proof: the proof after is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">binary_rec_eq</span> <span class=\"n\">_</span> <span class=\"n\">true</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_cast_eq</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n</code></pre></div>\n<p>This is what the autoporter produced. But the <code>convert</code> fails and I've just spent an hour trying to make it not fail, and failed.</p>",
        "id": 317277303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671673335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317273069\">said</a>:</p>\n<blockquote>\n<p>Here's the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Data.Nat.Bitwise</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n\n\n<span class=\"kd\">@[elab_as_elim]</span>\n<span class=\"kd\">def</span> <span class=\"n\">evenOddRec</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"n\">binaryRec</span> <span class=\"n\">h0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">bit</span><span class=\"o\">,</span> <span class=\"n\">bit0_val</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h_even</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">bit</span><span class=\"o\">,</span> <span class=\"n\">bit1_val</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h_odd</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.even_odd_rec</span> <span class=\"n\">Nat.evenOddRec</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_zero</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">binary_rec_zero</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.even_odd_rec_zero</span> <span class=\"n\">Nat.even_odd_rec_zero</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_even</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">bit_val_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">bit_val</span><span class=\"o\">,</span> <span class=\"n\">cond</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"n\">bit_val_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">bit</span> <span class=\"n\">true</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val</span><span class=\"o\">,</span> <span class=\"n\">cond</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">brecPind</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">):=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_n</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span>\n    <span class=\"n\">case</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"n\">h_2n</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h_even</span> <span class=\"n\">n</span> <span class=\"n\">h_n</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_2n</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h_2n</span>\n    <span class=\"n\">case</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"n\">h_2n_1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"n\">h_n</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_2n_1</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h_2n_1</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">binary_rec_eq</span> <span class=\"n\">P</span> <span class=\"n\">h0</span> <span class=\"n\">brecPind</span> <span class=\"n\">H</span> <span class=\"n\">false</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_cast_eq</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">binary_rec_eq</span> <span class=\"n\">_</span> <span class=\"n\">true</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">bit0_eq_two_mul</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_cast_eq</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Nat</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Here</p>",
        "id": 317277313,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673342
    },
    {
        "content": "<p>It's the entire file because I wanted to show multiple things</p>",
        "id": 317277317,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673359
    },
    {
        "content": "<p>Made some changes</p>",
        "id": 317277344,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673427
    },
    {
        "content": "<ol>\n<li>The lean3 proof of <code>even_odd_rec_odd</code> and <code>even_odd_rec_even</code> are identical </li>\n<li>If you open the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> now. In <code>even_odd_rec_even</code> I had to insert explicit arguments (same as <code>even_odd_rec_odd</code>, but I left it untouched for reference). These produced absurd case distinctions.</li>\n</ol>",
        "id": 317277517,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673581
    },
    {
        "content": "<p>this MWE shouldn't need any imports at all</p>",
        "id": 317277524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673597
    },
    {
        "content": "<p>You need <code>binaryRec</code></p>",
        "id": 317277534,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671673619
    },
    {
        "content": "<p>then state it</p>",
        "id": 317277551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673635
    },
    {
        "content": "<p>It compiles fine on mathlib master and building the imports is also super-quick</p>",
        "id": 317277554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671673640
    },
    {
        "content": "<p>Bitwise is necessary. binaryRec, binary_rec_eq, and all basic Nat stuff</p>",
        "id": 317277556,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673646
    },
    {
        "content": "<p>It also works quickly on the lean4 playground</p>",
        "id": 317277567,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673667
    },
    {
        "content": "<p>I've been building since 5 minutes ago -_-</p>",
        "id": 317277576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673680
    },
    {
        "content": "<p>you need <code>bodd</code> and all the other stuff Shreyas has been porting over the last few days. A mathlib-free MWE would be horrible</p>",
        "id": 317277635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671673703
    },
    {
        "content": "<p>switching branches is super painful because of the nightly bumps</p>",
        "id": 317277640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673713
    },
    {
        "content": "<p>Is it possible to make tools to make MWEs?</p>",
        "id": 317277643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671673716
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/M5w7pNW_OGgTF_vVoUEziJED/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/M5w7pNW_OGgTF_vVoUEziJED/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/M5w7pNW_OGgTF_vVoUEziJED/image.png\"></a></div>",
        "id": 317277649,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673726
    },
    {
        "content": "<p>I tried that and failed on the imports</p>",
        "id": 317277659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673742
    },
    {
        "content": "<p>You can open this on the playground</p>",
        "id": 317277660,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673742
    },
    {
        "content": "<p>because I was on a branch from yesterday I guess</p>",
        "id": 317277668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673766
    },
    {
        "content": "<p>but for an MWE there are way too many lines</p>",
        "id": 317277674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671673801
    },
    {
        "content": "<p>I used the playground button on the screenshot</p>",
        "id": 317277720,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317277668\">said</a>:</p>\n<blockquote>\n<p>because I was on a branch from yesterday I guess</p>\n</blockquote>\n<p>It's one def, one trivial theorem, and two nearly identical theorems. At best, the first trivial theorem could be removed, but that might also cause problems. The other two theorems depend on the def.</p>",
        "id": 317277769,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673874
    },
    {
        "content": "<p>And both these theorems have the same issue.</p>\n<ol>\n<li>In the first one, I show what happens when you give explicit arguments to the convert line.</li>\n<li>In the second one, I leave the lean3 version of the proof as is, so you can see the issue with the mathlib3 version of the proof.</li>\n</ol>",
        "id": 317277828,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673933
    },
    {
        "content": "<p>I don't see any meaningful ways to reduce this.</p>",
        "id": 317277833,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671673941
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bit</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"n\">bit1</span> <span class=\"n\">bit0</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bit0_val</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bit0</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bit1_val</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bit1</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">binaryRec</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">binary_rec_eq</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">binaryRec</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">binaryRec</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[elab_as_elim]</span>\n<span class=\"kd\">def</span> <span class=\"n\">evenOddRec</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"n\">binaryRec</span> <span class=\"n\">h0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">bit</span><span class=\"o\">,</span> <span class=\"n\">bit0_val</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h_even</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">bit</span><span class=\"o\">,</span> <span class=\"n\">bit1_val</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h_odd</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">binary_rec_eq</span> <span class=\"n\">_</span> <span class=\"n\">true</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 317277933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671674091
    },
    {
        "content": "<p>you can get rid of nat.basic too if you remove the <code>\\N</code> syntax, but we don't need to go full mathlib-free here since <code>convert</code> is a mathlib tactic anyway</p>",
        "id": 317277959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671674115
    },
    {
        "content": "<p>yeah but you've sorried a bunch of data now, so if you get the <code>convert</code> working then it might not work in the actual use case?</p>",
        "id": 317278406,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671674553
    },
    {
        "content": "<p>true, if definition unfolding is involved then you should provide the bodies of defs</p>",
        "id": 317278429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671674593
    },
    {
        "content": "<p>In this case it would take a lot longer to make the mwe (with only proofs sorried) than it would take you to compile Data.Nat.Basic :-( It can take a super-long time to make mathlib-free mwes now, this is why I was asking about auto-generating them (apparently they can do it in Coq?)</p>",
        "id": 317278762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671674949
    },
    {
        "content": "<p>Auto-generating MWEs would be very cool</p>",
        "id": 317278779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671674976
    },
    {
        "content": "<p>I think there are a couple levels we have to unlock before we can get there though</p>",
        "id": 317278786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671674995
    },
    {
        "content": "<p>But the set of things that come to bear on a single line of proof is generally approximately constant</p>",
        "id": 317278847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671675031
    },
    {
        "content": "<p>(unless it's a really bad definition-unfolding proof or a typeclass problem)</p>",
        "id": 317278883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671675091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317278779\">said</a>:</p>\n<blockquote>\n<p>Auto-generating MWEs would be very cool</p>\n</blockquote>\n<p>Could this not be hard to debug though? Especially in tactic heavy proofs</p>",
        "id": 317278945,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671675125
    },
    {
        "content": "<p>why?</p>",
        "id": 317278950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671675135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317278406\">said</a>:</p>\n<blockquote>\n<p>yeah but you've sorried a bunch of data now, so if you get the <code>convert</code> working then it might not work in the actual use case?</p>\n</blockquote>\n<p>This for example</p>",
        "id": 317278962,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671675160
    },
    {
        "content": "<p>the other tactics in the proof are hopefully not relevant and can be removed</p>",
        "id": 317278963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671675162
    },
    {
        "content": "<p>As long as <code>convert</code> doesn't unfold the definition, it doesn't matter what's behind it</p>",
        "id": 317278990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671675189
    },
    {
        "content": "<p>In this case I belatedly realized you are unfolding <code>evenOddRec</code> to <code>binaryRec</code> in this line of proof so we need that definition, but not the stack leading up to <code>binaryRec</code></p>",
        "id": 317279006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671675224
    },
    {
        "content": "<p>In broad terms: Tactics are doing very useful, but invisible work behind the scenes . It takes time to hone one's understanding about their exact behaviour. So one can only make educated guesses about what causes the error one observes using the tactic state output (and maybe pp). For example, if Kevin had not pointed out that sorrying out things might remove errors in downstream tactic uses, I would assume that such an example is in fact adequate.</p>",
        "id": 317280093,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671676272
    },
    {
        "content": "<p>I think it's fine to start with aggressive sorrying and re-add stuff if it turns out it was oversimplified</p>",
        "id": 317280192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671676341
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_as_elim]</span>\n<span class=\"kd\">def</span> <span class=\"n\">evenOddRec</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"n\">binaryRec</span> <span class=\"n\">h0</span> <span class=\"o\">(</span><span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">bit0_val</span> <span class=\"n\">i</span> <span class=\"bp\">▸</span> <span class=\"n\">h_even</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">bit1_val</span> <span class=\"n\">i</span> <span class=\"bp\">▸</span> <span class=\"n\">h_odd</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_even</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">evenOddRec</span><span class=\"o\">,</span> <span class=\"n\">binary_rec_eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">eq_rec_heq</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n  <span class=\"n\">eq_of_heq</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">bit0_val</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_odd_rec_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_even</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_odd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">h_even</span> <span class=\"mi\">0</span> <span class=\"n\">h0</span> <span class=\"bp\">=</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">evenOddRec</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">bit</span> <span class=\"n\">true</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">evenOddRec</span> <span class=\"n\">_</span> <span class=\"n\">h0</span> <span class=\"n\">h_even</span> <span class=\"n\">h_odd</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">evenOddRec</span><span class=\"o\">,</span> <span class=\"n\">binary_rec_eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">eq_rec_heq</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">H</span>\n  <span class=\"n\">eq_of_heq</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">bit1_val</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 317280348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671676499
    },
    {
        "content": "<p>okay that worked wow!</p>",
        "id": 317280735,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671676821
    },
    {
        "content": "<p>I will commit this as is, but I am going to spend some time understanding this afterwards</p>",
        "id": 317280752,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671676856
    },
    {
        "content": "<p>So in this proof you used heterogeneous equality, which I am guessing coerces equality between values of different types. Is there like a comprehensive list of ways this can go wrong (apart from the <code>congr</code> issue)? It seems quite handy for functional programmers, so I can see this getting wrongly used</p>",
        "id": 317282156,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671678226
    },
    {
        "content": "<p><code>Data.Nat.EvenOddRec</code> passed all checks and is ready to merge.</p>",
        "id": 317282440,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671678475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317282156\">said</a>:</p>\n<blockquote>\n<p>So in this proof you used heterogeneous equality, which I am guessing coerces equality between values of different types. Is there like a comprehensive list of ways this can go wrong (apart from the <code>congr</code> issue)? It seems quite handy for functional programmers, when dealing with representation issues, so I can potentially see this getting wrongly used</p>\n</blockquote>\n<p>This sort of thing is what we call \"DTT hell\". It hopefully doesn't come up that often, but this is the standard trick for dealing with it: do induction on some equality with a carefully chosen \"motive\" (that is, the type of the <code>have</code> statement in this example) to do dependent rewrites. Most of lean's tactics will not handle this situation well, either complaining \"the motive is not type correct\" or doing nothing at all, so you have to do it manually in this way.</p>",
        "id": 317283900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671679902
    },
    {
        "content": "<p>the heterogeneous equality is needed to make the motive typecheck, since the LHS has type <code>P a</code> and the RHS has type <code>P (2 * n)</code></p>",
        "id": 317283972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671679958
    },
    {
        "content": "<p>I'm not sure exactly what you mean by ways this can go wrong. This is a proof technique, it has a limited range of applicability but if it works then it works</p>",
        "id": 317284072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671680100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317283900\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Data.2ENat.2EEvenOddRec/near/317282156\">said</a>:</p>\n<blockquote>\n<p>So in this proof you used heterogeneous equality, which I am guessing coerces equality between values of different types. Is there like a comprehensive list of ways this can go wrong (apart from the <code>congr</code> issue)? It seems quite handy for functional programmers, when dealing with representation issues, so I can potentially see this getting wrongly used</p>\n</blockquote>\n<p>This sort of thing is what we call \"DTT hell\". It hopefully doesn't come up that often, but this is the standard trick for dealing with it: do induction on some equality with a carefully chosen \"motive\" (that is, the type of the <code>have</code> statement in this example) to do dependent rewrites. Most of lean's tactics will not handle this situation well, either complaining \"the motive is not type correct\" or doing nothing at all, so you have to do it manually in this way.</p>\n</blockquote>\n<p>By \"going wrong\" I am referring to the note of caution inside <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HEq#doc\">docs4#HEq</a></p>",
        "id": 317284778,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671680860
    },
    {
        "content": "<p>But I think I get the gist</p>",
        "id": 317284872,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671680971
    },
    {
        "content": "<p>Thanks</p>",
        "id": 317284877,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671680980
    },
    {
        "content": "<p>Hi,<br>\nI noticed that <a href=\"https://github.com/leanprover-community/mathlib4/pull/1148\">mathlib4#1148</a> has not been merged yet. Is there some issue with this PR that needs fixing?</p>",
        "id": 317436955,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671737151
    },
    {
        "content": "<p>It has no reviews and at the time of writing it doesn't even have a green tick. We don't yet know if there are issues with this PR that need fixing because it looks like nobody got round to looking at it yet other than Reid, who fixed some naming. Wel'l get there. Is this file on the critical line to any of the standard targets like data.real.basic ? Usually when I review I start at the top of <a href=\"https://bit.ly/3cKk3ld\">#queue4</a> and probably when you get the green tick back you'll be at the bottom of that queue? I'm not sure about how the order works to be honest.</p>",
        "id": 317437788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671737415
    },
    {
        "content": "<p>Ah okay, I noticed a fresh commit from <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 317438402,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671737634
    },
    {
        "content": "<p>Some names were fixed to meet the lean4 style. As I recall it, it was green last night.</p>",
        "id": 317438499,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1671737656
    },
    {
        "content": "<p>Feel free to review other PRs on <a href=\"https://bit.ly/3cKk3ld\">#queue4</a> ; this will get yours to the top quicker.</p>",
        "id": 317442214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671739168
    }
]
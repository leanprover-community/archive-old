[
    {
        "content": "<p>I want to start porting some meta code to Lean 4, and I want to start with the things I'm most familiar with, which are <code>@[simps]</code> and <code>@[to_additive]</code>.</p>\n<p>I'll have to ask a bunch of questions along the way, so to start:<br>\nIf in Lean 3 we used an attribute with a cache value, how do we do this in Lean 4? With a <code>PersistentEnvExtension</code> directly?</p>",
        "id": 263142355,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638278410
    },
    {
        "content": "<p>Although I guess that most cache-attributes like that just stored the <code>name_map</code> of parameters, which seems to be handled automatically by the attribute.</p>",
        "id": 263144012,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638279104
    },
    {
        "content": "<p>How hard would it be to use mathport to already port all files that are <em>below</em> all/most tactic files in the file hierarchy? Things like <code>data.list.defs</code> and <code>data.string.defs</code>? That would be useful for tactic writing.</p>",
        "id": 263148546,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638281002
    },
    {
        "content": "<p>Starting from the end: you can look at the ported files here: <a href=\"https://github.com/leanprover-community/mathlib3port/blob/master/Mathbin/Data/String/Defs.lean\">https://github.com/leanprover-community/mathlib3port/blob/master/Mathbin/Data/String/Defs.lean</a></p>\n<p>But particularly strings are probably a bad thing to port directly.  These should be rewritten.</p>",
        "id": 263148984,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638281171
    },
    {
        "content": "<blockquote>\n<p>Although I guess that most cache-attributes like that just stored the name_map of parameters, which seems to be handled automatically by the attribute.</p>\n</blockquote>\n<p>There are various kinds of attributes that store (and compute) different kinds of state.  I suggest reading through <a href=\"https://github.com/leanprover/lean4/blob/f01a124f187793cdf09788b0cc102eba156b1c60/src/Lean/Attributes.lean\">https://github.com/leanprover/lean4/blob/f01a124f187793cdf09788b0cc102eba156b1c60/src/Lean/Attributes.lean</a> to get an idea of the available attribute types.  You almost certainly shouldn't create a PersistentEnvExtension manually.</p>",
        "id": 263149358,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638281340
    },
    {
        "content": "<p>We also have another cache API here: <a href=\"https://github.com/leanprover-community/mathlib4/blob/8fe680846b7f4dd1b93688a6355c1c1a0cba7f06/Mathlib/Tactic/Cache.lean\">https://github.com/leanprover-community/mathlib4/blob/8fe680846b7f4dd1b93688a6355c1c1a0cba7f06/Mathlib/Tactic/Cache.lean</a>  But I don't think this is applicable for simps/toAdditive.</p>",
        "id": 263149464,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638281402
    },
    {
        "content": "<p>Thanks for the pointers!</p>",
        "id": 263150334,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638281738
    },
    {
        "content": "<p>In Lean 3 there is <code>has_attribute</code> which takes the <em>name</em> of an attribute, which is convenient if your attribute has not defined yet (e.g. the implementation of <code>to_additive</code> checks whether other declarations are marked as <code>to_additive</code>). How to do this in Lean 4? I can only find <code>ParametricAttribute.getParam</code> and <code>isAttribute</code> which are somewhat similar.</p>",
        "id": 263154720,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638283499
    },
    {
        "content": "<p>I don't think this exists in general.  But for to_additive, you could just look in the state of the attribute.</p>",
        "id": 263154924,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638283570
    },
    {
        "content": "<p>I guess I could do that, but then I have to inline the definition <a href=\"https://leanprover-community.github.io/mathlib_docs/find/to_additive.first_multiplicative_arg/src\">src#to_additive.first_multiplicative_arg</a>.</p>",
        "id": 263155291,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638283730
    },
    {
        "content": "<p>I mean you can still write a <code>has_attribute' `to_additive</code> function, it will just be specific to toAdditive (and won't work for other attributes).</p>",
        "id": 263155670,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638283889
    },
    {
        "content": "<p>before I declare the attribute? I don't see how.</p>",
        "id": 263156507,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638284261
    },
    {
        "content": "<p>Also, am I correct that I cannot tag a declaration with an attribute in the file where I define that attribute?</p>",
        "id": 263156822,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638284400
    },
    {
        "content": "<blockquote>\n<p>before I declare the attribute? I don't see how.</p>\n</blockquote>\n<p>Ah yes, the easiest thing is probably to just pass the state around.  You could also try to apply the <code>@[init]</code> attribute afterwards (not sure if that works):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">myAttr</span> <span class=\"o\">:</span> <span class=\"n\">ParametricAttribute</span> <span class=\"n\">Foo</span>\n\n<span class=\"c1\">-- here you can already refer to myAttr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myAttrInit</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">ParametricAttribute</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">registerParametricAttribute</span> <span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">init</span> <span class=\"n\">myAttrInit</span><span class=\"o\">]</span> <span class=\"n\">myAttr</span>\n</code></pre></div>",
        "id": 263163764,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638287339
    },
    {
        "content": "<blockquote>\n<p>Also, am I correct that I cannot tag a declaration with an attribute in the file where I define that attribute?</p>\n</blockquote>\n<p>Yes, depending on the attribute type you can also only tag declarations in the same file.</p>",
        "id": 263163837,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638287381
    },
    {
        "content": "<p>Thanks, that is helpful!</p>\n<p>Two more questions about attributes.</p>\n<ul>\n<li>If I define an attribute like this</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n<span class=\"n\">initialize</span> <span class=\"n\">fooAttr</span> <span class=\"o\">:</span> <span class=\"n\">ParametricAttribute</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">←</span>\n  <span class=\"n\">registerParametricAttribute</span> <span class=\"o\">{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">foo</span>\n    <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"foo desc.\"</span>\n    <span class=\"n\">getParam</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">decl</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span><span class=\"n\">foo</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ns</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ns.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unexpected foo syntax {stx}\"</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>I don't have to check that <code>ns</code> is a list of identifiers, because the parser will already complain if this is not the case, right?<br>\nAlso, can I actually get to the <code>throwError</code> line? It seems like the parser will not even run this code if the syntax does not match the first case.</p>\n<ul>\n<li>Suppose I have two syntax declarations </li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"o\">)</span> <span class=\"s2\">\"bar\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"s2\">\"bar!\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n</code></pre></div>\n<p>(this is in the <code>Mathport.Syntax</code> file for e.g. <code>toAdditive</code>). How do I make a single attribute that is triggered on both these parses? I tried something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">initialize</span> <span class=\"n\">barAttr</span> <span class=\"o\">:</span> <span class=\"n\">ParametricAttribute</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">←</span>\n  <span class=\"n\">registerParametricAttribute</span> <span class=\"o\">{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">bar</span>\n    <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"bar desc.\"</span>\n    <span class=\"n\">getParam</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">decl</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span><span class=\"n\">bar</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ns</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ns.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span><span class=\"n\">bar</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ns</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ns.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unexpected bar syntax {stx}\"</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>but that doesn't work for <code>bar!</code> (I get <code>unknown attribute [bar!]</code>)</p>",
        "id": 263278328,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638359568
    },
    {
        "content": "<blockquote>\n<p>I don't have to check that ns is a list of identifiers, because the parser will already complain if this is not the case, right?</p>\n</blockquote>\n<p>It's an <em>array</em> of <em>numbers</em>, but otherwise you're correct.</p>",
        "id": 263281160,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638361364
    },
    {
        "content": "<blockquote>\n<p>How do I make a single attribute that is triggered on both these parses?</p>\n</blockquote>\n<p>I don't think you can.  I would just either make two attributes or turn the parser into <code>\"bar\" \"!\"?</code>.</p>",
        "id": 263281271,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638361440
    },
    {
        "content": "<p>does that actually work? I would have expected it to parse <code>bar!</code> as an ident anyway</p>",
        "id": 263281601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638361604
    },
    {
        "content": "<p>You're right.  Writing <code>bar!</code> doesn't work, but <code>bar !</code> works, which is almost as good.</p>",
        "id": 263281786,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638361722
    },
    {
        "content": "<p>For a lot of attributes, I think we want to separate the data storage from the syntax/parsing part. In this case we have two syntax-level attributes but only one data storage component</p>",
        "id": 263281791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638361725
    },
    {
        "content": "<p>I think the built in mechanisms like <code>TagAttribute</code> tie the two parts together, so we don't want to use that</p>",
        "id": 263281840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638361761
    },
    {
        "content": "<p>not sure about <code>ParametricAttribute</code></p>",
        "id": 263281865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638361778
    },
    {
        "content": "<p>It also has a storage part, but we can just ignore it (or use <code>registerBuiltinAttribute</code> directly).</p>",
        "id": 263282056,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638361876
    },
    {
        "content": "<p>yeah, I think <code>registerBuiltinAttribute</code> is the way to go, most of the things done in the function <code>registerParametricAttribute</code> passes to it are not needed for a generic attribute definition</p>",
        "id": 263282363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638362053
    },
    {
        "content": "<p>In fact, I think we rarely want a simple <code>PersistentEnvExtension</code> that just tracks applications of the attribute. Usually the actual data store is somewhat derived from this</p>",
        "id": 263282599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638362191
    },
    {
        "content": "<p>I've defined a custom attribute like this for Aesop. Code: <a href=\"https://github.com/JLimperg/aesop/blob/55c0d71da597d540b51703afc13f488503ac2885/Aesop/Config.lean#L542\">https://github.com/JLimperg/aesop/blob/55c0d71da597d540b51703afc13f488503ac2885/Aesop/Config.lean#L542</a></p>",
        "id": 263283302,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1638362561
    },
    {
        "content": "<p>What's the reason for holding on to the <code>impl</code> after passing it to <code>registerBuiltinAttribute</code>?</p>",
        "id": 263283517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638362668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20simps.20and.20to_additive/near/263282599\">said</a>:</p>\n<blockquote>\n<p>In fact, I think we rarely want a simple <code>PersistentEnvExtension</code> that just tracks applications of the attribute. Usually the actual data store is somewhat derived from this</p>\n</blockquote>\n<p>One way we can do this with <code>ParametricAttribute</code> is to let the <code>getParam</code> function compute the data we want to store, right?</p>",
        "id": 263284352,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638363087
    },
    {
        "content": "<p>That assumes that what we want to build is a <code>NameMap A</code> for some <code>A</code>, where the key is the name of the definition we are putting the attribute on. Sometimes we want that, other times the key is not this definition but one of the parameters of the attribute or something else altogether, or perhaps it's not a <code>NameMap</code> at all but rather a discrimination tree or other data structure</p>",
        "id": 263284673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638363248
    },
    {
        "content": "<p>Ok, that's fair.</p>",
        "id": 263284731,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638363288
    },
    {
        "content": "<p>In this case, we also don't want to build two <code>NameMap</code>s, one for the <code>toAdditive</code> lemmas and one for <code>toAdditive!</code></p>",
        "id": 263284784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638363324
    },
    {
        "content": "<p>So shall I make a variant of <code>ParametricAttribute</code> that</p>\n<ul>\n<li>has a list/array of attribute names instead of 1 (e.g. <code>toAdditive</code> and <code>toAdditive!</code>; it will declare <code>BuiltinAttribute</code>s for each of them</li>\n<li>It has a custom type of what data it stores (generalizing <code>NameMap α</code> from <code>ParametricAttribute</code>). This data is \"shared\" among the different names of the attribute</li>\n</ul>",
        "id": 263284899,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638363369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20simps.20and.20to_additive/near/263283517\">said</a>:</p>\n<blockquote>\n<p>What's the reason for holding on to the <code>impl</code> after passing it to <code>registerBuiltinAttribute</code>?</p>\n</blockquote>\n<p>Not sure there is one now that I look at it.</p>",
        "id": 263284906,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1638363373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Is <code>PersistentEnvExtension</code> sufficient, or too general for you?</p>",
        "id": 263284998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638363431
    },
    {
        "content": "<p>basically, I'm suggesting that you adapt the code of <code>registerParametricAttribute</code> instead of calling it directly</p>",
        "id": 263285087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638363470
    },
    {
        "content": "<p>I could  work with that directly. But I expect that we will have multiple similar uses (for other attributes), and I thought a less general interface could be helpful.</p>",
        "id": 263285240,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638363540
    },
    {
        "content": "<p>you are probably right, but it might be helpful to have 1 or 2 examples first</p>",
        "id": 263285293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638363571
    },
    {
        "content": "<p>sounds reasonable</p>",
        "id": 263285308,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638363578
    },
    {
        "content": "<p>Am I correct that this function does not exist yet?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Parse a string. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">toString</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">strLitKind</span> <span class=\"n\">stxs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">stxs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getAtomVal</span><span class=\"bp\">!</span>\n<span class=\"bp\">|</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"s2\">\"String expected\"</span>\n</code></pre></div>",
        "id": 263293125,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638366937
    },
    {
        "content": "<p>I don't think that is correct, since the stored atom includes the quotation marks</p>",
        "id": 263293631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638367122
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span> <span class=\"n\">toString</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"s2\">\"foo\"</span><span class=\"o\">))</span>\n<span class=\"c1\">-- \"\\\"foo\\\"\"</span>\n</code></pre></div>",
        "id": 263293679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638367141
    },
    {
        "content": "<p>There is <code>Syntax.isStrLit?</code>.</p>",
        "id": 263294011,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638367234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> in my PR you mentioned to use <code>forallTelescope</code>. Am I correct that I need to be in <code>MetaM</code> to do that? I believe that means I cannot execute this during <code>AttributeImpl.add</code> (which is in <code>AttrM</code> a.k.a. <code>CoreM</code>)</p>",
        "id": 263298042,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638368863
    },
    {
        "content": "<p>Yes, <code>forallTelescope</code> is in Meta.  You can use <code>MetaM.run'</code> to call a MetaM function in CoreM.</p>",
        "id": 263298190,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638368927
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 263298401,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638369016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20simps.20and.20to_additive/near/263278328\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Suppose I have two syntax declarations </li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"o\">)</span> <span class=\"s2\">\"bar\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"s2\">\"bar!\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n</code></pre></div>\n<p>(this is in the <code>Mathport.Syntax</code> file for e.g. <code>toAdditive</code>). How do I make a single attribute that is triggered on both these parses? </p>\n</blockquote>\n<p>Does this not work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"bar\"</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"s2\">\"bar!\"</span><span class=\"o\">)</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n</code></pre></div>",
        "id": 263316383,
        "sender_full_name": "Mac",
        "timestamp": 1638375928
    },
    {
        "content": "<p>Or, if you want to discriminate between them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"s2\">\"bar\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span>\n<span class=\"n\">syntax</span> <span class=\"n\">bar</span><span class=\"bp\">!</span> <span class=\"o\">:=</span>  <span class=\"s2\">\"bar!\"</span> <span class=\"n\">num</span><span class=\"bp\">*</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">barAttr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">bar</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n</code></pre></div>",
        "id": 263316676,
        "sender_full_name": "Mac",
        "timestamp": 1638376046
    },
    {
        "content": "<p>Oh, that does seem to work as well.</p>",
        "id": 263317585,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638376406
    },
    {
        "content": "<p>Another question about auxiliary definitions (needed for <code>toAdditive</code>).<br>\nIn Lean 3, a <code>def</code> or <code>lemma</code> <code>foo</code> could generate a couple of automatically generated declarations. On the top of my head we have the following, but there are probably more.</p>\n<ul>\n<li><code>foo._proof_i</code> and <code>foo._match_i</code> which occur in the value of <code>foo</code>.</li>\n<li><code>foo.eqn_i</code> for the equations generated by <code>foo</code>.</li>\n</ul>\n<p>What is the status in Lean 4? I already see <code>foo._cstagei</code>, <code>foo._sunfold</code>, <code>foo._unsafe_rec</code>, <code>foo.match_i</code>. Are there methods of getting some/all auxiliary declarations for <code>foo</code> (something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.get_eqn_lemmas_for\">docs#tactic.get_eqn_lemmas_for</a>)?</p>",
        "id": 263318877,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638376839
    },
    {
        "content": "<p>I don't know enough about how to <code>to_additive</code> works in Lean 3 to know if this is reasonable, but is there any reason you just can't do the transformation on the ~syntax<code> rather than the elaborated </code>Expr`? That way you don't have to worry about the assorted of auxiliary definitions the elaborator may generate (which I don't think is actually bounded in Lean 4).</p>",
        "id": 263320043,
        "sender_full_name": "Mac",
        "timestamp": 1638377309
    },
    {
        "content": "<p>Getting all the features of <code>toAdditive</code> on Syntax might be hard. For example, <code>toAdditive</code> checks for each occurrence of a declaration whether it is applied to <code>Nat</code> (or some other fixed type), and if so, don't change that occurrence. This information is usually implicit in the user input.</p>",
        "id": 263322747,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1638378275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> You could have the elaborator repeat <em>some</em> of the work without starting at <code>Syntax</code>, e.g. using <code>Lean.Elab.addPreDefinitions</code>. It takes a list of (mutually recursive) <code>PreDefinition</code>s and generates the final definition and these helper defs from them.</p>",
        "id": 263323319,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638378548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I think using <code>syntax (name := bar) (\"bar\" &lt;|&gt; \"bar!\") num* : attr</code> leads to poor indexing of the syntax, since it doesn't start with a constant. If you have a lot of these then they all end up in a grab bag at the end</p>",
        "id": 263325882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638379610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> yeah, hence my second example.</p>",
        "id": 263326109,
        "sender_full_name": "Mac",
        "timestamp": 1638379690
    },
    {
        "content": "<p>that still has the same problem though, for <code>barAttr</code></p>",
        "id": 263326172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638379719
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> how so?</p>",
        "id": 263326202,
        "sender_full_name": "Mac",
        "timestamp": 1638379733
    },
    {
        "content": "<p><code>barAttr</code> doesn't start with a constant, so it can't be indexed like one</p>",
        "id": 263326243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638379748
    },
    {
        "content": "<p>the <code>firstTokens</code> system does account for nested parsers.</p>",
        "id": 263326245,
        "sender_full_name": "Mac",
        "timestamp": 1638379749
    },
    {
        "content": "<p>it doesn't require the start to literally be a token</p>",
        "id": 263326281,
        "sender_full_name": "Mac",
        "timestamp": 1638379766
    },
    {
        "content": "<p>The problem with <code>(\"bar\" &lt;|&gt; \"bar!\") num* </code> is not that it won't be indexed properly (it will still have as its <code>firstTokens</code> <code>bar</code> and <code>bar!</code> and be indexed accordingly). The problem is that you will no be easily able to distinguish between <code>bar</code> and <code>bar!</code> syntaxes (as they do not have separate node kinds).</p>",
        "id": 263326627,
        "sender_full_name": "Mac",
        "timestamp": 1638379890
    },
    {
        "content": "<p>At least, that is my understanding.</p>",
        "id": 263326740,
        "sender_full_name": "Mac",
        "timestamp": 1638379930
    },
    {
        "content": "<p>That's not necessarily a problem; in this case we actually want them to have the same node kind since they are morally the same tactic/attr</p>",
        "id": 263327179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638380102
    },
    {
        "content": "<p>for example, that would allow us to have only one <code>@[elab]</code> for the corresponding tactic, or only one name for the attr</p>",
        "id": 263327299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638380161
    },
    {
        "content": "<p>(This is all working around the fact that <code>\"bar\" \"!\"?</code> doesn't work)</p>",
        "id": 263327503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638380207
    },
    {
        "content": "<p>What's the block to using noWs between \"bar\" and \"!\"?</p>",
        "id": 263327902,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1638380339
    },
    {
        "content": "<p>I would put the keywords only in syntax defs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"s2\">\"bar\"</span>\n<span class=\"n\">syntax</span> <span class=\"n\">bar</span><span class=\"bp\">!</span> <span class=\"o\">:=</span>  <span class=\"s2\">\"bar!\"</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">barAttr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">bar</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n</code></pre></div>\n<p>That way semantically different tactic invocations are structurally syntactically different and thus work with pattern matching</p>",
        "id": 263328317,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638380508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> The issue is that <code>!</code> is an identifier char so <code>bar!</code> always gets lexed as an identifier</p>",
        "id": 263328478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638380565
    },
    {
        "content": "<p>Maybe a different character then to differentiate simps from simps with reporting of output lemmas?</p>",
        "id": 263328676,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1638380650
    },
    {
        "content": "<p>this issue comes up <em>a lot</em> in mathlib tactics. It's a popular character for tactic modifiers and there aren't any good replacements</p>",
        "id": 263329387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638380937
    },
    {
        "content": "<p>I'd rather investigate why it got turned into an identifier character in the first place but I don't want to burn social capital in the process, so I'm sticking with workarounds for now</p>",
        "id": 263329780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638381120
    },
    {
        "content": "<p>Innocent newbie question: does this also mean that we can't use <code>n!</code> notation for factorials?</p>",
        "id": 263330100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638381256
    },
    {
        "content": "<p>yes</p>",
        "id": 263330111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638381264
    },
    {
        "content": "<p>we'll need to pull out an inverted turkish dotted I or something</p>",
        "id": 263330155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638381295
    },
    {
        "content": "<p>or use <code>n !</code> or <code>(n)!</code></p>",
        "id": 263330231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638381337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20simps.20and.20to_additive/near/263329780\">said</a>:</p>\n<blockquote>\n<p>I'd rather investigate why it got turned into an identifier character in the first place but I don't want to burn social capital in the process, so I'm sticking with workarounds for now</p>\n</blockquote>\n<p>The short answer: <code>Array.get!</code>/<code>Array.get?</code>/<code>Array.get</code> etc.. I'm afraid it's a very useful convention for programming.</p>",
        "id": 263330993,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638381640
    },
    {
        "content": "<p>Those are good examples, but I would still be inclined toward a convention like <code>getE</code>/<code>getO</code>/<code>getD</code>/<code>get</code> for that, considering the tradeoff</p>",
        "id": 263331513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638381845
    },
    {
        "content": "<p>There definitely was some amount of regret when we figured out this would prevent <code>syntax \"foo\" ident?</code>. But it's also really hard to imagine giving it up at this point.</p>",
        "id": 263332013,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638382048
    },
    {
        "content": "<p>Is there no way to combine the two use cases using some clever macros or such?</p>",
        "id": 263332642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638382317
    },
    {
        "content": "<p>It would definitely be possible to e.g. turn off parsing <code>?</code> as part of the ident in <code>syntax</code>, I'm relatively sure we will do that at some point. For <code>bar!</code> custom parsing would be a bit more problematic because of the mentioned indexing, i.e. the token is parsed before this specific parser is even run. And for factorials... you <em>could</em> write a custom <code>ident</code> elaborator that tries to resolve the name including the <code>!</code> or else interpret it as a factorial application right now (edit: ah, hygiene might be a problem here though).</p>",
        "id": 263333562,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638382670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Would it be possible to flip this idea on its head and remove <code>!</code>/<code>?</code> from the ident <em>token</em> and just make a composite ident plus punctuation syntax that expands to identifier with the symbol at the end? That is something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Syntax</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Syntax</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">ident'</span> <span class=\"o\">:=</span> <span class=\"n\">ident</span> <span class=\"n\">noWs</span> <span class=\"o\">(</span><span class=\"s2\">\"!\"</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"s2\">\"?\"</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expandIdent'</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkIdentFrom</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId.appendAfter</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getAtomVal</span><span class=\"bp\">!</span>\n\n<span class=\"n\">macro</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident'</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">expandIdent'</span> <span class=\"n\">id</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">«</span><span class=\"n\">foo</span><span class=\"bp\">»!</span> <span class=\"c1\">-- unknown identifier 'foo!'</span>\n</code></pre></div>",
        "id": 263366837,
        "sender_full_name": "Mac",
        "timestamp": 1638397678
    },
    {
        "content": "<p>This would allow for the <code>!</code>/<code>?</code> to be used as identifiers in standard programming context (as is currently convenient) while making it easier to do something different in DSLs.</p>",
        "id": 263367190,
        "sender_full_name": "Mac",
        "timestamp": 1638397891
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Same issue as with the flipped idea: it will fail in macros because hygiene doesn't like ident manipulation</p>",
        "id": 263462534,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638462102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> isn't there <code>modifyBase</code>  and other such methods to modify identifier names in a hygiene-preserving manner? Or I am misunderstanding how those work?</p>",
        "id": 263466866,
        "sender_full_name": "Mac",
        "timestamp": 1638463894
    },
    {
        "content": "<p>(deleted <code>modifyBase</code> example -- <code>appendAfter</code> apparently already uses <code>modifyBase</code>)</p>",
        "id": 263467106,
        "sender_full_name": "Mac",
        "timestamp": 1638463978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20simps.20and.20to_additive/near/263323319\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> You could have the elaborator repeat <em>some</em> of the work without starting at <code>Syntax</code>, e.g. using <code>Lean.Elab.addPreDefinitions</code>. It takes a list of (mutually recursive) <code>PreDefinition</code>s and generates the final definition and these helper defs from them.</p>\n</blockquote>\n<p>Thank you for this suggestion <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>! That is very useful.</p>\n<p>So just checking that I understand this: If I add the <code>@[toAdditive]</code> attribute to a definition, theorem or opaque decl (is that <code>constant</code>?) then I'll use that <code>Declaration</code> to compute a new <code>PreDefinition</code>, and then use <code>Lean.Elab.addPreDefinitions</code> to add this declaration to the environment.</p>\n<p>Some questions:</p>\n<ul>\n<li>Do I just flatten out all the sub-definitions (like <code>foo._cstagei</code>) in the <code>value</code>, and then <code>addPreDefinitions</code> will add them in for the new declaration? Or should I do what we did in Lean 3: first additivize the sub-definitions and then finally process <code>foo</code>?</li>\n<li>Is all the <code>Modifiers</code> information of a <code>PreDefinition</code> still obtainable from the environment when executing the attribute code? For example, can I check whether a declaration is computable?</li>\n<li>Is the corresponding commands for inductives/structures  <code>Lean.Elab.Command.elabInductiveViews</code> and <code>Lean.Elab.Command.elabStructure</code>?</li>\n</ul>",
        "id": 264290309,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1639051113
    },
    {
        "content": "<blockquote>\n<p>opaque decl (is that constant?)</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p>Do I just flatten out all the sub-definitions (like foo._cstagei) in the value</p>\n</blockquote>\n<p><code>_cstage</code> should not occur in <code>value</code>, but for recursive definitions going back to the <code>PreDefinition.value</code> might be a bit problematic now that I think about it. If it was possible to access the pre-definitions in the attribute hook, that might yield a more feasible solution, but it is not, currently.</p>",
        "id": 264295682,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639054261
    },
    {
        "content": "<p>The other alternative I can see is to do the translation syntactically after all, but with type information taking from the info tree... which is not currently enabled outside of the server, but that might change soon</p>",
        "id": 264296681,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639054792
    },
    {
        "content": "<p>I see. I indeed also see that <code>_cstage</code> does not occur in the value.<br>\nIt would indeed be nice if the predefinition value is still obtainable somehow.<br>\nI could indeed also try to do the translation on the syntax: the main functionality still works without any type information/information about implicit arguments.</p>",
        "id": 264297353,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1639055107
    },
    {
        "content": "<p>Note that the <code>_cstage</code> are not even valid Lean terms but compiler IRs at various stages of type erasure... it might be possible to translate them as well, but personally I would try to avoid that</p>",
        "id": 264300942,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639056749
    },
    {
        "content": "<p>I see. It seems like the main options are:<br>\n(1) From a declaration, make a predefinition and translate that (disadvantage: predefinition value might be different than the declaration value)<br>\n(2) From the syntax, build the additive syntax (disadvantage: no information about implicit arguments when translating)<br>\n(3) Wait until there is better support for either (1) or (2).</p>\n<p>Is the problem with (1) <em>only</em> with recursive (or unsafe) definitions? If the predefinition value and the declaration value is the same for all safe nonrecursive definitions, then I think I'll go with (1). Almost all definitions involving <code>toAdditive</code> are not recursive.</p>",
        "id": 264302591,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1639057501
    },
    {
        "content": "<p>Yes, I believe so - <a href=\"https://github.com/leanprover/lean4/blob/265c18accd055c59e00afa837ab3469141b5ebd9/src/Lean/Elab/PreDefinition/Basic.lean#L99\">https://github.com/leanprover/lean4/blob/265c18accd055c59e00afa837ab3469141b5ebd9/src/Lean/Elab/PreDefinition/Basic.lean#L99</a></p>",
        "id": 264305742,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639058823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20simps.20and.20to_additive/near/263466866\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> isn't there <code>modifyBase</code>  and other such methods to modify identifier names in a hygiene-preserving manner? Or I am misunderstanding how those work?</p>\n</blockquote>\n<p>References to global declarations are detected at macro <em>declaration time</em> (when the syntax quotation is processed), since hygiene says that the macro's definition site, not its use site should provide the scope. When the macro runs, the information is already lost.</p>",
        "id": 264309105,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639060252
    },
    {
        "content": "<p>Am I correct that the Environment doesn't store whether a definition <code>foo</code> is computable? Is a semireliable way to check this by looking at whether <code>foo._cstage1</code> exists?</p>",
        "id": 264317060,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1639063719
    },
    {
        "content": "<p>That sounds like a quite reliable method to me :)</p>",
        "id": 264322395,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639065822
    },
    {
        "content": "<p>Am I correct that Lean 4 does not have variants of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.replace/src\">src#expr.replace</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.fold/src\">src#expr.fold</a> yet? Is <code>Lean.Expr.foldConsts</code> a good implementation to mimic if I want to define similar functions on <code>Expr</code> (in such a way that they only visit each subexpression once)?</p>",
        "id": 264326313,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1639067263
    },
    {
        "content": "<p>There is an <code>Expr.replace</code> function.</p>",
        "id": 264326531,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639067331
    },
    {
        "content": "<p>Oh thanks! I missed that before.</p>",
        "id": 264326693,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1639067383
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> We also have <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Transform.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Transform.lean</a></p>",
        "id": 264371603,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639086512
    }
]
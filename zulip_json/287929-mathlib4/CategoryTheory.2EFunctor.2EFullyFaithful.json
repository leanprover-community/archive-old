[
    {
        "content": "<p>I was hoping to help with the Category theory port effort, and it looks like most of the work is blocked by <a href=\"https://github.com/leanprover-community/mathlib4/pull/846\">mathlib4#846</a> opened by <span class=\"user-mention\" data-user-id=\"560559\">@Richard Osborn</span> .</p>\n<p>I'm happy to help with the file if the help is welcome... I've fixed a couple of the errors, and made progress on a couple more.</p>",
        "id": 316182255,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671161031
    },
    {
        "content": "<p>I think there is no problem just editting if the file is sitting around for a month and has a 'help wanted' tag</p>",
        "id": 316182635,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1671161327
    },
    {
        "content": "<p>Sorry, I've been busy with other things and feeling guilty I haven't looked at that.</p>",
        "id": 316183525,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671162136
    },
    {
        "content": "<p>From memory Richard indicated that <code>aesop</code> wasn't doing something that <code>tidy</code> used to, so you may need to experiment with powering up aesop (giving it access to more tactics or lemmas or whatever).</p>",
        "id": 316183550,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671162179
    },
    {
        "content": "<p>Please ping if you want more eyes!</p>",
        "id": 316183561,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671162191
    },
    {
        "content": "<p>I got the file to typecheck! There's still a lot of cleanup left to do, but I'll compile all the weird behaviors I encountered in this thread once I figure out what's going on...</p>",
        "id": 316195177,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671171940
    },
    {
        "content": "<p>Describing the weird behaviours as <code>-- Porting note: ...</code> or <code>-- Porting note: TODO ...</code> is  good too. :-)</p>",
        "id": 316208154,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671178596
    },
    {
        "content": "<p>I took a quick look at this file. It seems that <code>aesop_cat</code> can't see that things like <code>Function.Injective</code>, <code>Function.RightInverse</code>, etc. are functions and that <code>intros</code> should be applied. At least <code>aesop_cat</code> succeeds if the <code>Function.Injective</code> and/or <code>Function.RightInverse</code> are unfolded first. What's the right approach here? How does one train <code>aesop_cat</code> to use <code>intros</code> (or to unfold) in such situations?</p>",
        "id": 316266776,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671197422
    },
    {
        "content": "<p><code>aesop_cat (add norm unfold Function.Injective)</code> if you want to unfold <code>Injective</code> at one particular Aesop call.</p>\n<p>If you want to unfold <code>Injective</code> as a global rule, add <code>@[aesop norm unfold]</code> on <code>Function.Injective</code>. However, this is maybe too aggressive. For example, a rule <code>Involutive -&gt; Injective</code> would not apply any more since <code>Injective</code> is unfolded first. I've had good experiences with this setup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[aesop safe forward]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">injective_elim</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h₁</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₂</span>\n\n<span class=\"kd\">@[aesop 99%]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">injective_intro</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span>\n</code></pre></div>\n<p>If you have hypotheses <code>h : Injective f</code> and <code>h' : f a = f b</code>, the first rule will conclude <code>a = b</code>. If you have a target <code>Injective f</code>, the second rule will unfold <code>Injective</code>, but unsafely, thus giving other rules a chance to fire.</p>",
        "id": 316269059,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671198073
    },
    {
        "content": "<p>Thanks Jannis! What's the heuristic for that 99%? Does this mean the (unsafe) rule is applied 99% of the time or 1% of the time?</p>",
        "id": 316294767,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671204793
    },
    {
        "content": "<p>I haven't marked any of the lemmas in the file for Aesop. Is there a rough guideline for what kinds of lemmas would make for good Aesop lemmas?</p>",
        "id": 316334005,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671215486
    },
    {
        "content": "<p>Yea, the files should be complete other than <code>aesop_cat</code> and <code>unfold_proj</code> blocking them. The proofs can fairly easily be rewritten to work around the issues in the short term if you want to start porting subsequent files. I won’t have access to my computer until later tonight, but I can push new proofs while <code>aesop_cat</code> gets fixed and <code>unfold_proj</code> gets implemented. Also, feel free to work on the files. I only have a couple hrs each day to look into them.</p>",
        "id": 316334717,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1671215690
    },
    {
        "content": "<p>I did some work on it last night, and the file is pretty much done at this point. Just some minor aesthetic issues with one of the proofs... </p>\n<p>I think something that would be helpful is if someone more knowledgeable about how casts work in Lean 4 could check out what's going on at this porting note: <a href=\"https://github.com/leanprover-community/mathlib4/blob/60d4254544886e10cfc417aff29a3c6362b1a9c6/Mathlib/CategoryTheory/Functor/FullyFaithful.lean#L324\">https://github.com/leanprover-community/mathlib4/blob/60d4254544886e10cfc417aff29a3c6362b1a9c6/Mathlib/CategoryTheory/Functor/FullyFaithful.lean#L324</a> .</p>\n<p>I was able to get around the issue manually, but it seemed like in the Lean 3 proof, Lean was far more willing to rewrite through casts...</p>",
        "id": 316336628,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671216261
    },
    {
        "content": "<p>I golfed this proof a little bit...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- “Divide” a functor by a faithful functor. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Faithful.div</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Faithful</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h_obj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">G.obj</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">obj</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">map</span><span class=\"o\">,</span>\n    <span class=\"n\">map_id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">X</span>\n      <span class=\"n\">apply</span> <span class=\"n\">G.map_injective</span>\n      <span class=\"n\">apply</span> <span class=\"n\">eq_of_heq</span>\n      <span class=\"n\">refine</span> <span class=\"n\">HEq.trans</span> <span class=\"n\">h_map</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Functor.map_id</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"n\">HEq.refl</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n      <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">h_obj</span> <span class=\"o\">}</span>\n    <span class=\"n\">map_comp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n      <span class=\"n\">apply</span> <span class=\"n\">G.map_injective</span>\n      <span class=\"n\">apply</span> <span class=\"n\">eq_of_heq</span>\n      <span class=\"n\">refine</span> <span class=\"n\">HEq.trans</span> <span class=\"n\">h_map</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Functor.map_comp</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"n\">HEq.refl</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n      <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">h_obj</span> <span class=\"o\">}</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">h_map</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 316378673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671233035
    },
    {
        "content": "<p>I'm not really sure why casts showed up in the first place?</p>",
        "id": 316378780,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671233099
    },
    {
        "content": "<p>Oh that looks way better!</p>\n<p>It is quite strange, the original proof could just call<br>\n<code>transitive F.map (𝟙 X)</code>, but in Lean 4 it was failing to  unify <code>F.map (𝟙 X)</code> with something that could be <code>HEq</code> with <code>G.map (map (𝟙 X))</code></p>",
        "id": 316380140,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671233842
    },
    {
        "content": "<p>Could you push to the branch? I'm away from my computer for a few hours...</p>",
        "id": 316380277,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671233930
    },
    {
        "content": "<p>pushed!</p>",
        "id": 316380469,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671234044
    },
    {
        "content": "<p>Let me add back the porting note about the trans tactic, so we don't forget!</p>",
        "id": 316380661,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671234171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316294767\">said</a>:</p>\n<blockquote>\n<p>Thanks Jannis! What's the heuristic for that 99%? Does this mean the (unsafe) rule is applied 99% of the time or 1% of the time?</p>\n</blockquote>\n<p>The number is supposed to be a (very rough) estimate of the success probability of a rule. So \"when you have an <code>Injective</code> target, how likely is it that this rule will lead to a proof?\" Operationally, rules with higher success probability are tried first and the priority of the subgoals of a rule is the priority of the goal to which the rule was applied, multiplied with the success probability.</p>",
        "id": 316425283,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671270483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455674\">Matej Penciak</span> <a href=\"#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316334005\">said</a>:</p>\n<blockquote>\n<p>I haven't marked any of the lemmas in the file for Aesop. Is there a rough guideline for what kinds of lemmas would make for good Aesop lemmas?</p>\n</blockquote>\n<p>I tend to think not so much in terms of individual lemmas but in terms of proofs. So take some class of proofs that seems like they ought to be automatic and add the relevant lemmas as <code>apply</code> rules, if they should be applied to the target, or <code>forward</code>/<code>destruct</code> rules, if they should be used to generate new hypotheses. Equations should be registered as <code>simp</code> lemmas.</p>\n<p>To get reasonable performance, you'll have to avoid these sorts of rules:</p>\n<ul>\n<li>Anything that sends Aesop into a loop, e.g. an <code>apply</code> rule that is applicable to one of its own premises. These rules can be useful as low-priority local rules, but generally not as global rules.</li>\n<li>Similarly, anything that introduces metavariables, e.g. exists-intro or transitivity rules, is better used as a local rule (if at all).</li>\n<li><code>apply</code> rules with many premises on which Aesop can make progress but which don't ultimately lead to a proof.</li>\n<li>Too many <code>forward</code> rules in general, since the implementation of <code>forward</code> rules is currently a bit naive. (<code>destruct</code> is fine.)</li>\n</ul>\n<p>Also, the rules should be in simp-normal form (as usual) since Aesop simps the whole goal before it does anything else.</p>\n<p>A frequent source of tension is that while you build an API, you want rules that look through abstractions (e.g. unfold <code>Injective</code>) and when the API is built, you want rules that preserve abstractions. One way around this is to define a separate rule set for building the API; the other way is to add abstraction-breaking rules only locally. At some point I'll change the UI such that the rule set approach has less syntactic overhead.</p>",
        "id": 316432890,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671274111
    },
    {
        "content": "<p>I had another question while reviewing this PR. Consider the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `F` is full, and naturally isomorphic to some `F'`, then `F'` is also full. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Full.ofIso</span> <span class=\"o\">[</span><span class=\"n\">Full</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">≅</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Full</span> <span class=\"n\">F'</span> <span class=\"n\">where</span>\n  <span class=\"n\">preimage</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">F.preimage</span> <span class=\"o\">((</span><span class=\"n\">α.app</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">)</span>\n  <span class=\"n\">witness</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">NatIso.naturality_1</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">category_theory.full.of_iso</span> <span class=\"n\">CategoryTheory.Full.ofIso</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Faithful.of_iso</span> <span class=\"o\">[</span><span class=\"n\">Faithful</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">≅</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Faithful</span> <span class=\"n\">F'</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">map_injective</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">F.map_injective</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">NatIso.naturality_1</span> <span class=\"n\">α.symm</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">NatIso.naturality_1</span> <span class=\"n\">α.symm</span><span class=\"o\">])</span> <span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">category_theory.faithful.of_iso</span> <span class=\"n\">CategoryTheory.Faithful.of_iso</span>\n</code></pre></div>\n<p>This does technically fit with out naming conventions since <code>Functor.Full</code> has data while <code>Functor.Faithful</code> is a prop-valued class. But the asymmetry in the names here seems quite bad to me!</p>",
        "id": 316495491,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671301354
    },
    {
        "content": "<p>My vote would be to use lower-camel-case for both names, and more generally for names of all instances, regardless of whether they are props or not! Thoughts?</p>",
        "id": 316495633,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671301420
    },
    {
        "content": "<p>Hmm, I think it's quite a useful feature that we can distinguish prop-vs-data using the naming convention.</p>",
        "id": 316499529,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1671303669
    },
    {
        "content": "<p>This was a weird thing that came up in porting the file as well:</p>\n<p>In writing the proof for <a href=\"https://github.com/leanprover-community/mathlib4/blob/aa5e1f92324d6a35fbbb434b4b4a4f11224f54e5/Mathlib/CategoryTheory/Functor/FullyFaithful.lean#L320\">Faithful.div</a> , something about the parser for the structure syntax was bugging out and causing some issues. I've minimized it to the following MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">a_eq_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">natToFoo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">bar.b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">bar.b</span><span class=\"o\">,</span>\n    <span class=\"n\">a_eq_b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>When trying to fill in the <code>sorry</code>, the only way I can get the infoview to show my goals is to add a <code>done</code> at the end, otherwise it shows nothing.</p>",
        "id": 316506217,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671308215
    },
    {
        "content": "<p>This does not happen if instead I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">natToFoo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">bar.b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">bar.b</span><span class=\"o\">,</span>\n    <span class=\"n\">a_eq_b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>so it looks like it's something about the field init shorthand (which I actually didn't even know Lean had until I saw <code>Faithful.div</code>!)</p>",
        "id": 316506462,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671308379
    },
    {
        "content": "<p>Is that syntax definitely allowed? In my VS Code the <code>a</code> in <code>a, b</code> is blue, indicating that it's not a structure field.</p>",
        "id": 316506556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671308412
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span><span class=\"o\">,</span> <span class=\"c1\">-- unknown identifier 'a'</span>\n    <span class=\"n\">a_eq_b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"gr\">sorry</span>\n      <span class=\"n\">done</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 316506630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671308470
    },
    {
        "content": "<p>I'm not sure <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span>, but if you fill in the proof Lean doesn't complain, so I assumed it had something to do with this fancy thing I literally just read in the Rust book a couple days ago: <a href=\"https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand\">https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand</a></p>",
        "id": 316506721,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671308525
    },
    {
        "content": "<p>My guess is that if <code>a</code> is in the context, and has the same name  and type as a field in the structure you can just put it in.</p>",
        "id": 316506764,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671308565
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">natToFoo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_eq_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a_eq_b</span><span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">natToFoo</span> <span class=\"mi\">2</span> <span class=\"mi\">2</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- { a := 2, b := 2, a_eq_b := _ }</span>\n</code></pre></div>\n<p>works</p>",
        "id": 316506820,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671308606
    },
    {
        "content": "<p>Oh I see! You weren't attempting to assign <code>bar.b</code> to <code>a</code> too? Sorry, I misunderstood that part.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">natToFoo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">bar.b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">bar.b</span><span class=\"o\">,</span>\n    <span class=\"n\">a_eq_b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"c1\">-- ⊢ a = bar.b</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>I see the goal if I put the cursor just before the <code>s</code> of <code>sorry</code> (which is something I do a lot).</p>",
        "id": 316507146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671308794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316507146\">said</a>:</p>\n<blockquote>\n<p>Oh I see! You weren't attempting to assign <code>bar.b</code> to <code>a</code> too? Sorry, I misunderstood that part.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">natToFoo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">bar.b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">bar.b</span><span class=\"o\">,</span>\n    <span class=\"n\">a_eq_b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"c1\">-- ⊢ a = bar.b</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>I see the goal if I put the cursor just before the <code>s</code> of <code>sorry</code> (which is something I do a lot).</p>\n</blockquote>\n<p>But if you delete the sorry and try to fill in the goal, there is nothing in the infoview</p>",
        "id": 316507266,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671308878
    },
    {
        "content": "<p>Oh actually this isn't as bad as I remembered, as long as there is even a single line in the proof something appears in the infoview...</p>",
        "id": 316507528,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1671309019
    },
    {
        "content": "<p>Oh this is interesting: I always put a <code>sorry</code> at the end of a proof before I start working on it, so I had never noticed this phenomenon.</p>",
        "id": 316508929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671310009
    },
    {
        "content": "<p>this is the same issue that people were talking about <code>done</code>/<code>qed</code> in the other thread for: empty blocks are a syntax error and this breaks a lot of things</p>",
        "id": 316508983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1671310072
    },
    {
        "content": "<p>I see -- the issue is that the <code>}</code> just throws Lean into confusion because it was expecting a tactic.</p>",
        "id": 316509037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671310093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316499529\">said</a>:</p>\n<blockquote>\n<p>Hmm, I think it's quite a useful feature that we can distinguish prop-vs-data using the naming convention.</p>\n</blockquote>\n<p>This actually brings up another point. IMO <code>Functor.Full</code> could very well be made prop-valued. Anyone, one could certainly make an argument either way. What happens in the future, after the port is done, if we want to make <code>Functor.Full</code> Prop-valued? The current naming convention would probably make such a refactor more annoying.</p>\n<p>This is not unprecedented. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_limits\">docs#category_theory.limits.has_limits</a> used to contain data.</p>",
        "id": 316532562,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671328901
    },
    {
        "content": "<p>I would guess that such changes occur mostly for typeclasses. So if we choose a uniform naming convention for instances, that would eliminate the potential additional work (or at least most of it)</p>",
        "id": 316532973,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671329344
    },
    {
        "content": "<p>I should also mention that I'm not really invested in this suggestion. I'm sure I could get used to whatever convention we settle on. But j do think these things are worth discussing.</p>",
        "id": 316533036,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671329405
    },
    {
        "content": "<p>I was told by someone that in Isabelle/HOL they stick out the is_ convention for prop-valued typeclasses and if worked great</p>",
        "id": 316556674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671353315
    },
    {
        "content": "<p>I think that with proper language server support, doing a global rename of something should be pretty easy. So I think Lean 4 will actually make this easier then it was in Lean 3.</p>",
        "id": 316576480,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1671364755
    },
    {
        "content": "<p>Presumably the LSP could also detect which terms are proofs and which are data, and reflect that info in the editor in some way (e.g. text colour).</p>",
        "id": 316595724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671373553
    },
    {
        "content": "<p>Back to the aesop issue, I think the more important question is why aesop is not doing the variable introduction when it sees an <code>injective</code> goal.</p>",
        "id": 316638989,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671398575
    },
    {
        "content": "<p>Is it not actually trying <code>intro</code>, but instead looking at the syntactical form of the goal?</p>",
        "id": 316639006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671398592
    },
    {
        "content": "<p>If so, this should be changed (at least under an option).</p>",
        "id": 316639008,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671398602
    },
    {
        "content": "<p>We definitely don't want to be adding unsafe rules about unfolding Injective, I think.</p>",
        "id": 316639032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671398631
    },
    {
        "content": "<p>Aesop uses the <code>MetaM</code> equivalent of <code>intros</code>, which does not unfold <code>Injective</code> to discover the forall binders:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Function</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.Injective</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- ... ⊢ Function.Injective f</span>\n  <span class=\"n\">intros</span>\n  <span class=\"c1\">-- ... ⊢ Function.Injective f</span>\n  <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"c1\">-- ... ⊢ a₁ = a₂</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I can change this of course, but I think the current behaviour is correct. If we eagerly unfold <code>Injective</code> and introduce its premises, rules like <code>Involutive f -&gt; Injective f</code> will not work any more.</p>\n<p>(Interestingly, the behaviour of <code>intros</code> does not change if we make <code>Injective</code> an <code>abbrev</code>.)</p>",
        "id": 316771289,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671464210
    },
    {
        "content": "<p>As Scott said, maybe we could add an option for aesop to be more aggressive with intros?</p>",
        "id": 316780500,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671466853
    },
    {
        "content": "<p>This port PR is holding up a bunch of category theory porting. Do we want to wait until we figure out what to do with <code>aesop_cat</code> before merging?</p>",
        "id": 316780782,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671466952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/CategoryTheory.2EFunctor.2EFullyFaithful/near/316780500\">said</a>:</p>\n<blockquote>\n<p>As Scott said, maybe we could add an option for aesop to be more aggressive with intros?</p>\n</blockquote>\n<p>Can be done, but what's wrong with the scheme I outlined above?</p>",
        "id": 316782012,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671467348
    },
    {
        "content": "<p>One issue I see is that it's not just <code>Function.Injective</code> but various other things like <code>Function.RightInverse</code>, etc. I suppose we would have to manually add <code>intro/elim</code> rules for all of these with this approach? Maybe <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> had other issues in mind as well?</p>",
        "id": 316783003,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671467616
    },
    {
        "content": "<p>In any case, it seems that by adding an \"aggressive intros\" option to <code>aesop</code>, that could help <code>aesop_cat</code> cover more goals which are handled with <code>tidy</code> in mathlib3, and that would certainly be a great help in porting the category theory library!</p>",
        "id": 316783653,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671467777
    },
    {
        "content": "<p>Yes, my scheme would require two rules per <code>def</code>. I'll implement the option and then you can see whether it works better for you.</p>",
        "id": 316785999,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671468527
    },
    {
        "content": "<p>Thanks Jannis! that would be very helpful!</p>",
        "id": 316786145,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1671468577
    },
    {
        "content": "<p>Sure, no problem!</p>",
        "id": 316786326,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671468627
    },
    {
        "content": "<p>Implemented in <a href=\"https://github.com/JLimperg/aesop/commit/87a654a5a10f5edf3cfaee9052c08a4342b24179\">87a654a5a10f5edf3cfaee9052c08a4342b24179</a>.</p>",
        "id": 316802930,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671473889
    },
    {
        "content": "<p>The new option can be set with <code>aesop (options := { introsTransparency := some .default })</code>, which will cause <code>intros</code> to unfold definitions up to <code>default</code> transparency.</p>",
        "id": 316840983,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671488241
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, adding <code>(options := { introsTransparency := some .default }) </code> to the definition of <code>aesop_cat</code> causes previously working proofs in <code>Mathlib.CategoryTheory.Category.Basic</code> to instead use <code>sorry</code>!</p>",
        "id": 316877906,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671514037
    },
    {
        "content": "<p>Strangely this occurs for any value of <code>introsTransparency</code>, including <code>none</code>. Merely having the <code>(options := { })</code> is fine.</p>",
        "id": 316877998,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671514109
    },
    {
        "content": "<p>Ah, all okay. It's <code>introsTransparency?</code>. Not sure why it is generating <code>sorry</code> rather than giving a good error message.</p>",
        "id": 316878055,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1671514169
    },
    {
        "content": "<p>Sorry about the error (edited for posterity). I've also changed the elaboration of <code>(options := )</code> so that it throws an error instead of converting to <code>sorry</code>.</p>",
        "id": 316901493,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1671526538
    }
]
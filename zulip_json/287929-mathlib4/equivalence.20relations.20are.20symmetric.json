[
    {
        "content": "<p>In core <code>Init.Core</code> we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Equivalence</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- An equivalence relation is reflexive: `x ~ x` -/</span>\n  <span class=\"n\">refl</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/</span>\n  <span class=\"n\">symm</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>and in <code>Mathlib.Init.Logic</code> we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Symmetric</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⦄,</span> <span class=\"n\">x</span> <span class=\"bp\">≺</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≺</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Now this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Logic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"c1\">-- autoImplicit is sometimes v cool</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">h.symm</span> <span class=\"o\">:</span> <span class=\"n\">Symmetric</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  Equivalence.symm h</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  r ?m.52 ?m.53 → r ?m.53 ?m.52 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Symmetric r : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Is it because of the <code>{x y}</code> vs <code>⦃x y⦄</code> clash? Should I write a function from <code>Equivalence r</code> to <code>Symmetric r</code> called <code>Equivalence.Symmetric</code> or something?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Equivalence.Symmetric</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Symmetric</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.symm</span>\n</code></pre></div>\n<p>(and same question for trans -- and the coercion does work with refl but should <code>Equivalence.Reflexive</code> be written too?)</p>",
        "id": 308129417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667649419
    },
    {
        "content": "<p>Sure</p>",
        "id": 308130632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667650002
    },
    {
        "content": "<p>how about <code>Equivalence.symmetric</code> et al? (lowercase because it's a proof)</p>",
        "id": 308130715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667650049
    },
    {
        "content": "<p>I could just do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Logic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Function</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Comap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">2</span>  <span class=\"s2\">\" on \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Function.on_fun</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Reflexive.comap</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Reflexive</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetric.comap</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Symmetric</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Symmetric</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">hab</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Transitive.comap</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Transitive</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Transitive</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n\n<span class=\"c1\">-- works fine</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Equivalence.comap</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.refl</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"k\">fun</span> <span class=\"n\">hab</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.symm</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.trans</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Lean 3 proof nicer though:</span>\n<span class=\"c1\">-- ⟨h.1.comap f, h.2.1.comap f, h.2.2.comap f⟩</span>\n</code></pre></div>\n<p>Actually I can't even get <code>Equivalence.symmetric</code> to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Equivalence.symmetric</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Symmetric</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Equivalence.comap'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Reflexive.comap</span> <span class=\"n\">h.refl</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Symmetric.comap</span> <span class=\"n\">h.symmetric</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  Symmetric.comap (symmetric h) f</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Symmetric (r on f) : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Function.on_fun r f x✝ y✝ → Function.on_fun r f y✝ x✝ : Prop</span>\n<span class=\"cm\">the following variables have been introduced by the implicit lambda feature</span>\n<span class=\"cm\">  x✝ : ?m.657</span>\n<span class=\"cm\">  y✝ : ?m.657</span>\n<span class=\"cm\">you can disable implict lambdas using `@` or writing a lambda expression with `{}` or `[]` binder annotations.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 308131987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667650688
    },
    {
        "content": "<p>try <code>@(Symmetric.comap h.symmetric f)</code>?</p>",
        "id": 308132253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667650811
    },
    {
        "content": "<p>or <code>Symmetric.comap h.symmetric f ..</code></p>",
        "id": 308132325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667650847
    },
    {
        "content": "<p>I can't get the dots one working but the <code>@</code> is the trick I was missing: thanks! In fact dot notation also works: I've got this compiling</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Equivalence.comap'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">h.reflexive.comap</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">h.symmetric.comap</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">h.transitive.comap</span> <span class=\"n\">f</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>which I think is fine.</p>",
        "id": 308132822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667651125
    }
]
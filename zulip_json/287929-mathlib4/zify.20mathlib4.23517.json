[
    {
        "content": "<p>I'm keen to get <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span>'s port of <code>zify</code> in, but I'm having trouble with a casting issue.</p>\n<p>By adding some <code>norm_cast</code> attributes, I got the mathlib3 tests to work.</p>\n<p>However, if you add imports to the test file so that the <code>CommRing ℤ</code> instance becomes available, things fail again! Here's my summary from github:</p>\n<hr>\n<p>Okay, so we need to <code>import Mathlib.Init.Data.Int.Basic</code>, in order to get the <code>Preorder ℤ</code> instance. However as soon as the <code>CommRing ℤ</code> instance is available, which is currently defined in <code>Mathlib.Algebra.Ring.Basic</code>, the tests start failing again. </p>\n<p>In</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">z</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">&gt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">zify</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">push_cast</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">guard_hyp</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬↑</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">z</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₐ</span> <span class=\"bp\">↑</span><span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>which right now succeeds in this branch, after adding the import (and hence the <code>CommRing ℤ</code> instance), we get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hypothesis</span> <span class=\"n\">h</span> <span class=\"n\">has</span> <span class=\"n\">type</span> <span class=\"bp\">¬↑</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">z</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">not</span> <span class=\"bp\">¬↑</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">z</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Here the first <code>↑x</code> is <code>Int.ofNat x : ℤ</code>, while the other <code>↑x</code> is <code>@Nat.cast ℤ NonUnitalNonAssocSemiring.toAddMonoidWithOne x : ℤ</code>.</p>\n<hr>\n<p>I'm not sure what the appropriate resolution of this is, so if someone who understands how casts are meant to work in Lean 4 wants to help out here, that would be great. :-)</p>",
        "id": 307015907,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667170671
    },
    {
        "content": "<p>I believe the intention is for <code>Nat.cast</code> to take precedence over <code>Int.ofNat</code> in mathlib once the former is available. It should have a precedence such that this happens consistently, and there is a simp lemma rewriting <code>ofNat</code> to <code>Nat.cast</code> IIRC</p>",
        "id": 307033677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667189686
    },
    {
        "content": "<p>Thanks Scott for looking into this.<br>\nWhen I wrote the tests, I thought that the <code>Int.ofNat</code> cast lemmas were not tagged as <code>norm_cast</code> in mathlib3 and this was the reason why I did not add them, but now I see that I was wrong.</p>",
        "id": 307038225,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667193761
    }
]
[
    {
        "content": "<p>When I made the <a href=\"https://github.com/leanprover-community/mathlib4/pull/429\">minimal port of <code>Fintype</code></a> using the mathport output contained in <code>mathlib3port</code>, I also wrote some notes about what I needed to change to get mathport output working again.</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, do you think you might have time to go through these with me? I'd like to know how you think these changes should split up amongst:</p>\n<ul>\n<li>we should fix mathport to handle this!</li>\n<li>we could maybe manyana have mathport handle this</li>\n<li>we should add stuff in mathlib4 to make this smoother</li>\n<li>humans doing the porting are just going to have to cope</li>\n</ul>\n<p>I wrote my changes down <a href=\"https://gist.github.com/semorrison/8bfae773d332fe6722523f32c20b57aa\">here</a>. If there's a time we could chat in real-time that would be great, but we can also do it here if that's more efficient.</p>\n<p>Hopefully we can create some issues/PRs/documentation for porters to make these things easier in future.</p>",
        "id": 300282314,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1663902691
    },
    {
        "content": "<p>Quick summary of what I learnt from Mario, for anyone following along:</p>\n<ul>\n<li>There is lots of sadness about how mathport sometimes camelCases successfully, and sometimes_does_not. It's hard, and will take some work.</li>\n<li>The definition of List membership has changed from Lean3 to Lean4, so <code>rcases</code> on list membership hypotheses will all have to be written (and similarly in analogous cases). This would probably be a pain to have mathport handle automatically.</li>\n<li>Simp's behaviour with multiple binders has changed, making some simp lemmas which want to see some but not all of the binders in an expression not fire anymore. I'll make an issue somewhere about this, whether it's fixable or just for the sake of documenting the change.</li>\n<li><code>example : Nat → Nat := by refine' (fun x =&gt; _)</code> produces the goal <code>⊢ Nat → Nat</code>, rather than <code>x : Nat ⊢ Nat</code> as you might expect. With <code>fun x =&gt; ?_</code> we get the expected behaviour. This is not necessarily incorrect, but confusing when porting. Again, I'll make an issue somewhere.</li>\n</ul>",
        "id": 300285289,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1663905800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/using.20mathlib3port/near/300285289\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The definition of List membership has changed from Lean3 to Lean4, so <code>rcases</code> on list membership hypotheses will all have to be written (and similarly in analogous cases). This would probably be a pain to have mathport handle automatically.</li>\n</ul>\n</blockquote>\n<p>Is this backportable? Not sure how big a deal the manual porting would be</p>",
        "id": 300352088,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1663936566
    },
    {
        "content": "<p>re the <code>mem_split</code> proof</p>\n<blockquote>\n<ul>\n<li>I couldn't get <code>rcases h with (rfl | h)</code>, or any variant, to work.<br>\n Using <code>rfl</code> generates an error, but replacing it with <code>_</code> gives the desired behaviour.<br>\n I couldn't get <code>rcases</code> to introduce a new hypothesis named <code>h</code> in the 2nd branch.</li>\n</ul>\n</blockquote>\n<p>This works (but is arguably no better than what you wrote):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mem_split</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨[],</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">ih</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 300365323,
        "sender_full_name": "David Renshaw",
        "timestamp": 1663940888
    },
    {
        "content": "<p>I don't understand why we need 3 underscores in <code>⟨_, _, _, h⟩</code> here. Looking at the <a href=\"https://github.com/leanprover/lean4/blob/0925051c51e183a0b8c504ae53f5cab0525d6cac/src/Init/Data/List/Basic.lean#L248-L250\">definition of <code>List.Mem</code></a>, I would expect to only need one, for the parameter <code>(a : α)</code>. The other parameters of <code>tail</code> have curly braces, so should be implicit, right?</p>",
        "id": 300372971,
        "sender_full_name": "David Renshaw",
        "timestamp": 1663941849
    },
    {
        "content": "<p>For what it's worth, the behavior is the same in Lean 3 (with a backported version of Lean 4's <code>List.Mem</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">list_mem'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list_mem'</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">tail</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list_mem'</span> <span class=\"n\">b</span> <span class=\"n\">as</span> <span class=\"bp\">→</span> <span class=\"n\">list_mem'</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">list_mem'</span> <span class=\"n\">a</span>  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n   <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">list_mem'</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"n\">h'</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 300414193,
        "sender_full_name": "David Renshaw",
        "timestamp": 1663953435
    },
    {
        "content": "<p>It looks like Mario is <a href=\"#narrow/stream/113488-general/topic/.2316617.20explicit.20patterns.20in.20rcases/near/300461731\">changing</a> the behaviour of rcases in a way that will make less of a problem.</p>",
        "id": 300477865,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1663987920
    }
]
[
    {
        "content": "<p>I am porting <code>Algebra.Group.Ext</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/837\">#837</a> and I am stuck at the very beginning. The mathlib3 code is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.hom.group</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext, to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">monoid.ext</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">⦃</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"n\">m₁.mul</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.mul</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.to_mul_one_class</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.to_mul_one_class</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_one_class.one</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_one_class.ext</span> <span class=\"n\">h_mul</span><span class=\"o\">),</span>\n  <span class=\"n\">set</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.to_mul_one_class</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.to_mul_one_class</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hpow</span> <span class=\"o\">:</span> <span class=\"n\">m₁.npow</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.npow</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom.map_pow</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"o\">},</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">m₁</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">m₂</span> <span class=\"o\">},</span>\n  <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The mathlib4 is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Hom.Group</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext, to_additive]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Monoid.ext</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">⦃</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"n\">m₁.mul</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.mul</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"o\">:=</span>\n    <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">MulOneClass.one</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">MulOneClass.ext</span> <span class=\"n\">h_mul</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">}</span>\n  <span class=\"k\">have</span> <span class=\"n\">hpow</span> <span class=\"o\">:</span> <span class=\"n\">m₁.npow</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.npow</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom.map_pow</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">n</span>\n  <span class=\"n\">cases</span> <span class=\"n\">m₁</span>\n  <span class=\"n\">cases</span> <span class=\"n\">m₂</span>\n  <span class=\"n\">congr</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">monoid.ext</span> <span class=\"n\">Monoid.ext</span>\n</code></pre></div>\n<p>The first error is about <code>@MulOneClass.one M</code>. Why there is no <code>MulOneClass.one</code>? I can fix it with <code>@One.one M</code>, but the mathlib3 way is better in my opinion.</p>\n<p>Using <code>@One.one M</code> is get an error at <code>MulOneClass.ext h_mul</code></p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>application <span class=\"nb\">type</span> mismatch\n  congr_arg <span class=\"o\">(</span>@One.one M<span class=\"o\">)</span> <span class=\"o\">(</span>MulOneClass.ext ?m.404<span class=\"o\">)</span>\nargument\n  MulOneClass.ext ?m.404\nhas <span class=\"nb\">type</span>\n  ?m.81 <span class=\"o\">=</span> ?m.82 : Prop\nbut is expected to have <span class=\"nb\">type</span>\n  MulOneClass.toOne <span class=\"o\">=</span> MulOneClass.toOne : Prop\n</code></pre></div>\n<p>I don't understand exactly what's wrong here...</p>",
        "id": 313671927,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1670067847
    },
    {
        "content": "<p>I think this is because of <code>old_structure_cmd</code></p>",
        "id": 313672770,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670068205
    },
    {
        "content": "<p>Does <code>fun (inst : MulOneClass M) =&gt; inst.one</code> work?</p>",
        "id": 313672856,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670068250
    },
    {
        "content": "<p>It moves the error later, so I guess it works... but it's really hard to read</p>",
        "id": 313673135,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1670068387
    },
    {
        "content": "<p>The problem is that in Lean3/old structures <code>mul_one_class.one</code> is a real field, but in Lean 4/new structures <code>M.one</code> is actualy syntax for <code>M.to_has_one.one</code> but only works when used as field notation</p>",
        "id": 313673480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670068535
    },
    {
        "content": "<p>I think it would be a reasonable feature request to ask that <code> MulOneClass.one</code> be syntax for the lambda function above.</p>",
        "id": 313673625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670068595
    },
    {
        "content": "<p>This seems like the easiest thing to work around. Note that if the expected type of the function is known <code>(\\..one)</code> will work.</p>",
        "id": 313673868,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1670068707
    },
    {
        "content": "<p>OK, not it complains about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>synthesized <span class=\"nb\">type</span> class instance is not definitionally equal to expression inferred by typing rules, synthesized\n  toMulOneClass\ninferred\n  toMulOneClass\n</code></pre></div>\n<p><span aria-label=\"rolling eyes\" class=\"emoji emoji-1f644\" role=\"img\" title=\"rolling eyes\">:rolling_eyes:</span></p>",
        "id": 313674047,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1670068787
    },
    {
        "content": "<p>The proof has to be different anyhow, since the shape of the structure is different because of the new bundling.</p>",
        "id": 313674077,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1670068802
    },
    {
        "content": "<p>OK, I seems more complicated than I thought. I am closing my WIP PR (where I basically didn't do anything) to \"free\" the file to anyone else interested, since I don't have much time this weekend.</p>",
        "id": 313675634,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1670069418
    },
    {
        "content": "<p>So is something like the following even possible to write in lean4?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Hom.Group</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">M</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">M</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"c1\">-- M →* M : Type u_1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">M</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">M</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 313742340,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670108458
    },
    {
        "content": "<p>I mean, it is impossible to fill in the sorries in any version of Lean, so I guess not?</p>",
        "id": 313752063,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670117184
    },
    {
        "content": "<p>So I had a crack at porting the file. I managed to fix the proof of <code>Monoid.ext</code> and fix the proofs of injectivity, but was unable to fix the proofs for <code>DivInvMonoid.ext</code> and <code>Group.ext</code>. I've created a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/850\">mathlib4#850</a>, so if anyone has any insights, please feel free to work on it.</p>",
        "id": 313816095,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670164085
    },
    {
        "content": "<p>My main issue was that lean4 forgets that <code>m₁</code> is a <code>DivInvMonoid</code> when deconstructing the instance, so I don't have access to theorems that require a <code>DivInvMonoid</code> instance.</p>",
        "id": 313816297,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670164165
    },
    {
        "content": "<p>I also couldn't figure out how to tell lean that the <code>div</code> in <code>DivInvMonoid</code> was the same as the <code>hDiv</code> in <code>div_eq_mul_inv</code>.</p>",
        "id": 313817029,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670164472
    },
    {
        "content": "<p>So I managed to fix the first issue with deconstructing a class by delaying it in the proof giving me access to theorems for <code>DivInvMonoid</code> and <code>Group</code>. I feel like the main issue preventing me from completing the proofs is that lean is converting <code>(·*·)</code> and <code>(·/·)</code> into an <code>hMul</code> and <code>hDiv</code> and I can't quite wrap my head around how to give lean the information to apply lemmas using <code>(·*·)</code> and <code>(·/·)</code>. I've pushed updated versions of the proofs. Hopefully, the finishing touches to them is fairly trivial.</p>",
        "id": 313859178,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670191220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Porting.20Algebra.2EGroup.2EExt/near/313752063\">said</a>:</p>\n<blockquote>\n<p>I mean, it is impossible to fill in the sorries in any version of Lean, so I guess not?</p>\n</blockquote>\n<p>I think this question was asked poorly; in the real context, there are hypotheses available that say the <code>one</code> and <code>mul</code> agree</p>",
        "id": 313868130,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670198733
    },
    {
        "content": "<p>I think the problem is the new-style classes interfering with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.toMulOneClass</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>In particular, this calls <code>MonoidHom.mk</code> and <code>OneHom.mk</code>, and seems to pass the wrong typeclass arguments into these</p>",
        "id": 313868492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670199005
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">m₁.toMulOneClass</span> <span class=\"n\">m₂.toMulOneClass</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">MonoidHom.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OneHom.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">id</span> <span class=\"n\">h₁</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 313868744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670199266
    },
    {
        "content": "<p>I'm very new to Lean4; what does <code>(_)</code> mean compared to <code>_</code>?</p>",
        "id": 313868751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670199281
    },
    {
        "content": "<p>Also, this feels like a place where the opaqueness of <code>inferInstance</code> is causing a problem (swapping <code>m₁.toMulOneClass</code> for the suggested <code>by letI := m₁ &lt;;&gt; infer_instance</code> fails)</p>",
        "id": 313868851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670199365
    },
    {
        "content": "<p>I was able to copy across the mathlib3 proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">div_inv_monoid.ext</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">⦃</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">div_inv_monoid</span> <span class=\"n\">M</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"n\">m₁.mul</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.mul</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_inv</span> <span class=\"o\">:</span> <span class=\"n\">m₁.inv</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.inv</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.one</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">monoid.ext</span> <span class=\"n\">h_mul</span><span class=\"o\">),</span>\n  <span class=\"n\">set</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">m₁</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">m₂</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hpow</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">npow</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"n\">_</span> <span class=\"n\">m₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">npow</span> <span class=\"o\">:=</span>\n    <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.npow</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">monoid.ext</span> <span class=\"n\">h_mul</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hzpow</span> <span class=\"o\">:</span> <span class=\"n\">m₁.zpow</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.zpow</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom.map_zpow'</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_inv</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">m</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hdiv</span> <span class=\"o\">:</span> <span class=\"n\">m₁.div</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.div</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">map_div'</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">_</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_inv</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">},</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">m₁</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">m₂</span> <span class=\"o\">},</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">h_mul</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">hpow</span><span class=\"o\">,</span> <span class=\"n\">h_inv</span><span class=\"o\">,</span> <span class=\"n\">hdiv</span><span class=\"o\">,</span> <span class=\"n\">hzpow</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">DivInvMonoid.ext</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">⦃</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">DivInvMonoid</span> <span class=\"n\">M</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h_mul</span> <span class=\"o\">:</span> <span class=\"n\">m₁.mul</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.mul</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_inv</span> <span class=\"o\">:</span> <span class=\"n\">m₁.inv</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.inv</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span> <span class=\"bp\">=</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Monoid.ext</span> <span class=\"n\">h_mul</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">m₁.one</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.one</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">one</span><span class=\"o\">)</span> <span class=\"n\">this</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">m₁.toMulOneClass</span> <span class=\"n\">m₂.toMulOneClass</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">MonoidHom.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OneHom.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">id</span> <span class=\"n\">h₁</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_mul</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">hpow</span> <span class=\"o\">:</span> <span class=\"n\">m₁.npow</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.npow</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">npow</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Monoid.ext</span> <span class=\"n\">h_mul</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">hzpow</span> <span class=\"o\">:</span> <span class=\"n\">m₁.zpow</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.zpow</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">MonoidHom.map_zpow'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_inv</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">m</span>\n  <span class=\"k\">have</span> <span class=\"n\">hdiv</span> <span class=\"o\">:</span> <span class=\"n\">m₁.div</span> <span class=\"bp\">=</span> <span class=\"n\">m₂.div</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">map_div'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonoidHom.monoidHomClass</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"n\">h_inv</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">m₁</span> <span class=\"k\">with</span> <span class=\"bp\">@</span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">inv₁</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">div₁</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">zpow₁</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">m₂</span> <span class=\"k\">with</span> <span class=\"bp\">@</span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">inv₂</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">div₂</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">zpow₂</span><span class=\"o\">⟩</span>\n  <span class=\"n\">congr</span>\n</code></pre></div>",
        "id": 313869289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670199868
    },
    {
        "content": "<p>It seems that <code>@</code> and <code>(_)</code> is ultimately the trick here</p>",
        "id": 313869663,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670200208
    },
    {
        "content": "<p>Maybe it would be best to restart from the mathport output for the other instances now that we know that?</p>",
        "id": 313869744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670200245
    },
    {
        "content": "<p>Whatever ends up being the most readable/maintainable. The original mathport output is also in a block comment for <code>Group.ext</code>. Now that you have the <code>MonoidHom</code> working, it should be a similar proof. Are you planning on working on that one? I can probably figure it out, following this method.<br>\nI am still slightly concerned that <code>(·*·)</code> and <code>(·/·)</code> are <code>hMuls</code> and <code>hDivs</code>. And it seems as though <code>Mul</code> and <code>Div</code> don't extend the classes, which seems weird to me. I'm assuming there's a good reason.</p>",
        "id": 313870749,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670201202
    },
    {
        "content": "<p>Ok, I've fixed up all the proofs and have emulated the mathlib3 versions. Thank you for the help!<br>\nBtw, is the extra destructuring that is happening at the end of these proofs something that <code>congr</code> should be able to figure out on its own?</p>",
        "id": 313877755,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670207307
    },
    {
        "content": "<p>Do you mind adding to the  <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Porting-wiki\">porting wiki</a> what you had to do?</p>",
        "id": 313922736,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1670233210
    },
    {
        "content": "<p>As far as I understand it, to create a <code>MonoidHom</code> (or <code>OneHom</code>) with ambiguous instances, you need to use the <code>mk</code> constructor and then use <code>(_)</code> to delay the TC inference on the input type (or more generally any type in the  'contravariant' position?).</p>",
        "id": 313965701,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1670247740
    },
    {
        "content": "<p>It's not delaying it, it's disabling it entirely</p>",
        "id": 313974065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670248327
    },
    {
        "content": "<p>It's forcing it to use unification instead of typeclass search</p>",
        "id": 313975910,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670248368
    },
    {
        "content": "<p>Lean3 did that automatically for <code>{...}</code> notation</p>",
        "id": 313976749,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670248393
    }
]
[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/17767\">#17767</a><br>\nI wonder if there's a slicker proof using filters, or if there's an simpler statement of <code>is_compact.uniform_continuous_at_of_continuous_at</code> using filters.</p>",
        "id": 312987349,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669784670
    },
    {
        "content": "<p>I don't have much time, but I can bet the first step towards answering this question is to reformulate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓤</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">x.1</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">r</span><span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓤</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">prod.map</span> <span class=\"n\">f</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝓤</span> <span class=\"n\">α</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"n\">s</span> <span class=\"bp\">×ᶠ</span> <span class=\"bp\">⊤</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝓤</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>which says the same thing in a more filter-friendly way. Note it is also more reader-friendly, it says <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>×</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f \\times f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> sends the \"set\" of pairs of points in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> which are close to each other and such that the first point is in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> into the \"set\" of pairs of points in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span> which are close to each other.</p>",
        "id": 313013442,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1669799058
    },
    {
        "content": "<p>Thanks for the explanation, your statement now looks pretty intuitive to me. I'm wondering whether we could come up with a proof similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/compact_space.uniform_continuous_of_continuous/src\">src#compact_space.uniform_continuous_of_continuous</a> simply by calculation using filters.</p>",
        "id": 313101719,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669826417
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> for addressing reviews at <a href=\"https://github.com/leanprover-community/mathlib/pull/17767\">#17767</a>; it's now about to be merged. I was busy last week and I also thought about adopting <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>'s filter formulation of <code>is_compact.uniform_continuous_at_of_continuous_at</code> above; that's why I took no action on the PR for the whole week.</p>\n<p>The filter formulation would be nice if we could stay in the language of filters, but with the current proof it's harder to work with definitionally, so it didn't end up in the PR. I've worked out a proof that uses filters more substantially in <a href=\"https://gist.github.com/alreadydone/c2dd40c087ccf69de8461eb76d5091b4\">this gist</a>, but unfortunately it's longer. However, two lemmas there may still be worth including in mathlib. The first is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_compact.nhds_set_diagonal₁</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">𝓝ˢ</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">𝓤</span> <span class=\"n\">α</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓝ˢ</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(and the version with <code>fst</code> replaced by <code>snd</code>). Notice that the LHS tends to <code>𝓤 β</code> by continuity, and the RHS is <code>≥ 𝓤 α ⊓ 𝓟 (prod.fst ⁻¹' s) = 𝓤 α ⊓ (𝓟 s ×ᶠ ⊤)</code>, so this is a stronger result than <code>uniform_continuous_at_of_continuous_at</code>.</p>\n<p>The second is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">filter.le_of_inf_principal_compl_le</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f₂</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f₂</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which feels like it could be broken down to sublemmas, but I don't see how yet. The statement is a bit weird; for example <code>s ∈ f₂</code> could be replaced by <code>s ∈ g</code>.</p>",
        "id": 315305477,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670831187
    },
    {
        "content": "<p>I've been resisting the urge to work on this because I have very little time and you already had a more traditional proof. Maybe one day we will have fun refactoring this, but I don't think this should prevent merging the PR.</p>",
        "id": 315309072,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1670832683
    },
    {
        "content": "<p>I realized the second lemma above can be simplified to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">filter.le_of_inf_principal_compl_le</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>and updated <a href=\"https://gist.github.com/alreadydone/c2dd40c087ccf69de8461eb76d5091b4\">the gist</a>. Still find it very curious.</p>",
        "id": 315312972,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670834141
    }
]
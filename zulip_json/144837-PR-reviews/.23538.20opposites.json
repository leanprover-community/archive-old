[
    {
        "content": "<p>maybe someone can write a tactic!</p>",
        "id": 152229118,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545272934
    },
    {
        "content": "<p>Do we have modules over a non-commutative ring? If so you could do left modules over R = right modules over <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">R^{op}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">o</span><span class=\"mord mathit mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 152238513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1545290150
    },
    {
        "content": "<p>I agree that what you did should all be automated somehow. This is just the sort of thing that as a lecturer I would skip over -- I would let the students automate it.</p>",
        "id": 152238562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1545290197
    },
    {
        "content": "<p>do we have right modules?</p>",
        "id": 152238632,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290334
    },
    {
        "content": "<p>Oh well if we don't that would be great because you can just define them as left modules over the opposite ring :P</p>",
        "id": 152238648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1545290380
    },
    {
        "content": "<p>great!</p>",
        "id": 152238695,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290415
    },
    {
        "content": "<p>Note that by kenny's definition <code>R^op = R</code> for any ring</p>",
        "id": 152238699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545290420
    },
    {
        "content": "<p>what?</p>",
        "id": 152238702,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290428
    },
    {
        "content": "<p>you commuted the addition, which is commutative in a ring</p>",
        "id": 152238706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545290443
    },
    {
        "content": "<p>but multiplication?</p>",
        "id": 152238709,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290450
    },
    {
        "content": "<p>did you commute both? that's confusing</p>",
        "id": 152238724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545290478
    },
    {
        "content": "<p>yes, I commuted both</p>",
        "id": 152238725,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290485
    },
    {
        "content": "<p>since addition doesn't matter anyway</p>",
        "id": 152238727,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what's an argument against commuting both?</p>",
        "id": 152238730,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290506
    },
    {
        "content": "<p>it might still matter for defeq which way you have it</p>",
        "id": 152238787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545290584
    },
    {
        "content": "<p>like I asked on the PR, what do you want to use this for?</p>",
        "id": 152238800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545290614
    },
    {
        "content": "<p>I thought that everything is commutative in Kevin's world</p>",
        "id": 152238809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545290636
    },
    {
        "content": "<p>not really</p>",
        "id": 152238859,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290698
    },
    {
        "content": "<p>as long as he cares about group representation</p>",
        "id": 152238870,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290708
    },
    {
        "content": "<p>End(A,A) = A^op</p>",
        "id": 152238955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545290841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> what do you think?</p>",
        "id": 152239077,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291026
    },
    {
        "content": "<p>Ehm, we definitely care about non-commutative rings. It's just that we call them that: <em>non-commutative rings</em>, instead of <em>rings</em>.</p>",
        "id": 152239244,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291313
    },
    {
        "content": "<p>Whether commuting the addition is a good idea, I don't know. Mathematically it doesn't matter, and I guess it might make some things a bit easier to prove?</p>",
        "id": 152239251,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291352
    },
    {
        "content": "<blockquote>\n<p>End(A,A) = A^op</p>\n</blockquote>\n<p>what does that mean exactly? Since A^op ~= A why isn't it just End(A,A) = A?</p>",
        "id": 152239312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545291427
    },
    {
        "content": "<p><code>End(_,_)</code> looks a bit funny anyway <span class=\"emoji emoji-1f923\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 152239481,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> oops I meant End(A), I don't know what's wrong with me</p>",
        "id": 152239555,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291750
    },
    {
        "content": "<p>Well, maybe you're human? <span class=\"emoji emoji-1f600\" title=\"grinning\">:grinning:</span></p>",
        "id": 152239560,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291769
    },
    {
        "content": "<p>I don't think A^op and A are isomorphic in general?</p>",
        "id": 152239562,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291778
    },
    {
        "content": "<p>Definitely not.</p>",
        "id": 152239569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291785
    },
    {
        "content": "<p>Not that I can visualize a concrete situation where the choice matters, but it feels wrong to me to reverse the order of addition in the opposite ring</p>",
        "id": 152239573,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545291802
    },
    {
        "content": "<p>G^op and G are in fact isomorphic</p>",
        "id": 152239576,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291808
    },
    {
        "content": "<p>for a group G</p>",
        "id": 152239581,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291815
    },
    {
        "content": "<p>I think this still works for division rings</p>",
        "id": 152239583,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291828
    },
    {
        "content": "<p>Sure, for groups it's fine.</p>",
        "id": 152239585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291831
    },
    {
        "content": "<p>so H and H^op are isomorphic</p>",
        "id": 152239590,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291839
    },
    {
        "content": "<p>That's coincidence.</p>",
        "id": 152239633,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291850
    },
    {
        "content": "<p>Because H has order 2 in the Brauer group.</p>",
        "id": 152239636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291861
    },
    {
        "content": "<p>In general division rings arent isom to their opposite.</p>",
        "id": 152239640,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545291872
    },
    {
        "content": "<p>oh right never mind sorry</p>",
        "id": 152239664,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291907
    },
    {
        "content": "<p>Also, I wonder if these opposites will run into the same kind of issues we had/have in category theory, where it's too easy to get confused between an object of a category and an object of the opposite category</p>",
        "id": 152239676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545291926
    },
    {
        "content": "<p>that's exactly why I put <code>irreducible</code>!</p>",
        "id": 152239679,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545291940
    },
    {
        "content": "<p>Oh whoops, my mind was numbed by the endless identical instances and I missed that line</p>",
        "id": 152239729,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545291974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you think of the <code>irreducible</code> thing? It seems like a good idea to me? (But then, I might not know all the consequences...)</p>",
        "id": 152239745,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545292038
    },
    {
        "content": "<blockquote>\n<p>I don't like the use of irreducible here. What is the application of this file? additive and multiplicative are useful in contexts where you just assert that a theorem has a type involving addition instead of multiplication, and the kernel figures out the defeq; irreducible will block that kind of move. Also you aren't being specific about whether the addition or multiplication is being commuted here.</p>\n</blockquote>\n<p>(by Mario)</p>",
        "id": 152239793,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292090
    },
    {
        "content": "<p>For example, suppose I want to prove add_comm from mul_comm. The <code>multiplicative</code> trick relies on the fact that <code>add A x y = add A y x</code> is definitionally equal to <code>mul (multiplicative A) x y = mul (multiplicative A) y x</code>. With irreducible in there I have to insert lots of ops and unops and the kernel can't do it on its own</p>",
        "id": 152239934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545292337
    },
    {
        "content": "<p>By the way re: isom to opposite, I was thinking of the map x |-&gt; x, and using antihoms where appropriate</p>",
        "id": 152240032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545292509
    },
    {
        "content": "<p>and I think using that defintional equality is not very safe</p>",
        "id": 152240043,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292529
    },
    {
        "content": "<p>it's not, it has to be used in carefully controlled circumstances</p>",
        "id": 152240049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545292548
    },
    {
        "content": "<p>its use is more or less restricted to one liner proofs where you reinterpret a multiplicative theorem as additive</p>",
        "id": 152240100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545292597
    },
    {
        "content": "<p>Right, but here we will want to talk about <code>op R</code>, which is a completely different ring.</p>",
        "id": 152240111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545292631
    },
    {
        "content": "<p>I think it is fitting to make it irreducible.</p>",
        "id": 152240116,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545292645
    },
    {
        "content": "<blockquote>\n<p>its use is more or less restricted to one liner proofs where you reinterpret a multiplicative theorem as additive</p>\n</blockquote>\n<p>and it's open to abuse / misuse</p>",
        "id": 152240121,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292662
    },
    {
        "content": "<p>if you want it to be a different ring, then you should use a structure</p>",
        "id": 152240126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545292678
    },
    {
        "content": "<p>really?</p>",
        "id": 152240192,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292745
    },
    {
        "content": "<p>well isn't the effect the same</p>",
        "id": 152240203,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292751
    },
    {
        "content": "<p>It's not exactly the same, as <code>op (unop x)</code> will not be defeq to <code>x</code>.<br>\n(... <code>newtype</code>?)</p>",
        "id": 152240312,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545292888
    },
    {
        "content": "<p>then I think the current definition is better :P</p>",
        "id": 152240326,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292910
    },
    {
        "content": "<p>and this is consistent with my support of auxiliary types</p>",
        "id": 152240382,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292950
    },
    {
        "content": "<p>I think <code>additive</code> and <code>multiplicative</code> should be irreducible as well</p>",
        "id": 152240387,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545292961
    },
    {
        "content": "<blockquote>\n<p>I think <code>additive</code> and <code>multiplicative</code> should be irreducible as well</p>\n</blockquote>\n<p>I still hope that one day we will have a system where they don't exist.</p>",
        "id": 152240399,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545293001
    },
    {
        "content": "<p>If you are giving a newtype API for opposite, then I would rather have no defeqs at all</p>",
        "id": 152240461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293079
    },
    {
        "content": "<p><code>op (unop x) = x</code> is a theorem</p>",
        "id": 152240464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293089
    },
    {
        "content": "<p>as well as <code>unop (op x) = x</code></p>",
        "id": 152240470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293102
    },
    {
        "content": "<p>what is newtype?</p>",
        "id": 152240482,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545293116
    },
    {
        "content": "<p>it's a structure with one field</p>",
        "id": 152240492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293125
    },
    {
        "content": "<blockquote>\n<p>If you are giving a newtype API for opposite, then I would rather have no defeqs at all</p>\n</blockquote>\n<p>don't we like defeqs?</p>",
        "id": 152240493,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545293129
    },
    {
        "content": "<p>recall the real irreducible discussion</p>",
        "id": 152240500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293153
    },
    {
        "content": "<p>defeq breaks abstractions</p>",
        "id": 152240534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293163
    },
    {
        "content": "<p>I was hoping for \"newtype\" to be defeq in both directions but still a new type</p>",
        "id": 152240544,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545293166
    },
    {
        "content": "<p>it's a new type to the kernel</p>",
        "id": 152240550,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545293185
    },
    {
        "content": "<p>if lean had structure eta that would be possible</p>",
        "id": 152240551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545293186
    },
    {
        "content": "<p>on the basis that Haskell semantic equality (considering bottom) ~ Lean definitional equality</p>",
        "id": 152240561,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545293200
    },
    {
        "content": "<blockquote>\n<p>defeq breaks abstractions</p>\n</blockquote>\n<p>I don't understand</p>",
        "id": 152240565,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545293208
    },
    {
        "content": "<p>and also why is <code>unop (op x) = x</code> being defeq ok</p>",
        "id": 152240568,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545293217
    },
    {
        "content": "<p>(BTW, <em>lots</em> of category theory stuff would be less awful with eta for structures)</p>",
        "id": 152240594,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545293278
    },
    {
        "content": "<p>it's called a newtype because it's underlying representation is the same</p>",
        "id": 152241162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294085
    },
    {
        "content": "<p>it's a \"zero cost abstraction\"</p>",
        "id": 152241163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294085
    },
    {
        "content": "<blockquote>\n<p>on the basis that Haskell semantic equality (considering bottom) ~ Lean definitional equality</p>\n</blockquote>\n<p>I don't think this is a good comparison; why isn't that ~ lean propositional equality?</p>",
        "id": 152241305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294289
    },
    {
        "content": "<p>I don't understand why, but it seems to be a useful heuristic in practice.</p>",
        "id": 152241327,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294328
    },
    {
        "content": "<p>For example <code>fst (a, b) = a</code> is okay, but <code>(fst p, snd p) = p</code> is not.</p>",
        "id": 152241333,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294347
    },
    {
        "content": "<p>The stuff about \"lazy patterns\" should fit in somehow, too. But I don't know how to make real sense out of any of this. For one thing, Haskell has a (partial) definedness ordering between things like <code>(fst p, snd p)</code> and <code>p</code>, but in Lean, the thing that would be more defined in Haskell is instead somehow \"better\", but I don't know why.</p>",
        "id": 152241465,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294545
    },
    {
        "content": "<p>It's not like <code>\\lam \\&lt;a, b\\&gt;, \\&lt;a, b\\&gt;</code> is \"less defined\" than <code>\\lam p, p</code></p>",
        "id": 152241485,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294592
    },
    {
        "content": "<p>hm, you may be on to something here</p>",
        "id": 152241532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294610
    },
    {
        "content": "<p>I hope you can figure out what it is, because I find it puzzling!</p>",
        "id": 152241566,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294640
    },
    {
        "content": "<p>It reminds me of the problem of understanding metamath semantics</p>",
        "id": 152241577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294662
    },
    {
        "content": "<p>Maybe another way to think of it is that every type is populated, in additional to the usual things, with \"raw variables\"</p>",
        "id": 152241588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294692
    },
    {
        "content": "<p>which are just terms that don't denote anything, like atoms</p>",
        "id": 152241593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294704
    },
    {
        "content": "<p>and those two lambdas behave differently on raw variables</p>",
        "id": 152241633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294723
    },
    {
        "content": "<p>Yes, this sounds promising</p>",
        "id": 152241638,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294725
    },
    {
        "content": "<p>that gives an ordering too perhaps, by specializing variables to values (which might contain new variables inside)</p>",
        "id": 152241655,
        "sender_full_name": "Reid Barton",
        "timestamp": 1545294782
    },
    {
        "content": "<p>exactly</p>",
        "id": 152241661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294788
    },
    {
        "content": "<p>that's how metamath semantics works</p>",
        "id": 152241663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294795
    },
    {
        "content": "<p>it's all about the metavariables</p>",
        "id": 152241667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545294806
    },
    {
        "content": "<p>so what should we do? <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 154559706,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546857878
    },
    {
        "content": "<p>I guess I have made opposite inductive</p>",
        "id": 154631186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546936882
    },
    {
        "content": "<p>Should we make <code>order_dual</code> in <code>order/basic.lean</code> also a structure / inductive?</p>",
        "id": 154975129,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547281914
    },
    {
        "content": "<p>or maybe we should merge these two</p>",
        "id": 154975174,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547281928
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> what do you think about merging those two?</p>",
        "id": 156643371,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548194098
    },
    {
        "content": "<p>Which two?</p>",
        "id": 156643518,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548194189
    },
    {
        "content": "<p>I guess Kenny meant \"merge this too\"</p>",
        "id": 156643551,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194211
    },
    {
        "content": "<p>I would prefer <code>opposite</code> to be like <code>order_dual</code>, just a definition</p>",
        "id": 156643596,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194263
    },
    {
        "content": "<p>I think he continues from the previous message in this thread</p>",
        "id": 156643616,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1548194277
    },
    {
        "content": "<p>From January 12th</p>",
        "id": 156643678,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1548194296
    },
    {
        "content": "<p>Ah</p>",
        "id": 156643731,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548194353
    },
    {
        "content": "<p>ah</p>",
        "id": 156643736,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194360
    },
    {
        "content": "<p>oh, sorry, I meant merging opposite and order_dual</p>",
        "id": 156643776,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548194392
    },
    {
        "content": "<p>Hm, or we need <code>multiplicative_opp</code> and <code>additive_opp</code>...</p>",
        "id": 156643870,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194427
    },
    {
        "content": "<p>I suppose you could have an ordered group and want to reverse the multiplication but not the order, or vice versa</p>",
        "id": 156643898,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548194455
    },
    {
        "content": "<p>Yep</p>",
        "id": 156643913,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194465
    },
    {
        "content": "<p>then what should I do?</p>",
        "id": 156643940,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548194489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> I don't see why we need multiplicative_opp and additive_opp; the only structure with both addition and multiplication are children of <code>semiring</code> in which addition is commutative anyway, right?</p>",
        "id": 156644221,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548194748
    },
    {
        "content": "<p>I don't know. I don't do a lot of non-commutative algebra.</p>",
        "id": 156644378,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194856
    },
    {
        "content": "<p>I wouldn't merge it, for the problem Reid mentioned. I think we should restrict <code>opposite</code> to <code>*</code> currently, and see what the actual applications are.</p>",
        "id": 156644453,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548194915
    },
    {
        "content": "<p>there's a heavy lack of consensus on this thread... everyone seems to want different things</p>",
        "id": 156644457,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548194917
    },
    {
        "content": "<p>I also have the sense which I can't explain clearly that <code>opposite</code> should be just for multiplication and not addition.</p>",
        "id": 156644497,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548194958
    },
    {
        "content": "<p>I agree that <code>opposite</code> should not flip both. If necessary we can have <code>add_opposite</code></p>",
        "id": 156644622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195086
    },
    {
        "content": "<p>ok, but what about merging opposite and order_dual?</p>",
        "id": 156644718,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548195152
    },
    {
        "content": "<p>and what about irreducible def vs. just def vs. newtype?</p>",
        "id": 156644744,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548195184
    },
    {
        "content": "<p>I've just been trying out different options for opposite categories and my impression there is that an irreducible def is the best option, though you could probably make do with other options for algebra because there isn't as heavy use of dependent types there</p>",
        "id": 156644854,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548195274
    },
    {
        "content": "<p>these all seem like different things</p>",
        "id": 156644857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195278
    },
    {
        "content": "<p>you may want to invert the order without commuting the multiplication, or the addition</p>",
        "id": 156644876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195301
    },
    {
        "content": "<p>they are independent axes</p>",
        "id": 156644888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195308
    },
    {
        "content": "<p>so they should be different constructions</p>",
        "id": 156644900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195322
    },
    {
        "content": "<p>I'm sure there will be various diamond issues like how <code>opposite (order_dual A) != order_dual (opposite A)</code>... I don't have a unified suggestion here</p>",
        "id": 156644989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195375
    },
    {
        "content": "<p>remind me why newtypes are bad <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> . refl is overrated</p>",
        "id": 156645129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195516
    },
    {
        "content": "<p>you should be using simp lemmas anyway in category theory</p>",
        "id": 156645153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195539
    },
    {
        "content": "<p>It's really hard to deal with nondefinitional equalities between objects in category theory though.</p>",
        "id": 156645265,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548195617
    },
    {
        "content": "<p>If you define the objects of C^op to be an inductive type/structure, then eventually you have to deal with the fact that a general object of C^op is not definitionally of the form <code>op</code> of something</p>",
        "id": 156645445,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548195771
    },
    {
        "content": "<p>isn't that by cases on the objects?</p>",
        "id": 156645580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195855
    },
    {
        "content": "<p>Or you can state your theorem to only apply to objects of the form <code>op X</code></p>",
        "id": 156645637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548195914
    },
    {
        "content": "<p>you can't really though, because you need to provide a natural transformation between two functors C^op -&gt; Type or something</p>",
        "id": 156645671,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548195954
    },
    {
        "content": "<p>You could define it using cases on the object but putting that in a definition feels like a bad idea</p>",
        "id": 156645732,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548195977
    },
    {
        "content": "<p>I need to run but later I can prepare a version with irreducible and a version with an inductive type to compare</p>",
        "id": 156645771,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548196018
    },
    {
        "content": "<p>In that case you can just use the <code>unop</code> function; the cases happens in the equality proof part</p>",
        "id": 156645789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548196033
    },
    {
        "content": "<p>Well, this hasn't happened yet but potentially you could need to build something by composing a function ... -&gt; X with a function op (unop X) -&gt; ...</p>",
        "id": 156645860,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548196089
    },
    {
        "content": "<p>I guess the categorical formulation of what's going on is that <code>op : C =&gt; C^op</code> is a contravariant functor, and <code>unop</code> is its essential inverse</p>",
        "id": 156646207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548196346
    },
    {
        "content": "<p>so the roundtrip is an iso</p>",
        "id": 156646226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548196369
    },
    {
        "content": "<p>but in category theory (at least the way I learnt it), C^op is the category with the same objects as C but <code>Mor[C^op](X,Y) := Mor[C](Y,X)</code></p>",
        "id": 156646280,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548196422
    },
    {
        "content": "<p>I mean in category theoretic language, not using material properties of the category</p>",
        "id": 156646408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548196506
    },
    {
        "content": "<p>\"the objects of C^op are the objects of C\" does not typecheck in category language</p>",
        "id": 156646425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548196529
    },
    {
        "content": "<p>I'm not sure how to define C^op using universal properties</p>",
        "id": 156646501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548196568
    },
    {
        "content": "<p>Just like any category language definition, it is defined up to a natural (2-)isomorphism</p>",
        "id": 156646575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548196626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> what do you think? irreducible def or newtype?</p>",
        "id": 156646940,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548196909
    },
    {
        "content": "<p>I prefer a (ir)reducible def. Or at least a <code>structure</code> with one field instead of a inductive</p>",
        "id": 156647057,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1548197015
    },
    {
        "content": "<p>I think the \"newtype\" option is a structure with one field</p>",
        "id": 156647129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548197054
    },
    {
        "content": "<p>so... irreducible def it is?</p>",
        "id": 156647311,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548197247
    },
    {
        "content": "<p>I think using a newtype is the \"purist\" approach, and it is workable if you are consistent about it. the (ir)reducible def approach has lower overhead, but lean will not check as much for you - the onus is on you to not misuse the defeqs</p>",
        "id": 156647491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548197405
    },
    {
        "content": "<p>well but Reid has more experience on this?</p>",
        "id": 156647738,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548197659
    },
    {
        "content": "<p>I'm just saying what the tradeoff is</p>",
        "id": 156647816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548197762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> are you happy with making it an irreducible def and then afterwards see if it brings any problems?</p>",
        "id": 156648359,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548198209
    },
    {
        "content": "<p>I would prefer to just make it a regular def for now</p>",
        "id": 156648373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548198233
    },
    {
        "content": "<p>which is I think the current state of the PR</p>",
        "id": 156648425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1548198262
    },
    {
        "content": "<p>well it's an inductive type currently</p>",
        "id": 156648458,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548198315
    },
    {
        "content": "<p>the first version was an irreducible def</p>",
        "id": 156648463,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548198321
    },
    {
        "content": "<p>Hmm... in the category theory opposites PR it is currently a (normal reducibility) definition. Perhaps Mario was talking about that one.</p>",
        "id": 156649703,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1548199808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> what do you think then?</p>",
        "id": 156649757,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548199873
    },
    {
        "content": "<p>I think the semireducible def seems like a reasonable compromise. I wouldn't go all the way to the inductive type yet, unless we find that we're still finding confusing situations (because Lean is happily accepting things that \"aren't quite right\").</p>",
        "id": 156649849,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1548199952
    },
    {
        "content": "<p>Certainly making the def irreducible (using a newtype would have had the same benefit) revealed lots of places in the category_theory files where things \"weren't quite right\". So I appreciate the argument for keeping this level of protection permanently, and this is the argument for using a newtype.</p>",
        "id": 156649931,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1548200015
    },
    {
        "content": "<p>semireducible is the default right?</p>",
        "id": 156650004,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548200059
    },
    {
        "content": "<p>Yes</p>",
        "id": 156650024,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1548200092
    },
    {
        "content": "<p>done</p>",
        "id": 156650101,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548200167
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> do you see any problem with this PR?</p>",
        "id": 156650107,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548200183
    },
    {
        "content": "<p>Actually I'm not in a hurry; I would rather <a href=\"https://github.com/leanprover/mathlib/issues/614\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/issues/614\">#614</a> to be merged first</p>",
        "id": 156650116,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1548200203
    },
    {
        "content": "<blockquote>\n<p>I'm just saying what the tradeoff is</p>\n</blockquote>\n<p>Indeed this comes down to a tradeoff between conciseness/implicitness/ambiguity and unambiguity/explicitness/verbosity. The best point on the spectrum is I think not something we can deduce by pure thought but have to learn from experience.</p>",
        "id": 156694975,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548255521
    },
    {
        "content": "<p>In category theory, we've had the experience that a plain (semireducible) type can lead to confusion or to difficulty getting Lean to understand what we want to do. Note that the ambiguity can occur in either direction--Lean might not interpret our input as expected but also the types and goals that Lean displays might not mean what we would guess. (For example, it was easy to get into a situation where the goal was <code>X \\hom Y</code> but you really needed to supply <code>Y \\hom X</code> because the implicit category instance was that of the opposite category.)</p>",
        "id": 156695266,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548255761
    },
    {
        "content": "<p>I don't know whether usages of the \"implicit\" style for opposites in algebra would run into the same kinds of difficulties.</p>",
        "id": 156695306,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548255802
    },
    {
        "content": "<p>I do like the way <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> has set up a mini-API for converting to and from opposites, which should make it easy to try out the different implementation choices (I copied this to try out different designs for opposite categories)</p>",
        "id": 156695447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1548255898
    }
]
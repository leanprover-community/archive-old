[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7654\">#7654</a> is not very exciting, but it is somewhat exposed to bitrot, so I wouldn't mind if it could be merged sooner rather than later.</p>\n<p>No new maths, just allows us to talk about <code>ideal</code> in a noncommutative ring, meaning a left ideal.</p>\n<p>I thought it best _not_ to change the name to <code>left_ideal</code>, so that in a commutative ring (still our biggest audience!) one doesn't have to write the pesky <code>left_</code>. This will mean however that we'll need a separate name later for two-sided ideals.</p>",
        "id": 240731364,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622337889
    },
    {
        "content": "<p>This also highlights something that I faced with the order refactor.  One of my reasons was to allow not-necessarily commutative semigroups/monoids/semirings/rings to be ordered.  In this specific case, there were some lemmas that could be proven by using either left- or right- monotonicity.  For instance, <code>1 &lt; a -&gt; 1 &lt; a ^ n</code> that follows from either left or right monotonicity of multiplication.  In this case, I called the two versions <code>left.[name]</code> and <code>right.[name]</code>, though I would be happy with a more consistent naming.  For instance, a convention that the \"usual\" name is an implied <code>left</code> and that explicitly only <code>right</code> is mentioned.</p>",
        "id": 240764198,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1622393237
    },
    {
        "content": "<p>Another way to resolve \"Z follows from either X or Y\" where both X and Y are typeclasses are to introduce another typeclass for Z</p>",
        "id": 240767545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622398503
    },
    {
        "content": "<p>Then you only need a single <code>z</code> lemma instead of <code>z_X</code> and <code>z_Y</code></p>",
        "id": 240767568,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622398555
    },
    {
        "content": "<p>Having <code>ideal</code> meaning left ideal feels wrong. An ideal should be the kernel of a ring morphism, and other notions should have longer names. Can't we have a definition of ideals that include both sides and then a constructor for commutative ring where you only have to prove one side? I guess this doesn't work with the trick of using submodule theory to define ideal.</p>",
        "id": 240798742,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1622444708
    },
    {
        "content": "<p>It's still a bi-submodule, right?</p>",
        "id": 240799160,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622445071
    },
    {
        "content": "<p>Yes, it's a bimodule. But do we have bimodules?</p>",
        "id": 240799369,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1622445253
    },
    {
        "content": "<p>No, but we'll certainly need them if we are generalizing all this stuff. Guess we'll need a new notational class as well? <span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span></p>",
        "id": 240799965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622445677
    },
    {
        "content": "<p>I have been toying with the idea of having a <code>to_right</code> attribute, similar to <code>to_additive</code> that would convert a <code>left</code> lemma to a <code>right</code> lemma.  If we really take on-board of removing commutativity as much as possible, it may be useful to have it.</p>",
        "id": 240800341,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1622445907
    },
    {
        "content": "<p>We have right-modules now as <code>module (opposite R) M</code></p>",
        "id": 240800694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446183
    },
    {
        "content": "<p>But we would also need a <code>has_ralacs</code> class, with appropriate notation, I think. Because as Eric points out, now we need to use <code>opposite R</code>. I think that's a notational headache.</p>",
        "id": 240800766,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622446214
    },
    {
        "content": "<p>(at least, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/opposite.monoid.to_mul_action\">docs#opposite.monoid.to_mul_action</a> which confers the obvious right action on a monoid on itself)</p>",
        "id": 240800822,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446264
    },
    {
        "content": "<p>I don't think we need such a class, a notation for <code>op r \\smul m</code> would suffice. I asked about this in another thread recently</p>",
        "id": 240800883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446312
    },
    {
        "content": "<p>I assume a bimodule is \"nothing more\" than <code>[module R M] [module (opposite R) M] [smul_comm_class R (opposite R) M]</code>?</p>",
        "id": 240801133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446456
    },
    {
        "content": "<p>is there a way to enforce the convention that <em>asymmetric</em> things are formulated only for \"left\" assumptions?  I am thinking of something similar to the convention of never using <code>ge</code>.</p>\n<p>I do not know how extensive is the use of <code>right</code>-lemmas in a bi-context.  As Eric points out, if this is relatively rare, the <code>opposite</code> way could be a good compromise, in a situation where you have a bi-something and want to play really with both left and right assumptions.</p>",
        "id": 240801166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1622446490
    },
    {
        "content": "<p>I guess that could work. Of course ideals are not rare, but they could be done separately...</p>",
        "id": 240801279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622446562
    },
    {
        "content": "<p>We would still need a new <code>subbimodule</code> structure</p>",
        "id": 240801361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446601
    },
    {
        "content": "<p>Composition works for typeclasses but not for bundled subobjects</p>",
        "id": 240801381,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446614
    },
    {
        "content": "<p>Unless we come up with a more sophisticated approach to bundling</p>",
        "id": 240801406,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622446632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings/near/240801361\">said</a>:</p>\n<blockquote>\n<p>We would still need a new <code>subbimodule</code> structure</p>\n</blockquote>\n<p><code>sub_smul_comm_class</code> <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span> <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 240801511,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622446701
    },
    {
        "content": "<p>((Un)related: should <code>smul_comm_class</code> be renamed to <code>smul_comm</code>?)</p>",
        "id": 240801579,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622446757
    },
    {
        "content": "<p>(and the cryptic <code>is_scalar_tower</code> to <code>smul_assoc</code>?)</p>",
        "id": 240801788,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1622446873
    },
    {
        "content": "<p>ooh, wait, the reason that doesn't work is that the lemmas are already called <code>smul_comm</code> and <code>smul_assoc</code>...</p>",
        "id": 240801917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622446944
    },
    {
        "content": "<p>Those could become <code>has_smul_comm</code>, though, right(/opposite)?  Or is <code>has_[...]</code> something else?</p>",
        "id": 240802225,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1622447157
    },
    {
        "content": "<p>I agree there is a problem with naming, on the other hand I don't want to have to do a massive refactor of our handling of ideals just to be able to say that a division ring is noetherian (which requires no new maths at all in current mathlib, just relaxing commutativity assumptions).</p>\n<p>I would propose perhaps the following as a path to the utopian world we want:</p>\n<ol>\n<li>this PR as is, and we hold our noses for a moment about names</li>\n<li>in a next PR, we rename <code>ideal</code> to <code>left_ideal</code>, and add a new abbreviation <code>ideal</code> for <code>left_ideal</code>, but only in the presence of commutativity</li>\n<li>we add <code>two_sided_ideal</code>, <code>right_ideal</code>, <code>bimodule</code>, <code>subbimodule</code>, <code>has_right_scalar</code> etc... progressively.</li>\n</ol>",
        "id": 240804305,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622448581
    },
    {
        "content": "<p>I agree that this is probably the best way forward</p>",
        "id": 240804534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622448763
    },
    {
        "content": "<p>I'm delighted to see this PR and really looking forward to the day we get to bimodules properly, especially as they do come up in even commutative land from time to time.</p>",
        "id": 240809664,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622452246
    },
    {
        "content": "<p>I had an example just yesterday with something equivalent to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"c1\">-- Alternatively could drop `algebra R A` and  use `smul_comm_class R A M` instead of</span>\n<span class=\"c1\">-- `is_scalar_tower R A M` at cost of then needing manual `smul_comm_class.symm` somewhere.</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">works</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- Finds `linear_map.module`</span>\n\n<span class=\"c1\">-- This is really `module Aᵒᵖ (M →ₗ[R] N)` but since `A` is commutative `Aᵒᵖ ≃+* A` have below also</span>\n<span class=\"kd\">instance</span> <span class=\"n\">fails</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">also_fails</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 240809726,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622452298
    },
    {
        "content": "<p>The point being that we define the left module structure on linear maps (using the scalar action in the codomain) but not the right module structure (using the scalar action in the domain).</p>",
        "id": 240809940,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622452437
    },
    {
        "content": "<p>Why is that the right definition of the \"right\" action? Shouldn't the right action just be the right action in the codomain, to match the left action?</p>",
        "id": 240830233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622465725
    },
    {
        "content": "<p>IIUC we agree: I haven't actually proposed a definition of the \"right\" action the above but just noticed that we only have a definition of the \"left\" action.</p>",
        "id": 240830809,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622466072
    },
    {
        "content": "<p>There is no <code>A</code>-action on the codomain <code>N</code> at all.</p>",
        "id": 240831391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622466391
    },
    {
        "content": "<p>Isn't that my point? I.e., the reason <code>module A (M →ₗ[R] N)</code> fails is because we define our scalar actions using the scalar action in the codomain so when there isn't one there <code>linear_map.module</code> fails and there is no other instance.</p>",
        "id": 240832008,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622466794
    },
    {
        "content": "<p>But if we also defined the right <code>A</code> action, then we would find an instance in this case. However to avoid diamond issues (or indeed to work when <code>A</code> is not commutative) it would have to be on the type <code>Aᵒᵖ</code> or else using a new <code>has_right_scalar</code> typeclass.</p>",
        "id": 240832250,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622466945
    },
    {
        "content": "<p>I think I have this correct but please correct me if I am muddled.</p>",
        "id": 240832332,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622466980
    },
    {
        "content": "<p>Actually I need to think about this, there is a second action but this is not as simple as a left-right issue.</p>",
        "id": 240832774,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622467209
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 240837753,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622470073
    },
    {
        "content": "<p>Our \"general philosophy\" with pi instances is to inherit structure on the pi type from structure on the codomain. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>N</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">f:N\\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and we want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to act on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> s somehow, then the natural definition is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(af)(n)=a(fn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, which works great if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> acts on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, and the fact that all that's happening is that the brackets are moving around means that the diagrams will commute. However if you imagine writing maps on the right, writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">nf</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">fn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">n</span></span></span></span> (which is just a notational change, i.e. it doesn't matter that this is not Lean syntax) then we now want to know what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">af</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> should be and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(af)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> now looks like it should naturally be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mi>a</mi><mo stretchy=\"false\">)</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">(na)f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">na</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, meaning that there is a natural left-action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(N,M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> has a right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-action.</p>",
        "id": 240840715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622471762
    },
    {
        "content": "<p>Mathematically I've just convinced myself that in bimodule land, being left-linear kills off the ring you're linear over but retains the other two rings each module carried an action of.</p>",
        "id": 240840953,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622471914
    },
    {
        "content": "<p>I.e. if <code>M</code> is an <code>(A, B)</code>-bimodule and <code>N</code> is an <code>(A, C)</code>-bimodule then we can talk about left-<code>A</code>-linear maps and these are a <code>(B, C)</code>-bimodule.</p>",
        "id": 240841026,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622471977
    },
    {
        "content": "<p>Yes, that sounds right -- analogous to the fact that the tensor product of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(A,B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>-bimodule and a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(B,C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>-bimodule is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(A,C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>-bimodule.</p>",
        "id": 240841039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622471987
    },
    {
        "content": "<p>(or <code>(C, B)</code> for maps the other way)</p>",
        "id": 240841050,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622471994
    },
    {
        "content": "<p>And of course similar story for right-linear if its the right rings the two modules have in common.</p>",
        "id": 240841101,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622472009
    },
    {
        "content": "<p>So when people say linear maps over a non-commutative ring are just an abelian group it's because they only had Z actions on the other side of their bimodules etc.</p>",
        "id": 240841154,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622472050
    },
    {
        "content": "<p>Right, and my \"write maps on the right\" viewpoint convinces you that a right action of an object on the domain of a hom set naturally translates to a left action of the object on the hom set (for me, this is not so \"natural\" if you just write down the algebra with maps on the left.)</p>",
        "id": 240841183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622472074
    },
    {
        "content": "<p>I think so. I'm 99% convinced. One moment.</p>",
        "id": 240841337,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622472135
    },
    {
        "content": "<p>Now 100%</p>",
        "id": 240841394,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622472176
    },
    {
        "content": "<p>Another way of seeing it is that Hom(M,N) is covariant in N but contravariant in M.</p>",
        "id": 240841399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622472178
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>M</mi><mo>∗</mo></msup><mo>⊗</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(M,N) = M^* \\otimes N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.772026em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></p>",
        "id": 240841675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622472328
    },
    {
        "content": "<p>I think then you can transfer all the natural actions from the tensor product to Hom in a natural way.</p>",
        "id": 240841791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622472381
    },
    {
        "content": "<p>I often secretly use this <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span>to figure out what should be true and then translate back into Hom afterward</p>",
        "id": 240841795,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622472382
    },
    {
        "content": "<p>The LaTeX statement is not true in general but it's a pretty good guide to what's going on!</p>",
        "id": 240841885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622472429
    },
    {
        "content": "<p>Yes, that's why I only do it secretly.</p>",
        "id": 240841899,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622472439
    },
    {
        "content": "<p>So did we conclude what <code>has_scalar (opposite R) (R -&gt; R)</code> should mean? IMO it should be <code>fun r f x, f x * r.unop</code> to match the <code>fun r f x, r * f x</code> action of <code>has_scalar R (R -&gt; R)</code>?</p>",
        "id": 240852010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622478738
    },
    {
        "content": "<p>(I also suspect the instance of that definition is found by typeclass search today)</p>",
        "id": 240852318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622478990
    },
    {
        "content": "<p><del>Not sure about being found by typeclass today but otherwise agree.</del></p>",
        "id": 240852583,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622479174
    },
    {
        "content": "<p>I think it's found today for <code>monoid R</code> but am not in a position to check</p>",
        "id": 240853035,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622479529
    },
    {
        "content": "<p>I think I can summarise what I claim is missing as the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"c1\">-- Exists</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pi.has_scalar</span>\n\n<span class=\"c1\">-- Missing</span>\n<span class=\"kd\">instance</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">r.unop</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">baz</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">has_scalar.smul</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">has_scalar.smul</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"c1\">-- Finds `bar` above</span>\n</code></pre></div>",
        "id": 240853457,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622479890
    },
    {
        "content": "<p>So we're encoding right actions as left actions by the opposite ring?</p>",
        "id": 240853693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622480062
    },
    {
        "content": "<p>In this snippet yes, but I'm not yet convinced this is what we should do in Mathlib.</p>",
        "id": 240853729,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I too am confused again!</p>",
        "id": 240854059,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480362
    },
    {
        "content": "<p>Your snippet is not compatible with the version I propose above that you expressed agreement with!</p>",
        "id": 240854074,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622480378
    },
    {
        "content": "<p>I know. I'm just trying to think this through again.</p>",
        "id": 240854169,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480429
    },
    {
        "content": "<p>Eric is proposing using the action on the codomain and Oliver on the domain</p>",
        "id": 240854285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622480518
    },
    {
        "content": "<p>Yes</p>",
        "id": 240854327,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480523
    },
    {
        "content": "<p>Otherwise we have no way to express \"use the right action on the codomain\"</p>",
        "id": 240854363,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622480562
    },
    {
        "content": "<p>And the action on the domain usually isn't as strong - for instance, I don't think it's distributive on general pi types, only on add_monoid_homs</p>",
        "id": 240854426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622480618
    },
    {
        "content": "<p>It might not actually be an action I want after all. In the cases I can think of that I care about (e.g., left-linear maps between bimodules) it isn't.</p>",
        "id": 240854748,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.237654.2C.20generalize.20ideals.20to.20left.20ideals.20in.20noncomm.20rings/near/240852010\">said</a>:</p>\n<blockquote>\n<p>So did we conclude what <code>has_scalar (opposite R) (R -&gt; R)</code> should mean? IMO it should be <code>fun r f x, f x * r.unop</code> to match the <code>fun r f x, r * f x</code> action of <code>has_scalar R (R -&gt; R)</code>?</p>\n</blockquote>\n<p>As of now I revert to agreeing with this and mentally bookmark the action I mentioned as a weird thing that exists but which I don't need.</p>",
        "id": 240854891,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480934
    },
    {
        "content": "<p>I can't believe I'm still talking about this <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 240854923,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622480965
    },
    {
        "content": "<p>For record I guess we can do the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Give X left `A` and right `B` action</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">A</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">B</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Give Y left `C` and right `D` action</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">C</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">D</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Right action on maps from left action on domain (my original action)</span>\n<span class=\"kd\">def</span> <span class=\"n\">right_A</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a.unop</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Left action on maps from right action on domain (not previously discussed)</span>\n<span class=\"kd\">def</span> <span class=\"n\">left_B</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Left action on maps from left action on codomain (\"usual\" pi action)</span>\n<span class=\"kd\">def</span> <span class=\"n\">left_C</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pi.mul_action</span> <span class=\"n\">C</span>\n\n<span class=\"c1\">-- Right action on maps from right action on codomain (Eric's action)</span>\n<span class=\"kd\">def</span> <span class=\"n\">right_D</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">D</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 240859555,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622484733
    },
    {
        "content": "<p>In other words if <code>X</code> carries a left <code>A</code>-action a right <code>B</code>-action and <code>Y</code> carries a left <code>C</code>-action and a right <code>D</code>-action then the maps <code>X → Y</code> carry four actions (two left, two right) covariantly in the codomain and contravariantly in the domain.</p>",
        "id": 240859684,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622484870
    },
    {
        "content": "<p>Does <code>infer_instance</code> find <code>right_D</code>?</p>",
        "id": 240860501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622485578
    },
    {
        "content": "<p>Oh, it does!</p>",
        "id": 240860510,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622485593
    },
    {
        "content": "<p>Right, of course it should. It's just the usual pi action.</p>",
        "id": 240860549,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622485638
    },
    {
        "content": "<p>Exactly</p>",
        "id": 240860566,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622485652
    },
    {
        "content": "<p><del>I think we're good here: I feel I understand things and I believe the actions we want are the ones we have, namely the actions on the codomain.</del> I'll have to think about what we should do but at least I understand now.</p>",
        "id": 240860593,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622485682
    },
    {
        "content": "<p>I think it probably does make sense to have some way to spell the other actions, perhaps via type aliases</p>",
        "id": 240860757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622485800
    },
    {
        "content": "<p>This thorn has come up on polynomials quite recently, as they provide actions for both domain and codomain (of the evaluation function)</p>",
        "id": 240860832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622485845
    },
    {
        "content": "<p>Which unsurprisingly forms a bad diamond</p>",
        "id": 240860852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622485865
    },
    {
        "content": "<p>Actually I tend to think we may have to do something here.</p>",
        "id": 240860936,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1622485935
    },
    {
        "content": "<p><del>I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra\">docs#monoid_algebra</a> comap is the type alias for monoid algebras. Which naturally is not reused at all for polynomials...</del></p>",
        "id": 240861013,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622486025
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.comap_distrib_mul_action\">docs#finsupp.comap_distrib_mul_action</a> is what I'm thinking of</p>",
        "id": 240861147,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622486134
    },
    {
        "content": "<p>Which is registered as an instance for <code>monoid_algebra</code> but not finsupp</p>",
        "id": 240861408,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622486367
    }
]
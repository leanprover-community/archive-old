[
    {
        "content": "<p>This PR adds a feature to <code>linear_combination</code> but also changes the syntax slightly: in the case where  no coefficient is provided and it defaults to 1, you now need to surround the argument in parentheses. (<code>linear_combination (h1) (h2)</code>). I think this is acceptable and <code>linear_combination</code> isn't heavily used right now, but wanted to check if anyone objects to the change!</p>",
        "id": 281367468,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651789617
    },
    {
        "content": "<p>How ridiculous and/or viable would it be to change the syntax dramatically to something like <code>linear_combination h1 + 3 • h2</code>?</p>",
        "id": 281367956,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651790021
    },
    {
        "content": "<p>I think it would be ~impossible to do that and support arbitrary proof term inputs like this PR does</p>",
        "id": 281368046,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651790087
    },
    {
        "content": "<p>Since it's ambiguous whether the <code>+</code> is part of a proof term or tactic syntax</p>",
        "id": 281368065,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651790107
    },
    {
        "content": "<p>The + can't be part of a proof term since has_add only works on Type not Prop</p>",
        "id": 281368307,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651790292
    },
    {
        "content": "<p>But I guess a subterm could contain data. I'm not claiming it's necessarily a good idea!</p>",
        "id": 281368369,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651790361
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">p</span> <span class=\"bp\">`+`</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">eq.refl</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 281368401,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651790382
    },
    {
        "content": "<p>There may be a way to coerce it into working but it would be hacky and not worth it IMO!</p>",
        "id": 281368489,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651790437
    },
    {
        "content": "<p>This is my preferred syntax as well, I don't think it's a crazy idea as long as you parse the expressions with the right precedence</p>",
        "id": 281382000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651803230
    },
    {
        "content": "<p>see <a href=\"#narrow/stream/116395-maths/topic/groebner.20basis.20algorithm/near/197257520\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/groebner.20basis.20algorithm/near/197257520</a>, which predates <code>linear_combination</code></p>",
        "id": 281382168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651803396
    },
    {
        "content": "<p>the solution to your example <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>  is \"stop doing that silly thing\"</p>",
        "id": 281382187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651803447
    },
    {
        "content": "<p>if you redefine basic operators with a local notation then lots of stuff will break</p>",
        "id": 281382198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651803477
    },
    {
        "content": "<p>here's a parser:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.core</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.get_frozen_name</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">e.is_annotation</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"n\">frozen_name</span><span class=\"o\">,</span> <span class=\"n\">expr.const</span> <span class=\"n\">n</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">name.anonymous</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">opt_param</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"n\">e1</span> <span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">::</span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e1</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mk_mul</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">::</span><span class=\"n\">es</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"bp\">%%</span><span class=\"o\">(</span><span class=\"n\">mk_mul</span> <span class=\"n\">es</span><span class=\"o\">))</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">pexpr</span> <span class=\"bp\">×</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"n\">e</span> <span class=\"k\">in</span>\n  <span class=\"k\">match</span> <span class=\"n\">head.get_frozen_name</span><span class=\"o\">,</span> <span class=\"n\">args</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_add.add</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span> <span class=\"bp\">++</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_sub.sub</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span> <span class=\"bp\">++</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"n\">neg</span><span class=\"o\">)</span> <span class=\"n\">ms</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_mul.mul</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">::</span><span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_neg.neg</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"n\">neg</span><span class=\"o\">)</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">mk_mul</span> <span class=\"n\">ms</span> <span class=\"k\">in</span> <span class=\"o\">[(</span><span class=\"k\">if</span> <span class=\"n\">neg</span> <span class=\"k\">then</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">-%%</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">)]</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"n\">setup_tactic_parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.linear_combo</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">as_linear_combo</span> <span class=\"n\">ff</span> <span class=\"o\">[]</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">p.mmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"k\">do</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">i_to_expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">i_to_expr</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)),</span>\n  <span class=\"n\">trace</span> <span class=\"n\">p</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"gr\">admit</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">linear_combo</span> <span class=\"bp\">-</span><span class=\"n\">h1</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">h2</span>\n  <span class=\"c1\">-- [(-1, h1), (-2, h2)]</span>\n</code></pre></div>",
        "id": 281384635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651806208
    },
    {
        "content": "<p>Going a step further; would something like a <code>has_padd</code> class be possible, which would avoid the need to do any parsing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_padd</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">padd</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- I think Lean should be able to handle the overloading</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`+`</span> <span class=\"o\">:=</span> <span class=\"n\">has_padd.padd</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_padd</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">padd</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg2</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)}</span>\n</code></pre></div>",
        "id": 281405241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651823669
    },
    {
        "content": "<p>You could then put instances on things like <code>is_even</code> too (and many things matching <a href=\"https://leanprover-community.github.io/mathlib_docs/find/.add\">docs#.add</a>)</p>",
        "id": 281405307,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651823734
    },
    {
        "content": "<p>Eric, I do not know if this can really be pulled off, but your suggestion looks <em>great</em>!  If it can be made to work, I can definitely find uses for it!</p>\n<p>It feels a little like a \"monadic instance of addition\".</p>",
        "id": 281421374,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651833849
    },
    {
        "content": "<p>Adding proofs is definitely unexpected, so I'm not really sold. And I don't see why we should treat addition separately from literally any other operator (inversion, subtraction, power, order ...)</p>",
        "id": 281422421,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651834701
    },
    {
        "content": "<p>I would be proposing we apply the same gimmick to lots of operators, so I don't think inconsistency is that relevant; but the unexpectedness is certainly a concern</p>",
        "id": 281422633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651834824
    },
    {
        "content": "<p>There will be the need of <code>to_padditive</code>...</p>",
        "id": 281423391,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651835394
    },
    {
        "content": "<p>I'm more comfortable with the pexpr parser approach because it doesn't bleed out into other things. I don't want adding proofs with <code>+</code> to be generally possible, not least because of the overloading of <code>+</code></p>",
        "id": 281428525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651838827
    },
    {
        "content": "<p>I think it is more excusable when it is part of a bespoke tactic, people are already used to tactics introducing their own funny syntax</p>",
        "id": 281428713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651838912
    },
    {
        "content": "<p>I think what I'm actually after here is a tactic version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/congr_arg\">docs#congr_arg</a> that's generalized to <code>n</code> variables and has a nice syntax</p>",
        "id": 281429052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651839115
    },
    {
        "content": "<p>Rather than restricting ourself to only a few operators (like your pexpr trick), or building nasty hacks (like my <code>padd</code>)</p>",
        "id": 281429126,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651839140
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#congr\">tactic#congr</a>?</p>",
        "id": 281429172,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651839175
    },
    {
        "content": "<p>So something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcd</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hef</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">combine</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">hcd</span><span class=\"o\">]</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">hef</span><span class=\"o\">]),</span>\n    <span class=\"c1\">-- this: 1 + a + c * e = 1 + b + d * f</span>\n    <span class=\"n\">trivial</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 281429335,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651839256
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#congr\">tactic#congr</a> requires you to state your goal up front, this would work out the sides of the equality from the inputs.</p>",
        "id": 281429570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651839368
    },
    {
        "content": "<p>this is pretty similar to <code>&lt;- e</code> desugaring in lean 4</p>",
        "id": 281429862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651839538
    },
    {
        "content": "<p>With the difference being that instead of evaluating the expression on the results of the monads <code>e</code>, you evaluate <code>congr_argn</code> on the  expression and the <code>e</code>s?</p>",
        "id": 281430420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651839869
    },
    {
        "content": "<p>I guess I agree the parsing task is pretty similar</p>",
        "id": 281430502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651839912
    },
    {
        "content": "<p>Oh, another example of this kind of transformation is <code>%%e</code> in expr quotations</p>",
        "id": 281430504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651839916
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">λ</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"bp\">%%</span><span class=\"n\">h2</span> <span class=\"bp\">+</span> <span class=\"bp\">%%</span><span class=\"n\">h3</span><span class=\"o\">)</span>\n<span class=\"c1\">-- λ (h1 h2 h3 : pexpr),</span>\n<span class=\"c1\">--   ((``(λ (_x_1 _x_2 _x_3 : _), has_add.add (has_add.add _x_1 _x_2) _x_3)</span>\n<span class=\"c1\">--      .subst (to_pexpr h1))</span>\n<span class=\"c1\">--      .subst (to_pexpr h2))</span>\n<span class=\"c1\">--      .subst (to_pexpr h3)</span>\n</code></pre></div>",
        "id": 281430642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651839994
    },
    {
        "content": "<p>thats <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.subst\">docs#expr.subst</a> not <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eq.subst\">docs#eq.subst</a> I assume</p>",
        "id": 281430705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651840040
    },
    {
        "content": "<p>yes</p>",
        "id": 281430727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651840056
    },
    {
        "content": "<p>So should we just hack into that parser and manipulate the resulting pexpr?</p>",
        "id": 281430815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651840101
    },
    {
        "content": "<p>although... it wouldn't be too hard to parse that pexpr with the lambda and subst</p>",
        "id": 281430827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651840113
    },
    {
        "content": "<p>Here's a free corner of the syntax: <code>combine 1 + _ h1 + _ h2 + _ h3</code></p>",
        "id": 281431363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651840442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281384635\">said</a>:</p>\n<blockquote>\n<p>here's a parser:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.core</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">expr.get_frozen_name</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">e.is_annotation</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"n\">frozen_name</span><span class=\"o\">,</span> <span class=\"n\">expr.const</span> <span class=\"n\">n</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">name.anonymous</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">opt_param</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"n\">e1</span> <span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">::</span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e1</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mk_mul</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">::</span><span class=\"n\">es</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"bp\">%%</span><span class=\"o\">(</span><span class=\"n\">mk_mul</span> <span class=\"n\">es</span><span class=\"o\">))</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">pexpr</span> <span class=\"bp\">×</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"n\">e</span> <span class=\"k\">in</span>\n  <span class=\"k\">match</span> <span class=\"n\">head.get_frozen_name</span><span class=\"o\">,</span> <span class=\"n\">args</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_add.add</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span> <span class=\"bp\">++</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_sub.sub</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span> <span class=\"bp\">++</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"n\">neg</span><span class=\"o\">)</span> <span class=\"n\">ms</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_mul.mul</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">::</span><span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_neg.neg</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"n\">neg</span><span class=\"o\">)</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">mk_mul</span> <span class=\"n\">ms</span> <span class=\"k\">in</span> <span class=\"o\">[(</span><span class=\"k\">if</span> <span class=\"n\">neg</span> <span class=\"k\">then</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">-%%</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">)]</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"n\">setup_tactic_parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.linear_combo</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">as_linear_combo</span> <span class=\"n\">ff</span> <span class=\"o\">[]</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">p.mmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"k\">do</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">i_to_expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">i_to_expr</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)),</span>\n  <span class=\"n\">trace</span> <span class=\"n\">p</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"gr\">admit</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">linear_combo</span> <span class=\"bp\">-</span><span class=\"n\">h1</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">h2</span>\n  <span class=\"c1\">-- [(-1, h1), (-2, h2)]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Interesting. This is lower level and more robust than my attempt to do this yesterday (trying to split the components at parse time instead of after). Let me try it out a bit. One thing I worry about a little is the predictability of when you need parens around the scalar and/or proof term, but your approach is better than mine here</p>",
        "id": 281449195,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651848217
    },
    {
        "content": "<p>I should say, my ulterior motive here is for a tactic that will produce <code>Try this:</code> suggestions involving <code>linear_combination</code>, so I'd really like the syntax of <code>linear_combination</code> to stay predictable.</p>",
        "id": 281449386,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651848269
    },
    {
        "content": "<p>Can't say I'm a big fan of adding global notation instances to Prop, but it's kind of cute that it works!</p>",
        "id": 281449663,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651848364
    },
    {
        "content": "<p>Also, this syntax change is mostly orthogonal to <a href=\"https://github.com/leanprover-community/mathlib/pull/13979\">#13979</a>, so it should be a separate PR</p>",
        "id": 281450444,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651848707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281429335\">said</a>:</p>\n<blockquote>\n<p>So something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcd</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hef</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">combine</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">hcd</span><span class=\"o\">]</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">[</span><span class=\"n\">hef</span><span class=\"o\">]),</span>\n    <span class=\"c1\">-- this: 1 + a + c * e = 1 + b + d * f</span>\n    <span class=\"n\">trivial</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>One way to understand this <code>combine</code> tactic proposal is that (in this example) you're explicitly writing down the motive for an \"<code>eq.rec3</code>\" along with which equalities are used. Maybe rather than a tactic, you could have a <code>congr!</code> macro that looks something like <code>congr!(1 + %hab + %hcd + %hef)</code> so it could be easily used in term mode too.</p>",
        "id": 281485078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651866090
    },
    {
        "content": "<p>I hadn't even considered that term-mode macros exist</p>",
        "id": 281485122,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651866120
    },
    {
        "content": "<p>I'm warming to <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> 's parser for <code>linear_combination</code>. <a href=\"https://github.com/leanprover-community/mathlib/commit/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad\">https://github.com/leanprover-community/mathlib/commit/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad</a>  </p>\n<p>Two quirks. One, I had to add a <code>with</code> in order to parse the optional config object, otherwise it gets picked up as part of the pexpr. This isn't a problem. Two, it doesn't like the <a href=\"https://github.com/leanprover-community/mathlib/commit/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad#diff-bab69459876baf7d7bd3c5a90d915708f02e0912cbc69df05303049e3fed3707R181\">zero arguments case</a>, without a trailing <code>.</code> it tries to parse the next <code>example</code>. Not sure what the fix is there.</p>",
        "id": 281572654,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1651975650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> Where is your \"zero arguments case\" link going? I don't see any examples of zero arguments in the PR.</p>",
        "id": 281582749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651991245
    },
    {
        "content": "<p>I wanted to write it to parse <code>0</code> as an empty list of summands, but it will require more lean API (as you know, it is woefully underpowered when it comes to reflection on <code>pexpr</code>s). Here's a workaround that uses string parsing to recognize prenums:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">pexpr.is_prenum</span> <span class=\"o\">:</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.macro</span> <span class=\"n\">m</span> <span class=\"o\">[])</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">expr.macro_def_name</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"n\">prenum</span> <span class=\"k\">then</span> <span class=\"n\">string.to_nat</span> <span class=\"n\">e.to_string</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">pexpr</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">pexpr</span> <span class=\"bp\">×</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pexpr.get_app_args</span> <span class=\"n\">e</span> <span class=\"k\">in</span>\n  <span class=\"k\">match</span> <span class=\"n\">head.get_frozen_name</span><span class=\"o\">,</span> <span class=\"n\">args</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_add.add</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span> <span class=\"bp\">++</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_sub.sub</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span> <span class=\"bp\">++</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"n\">neg</span><span class=\"o\">)</span> <span class=\"n\">ms</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_mul.mul</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">e2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">::</span><span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"n\">e2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">``</span><span class=\"n\">has_neg.neg</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">e1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">as_linear_combo</span> <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"n\">neg</span><span class=\"o\">)</span> <span class=\"n\">ms</span> <span class=\"n\">e1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">head.is_prenum</span><span class=\"o\">,</span> <span class=\"n\">args</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">mk_mul</span> <span class=\"n\">ms</span> <span class=\"k\">in</span> <span class=\"o\">[(</span><span class=\"k\">if</span> <span class=\"n\">neg</span> <span class=\"k\">then</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">-%%</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">)]</span>\n    <span class=\"kd\">end</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Now you can write <code>linear_combo 0</code> and <code>linear_combo 0 + h1</code> and so on.</p>",
        "id": 281583100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651991926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281582749\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> Where is your \"zero arguments case\" link going? I don't see any examples of zero arguments in the PR.</p>\n</blockquote>\n<p>Huh, guess the link to a line of a commit doesn't work, it's <a href=\"https://github.com/leanprover-community/mathlib/blob/bcf90ce52d427bc4236400c4ec98c767b3f4e5ad/test/linear_combination.lean#L181\">here</a>. Not changed in the PR, on <a href=\"https://github.com/leanprover-community/mathlib/tree/robertylewis/lc-syntax\">branch#robertylewis/lc-syntax</a> since the syntax change is mostly independent of this PR</p>",
        "id": 281602521,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1652021271
    },
    {
        "content": "<p>I don't love having to write 0 for the empty list. <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> as <code>linear_combination</code>'s main customer, what do you think here?</p>",
        "id": 281602569,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1652021312
    },
    {
        "content": "<p>I don't think optional exprs have ever worked. <code>transitivity</code> shows the same behavior. It works if there is anything else around the tactic: <code>by { linear_combo }</code> or <code>begin linear_combo end</code> or <code>linear_combo,</code> in a tactic sequence all work fine. So I would say use <code>texpr?</code> in the parser and take advantage of it when you can</p>",
        "id": 281603123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652022081
    },
    {
        "content": "<p>Here's a possible realization of <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s idea from earlier. It's a tactic since I couldn't get <code>user_command</code>s to work -- they don't seem to have access to local variables. (I'm not proposing that this be used for <code>linear_combination</code>, but it would be nice to have something like this for creating congruence lemmas.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">congr_subst</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">prefix</span> <span class=\"bp\">`%!`</span><span class=\"o\">:</span><span class=\"n\">std.prec.max_plus</span> <span class=\"o\">:=</span> <span class=\"n\">congr_subst</span>\n\n<span class=\"c1\">-- use congr lemmas? (like mk_specialized_congr_lemma used by tactic.congr)</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">congr_mk</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">congr_subst</span> <span class=\"bp\">%%</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"c1\">-- need to be careful due to potential dependent types</span>\n  <span class=\"n\">hf</span> <span class=\"bp\">←</span> <span class=\"n\">congr_mk</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">hx</span> <span class=\"bp\">←</span> <span class=\"n\">congr_mk</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">hf</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">mk_congr</span> <span class=\"n\">hf</span> <span class=\"n\">hx</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">hf</span><span class=\"o\">),</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">mk_congr_fun</span> <span class=\"n\">hf</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">mk_congr_arg</span> <span class=\"n\">f</span> <span class=\"n\">hx</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">interactive.exact_congr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n  <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">i_to_expr_strict</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"c1\">-- the definition of congr_subst results in reasonable type errors here</span>\n  <span class=\"n\">he</span> <span class=\"bp\">←</span> <span class=\"n\">congr_mk</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">he</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">mk_eq_refl</span> <span class=\"n\">e</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.exact</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">he</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.exact</span> <span class=\"n\">he</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">11</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">11</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact_congr</span> <span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">*%!</span><span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*%!</span><span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">ring_nf</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">9</span><span class=\"bp\">*</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact_congr</span> <span class=\"mi\">2</span><span class=\"bp\">*%!</span><span class=\"n\">h1</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"bp\">*%!</span><span class=\"n\">h2</span> <span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"bp\">*%!</span><span class=\"n\">h3</span> <span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"bp\">*%!</span><span class=\"n\">h4</span><span class=\"o\">,</span>\n  <span class=\"n\">ring_nf</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 281627870,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652058933
    },
    {
        "content": "<p>Nice! Agreed, I don't think it makes sense for <code>linear_combination</code>, but something like that is a useful feature in its own right</p>",
        "id": 281629593,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1652061448
    },
    {
        "content": "<p>If people are okay with the slightly broken syntax in the empty case I'll PR it soon. But <a href=\"https://github.com/leanprover-community/mathlib/pull/13979\">#13979</a> is independent and can be merged first</p>",
        "id": 281629649,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1652061509
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib/pull/14229\">#14229</a> which builds on this one, adding Mario's parser.</p>",
        "id": 282842391,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1652904635
    }
]
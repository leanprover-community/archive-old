[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span> Any news on this PR? Are there problems or challenges showing up?</p>",
        "id": 165044255,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557206966
    },
    {
        "content": "<p>Yes, It's definitely a challenge. I don't believe in Mario's proposal to remove the <code>set</code> argument of <code>linear_independent</code> anymore. I tried it and it led me into something that felt like a swamp. It wasn't really that I got stuck, but it just felt harder and harder to move forward <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> .</p>",
        "id": 165051068,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1557216360
    },
    {
        "content": "<p>pray tell</p>",
        "id": 165051416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557216642
    },
    {
        "content": "<p>my claim is that it should be easier, so even if you were able to finish a proof if it seemed unnecessarily complicated then I would like to see it</p>",
        "id": 165051515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557216753
    },
    {
        "content": "<p>Ok, I pushed my current state to the pull request. It's a big mess, but what I have been trying to do is to adapt <code>linear_independent_union</code> to the new definition. I figured that I'd need some auxilliary lemmas and started adding those on the top of the file. But those lemmas again needed additional lemmas etc.</p>",
        "id": 165053977,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1557219509
    },
    {
        "content": "<p>My new plan is to change the definition of <code>is_basis</code> first. Some lemmas about <code>linear_dependent</code> seem to be very specifically designed to be used in the section about <code>is_basis</code>. Once I have made it work for <code>is_basis</code>, I might see more clearly.</p>",
        "id": 165148467,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1557308841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> How do you think should the lemmas <code>exists_linear_independent</code> and <code>linear_independent_sUnion_of_directed</code> look like after the refactoring? I am tempted to use sets for this, i.e. <code>linear_independent α (subtype.val : s → β)</code> for <code>s : set β</code>.</p>",
        "id": 166372225,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1558625719
    },
    {
        "content": "<p><code>exists_linear_independent</code> should use sets to some extent. Given a linear independent family <code>f : I -&gt; V</code> and a set <code>t : set V</code> such that <code>\\all i, f i \\in t</code>, there exists a <code>b \\sub t</code> such that <code>\\all i, f i \\in b</code> and <code>t \\sub span b</code> and <code>(coe : b -&gt; V)</code> is linear independent</p>",
        "id": 166406601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558651166
    },
    {
        "content": "<p><code>linear_independent_sUnion_of_directed</code> looks equivalent to some statement about colimits, I will ask <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 166406701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558651274
    },
    {
        "content": "<p>The background is a collection of maps <code>f j : I j -&gt; V</code> where <code>j : J</code> is coming from a partially ordered index set, and there is a map <code>h j j' : I j -&gt; I j'</code> when <code>j &lt;= j'</code>, and <code>f j' = h j j' o f j</code></p>",
        "id": 166407026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558651675
    },
    {
        "content": "<p>This is for the goal of proving that every vector space has a basis, right?<br>\nIf you're going to do it using Zorn's lemma then you need to bring in sets at some point I suppose.</p>",
        "id": 166407193,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558651807
    },
    {
        "content": "<p>I'm just thinking about <code>linear_independent_sUnion_of_directed</code> in isolation at the moment</p>",
        "id": 166407211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558651839
    },
    {
        "content": "<p>In its current form, it looks like the lemma basically reflects the fact that linear independence can be checked on finite subsets</p>",
        "id": 166407215,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558651842
    },
    {
        "content": "<p>if you replace the sets with familes, then I think it's talking about a colimit cone in Type</p>",
        "id": 166407310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558651895
    },
    {
        "content": "<p>(Obviously this is bringing enough new tech to the statement that the original version will be wanted anyway, but I'm trying to find the \"natural generalization\")</p>",
        "id": 166407394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558651976
    },
    {
        "content": "<p>Not just in Type, but types equipped with a map to β (i.e. <code>over Type β</code>)</p>",
        "id": 166407425,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558652015
    },
    {
        "content": "<p>i.e. \"families in β\"</p>",
        "id": 166407442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558652040
    },
    {
        "content": "<p>So then I suppose it says that the families which consist of linearly independent elements are closed under directed colimits</p>",
        "id": 166407522,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558652088
    },
    {
        "content": "<blockquote>\n<p>Obviously this is bringing enough new tech to the statement that the original version will be wanted anyway, but I'm trying to find the \"natural generalization\"</p>\n</blockquote>\n<p>You mean I should leave the current version basically as is and then derive the family version from it? IMO that would be the easiest way to prove it.</p>",
        "id": 166431644,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1558685149
    },
    {
        "content": "<p>I mean you should in principle derive the union from the family version, but since the family version looks complicated just keep the set version and put the family version off until we need it</p>",
        "id": 166433645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558687267
    },
    {
        "content": "<p>ok</p>",
        "id": 166434116,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1558687804
    },
    {
        "content": "<p>I think I will have something that complies again soon. Then I'll show you what I've done so far.</p>",
        "id": 166434146,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1558687850
    },
    {
        "content": "<p>Maybe actually not so soon. Now I have run into issues with universe levels in<code>dimension.lean</code>.</p>",
        "id": 166643287,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1558968602
    },
    {
        "content": "<p>Yay! I finally have something that compiles again. The main change I made is to use families instead of sets for <code>is_basis</code>. The predicate <code>linear_independent</code> still has two arguments, one for families and one for sets, but I am working on eliminating the set argument now.</p>",
        "id": 167468540,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1559815839
    },
    {
        "content": "<p>I added a function</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">elim</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">⊕</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n</pre></div>\n\n\n<p>to <code>data/sum.lean</code>, as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  proposed.</p>\n<p>But where should the lemmas</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">elim_injective</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">elim_range</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">range</span> <span class=\"n\">f</span> <span class=\"err\">∪</span> <span class=\"n\">range</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>go? <code>injective</code> and <code>range</code> are not imported in <code>data/sum.lean</code>.</p>",
        "id": 168319773,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1560784993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span> I would put them close to <code>sum_range_succ</code> etc... somewhere in <code>data/finsupp</code> I guess.</p>",
        "id": 168324720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560788362
    },
    {
        "content": "<p>Not sure what you mean. <code>sum_range_succ</code> exists only in <code>algebra/big_operators</code> and its not about the <code>⊕</code> sum, but about <code>finset.sum</code>. And why should it go into <code>data/finsupp</code>?</p>",
        "id": 168378994,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1560845658
    },
    {
        "content": "<p><code>sum.elim_injective</code> should fit in <code>data.sum</code>, unless you are using some unusual theorem about <code>injective</code>. The definition is in core, in the <code>function</code> namespace</p>",
        "id": 168379282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845925
    },
    {
        "content": "<p><code>sum.elim_range</code> can go in <code>data.set.basic</code> or <code>data.set.lattice</code></p>",
        "id": 168379298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845946
    },
    {
        "content": "<p>Oh, right. I simply forgot to add <code>function.</code> before <code>injective</code> and then thought it was not available.</p>",
        "id": 168379779,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1560846388
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span> My bad... I actually meant <code>big_operators</code>, I think. Anyway, please follow Mario's advice.</p>",
        "id": 168381696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560848381
    },
    {
        "content": "<p>Ok, thanks.</p>",
        "id": 168381752,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1560848410
    },
    {
        "content": "<p>I have finally removed the set argument of <code>linear_independent</code> completely. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Please have a look at the pull request again. I think it is ready to be merged now.</p>",
        "id": 168535457,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1560970510
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/943\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/943\">https://github.com/leanprover-community/mathlib/pull/943</a></p>",
        "id": 168535492,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1560970534
    },
    {
        "content": "<p>You added 1000 lines of code!! Wow!</p>",
        "id": 168536643,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560971310
    },
    {
        "content": "<p>I hope it's not just because my proving style is more verbose than yours :-)</p>",
        "id": 168573096,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561016057
    },
    {
        "content": "<p>As we discussed earlier, <code>exists_linear_independent</code>, <code>linear_independent_sUnion_of_directed</code>, and related lemmas still use sets (coerced to a subtype and then used as the index type). I hope that you can accept the pull request anyway because every time I rebase on top of master, there are new commits using <code>lc</code> or <code>linear_independent</code> and I have to adapt them to my changes.</p>",
        "id": 168575144,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561018361
    },
    {
        "content": "<p>In an failed attempt to replace these lemmas based on sets by lemmas based on types, I added the section <code>sigma</code> on the bottom of <code>data/finsupp</code>. It is not used anywhere now, but I think it might be useful in the future. Let me know if you'd rather have it removed.</p>",
        "id": 168575298,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561018517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span>, I just started having a look at your branch. I'm glad <code>lc</code> doesn't exist anymore, good riddance. :-)</p>\n<p>I'm still bamboozled by the basic thing I've been missing all along with the <code>lc</code> library. Where is the definition:</p>\n<div class=\"codehilite\"><pre><span></span>def just_add_up_the_terms {α β} [discrete_field α] [add_comm_group β] [vector_space α β] (f : β →₀ α) : β := sorry\n</pre></div>",
        "id": 168659677,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099359
    },
    {
        "content": "<p>isn't that <code>lc.total</code> (now <code>finsupp.total</code>)?</p>",
        "id": 168659697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561099412
    },
    {
        "content": "<p>I guess you mean <code>finsupp.total</code>?</p>",
        "id": 168659698,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561099412
    },
    {
        "content": "<p>one second too slow :D</p>",
        "id": 168659709,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561099437
    },
    {
        "content": "<p>How do I use that? I tried</p>\n<div class=\"codehilite\"><pre><span></span>def just_add_up_the_terms {α β} [discrete_field α] [add_comm_group β] [vector_space α β] (f : β →₀ α) : β := (finsupp.total _ _ _ id).1 f\n</pre></div>",
        "id": 168659749,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099444
    },
    {
        "content": "<p>It's hard to beat Mario :D</p>",
        "id": 168659752,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561099451
    },
    {
        "content": "<p>(which already seems ... a bit long-winded ... for the basic operation)</p>",
        "id": 168659758,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099465
    },
    {
        "content": "<p>but get errors about not finding an <code>add_comm_group (β →₀ α)</code> instance</p>",
        "id": 168659774,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099489
    },
    {
        "content": "<p>So I guess I'm down to two questions: <br>\n1. why don't we generate that instance, and <br>\n2. can we have a shorter name for this, that doesn't require me to put in the <code>_ _ _ id</code>?</p>",
        "id": 168659872,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099578
    },
    {
        "content": "<p>I think Alex said something about how leaving those arguments out causes the tc inference to fail, which is why they are explicit in the first place</p>",
        "id": 168660000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561099774
    },
    {
        "content": "<p>But what if we specialise <code>v</code> to <code>id</code> first? Then the types are all determined by <code>f</code>, I think.</p>",
        "id": 168660054,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099811
    },
    {
        "content": "<p>they are, I'm not exactly sure about the order of operations here. I was surprised by this as well</p>",
        "id": 168660060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561099837
    },
    {
        "content": "<p>I think my main complaint is that I want a function with <code>v</code> already specialised to <code>id</code>, as this seems like most peoples' main use case.</p>",
        "id": 168660079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099870
    },
    {
        "content": "<p>More precisely, I think that it won't be able to use <code>f</code> for type inference because that happens after the coercion is inserted, and it can't insert the coercion until it knows the type of the finsupp.total application</p>",
        "id": 168660093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561099908
    },
    {
        "content": "<p>Ok, the instance not being generated is just about decidability:</p>\n<div class=\"codehilite\"><pre><span></span>import linear_algebra.finsupp\n\nlocal attribute [instance, priority 0] classical.prop_decidable\nnoncomputable theory\n\ndef finsupp.total&#39; {α β} [discrete_field α] [add_comm_group β] [vector_space α β] (f : β →₀ α) : β := (finsupp.total _ _ _ id).1 f\n</pre></div>",
        "id": 168660104,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099915
    },
    {
        "content": "<p>Which coercion?</p>",
        "id": 168660160,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099943
    },
    {
        "content": "<p>rah rah kill decidability arguments</p>",
        "id": 168660162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561099945
    },
    {
        "content": "<p>the coercion from -&gt;0 to -&gt;</p>",
        "id": 168660173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561099965
    },
    {
        "content": "<p>Sorry, I don't see where such a coercion is happening.</p>",
        "id": 168660189,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561099998
    },
    {
        "content": "<p>Or rather, the coercion from -&gt;l to -&gt;</p>",
        "id": 168660190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100000
    },
    {
        "content": "<p>ah</p>",
        "id": 168660192,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100005
    },
    {
        "content": "<p><code>finsupp.total</code> is a linear function</p>",
        "id": 168660193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100007
    },
    {
        "content": "<p>is the .1 supposed to be the coercion?</p>",
        "id": 168660200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100034
    },
    {
        "content": "<p>yes</p>",
        "id": 168660219,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100042
    },
    {
        "content": "<p>Maybe you could use <code>finsupp.sum</code> instead.</p>",
        "id": 168660324,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561100170
    },
    {
        "content": "<p>but then I still need to provide the silly binary function doing scalar multiplication</p>",
        "id": 168660345,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100225
    },
    {
        "content": "<p>isn't it just (\\bu)?</p>",
        "id": 168660351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100237
    },
    {
        "content": "<p>I just want to sum up a linear combination! :-)</p>",
        "id": 168660352,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100238
    },
    {
        "content": "<p>I think it's reasonable to have this as a dedicated function. I guess it used to be there with <code>lc.total</code></p>",
        "id": 168660363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100266
    },
    {
        "content": "<p>But I shouldn't need to say it at all, even if it is just (\\bu), I think.</p>",
        "id": 168660364,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100272
    },
    {
        "content": "<p>should it be linear?</p>",
        "id": 168660410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100292
    },
    {
        "content": "<p>actually I guess the function can be defined in more generality than \"linear\" can be</p>",
        "id": 168660428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100345
    },
    {
        "content": "<p>Ugh, what is the deal with <code>fin_supp.zip_with</code>? It has explicitly <code>decidable_eq</code> arguments for the types \\a and \\b, but then summons mid-proof a classical instance of decidability for \\b\\1.</p>",
        "id": 168660591,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100574
    },
    {
        "content": "<p>Surely it should be all or none</p>",
        "id": 168660602,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100608
    },
    {
        "content": "<p>(Sorry, Alex, I am not complaining to you about these things --- I suspect they predate your helpful refactor. :-)</p>",
        "id": 168660656,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100649
    },
    {
        "content": "<p>I want to kill all decidability args in finsupp, polynomial and mv_polynomial</p>",
        "id": 168660764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100829
    },
    {
        "content": "<p>I am very much in favour. :-)</p>",
        "id": 168660767,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100839
    },
    {
        "content": "<p>Those files use classical everywhere already.</p>",
        "id": 168660773,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100860
    },
    {
        "content": "<p>we are fooling ourselves to think these are actually computation-friendly</p>",
        "id": 168660777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100872
    },
    {
        "content": "<blockquote>\n<p>I want to kill all decidability args in finsupp, polynomial and mv_polynomial</p>\n</blockquote>\n<p>Does that also kill computation?</p>",
        "id": 168660778,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561100873
    },
    {
        "content": "<p>I think it was already dead.</p>",
        "id": 168660817,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100884
    },
    {
        "content": "<p>if you actually want to compute with polynomials finsupp is a <em>terrible</em> representation</p>",
        "id": 168660825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100901
    },
    {
        "content": "<p>/me is sad there is no parrot emoji.</p>",
        "id": 168660830,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> which list is the best list computationally?</p>",
        "id": 168660842,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561100937
    },
    {
        "content": "<p>For polynomial, a list or array of coefficients</p>",
        "id": 168660855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I was positively surprised by the following reasonable fast proof in an otherwise very slow file:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">witt_add_zero</span> <span class=\"o\">:</span> <span class=\"n\">witt_add</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">dec_trivial</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">witt_mul_zero</span> <span class=\"o\">:</span> <span class=\"n\">witt_mul</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">dec_trivial</span>\n</pre></div>",
        "id": 168660857,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561100959
    },
    {
        "content": "<p>So, how shall we go about removing decidability arguments here? In Alex's PR? Separately?</p>",
        "id": 168660863,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561100973
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is <code>list</code> better or is <code>array</code> better?</p>",
        "id": 168660866,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561100975
    },
    {
        "content": "<p>separately</p>",
        "id": 168660869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100979
    },
    {
        "content": "<p>we've made alex wait long enough, I think this is ready for merge</p>",
        "id": 168660878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561100997
    },
    {
        "content": "<p>If we go classical, you have to prove those statements by hand. But maybe that's a small offer to make.</p>",
        "id": 168660905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561101002
    },
    {
        "content": "<p>array is more efficient in the VM</p>",
        "id": 168660927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561101011
    },
    {
        "content": "<blockquote>\n<p>we've made alex wait long enough, I think this is ready for merge</p>\n</blockquote>\n<p>I haven't had a chance to look at it, but I trust your judgement.</p>",
        "id": 168660938,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561101021
    },
    {
        "content": "<p>Go for it!</p>",
        "id": 168660943,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561101029
    },
    {
        "content": "<p>you have to prove those statements by simp</p>",
        "id": 168660944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561101029
    },
    {
        "content": "<p>how is a function represented in VM?</p>",
        "id": 168660971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561101082
    },
    {
        "content": "<p>an <code>array</code> is represented as an array in the VM, don't let the signature fool you</p>",
        "id": 168660984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561101103
    },
    {
        "content": "<p>a function is a closure</p>",
        "id": 168660987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561101115
    },
    {
        "content": "<p>You are going to hate me for making this suggestion, but I notice that you are using the idiom <code>linear_independent α (λ x, x : s → β)</code> a lot. Maybe we should give this a name <code>linear_independent_set α s</code>, just to make the statements a bit nicer.</p>",
        "id": 168661442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561101779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> but you still need some decidability if you use arrays to make polynomials right</p>",
        "id": 168662317,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561103056
    },
    {
        "content": "<p>yes, but that's a problem for the computational interpretation only</p>",
        "id": 168662330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103082
    },
    {
        "content": "<p>it doesn't affect the definition or use of <code>polynomial</code></p>",
        "id": 168662338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103096
    },
    {
        "content": "<p>you need decidability of zero already if you want to add two polynomials together</p>",
        "id": 168662419,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561103165
    },
    {
        "content": "<p>not if you don't trim zeros</p>",
        "id": 168662428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103181
    },
    {
        "content": "<p>I thought quotients are bad for computation</p>",
        "id": 168662436,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561103195
    },
    {
        "content": "<p>depends on what you want to do</p>",
        "id": 168662448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103208
    },
    {
        "content": "<p>I am actually not proposing a computational implementation at all. I just want to remove decidability args from finsupp without changing the definition</p>",
        "id": 168662469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103247
    },
    {
        "content": "<p>(0x+1)^100 is very inefficient whereas 1^100 is very efficient right</p>",
        "id": 168662471,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561103249
    },
    {
        "content": "<p>I think that we should revisit computational polynomials if and when we ever care to compute with them</p>",
        "id": 168662548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103319
    },
    {
        "content": "<p>Generally there are a lot of factors that go into efficient implementations; dropping the <code>noncomputable</code> is only the beginning</p>",
        "id": 168662570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103361
    },
    {
        "content": "<p>and without an application it's likely to be mis-optimized</p>",
        "id": 168662579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103384
    },
    {
        "content": "<p>Compare this with computational real numbers vs <code>real</code> which is \"computable\" but basically useless</p>",
        "id": 168662639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561103452
    },
    {
        "content": "<blockquote>\n<p>and without an application it's likely to be mis-optimized</p>\n</blockquote>\n<p>This is just the tip of the iceberg. I had some very illuminating conversations with William Stein about this a few years ago, regarding implementation of linear algebra. I did some computations of modular forms in Sage a long time ago, and they were fast. I did some more, several years later, and they were much slower. Amongst the algorithms which go into all of this are basic linear algebra algorithms. I asked William what was going on, and he said that what happens in practice is that people observe that the linear algebra algorithms run slowly for the use case they have in mind, so they rip them out and implement \"better\" ones (e.g. perhaps from a newer paper) which run much better in their use case, but then they don't notice that there are other use cases which have degraded. There is no silver bullet for optimisation.</p>",
        "id": 168666153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561107826
    },
    {
        "content": "<p>Some recent discussions here as well as some talks at Big Proof 2 have led me to the following position regarding doing computer algebra in Lean. The foundational layer of definitions (for things like polynomials, or localizations of rings) should be the mathematical ones, fully general (e.g. without finiteness assumptions), and not necessarily efficient to compute with or even computable at all. On top of that one can then build representations which are good for computation in specific scenarios (e.g. polynomials in finitely many variables, or localization of a Euclidean domain), and use the underlying mathematical concepts to specify the semantics of the representations and algorithms and prove correctness of the algorithms.</p>",
        "id": 168669469,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561111897
    },
    {
        "content": "<p>AFAIK all currently existing computer algebra systems have only this second layer--the foundational layer and the relationship between them exists only in the form of documentation and pen-and-paper proofs.</p>",
        "id": 168669624,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561112054
    },
    {
        "content": "<p>If I understand correctly, this would also make it more conceptual that one can swap out different computational overlays depending on application.</p>",
        "id": 168670703,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561113463
    },
    {
        "content": "<p>So, when I naively make everything in <code>data/finsupp.lean</code> classical (and hence noncomputable), various <code>rfl</code> proofs in <code>data/polynomial.lean</code> break.</p>",
        "id": 168728106,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561163420
    },
    {
        "content": "<p>I guess this is to be expected. Is there an easy work-around? Or do I have to think?</p>",
        "id": 168728110,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561163442
    },
    {
        "content": "<p>it should be by unfold [relevant defs]</p>",
        "id": 168733233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561172805
    },
    {
        "content": "<p>Hmm --- I don't seem to be very good at this:</p>\n<div class=\"codehilite\"><pre><span></span>@[simp] lemma coeff_one_zero (n : ℕ) : coeff (1 : polynomial α) 0 = 1 :=\nbegin\n  dsimp [coeff, has_one.one, single], split_ifs, refl, refl,\nend\n</pre></div>\n\n\n<p>Claims to finish the proof, which is already pretty strange: surely the second branch of the split_ifs should give the goal <code>0 = monoid.one α</code>. But then Lean says <code>invalid simplification lemma</code>.</p>",
        "id": 168734016,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561174445
    },
    {
        "content": "<p>Same outcome with the slightly more reasonable</p>\n<div class=\"codehilite\"><pre><span></span>@[simp] lemma coeff_one_zero (n : ℕ) : coeff (1 : polynomial α) 0 = 1 :=\nbegin\n  dsimp [coeff, has_one.one, single], rw if_pos, refl\nend\n</pre></div>",
        "id": 168734091,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561174661
    },
    {
        "content": "<p>the definition of <code>1</code> is <code>single 1 0</code> I assume? Why not something involving coeff_single?</p>",
        "id": 168734145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561174754
    },
    {
        "content": "<p>We haven't proved <code>coeff_single</code> yet, and it's another <code>rfl</code> lemma that is going to need redoing!</p>",
        "id": 168734255,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561174979
    },
    {
        "content": "<p>you should prove that instead</p>",
        "id": 168734265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561175002
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>lemma coeff_single : coeff (single n a) m = if n = m then a else 0 :=\nbegin\n  dsimp [single], refl\nend\n</pre></div>\n\n\n<p>gives</p>\n<div class=\"codehilite\"><pre><span></span>invalid apply tactic, failed to unify\n  ite (n = m) a 0 = ite (n = m) a 0\nwith\n  ?m_2 = ?m_2\n</pre></div>\n\n\n<p>which is presumably about the decidability instances ...</p>",
        "id": 168734307,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561175069
    },
    {
        "content": "<p>use <code>congr</code> instead</p>",
        "id": 168734324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561175148
    },
    {
        "content": "<p>Ok, that fixes <code>coeff_single</code>.</p>",
        "id": 168734443,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561175286
    },
    {
        "content": "<p>But I still have <code>invalid simplification lemma</code> for</p>\n<div class=\"codehilite\"><pre><span></span>@[simp] lemma coeff_one_zero (n : ℕ) : coeff (1 : polynomial α) 0 = 1 :=\nbegin\n  dsimp [has_one.one], rw [coeff_single, if_pos], refl\nend\n</pre></div>",
        "id": 168734450,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561175340
    },
    {
        "content": "<p>did you try <code>:= coeff_single _ _</code>?</p>",
        "id": 168736568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561180043
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[simp] lemma coeff_one_zero (n : ℕ) : coeff (1 : polynomial α) 0 = 1 := coeff_single\n</pre></div>\n\n\n<p>is indeed accepted as a proof, but it still complains <code>invalid simplication lemma</code>. (Sorry!)</p>",
        "id": 168736837,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561180644
    },
    {
        "content": "<p>drop the n</p>",
        "id": 168737065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561181144
    },
    {
        "content": "<p>I made a bunch of changes. Just tidying. Is everyone happy for this to be merged? I'd like to use it.</p>",
        "id": 168856346,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1561388094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 168856373,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1561388105
    },
    {
        "content": "<p>Sorry that I haven't invested more time in reviewing this PR. I was on holiday, and now I have a bunch of other stuff that I need to catch up with.</p>",
        "id": 168857607,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561388787
    },
    {
        "content": "<p>So I hope others can jump in this week.</p>",
        "id": 168857634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561388808
    },
    {
        "content": "<p>Wow, Chris transformed my 20 line proof into a one-liner :D</p>",
        "id": 168864184,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1561393954
    },
    {
        "content": "<p>This is now merged!</p>",
        "id": 169557822,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562153091
    },
    {
        "content": "<p>Big thanks to <span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span> for all the effort!</p>",
        "id": 169558044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562153354
    },
    {
        "content": "<p>Thanks to <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> as well for shortening my proofs!</p>",
        "id": 169558463,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1562153828
    }
]
[
    {
        "content": "<p>This PR is an attempt on defining open immersions of presheafed spaces, via</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">open_immersion</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">PresheafedSpace</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">base_open</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f.base</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">iso_restrict</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y.restrict</span> <span class=\"n\">base_open</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fac</span> <span class=\"o\">:</span> <span class=\"n\">iso_restrict.hom</span> <span class=\"bp\">≫</span> <span class=\"n\">Y.of_restrict</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The main problem is that, I feel like I'm sometimes working against Lean to get the things defined/proved.<br>\nAlmost everything in this PR is basically proving that every <code>eq_to_hom</code> commutes with some natural transformation.<br>\nUsually the solution is to not consider equalities of functors, but this is unavoidable here since to state isomorphisms of presheafed spaces we need equalities of morphisms, which are actually equalities of natural transformations of functors. </p>\n<p>The current solution is to manually define simp lemmas so that the <code>eq_to_hom</code>s are actually  some sort of <code>X.presheaf.map (eq_to_hom _)</code>, so that the naturality of the morphism can be applied,  and we may use <code>congr, apply subsingleton.elim</code> when these terms remain.<br>\nBut the down side is that I have to unfold a lot of things to make this work, and Lean is quite unhappy about it: a lot of the proofs are on the brink of timing out (though I managed to squeeze them in). </p>\n<p>Is there a better approach on this obstacle?</p>",
        "id": 259771185,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1635660431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> For achieving this, I also reverted one or two changes made in <a href=\"https://github.com/leanprover-community/mathlib/issues/9972\">#9972</a>.</p>",
        "id": 259771192,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1635660478
    },
    {
        "content": "<p>I haven't looked at your code, but I also came to the conclusion once that it's better to use <code>F.map (eq_to_hom _)</code> rather than <code>eq_to_hom _</code> in some situations. As you said, this allows you to apply <code>F.map_comp</code> and naturality of a morphism directly. In any case, you can switch from one to the other by <code>eq_to_hom_map</code>.</p>",
        "id": 259778537,
        "sender_full_name": "Justus Springer",
        "timestamp": 1635671692
    },
    {
        "content": "<p>Now my month of teaching hell is over I hope to find the time to look at all the work which has been going on in algebraic geometry. I must say it scares me a little that stuff which is so mathematically simple-looking can cause such problems, however I remember seeing this sort of problem before even before categories were involved.</p>",
        "id": 259788125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635687213
    },
    {
        "content": "<p>I think the suggested definition is too complicated. <code>open_immersion f</code> should be <code>Prop</code> valued for one.</p>",
        "id": 259796127,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635697868
    },
    {
        "content": "<p>I'll be busy for a few hours, but I can sketch some ideas for this later</p>",
        "id": 259796193,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635697956
    },
    {
        "content": "<p>I have thought of wrapping it in some <code>class is_open_immersion</code> that merely asserts that such an isomorphism exists (a bit like <code>iso</code> and <code>is_iso</code>) when I was working on it and was also bothered with the fact that this is not a <code>Prop</code>. <br>\nHowever, I assumed that I had to work with fixed isomorphisms nonetheless, so I put this aside.</p>\n<p>It would be great if there are some better ideas.</p>",
        "id": 259796559,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1635698426
    },
    {
        "content": "<p>I see that you changed the <code>ext</code> lemma in presheafed_space.lean (but not reverted to earlier version, so do you mean you reverted the proofs), anything else? It makes some proofs slightly longer, so why not introduce another ext lemma and use it when appropriate? I’m not sure how much such an additional layer might slow things down. I sometimes also needed the <code>F.map</code> in my Gamma-Spec adjunction proofs, and my solution was to introduce <a href=\"https://github.com/leanprover-community/mathlib/pull/9802/files#diff-7b933491f18454c2fb8959ff924f83d5aa80ef616bbb58523cbc51302e981a8fR75\">a lemma</a>, similar to the lemma above it that already existed. In fact we probably need such a lemma for the case of a composition of continuous maps equals id as well. (By the way, my experience was that I never needed <code>subsingleton.elim</code> (<code>refl</code> would work), but <code>subsingleton.helim</code> was sometimes useful.)</p>\n<p>And why not define open immersion simply as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">open_immersion</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">PresheafedSpace</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">base_open</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f.base</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">iso_restrict</span> <span class=\"o\">:</span> <span class=\"n\">X.presheaf</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">Y.restrict</span> <span class=\"n\">base_open</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">presheaf</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>? I think both are equivalent, and you would have one less condition and less isomorphisms to worry about, and it seems to me many proofs would be rendered unnecessary with this def.</p>\n<p>I have also been getting timeouts to establish the adjunction, and I just need to fix the timeouts in the final right triangle identity to establish it.</p>",
        "id": 259803024,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635707358
    },
    {
        "content": "<p>It seems that the universal property of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.PresheafedSpace.restrict\">docs#algebraic_geometry.PresheafedSpace.restrict</a> is missing. Here is approximately what I would suggest as a definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.presheafed_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">algebraic_geometry</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">algebraic_geometry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">PresheafedSpace.restrict_lift</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">PresheafedSpace</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Top</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y.carrier</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hι</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X.carrier</span> <span class=\"bp\">⟶</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"n\">ι</span> <span class=\"bp\">=</span> <span class=\"n\">f.base</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y.restrict</span> <span class=\"n\">hι</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f.c.app</span> <span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"n\">X.presheaf.map</span> <span class=\"o\">(</span><span class=\"n\">eq_to_hom</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">topological_space.opens.map</span><span class=\"o\">],</span>\n      <span class=\"n\">congr'</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n      <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">set.preimage_comp</span><span class=\"o\">,</span>\n      <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">set.preimage_image_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hι.1.2</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">),</span>\n    <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">intros</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">quiver.hom.unop_op</span><span class=\"o\">,</span> <span class=\"n\">Top.presheaf.pushforward_obj_map</span><span class=\"o\">,</span>\n        <span class=\"n\">functor.op_map</span><span class=\"o\">,</span> <span class=\"n\">nat_trans.naturality_assoc</span><span class=\"o\">,</span>\n        <span class=\"n\">category.assoc</span><span class=\"o\">],</span>\n      <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">topological_space.opens.map</span><span class=\"o\">],</span>\n      <span class=\"n\">simp_rw</span> <span class=\"bp\">←</span> <span class=\"n\">X.presheaf.map_comp</span><span class=\"o\">,</span>\n      <span class=\"n\">congr'</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_open_immersion</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">PresheafedSpace</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f.base</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"n\">is_iso</span> <span class=\"o\">(</span><span class=\"n\">PresheafedSpace.restrict_lift</span> <span class=\"n\">f.base</span> <span class=\"n\">base</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">algebraic_geometry</span>\n</code></pre></div>",
        "id": 259803751,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635708387
    },
    {
        "content": "<p>Or if you don't want to use <code>restrict</code> and prove the isomorphism after the fact, you can use something approximately like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">is_open_immersion'</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">PresheafedSpace</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f.base</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">topological_space.opens</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">is_iso</span> <span class=\"o\">(</span><span class=\"n\">f.c.app</span> <span class=\"o\">(</span><span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">base.is_open_map.functor.obj</span> <span class=\"n\">U</span><span class=\"o\">))))</span>\n</code></pre></div>",
        "id": 259804099,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635708890
    },
    {
        "content": "<p>I probably only changed two simp lemmas. In my experience, I never needed  nor wanted <code>eq_of_hom</code>s of <code>C</code>, but at most an <code>eq_to_hom</code> of open sets. The problem is that you can get from <code>U = V</code> to <code>F(U) = F(V)</code> quite easily, but not the other way. It is especially the case where there are more than one structured spaces around. In my case, the old lemmas almost always lead people (me) into wrong paths. <br>\nCorrect me if I'm wrong, but I suppose we should come to a general philosophy about how to tackle such a problem, document it well, make the simp lemmas adhere to this principle, and to ultimately guide other people who uses this API into the path that (we believe) is the best.</p>\n<p>The former principle is to never use equalities of functors, and I have to say this is indeed the better way out most of the times. But this clearly does not solve the problem here (as what you have noticed and fixed), and we should come to a better solution.</p>",
        "id": 259804563,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1635709462
    },
    {
        "content": "<p>Those definitions of <code>open_immersion</code>s all seem a lot better than what I have here. I'll try them out tomorrow and see which works out best.</p>",
        "id": 259804595,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1635709558
    },
    {
        "content": "<p>Hmm I think my defintion of <code>open_immersion</code> doesn't work as it doesn't mention <code>f.c</code>. I like <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> 's last definition.</p>",
        "id": 259804934,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635710007
    },
    {
        "content": "<p>I agree <code>open_immersion</code> should be a Prop, as the isomorphisms are dictated by <code>f.c</code> and there should be no choice/data.<br>\nThere would be a more succinct way to state the iso condition after the adjunction between pushforward and restriction functors on presheaves is defined, namely that the presheaf hom from the restriction of <code>Y.presheaf</code> to <code>X.presheaf</code> that is <code>hom_equiv</code> to <code>f.c</code> is an isomorphism, but I’m not sure it will be easier to work with.</p>",
        "id": 259806990,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635712456
    },
    {
        "content": "<p>I would encourage <code>is_open_immersion</code> for the name and yes I think it should be a Prop-valued predicate on morphisms</p>",
        "id": 259813024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635721136
    },
    {
        "content": "<p>should we change <code>open_embedding</code> to <code>is_open_embedding</code> then?</p>",
        "id": 259822981,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635736860
    },
    {
        "content": "<p>Changing names in the topology library should be coordinated with the rest of the community. There are many people who will want to take part in a vote on that topic.</p>",
        "id": 259830736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635747719
    },
    {
        "content": "<p>I think it's a very good observation that talking about equality of morphisms of schemes (or LRS/RS) involves an equality of functors. And this is \"evil\". I don't know whether we should redesign things here, or whether there is some technical justification that we can get away with a suitable <code>ext</code>-lemma in this subpart of the library.</p>",
        "id": 259830871,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635747883
    },
    {
        "content": "<p>Thanks for all your work in this direction <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> !</p>",
        "id": 259830894,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635747911
    },
    {
        "content": "<p>The category of schemes is a concrete category so surely an equality of morphisms of schemes should just be an equality of functions!</p>",
        "id": 259837534,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635755210
    },
    {
        "content": "<p>But it's not concrete in the obvious way.</p>",
        "id": 259837615,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635755280
    },
    {
        "content": "<p>No?  :-(</p>",
        "id": 259837663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635755306
    },
    {
        "content": "<p>Oh you're right</p>",
        "id": 259837689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635755330
    },
    {
        "content": "<p>A morphism of schemes isn't determined by the function between the underlying topological spaces.</p>",
        "id": 259837705,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635755345
    },
    {
        "content": "<p>Right</p>",
        "id": 259837809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635755420
    },
    {
        "content": "<p>At least schemes form an ordinary 1-category, so equality of morphisms there isn't inherently evil.</p>\n<p>I think the underlying question here is this: suppose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> are topological spaces, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f, g : X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> are continuous maps, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is a presheaf on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. If we know <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f = g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>, how do we relate the push-forwards <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f^*P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>g</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">g^*P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8831359999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>? (Another way of thinking about it would be to say: \"the category of presheaves associated with a space\" determines a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">o</mi><mi mathvariant=\"sans-serif\">p</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Top} \\to \\mathsf{Cat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Top</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">Cat</span></span></span></span></span>, but the codomain here is naturally a 2-category, so what does it mean for this to be functorial? In particular you want to spell out what happens to two equal maps when you apply the functor)</p>\n<p>The current version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.PresheafedSpace.ext\">docs#algebraic_geometry.PresheafedSpace.ext</a> answers this question by saying \"well, obviously <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mi>P</mi><mo>=</mo><msup><mi>g</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f^*P = g^*P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8831359999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> so they are isomorphic by <code>eq_to_hom</code>\". In this PR, we unfold the definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f^*P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>: it is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>∘</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P \\circ F(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.opens.map\">docs#topological_space.opens.map</a>, and this gives another way of going from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f^*P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>g</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">g^*P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8831359999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>.</p>\n<p>Now (as boring as it sounds) I wonder if it wouldn't be a good idea to declare a definition for \"the isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>∗</mo></msup><mi>P</mi><mo>≅</mo><msup><mi>g</mi><mo>∗</mo></msup><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f^* P \\cong g^* P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8831359999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> induced by an equality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f = g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>\"? I don't know how it should be defined, but my guess is that you might even want to unfold the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.opens.map\">docs#topological_space.opens.map</a>. Then you can prove whatever lemmas are needed about how this isomorphism behaves, and try to consistently use it instead of <code>eq_to_hom</code>s to state <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.PresheafedSpace.ext\">docs#algebraic_geometry.PresheafedSpace.ext</a> etc.</p>",
        "id": 259851338,
        "sender_full_name": "David Wärn",
        "timestamp": 1635764989
    },
    {
        "content": "<p>I'm under the impression, if we had a good api for pseudofunctors, that all of these issues would disappear, and we would never need to talk about equality of functors. I suspect that by first defining the pseudofunctor from <code>Top</code> to <code>Cat</code> sending <code>X</code> to <code>opens X</code> and using that to construct the pseudofunctor sending <code>X</code> to <code>Presheaf X</code> would have better definitional properties than just using <code>eq_to_iso</code>to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><mi>P</mi><mo>≅</mo><msub><mi>g</mi><mo>∗</mo></msub><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f_* P \\cong g_* P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> directly given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f = g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> (this is essentially what <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> suggested).</p>",
        "id": 259862991,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635773234
    },
    {
        "content": "<p>If we can't solve these issues without using equality of functors for the Zariski topology, then we will not have much fun if/when we go on to discuss etale sheaves.</p>",
        "id": 259863597,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635773552
    },
    {
        "content": "<p>A completely different approach would I guess be to also define predicates on sheaves saying \"I am the pushforward\" or \"I am the pullback\". In reality I should think one wants more than the isomorphism, one wants \"I satisfy the universal property\" because this determines the object up to unique isomorphism.</p>",
        "id": 259863683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635773600
    },
    {
        "content": "<p>Statements like \"f^*(g^*F)=(fg)^*F\" are not really meaningful despite the fact that the literature is full of them</p>",
        "id": 259863854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635773689
    },
    {
        "content": "<p>But the statement that they're isomorphic is too weak</p>",
        "id": 259863896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635773717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310069.20Open.20immersions.20of.20presheafed.20spaces/near/259863896\">said</a>:</p>\n<blockquote>\n<p>But the statement that they're isomorphic is too weak</p>\n</blockquote>\n<p>Right -- you need the various coherences between these isomorphisms as well, which you can either encode as a universal property, or as part of the axioms of a pseudofunctor. I think these two approaches are not so different after all ;)</p>",
        "id": 259864020,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635773767
    },
    {
        "content": "<p>Actually we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.pushforward_eq\">docs#Top.presheaf.pushforward_eq</a> I think that should be used instead of <code>eq_to_hom</code> in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.PresheafedSpace.ext\">docs#algebraic_geometry.PresheafedSpace.ext</a></p>",
        "id": 259866078,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1635774953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310069.20Open.20immersions.20of.20presheafed.20spaces/near/259862991\">said</a>:</p>\n<blockquote>\n<p>I'm under the impression, if we had a good api for pseudofunctors, that all of these issues would disappear, and we would never need to talk about equality of functors. I suspect that by first defining the pseudofunctor from <code>Top</code> to <code>Cat</code> sending <code>X</code> to <code>opens X</code> and using that to construct the pseudofunctor sending <code>X</code> to <code>Presheaf X</code> would have better definitional properties than just using <code>eq_to_iso</code>to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><mi>P</mi><mo>≅</mo><msub><mi>g</mi><mo>∗</mo></msub><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">f_* P \\cong g_* P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> directly given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f = g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> (this is essentially what <span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> suggested).</p>\n</blockquote>\n<p>People talked about 2-functors <a href=\"https://leanprover-community.github.io/mathlib_docs/topology/category/Top/opens.html\">in the documentation</a> but in the case of <code>pushforward</code> and <code>restrict</code> (pullback along open maps) these are actual functors, not just pseudofunctors, just not usefully so according to the docs, but maybe we just haven't built the right APIs. For these functors, it probably suffices to default the <code>simp</code>/<code>ext</code> lemmas to versions with <code>F.map</code> as <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> is suggesting; definitions can be left intact probably. (I recently changed the definitions in <a href=\"https://github.com/leanprover-community/mathlib/issues/9972\">#9972</a> (approved by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> very quickly probably because they simplify proofs) and the original definitions indeed used isomorphisms, but I think simpler definition that can't be unfolded makes things faster; correct me if I'm wrong.) For general pullback and descent you probably need the pseudofunctor / fibered category formalism (flat morphisms locally of finite presentation are actually open, but the need of tensor product in defining pullback would make pullback along composition not equal to composition of pullbacks).</p>\n<p>We need the explicit <code>F.map</code> for <code>eq_to_hom</code> because <code>eq_to_hom</code> isn't exactly the identity <code>𝟙</code>, and can't be \"lifted\" to <code>F.map (eq_to_hom _)</code> one level down without providing a proof that the types are equal already on that level, which can be annoying, unlike <code>𝟙</code> which can be trivially lifted with <code>rw ← F.map_id</code> to <code>F.map (𝟙 _)</code>. Lean uses the lower level equality to prove the higher level equality, but forget about the low level one afterwards (because equality is Prop?), but it seems it won't forget when it's typechecking defeq's. With isomorphisms (which is data) such tracking is made explicit, but is maybe more than what we'll ever need.</p>",
        "id": 259898771,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635790116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310069.20Open.20immersions.20of.20presheafed.20spaces/near/259837615\">said</a>:</p>\n<blockquote>\n<p>But it's not concrete in the obvious way.</p>\n</blockquote>\n<p>Here is an <a href=\"https://mathoverflow.net/a/160768/3332\">alleged simple concretization</a> of <code>Scheme</code> but I believe it's wrong as the map between the disjoint unions of stalks is multi-valued: one f(x) could correspond to multiple x's , possibly none. If one uses the disjoint union of sections over open sets then I believe it does work, even for <code>PresheafedSpace</code> where morphisms aren't determined on stalks. However disjoint unions are just sigma types and this won't get rid of dependent typing issues and you'd still need to use == to state an equality of sections (functors are also elements of sigma types and you may use <code>eq_to_hom</code> or <code>==</code> to state their equality on maps as in <code>functor.ext</code> and <code>functor.hext</code>, and I'm not sure if this has to do with the philosophy that functor equality is evil).</p>",
        "id": 259907370,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1635794027
    },
    {
        "content": "<p>Just to be clear -- I spoke without thinking when I claimed the category was complete -- I thought that the underlying top space would do the job but of course it doesn't eg Frobenius map</p>",
        "id": 259927345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635804121
    },
    {
        "content": "<p>Or any pair of field-homs between two fields, for that matter.</p>",
        "id": 259957753,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635834800
    }
]
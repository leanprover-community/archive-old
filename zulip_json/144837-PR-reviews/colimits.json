[
    {
        "content": "<p>I'd like to make some plans for progress on colimits.</p>",
        "id": 162285074,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554157780
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> has a PR open that provides direct limits for rings and fields, but that is disconnected from the limits library. That PR builds direct limits by first taking coproducts, and then quotienting. As was pointed out in the comments there, this construction could be generalised further --- in fact all colimits in <code>CommRing</code> can be constructed this way, but some of the nice properties only hold for directed/filtered colimits. There is also an alternative construction, which takes the disjoint union (i.e. the colimit of the underlying types), which only works for filtered colimits. This construction hasn't been implemented by anyone, to my knowledge.</p>",
        "id": 162285079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554157786
    },
    {
        "content": "<p>I would eventually like to see both constructions, using the API of the limits library, all written in a way that is easy and obvious to generalise from one algebraic category to the next (and possibly eventually with tactics that do most of the busy work).</p>",
        "id": 162285086,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554157797
    },
    {
        "content": "<p>(e.g. someday someone is going to want filtered colimits of semifoobiquandles, and in the long run it shouldn't be difficult)</p>",
        "id": 162285177,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554157844
    },
    {
        "content": "<p>That all said, I'm not opposed to getting Kenny's work merged sooner rather than later, as long as we have a roadmap to eventually achieve the nicer setup.</p>",
        "id": 162285187,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554157851
    },
    {
        "content": "<p>In Kenny's PR, he wrote </p>\n<blockquote>\n<p>It is constructed as a quotient of the free module (for the module case) or quotient of<br>\nthe free commutative ring (for the ring case) instead of a quotient of the disjoint union<br>\nso as to make the operations (addition etc.) \"computable\".</p>\n</blockquote>\n<p>Can someone explain to me what this means?</p>",
        "id": 162285320,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554157939
    },
    {
        "content": "<p>So... what steps are on the roadmap? To hook Kenny's existing constructions up to the limits API, I think we would aspire to</p>\n<ul>\n<li>define <code>has_coproduct</code> and <code>has_coequalizer</code> (variants of these exist in branches; we should talk to <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> about which to go with),</li>\n<li>start providing instances --- I'd suggest actually doing the warm-up case of <code>SemiGrp</code>first, to get the structure right, and then go back through doing the relevant bits of the algebraic hierarchy</li>\n<li>provide <code>has_coequalizers CommRing</code>, which is straightforward.</li>\n<li>provide <code>has_coproducts CommRing</code> by plugging in the already known universal properties of the free constructions.</li>\n<li>state directly the construction of the colimit in CommRing as a quotient of a free product,</li>\n<li>prove <code>has_coproducts + has_coequalizers -&gt; has_coproducts</code> in generality (this exists in branches, I think, but needs updating).</li>\n<li>prove that in <code>CommRing</code> this is definitionally equal to the construction given above</li>\n<li>finish providing the <code>has_coproducts CommRing</code> instance, checking along the way that we can make it agree with the abstract construction</li>\n</ul>",
        "id": 162285936,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158491
    },
    {
        "content": "<p>The other half of the roadmap is to provide the disjoint union construction.</p>",
        "id": 162285951,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158508
    },
    {
        "content": "<p>One way of defining the direct limit of rings is to take the disjoint union of the rings (which is not a ring) and then quotient out by the smallest equivalence relation which relates <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span></span></span></span> for all morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mrel\">:</span><span class=\"mord mathit\">A</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> in the direct limit diagram and all <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a\\in A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">∈</span><span class=\"mord mathit\">A</span></span></span></span>. To add two elements <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> in the quotient one first rings rings <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> that they're in, one then randomly chooses a ring further down the structure, say <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A_1\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A_2\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, pushes <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> down to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and then adds there. This involves choices. </p>\n<p>Another way, which I think you have to use when doing general colimits, is to take the disjoint union of the rings, form the polynomial ring with coefficents in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> over this set, and then quotient out by the ideal generated by elements of the form <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f(a)-b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mbin\">−</span><span class=\"mord mathit\">b</span></span></span></span> regarded as degree 1 elements in this big ring. Now one can define addition on the quotient without making choices...perhaps?</p>",
        "id": 162286034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554158551
    },
    {
        "content": "<p>Here the work to be done is of a different nature. The main work is to take the colimit of underlying types, and equip that with the relevant algebraic structure.</p>",
        "id": 162286039,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158555
    },
    {
        "content": "<p>(as Kevin said in the meantime)</p>",
        "id": 162286077,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158606
    },
    {
        "content": "<p>Now, I think one can make this really smooth.</p>",
        "id": 162286085,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158620
    },
    {
        "content": "<p>There are two steps. We need to construct operations on the colimit type (e.g. multiplication, defined as Kevin just said), and we need to check axioms.</p>",
        "id": 162286151,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158665
    },
    {
        "content": "<p>The work of checking that the operations are well-defined, and that the axioms are satisfied, is of a quite similar nature.</p>",
        "id": 162286206,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158724
    },
    {
        "content": "<p>In the disjoint union case one still has to choose a random point further down the line.</p>",
        "id": 162286217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554158744
    },
    {
        "content": "<p>We have two elements in the disjoint union, and we are trying to show that they are equal in the quotient.</p>",
        "id": 162286219,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158749
    },
    {
        "content": "<p>As an example, let's consider checking associativity of multiplication.</p>",
        "id": 162286279,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158772
    },
    {
        "content": "<p>In the quotient ring case one just uses the usual <code>quotient.lift</code> or whatever it is.</p>",
        "id": 162286283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554158782
    },
    {
        "content": "<p>Isn't Kenny's issue more with defining the structures than checking axioms?</p>",
        "id": 162286291,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554158812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I was starting to talk here about the disjoint union construction, which Kenny wasn't doing.</p>",
        "id": 162286311,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158848
    },
    {
        "content": "<p>So what I think he must not like is defining addition on the quotient.</p>",
        "id": 162286323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554158868
    },
    {
        "content": "<p>So yes, he wasn't dealing with the issue I'm talking about now.</p>",
        "id": 162286326,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158876
    },
    {
        "content": "<p>OK</p>",
        "id": 162286339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554158882
    },
    {
        "content": "<p>Say we have a = (x, a_x), b = (y, b_y), z = (z, b_z). (The first element of the pair is the point in the colimit, then the second element is an element of the ring at that point.)</p>",
        "id": 162286406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158939
    },
    {
        "content": "<p>We're trying to prove <code>(a*b)*c</code> = <code>a*(b*c)</code>.</p>",
        "id": 162286427,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158959
    },
    {
        "content": "<p>But the chosen representatives of these multiplications sit in different pieces of the disjoint union.</p>",
        "id": 162286443,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554158983
    },
    {
        "content": "<p>So certainly we need to go to _some_ higher point in the colimit. But it's not enough to just go to some point higher than those two points.</p>",
        "id": 162286508,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159014
    },
    {
        "content": "<p>say <code>(a*b)</code> was sitting over some point <code>p</code>, <code>b*c</code> was sitting over <code>q</code>, and <code>(a*b)*c)</code> sits over <code>r</code>, while <code>a*(b*c)</code> sits over <code>s</code>.</p>",
        "id": 162286570,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159096
    },
    {
        "content": "<p>We now have this big messy diagram, with points <code>x y z p q r s</code>, and we want to use the fact that there is a cocone for that diagram, and pass to that point before trying to prove <code>(a*b)*c = a*(b*c)</code>.</p>",
        "id": 162286631,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159147
    },
    {
        "content": "<p>So what do we do? We identify that cocone point, called it <code>w</code>, and maps from each of <code>x y z p q r s</code> to <code>w</code>. We then say that we're going to proving the equality <code>(a*b)*c = a*(b*c)</code> by doing it over the point <code>w</code>, and then by repeating using the axiom that <code>w</code> really is a cone point, and that all the morphisms in sight are ring homomorphisms, we see this reduces to the equation <code>(f(a_x)*g(b_y))*h(c_z) = f(a_x)*(g(b_y)*h(c_z))</code>, where <code>f g h</code> are the morphisms from <code>x y z</code> respectively to <code>w</code>.</p>",
        "id": 162286791,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159336
    },
    {
        "content": "<p>This goal we can finally discharge directly with <code>mul_assoc</code>.</p>",
        "id": 162286796,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159348
    },
    {
        "content": "<p>This whole argument should in the first instance be written in a way so that it's completely clear that it was generic --- it barely mattered that we were proving multiplicative associativity rather than distributivity, the argument is always the same.</p>",
        "id": 162286977,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159492
    },
    {
        "content": "<p>Later, we can write some tactics (like <code>pi_instance</code>) that do this work for us.</p>",
        "id": 162286988,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159516
    },
    {
        "content": "<p>I think we may also want a tactic that \"builds diagrams\" for us, out of a collection of objects and morphisms in the local hypotheses. This would enable us to write a tactic that says \"check that the goal is an equality in a colimit type; check the local environment for objects and morphisms in the indexing category, and build the cocone over all of them; now attempt to prove the equality by passing to the cocone point\".</p>",
        "id": 162287113,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>, I'd love to hear what you guys think of this plan!</p>",
        "id": 162287282,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554159802
    },
    {
        "content": "<p>I don't really understand what can be done with tactics but it sounds like a tactic can be used to generate this proof</p>",
        "id": 162305041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554183161
    },
    {
        "content": "<p>I think this is really cool. There is just one uncomfortable feeling that is nagging at me: So far we haven't really been able to apply the category lib in other parts of the library. I don't know exactly why that is. But I'd first like to make sure that it is not because of some DTT/Lean issue that we aren't aware of. If it is one of those things that mathematicians handle transparently and aren't even aware of, but Lean gets hung up about, then we are doomed...</p>",
        "id": 162306290,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554185086
    },
    {
        "content": "<p>If it is only because <code>category_theory/</code> is considered \"high-level\" and we don't want those imports in \"lower-level\" parts of the library, then we have some sort of social problem.</p>",
        "id": 162306313,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554185149
    },
    {
        "content": "<p>In practice I have an actual bunch of rings in the sense that they're types <code>X i</code> with <code>[ring X i]</code> and I want to take their actual direct limit and prove it's a ring and have access to the universal property, all by magic.</p>",
        "id": 162307031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554186213
    },
    {
        "content": "<p>I think the simplest/Lean-iest way to do these in general is: First, construct the colimit of an arbitrary diagram of (say) rings, as the quotient of an inductive type by an inductive proposition. Then check that when the input diagram is filtered, the object we built also has the following properties:</p>\n<ul>\n<li>Every element of the underlying inductive type is in the image of the map from one of the rings of the diagram.</li>\n<li>Every pair of elements of the original rings which become equal in the colimit (after forming the quotient) already become equal at some point in the diagram.</li>\n</ul>\n<p>Both of these are easy inductions: the point is that each constructor of the inductive type and the inductive proposition is built from only finitely many smaller terms, so we can pass to a point in the diagram where the statement we are proving holds for all of them.</p>\n<p>Once we check these two properties, then we can conclude by a general lemma that the colimit is isomorphic to the \"disjoint union mod identifying elements with their images\" construction, or that the colimit is preserved by the forgetful functor to sets, or whatever exact statement of that we want.</p>",
        "id": 162351925,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554223219
    },
    {
        "content": "<p>And can we provide easy glue with unbundled (say) rings? So that if you have <code>X : I → Type</code> and <code>[\\for i, ring (X i)]</code>, you can easily build a diagram in <code>Ring</code>?</p>",
        "id": 162352063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554223363
    },
    {
        "content": "<p>Because otherwise we have a nice and abstract machine, but it becomes a pain to use in the rest of mathlib</p>",
        "id": 162352089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554223386
    },
    {
        "content": "<p>I think you just do it?</p>",
        "id": 162352094,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554223392
    },
    {
        "content": "<p>It shouldn't take more than half a line... and we want this for all bundled categories, I guess.</p>",
        "id": 162352176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554223455
    },
    {
        "content": "<p>And we want it for indexed families, but also for single objects, and maybe other thingies?</p>",
        "id": 162352205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554223496
    },
    {
        "content": "<p><code>mk_ob</code> makes a type with a ring instance into an object of <code>Ring</code></p>",
        "id": 162352625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554223806
    },
    {
        "content": "<p>for a functor, obviously you'd have to provide all the fields: action on objects, action on morphisms, identity and composition laws; so it would be a little longer</p>",
        "id": 162352660,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554223844
    },
    {
        "content": "<p>Ideally, you would be in a situation where you already have a functor</p>",
        "id": 162352678,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554223859
    },
    {
        "content": "<p>Yeah, but in the rest of mathlib you aren't in that ideal situation.</p>",
        "id": 162352734,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554223905
    },
    {
        "content": "<p>So <code>mk_ob</code> is good. We'll need similar things for the categories that are quasi-bundled. (Like <code>CommRing</code>, which doesn't use the machinery, even though it is an obvious candidate.)</p>",
        "id": 162352835,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554223950
    },
    {
        "content": "<p>Yes, I suggest making <code>CommRing.mk_ob</code>, etc., which also helps Lean understand what category it's supposed to produce an object of--I'm not  confident <code>mk_ob</code> would work in most cases without a type ascription</p>",
        "id": 162353032,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554224100
    },
    {
        "content": "<p>Can we replace <code>bundled</code> and <code>concrete_category</code> with some <code>meta</code> stuff that rolls all these categories for us?</p>",
        "id": 162353820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554224635
    },
    {
        "content": "<p>Why?</p>",
        "id": 162353898,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554224667
    },
    {
        "content": "<p>It could also create a bunch of forgetful functors corresponding to classes that extend each other.</p>",
        "id": 162353909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554224672
    },
    {
        "content": "<p>Because then we will have <code>Ring.mk_ob</code> and <code>Group.mk_ob</code> etc...</p>",
        "id": 162353929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554224688
    },
    {
        "content": "<p>You can generate better code if you use some <code>meta</code> stuff.</p>",
        "id": 162353960,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554224707
    },
    {
        "content": "<p>Or am I dreaming?</p>",
        "id": 162353987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554224729
    },
    {
        "content": "<p>Sadly something like this doesn't work either</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">instances</span><span class=\"bp\">.</span><span class=\"n\">rings</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">instances</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">categorify</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">X</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">unify</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">mk_Ring</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">unification_hint</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pattern</span> <span class=\"o\">:=</span> <span class=\"n\">categorify</span> <span class=\"n\">R</span> <span class=\"err\">≟</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">constraints</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">X</span> <span class=\"err\">≟</span> <span class=\"n\">mk_ob</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 162355170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554225526
    },
    {
        "content": "<p>I think that is trying to solve a problem we don't have yet. It's not hard to write such things by hand for now.</p>",
        "id": 162355187,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554225543
    },
    {
        "content": "<p>Yeah, that's true.</p>",
        "id": 162355643,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554225846
    },
    {
        "content": "<p>This sounds great, thanks <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>. So --- where do we start, and in particular what happens to <a href=\"https://github.com/leanprover-community/mathlib/issues/754\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/754\">#754</a>?</p>",
        "id": 162387207,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554251684
    },
    {
        "content": "<p>It seems like the very first step is seeing if we can repackage Kenny's work into providing <code>has_colimits CommRing</code>.</p>",
        "id": 162387230,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554251718
    },
    {
        "content": "<p>It would have to be generalised, because we want it to construct arbitrary colimits, not just direct limits.</p>",
        "id": 162387295,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554251808
    },
    {
        "content": "<p>It would be nice if his construction of the colimit more obviously did so \"as the quotient of an inductive type by an inductive proposition\".</p>",
        "id": 162387298,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554251813
    },
    {
        "content": "<p>Okay, I just followed <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>'s suggestions for implementing colimits (just the first half of the recipe, nothing about filtered colimits and disjoint unions yet), and did the special case of monoids.</p>",
        "id": 162422774,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293316
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/colimits/src/algebra/colimits.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/colimits/src/algebra/colimits.lean\">https://github.com/leanprover-community/mathlib/blob/colimits/src/algebra/colimits.lean</a></p>",
        "id": 162422928,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293437
    },
    {
        "content": "<p>I was very carefully to never ever think about monoids, however.</p>",
        "id": 162422937,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293448
    },
    {
        "content": "<p>I claim that you could pipe <code>#print monoid</code> into a python script that would produce that file.</p>",
        "id": 162422983,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293474
    },
    {
        "content": "<p>And if you piped <code>#print comm_ring</code> into the same script you'd end up with <code>has_colimits CommRing</code>.</p>",
        "id": 162423014,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293510
    },
    {
        "content": "<p>(Well, ... maybe that's slightly optimistic. But pretty close!)</p>",
        "id": 162423072,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293530
    },
    {
        "content": "<p>The proofs could be compressed a lot with some automation. (And that each such compression would make the python script for other algebraic structures easier to implement.)</p>",
        "id": 162423102,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293582
    },
    {
        "content": "<p>It was all very pleasantly \"downhill\". You just do the obvious thing at every step.</p>",
        "id": 162423139,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293622
    },
    {
        "content": "<p>On the other hand, the construction you get is absolutely awful. It looks nothing like a free monoid.</p>",
        "id": 162423411,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554293845
    },
    {
        "content": "<p>This is cool.</p>",
        "id": 162423851,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554294222
    },
    {
        "content": "<p>Is the next step to build the python script?</p>",
        "id": 162423855,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554294236
    },
    {
        "content": "<p>Or are you going for tactics directly?</p>",
        "id": 162423903,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554294244
    },
    {
        "content": "<p>I expressed a related sentiment/dream yesterday:</p>\n<blockquote>\n<p>Can we replace <code>bundled</code> and <code>concrete_category</code> with some <code>meta</code> stuff that rolls all these categories for us?</p>\n</blockquote>\n<p><a href=\"#narrow/stream/144837-PR-reviews/topic/colimits/near/162353820\" title=\"#narrow/stream/144837-PR-reviews/topic/colimits/near/162353820\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/colimits/near/162353820</a></p>",
        "id": 162423932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554294299
    },
    {
        "content": "<p>I think the next step if to wait until Reid has a chance to say if this is what he had in mind! If it is, then some tactics to cleanup, then attempting to do another example by hand, then ... asking Keeley if he knows a trick for defining new inductive types in commands. :-)</p>",
        "id": 162424633,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554294857
    },
    {
        "content": "<p>I once wrote python code which produced Lean code: <a href=\"https://xenaproject.wordpress.com/2018/07/26/617-is-prime/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2018/07/26/617-is-prime/\">https://xenaproject.wordpress.com/2018/07/26/617-is-prime/</a></p>",
        "id": 162427833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554297304
    },
    {
        "content": "<p>It might be better to add constructors making <code>relation</code> an equivalence relation and using <code>quotient</code> instead of <code>quot</code>, particularly for the part about filtered colimits. (To handle the infinitary case correctly you actually need to do this, though I guess it doesn't matter in the finitary case.)</p>",
        "id": 162438452,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554304883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> could you briefly explain why? I was a bit worried about this, but it seemed to just be adding more cases to the proofs to use <code>quotient</code>.</p>",
        "id": 162460581,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554319481
    },
    {
        "content": "<p>Suppose you have an infinitary operation f and you want to prove x1 ~ y1, x2 ~ y2, ... implies f(x1, x2, ...) ~ f(y1, y2, ...). You cannot conclude this from the fact that f preserves ~ in each argument separately.</p>",
        "id": 162462264,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554320744
    },
    {
        "content": "<p>To put it another way, say you form <code>relation'</code> by adding refl, symm, trans constructors to <code>relation</code>. Then in the infinitary case, <code>relation'</code> is bigger than the equivalence relation generated by <code>relation</code>. <code>relation'</code> is the correct one to use. If you quotient by the equivalence relation generated by <code>relation</code>, then you will not be able to define the operations on the quotient.</p>",
        "id": 162462518,
        "sender_full_name": "Reid Barton",
        "timestamp": 1554320910
    },
    {
        "content": "<p>Thanks. I will try this out.</p>",
        "id": 162468131,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554324435
    },
    {
        "content": "<p>How do you feel about the objection that \"this colimit is ugly\", because it's not the nice one for monoids that a human would produce (words)?</p>",
        "id": 162468214,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554324484
    },
    {
        "content": "<p>Of course you can use the colimit API, so in some sense you have everything.</p>",
        "id": 162468225,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554324498
    },
    {
        "content": "<p>But I worry that implementing this generic approach widely is just going to leave us with the desire to build concrete models in many cases anyway.</p>",
        "id": 162468241,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554324519
    },
    {
        "content": "<p>Does having the \"ugly\" colimit make it easier to build these concrete models? (Perhaps after setting up the \"filtered colimit as disjoint union\" machinery?)</p>",
        "id": 162468309,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554324602
    },
    {
        "content": "<p>Kenny defined <code>powers x</code> for x in a ring, as {x^n : n in nat}. This was in the middle of a bunch of monoidy stuff in his localisation work. I asked him recently why he didn't just define it to be the monoid generated by x. He said that this was a pain to work with (the monoid generated by x is some inductive prop-- if a and b are in then a*b is in etc) and that in practice it was much easier to just use the concrete definition rather than having to prove it and rewrite the proof all the time.</p>",
        "id": 162468407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554324661
    },
    {
        "content": "<p>My suspicion is that you can have your cake and eat it too. I don't know what \"rewrite the proof all the time\" could mean --- you prove the monoid generated by a singleton is <code>powers x</code> once, in the file about free monoids. But you should make sure to express the universal properties of <code>powers x</code> using a uniform API for universal properties (i.e. adjunctions, limits, etc), rather than writing them as stray lemmas.</p>",
        "id": 162469438,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554325340
    },
    {
        "content": "<p>He wanted to write &lt;2,rfl&gt; and &lt;1,rfl&gt; and &lt;0,rfl&gt; in term mode rather than having to rewrite the proof that he wrote once, lots of times.</p>",
        "id": 162471003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554326529
    },
    {
        "content": "<p>Sorry, not sure what that means. Perhaps we can get him to show the example sometime.</p>",
        "id": 162471639,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554327050
    },
    {
        "content": "<p>He can write <code>&lt;2,rfl&gt;</code> instead of <code>proof_of_equivalence.2 &lt;2,rfl&gt;</code></p>",
        "id": 162471891,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1554327268
    },
    {
        "content": "<p>He constantly wanted to prove things like \"1 in powers x\" or \"x^2 in powers x\" and he could prove them very easily from his definition, the proof that x^2 is in powers x is &lt;2,rfl&gt;. Sometimes he wanted to prove that x^(m+n) was in powers x and his proof was &lt;m+n,rfl&gt;. He found it easier to work with. With powers x = {y : exists n, x^ n = y} he would have to rewrite every time</p>",
        "id": 162471906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554327286
    },
    {
        "content": "<p>What Chris said</p>",
        "id": 162471914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554327294
    },
    {
        "content": "<p>he decided that the benefits outweighed the disadvantages on this particular occasion.</p>",
        "id": 162471947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554327327
    },
    {
        "content": "<p>It's a subtle business. It's all about your use case, probably.</p>",
        "id": 162471968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554327346
    },
    {
        "content": "<p>I don't think it depends on your use case. You still have all the constructors and recursors for <code>powers</code> as you have with the closure definition, as lemmas. But lemma won't give you anonymous constructor notation unfortunately, it needs to be an actual constructor for that.</p>",
        "id": 162472392,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1554327687
    }
]
[
    {
        "content": "<p>I opened the PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17717\">#17717</a> defining <code>finsupp.map_range_sub</code> (and <code>finsupp.map_range_neg</code>), but I quickly noticed several things. First of all it doesn't type-check in my use case, where I want to do e.g. <code>finsupp.map_range_sub (map_sub polynomial.derivative)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.defs</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">finsupp.map_range_add</span> <span class=\"o\">(</span><span class=\"n\">map_add</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- this works</span>\n<span class=\"k\">#check</span> <span class=\"n\">finsupp.map_range_sub</span> <span class=\"o\">(</span><span class=\"n\">map_sub</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- this doesn't type-check</span>\n</code></pre></div>\n<p>I thought the issue was that <code>finsupp.map_range_add</code> and <code>map_add</code> both require <code>has_add</code> for domain and codomain types so they unify nicely, whereas <code>map_sub</code> requires <code>add_group</code> for the domain type and <code>subtraction_monoid</code> for  the codomain type. Initially I defined <code>finsupp.map_range_sub</code> requiring <code>add_group</code> for the domain and the codomain types but it returned an error, but I realised that the <code>has_sub</code> instance for <code>finsupp</code> can be generalised for domain and codomain types that are just <code>sub_neg_zero_monoid</code>, so I did the same for <code>finsupp.map_range_sub</code>. This also does not type-check, because <code>map_sub</code> requires typeclasses that are stronger than this and I can't supply a proof inside <code>finsupp.map_range_sub</code> just using <code>map_sub</code>. This suggests to me that <code>finsupp.map_range_sub</code> should be defined with <code>add_group</code>, then having to define a <code>map_sub''</code> whose codomain type is <code>add_group</code> manually, but I always had the impression that proofs should be defined in the greatest generality whenever possible. Is this not the right approach?</p>\n<p>There is also the possibly-unrelated issue that <code>map_sub</code> is defined for functions that are <code>add_monoid_hom_class</code> rather than just a plain function <code>G -&gt; H</code>, so I have to \"cast\" the proof manually? For <code>polynomial derivative</code> I also noticed something weird:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.derivative</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">polynomial.derivative.map_add</span> <span class=\"c1\">-- ok</span>\n<span class=\"k\">#check</span> <span class=\"n\">polynomial.derivative.map_sub</span> <span class=\"c1\">-- !?</span>\n<span class=\"k\">#check</span> <span class=\"n\">map_sub</span> <span class=\"n\">polynomial.derivative</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>\n<p>It seems to complain that <code>linear_map.map_sub</code> takes in a linear map but <code>polynomial.derivative</code> is semilinear, but <code>linear_map.map_add</code> works just fine? If I put <code>polynomial.derivative.map_sub</code> into <code>finsupp.map_range_sub</code> it does not return an error but instead just thinks really hard before timing out in my machine. Perhaps this is just a Lean 3 unification bug that is completely unrelated to the above but I thought it wouldn't hurt to ask.</p>",
        "id": 312341978,
        "sender_full_name": "David Ang",
        "timestamp": 1669468371
    },
    {
        "content": "<p>I don't think <code>finsupp.map_range_add (map_add sorry)</code> is a meaningful thing to want to do. Usually Lean would do typeclass inference to help elaborate, but lean can't do that if you pass in <code>sorry</code>. Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with no <code>sorry</code>s and no metavariables (like your <code>#check</code> has)?</p>",
        "id": 312346544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669470364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2317717.20.28need.20help.29.20finsupp.2Emap_range_sub/near/312346544\">said</a>:</p>\n<blockquote>\n<p>I don't think <code>finsupp.map_range_add (map_add sorry)</code> is a meaningful thing to want to do. Usually Lean would do typeclass inference to help elaborate, but lean can't do that if you pass in <code>sorry</code>. Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with no <code>sorry</code>s and no metavariables (like your <code>#check</code> has)?</p>\n</blockquote>\n<p>Sure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.derivative</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">sub_neg_zero_monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">sub_neg_zero_monoid</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">has_sub'</span> <span class=\"o\">:</span> <span class=\"n\">has_sub</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">finsupp.zip_with</span> <span class=\"n\">has_sub.sub</span> <span class=\"o\">(</span><span class=\"n\">sub_zero</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_apply</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">-</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g₁</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">g₂</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">finsupp.map_range_sub</span> <span class=\"o\">[</span><span class=\"n\">add_monoid_hom_class</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finsupp.map_range</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"bp\">-</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finsupp.map_range</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">v₁</span> <span class=\"bp\">-</span> <span class=\"n\">finsupp.map_range</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">finsupp.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hf'</span><span class=\"o\">,</span> <span class=\"n\">sub_apply</span><span class=\"o\">,</span> <span class=\"n\">finsupp.map_range_apply</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">polynomial</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">inner_derivative</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">finsupp.map_range.linear_map</span> <span class=\"n\">derivative</span> <span class=\"n\">f.to_finsupp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">inner_derivative</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inner_derivative</span><span class=\"o\">,</span> <span class=\"n\">finsupp.map_range.linear_map_apply</span><span class=\"o\">,</span> <span class=\"n\">to_finsupp_add</span><span class=\"o\">,</span> <span class=\"n\">to_finsupp_sub</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.map_range_add</span> <span class=\"n\">derivative.map_add</span><span class=\"o\">],</span> <span class=\"c1\">-- works</span>\n  <span class=\"c1\">-- rw [finsupp.map_range_add derivative.map_sub], -- does not work</span>\n  <span class=\"c1\">-- rw [finsupp.map_range_add $ map_sub derivative], -- does not work</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 312354027,
        "sender_full_name": "David Ang",
        "timestamp": 1669472503
    },
    {
        "content": "<p>The <code>has_sub'</code>, <code>sub_apply</code>, and <code>finsupp.map_range_sub</code> are already in the PR, I just copied them over for convenience</p>",
        "id": 312354094,
        "sender_full_name": "David Ang",
        "timestamp": 1669472532
    },
    {
        "content": "<p><code>rw [finsupp.map_range_sub _ (C X : F[X][X]).to_finsupp]</code> makes progress</p>",
        "id": 312375560,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669482739
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 312375740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669482839
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.map_range_sub</span> <span class=\"o\">(</span><span class=\"n\">map_sub</span> <span class=\"o\">(</span><span class=\"n\">derivative</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))],</span>\n</code></pre></div>\n<p>works too</p>",
        "id": 312376978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669483509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2317717.20.28need.20help.29.20finsupp.2Emap_range_sub/near/312376978\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.map_range_sub</span> <span class=\"o\">(</span><span class=\"n\">map_sub</span> <span class=\"o\">(</span><span class=\"n\">derivative</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))],</span>\n</code></pre></div>\n<p>works too</p>\n</blockquote>\n<p>Sure thanks, but what should I do with the PR? Keep it as it is or revert it back to <code>add_group</code>? And do we want<code>add_monoid_hom_class</code> rather than just a plain function?</p>",
        "id": 312378652,
        "sender_full_name": "David Ang",
        "timestamp": 1669484520
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 312379141,
        "sender_full_name": "David Ang",
        "timestamp": 1669484814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> I think we should probably add versions that use <code>add_monoid_hom_class</code> (assuming <code>add_group</code>), which can be deduced from the current, more general versions, or we could remove the general versions and prove the <code>add_monoid_hom_class</code> versions directly.</p>\n<p>If your purpose is to define <code>inner_derivative</code> as a <code>linear_map</code>, however, this is how I would do it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.derivative</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.algebra_map</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">polynomial</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">polynomial</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_finsupp_linear_equiv</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">F</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"n\">to_finsupp_smul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">to_finsupp_iso</span> <span class=\"n\">F</span> <span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\"> a bit strange that it becomes computable if you write out all fields -/</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">noncomputable</span> <span class=\"c\">/-</span><span class=\"cm\"> not necessary for inner_derivative but nice to have -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_finsupp_alg_equiv</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">F</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">to_finsupp_iso</span> <span class=\"n\">F</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">inner_derivative</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_finsupp_linear_equiv</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">symm.to_linear_map.comp</span> <span class=\"bp\">$</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.map_range.linear_map</span> <span class=\"n\">derivative</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">to_finsupp_linear_equiv</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">to_linear_map</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">polynomial</span>\n</code></pre></div>",
        "id": 312390302,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669492086
    },
    {
        "content": "<p>The current PR looks fine as is to me</p>",
        "id": 312402005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669501805
    },
    {
        "content": "<p>I think your intended application just has too many implicit types, and it's reasonable to require you to clarify what you're talking about. This type of thing comes up a lot, and is the reason behind many seemingly obvious <code>(_ : T)</code> annotations in mathlib.</p>",
        "id": 312402163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669501900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2317717.20.28need.20help.29.20finsupp.2Emap_range_sub/near/312390302\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> I think we should probably add versions that use <code>add_monoid_hom_class</code> (assuming <code>add_group</code>), which can be deduced from the current, more general versions, or we could remove the general versions and prove the <code>add_monoid_hom_class</code> versions directly.</p>\n<p>If your purpose is to define <code>inner_derivative</code> as a <code>linear_map</code>, however, this is how I would do it:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.derivative</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.algebra_map</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">polynomial</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">polynomial</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_finsupp_linear_equiv</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">F</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"n\">to_finsupp_smul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">to_finsupp_iso</span> <span class=\"n\">F</span> <span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\"> a bit strange that it becomes computable if you write out all fields -/</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">noncomputable</span> <span class=\"c\">/-</span><span class=\"cm\"> not necessary for inner_derivative but nice to have -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_finsupp_alg_equiv</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">F</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">to_finsupp_iso</span> <span class=\"n\">F</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">inner_derivative</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_finsupp_linear_equiv</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">symm.to_linear_map.comp</span> <span class=\"bp\">$</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.map_range.linear_map</span> <span class=\"n\">derivative</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">to_finsupp_linear_equiv</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">to_linear_map</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">polynomial</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I added the <code>add_monoid_hom_class</code> lemmas assuming <code>sub_neg_zero_monoid</code>. Do we actually want <code>inner_derivative</code> in <code>polynomial.derivative</code>? I thought it's a niche definition so defining it ad-hoc in my file should work</p>",
        "id": 312476326,
        "sender_full_name": "David Ang",
        "timestamp": 1669558866
    },
    {
        "content": "<p>I don't think we want <code>inner_derivative</code>, but I do think we want a version of <code>finsupp.map_domain.linear_map</code> that works on <code>polynomial</code></p>",
        "id": 312478933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669560204
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>, to_finsupp_alg_equiv already exists, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.to_finsupp_iso_alg\">docs#polynomial.to_finsupp_iso_alg</a></p>",
        "id": 312479087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669560279
    },
    {
        "content": "<p>Probably we should remove those <code>iso</code> names in favor of more standard naming</p>",
        "id": 312479105,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669560296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> There doesn't exist a version <code>F[X] ≃ₐ[R] add_monoid_algebra F ℕ</code> with <code>R ≠ F</code>, or does there? This is used to define inner_derivative because we don't have <code>F[X][X] ≃ₐ[F[X]] ...</code>, only <code>F[X][X] ≃ₐ[F]  ...</code>.</p>\n<p>I think for polynomials in two variables, working with F[X][X] is probably most convenient. For example it's easy to evaluate a polynomial <code>f(X,Y)</code> at <code>Y := p(X)</code>, and if you use <code>mv_polynomial</code> you have to use an indexing type <code>fin 2</code> or <code>bool</code>, and to evaluate you need to provide a function indexed by the type. </p>\n<p>In our use case we're considering S := K[X][X]/(f) with <code>f</code> a monic polynomial in the second variable, so S has a power_basis as a module over the PID K[X], so K[X][X] is the more natural way to set things up compared to mv_polynomial. We need to translate between the two to apply <a href=\"http://mv_polynomial.vanishing_ideal_zero_locus_eq_radical\">nullstellensatz</a> though. <code>inner_derivative</code> is used to state the <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/multivariate.20chain.20rule.20for.20polynomials/near/311515747\">chain rule</a>, though maybe we don't need linearity and could get away with the direct definition <code>p.sum (λ n r, C r.derivative * X ^ n)</code>. It's surely OK to confine <code>inner_derivative</code> to EllipticCurve-specific files, but I anticipate it will be useful in other circumstances.</p>",
        "id": 312509225,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669576613
    },
    {
        "content": "<p>We should probably generalize <code>to_finsupp_alg_iso</code> to have that form</p>",
        "id": 312509405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669576735
    },
    {
        "content": "<p>But you can get there today with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alg_equiv.restrict_scalars\">docs#alg_equiv.restrict_scalars</a></p>",
        "id": 312509422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669576750
    }
]
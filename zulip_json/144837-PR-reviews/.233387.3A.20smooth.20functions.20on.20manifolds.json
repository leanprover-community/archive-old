[
    {
        "content": "<p>I have updated the PR on smooth functions between manifolds (rather, I have closed the first one and opened a second one). I have a problem, since it is way too big (+1646, -85) but I would really love to have this before Friday for the manifold session. (Or maybe I could do the session from the branch if needed).</p>",
        "id": 203723716,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594651455
    },
    {
        "content": "<p>I will look at this PR bit by bit, but it will need a look-through by more experienced people, too.  First comment:  this new tactic, <code>mfld_set_eq_tac</code>, is wonderful!  A few suggestions for it:</p>",
        "id": 203735549,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594656920
    },
    {
        "content": "<p>(1) Should it be in <code>topology.local_homeomorph</code>rather than in <code>geometry.manifold.charted_space</code>?  There might already be proofs in that file that can be carried out by the tactic.</p>",
        "id": 203735595,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594656949
    },
    {
        "content": "<p>(2) Here is something it can do with one <code>rw</code> hint; would it make sense to add that lemma to <code>mfld_simps</code>? </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">image_inter_source_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">mfld_set_eq_tac</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203735801,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594657059
    },
    {
        "content": "<p>(3) Would it make sense to have a second tactic for proving that a set is a subset of another set?  I know zero about tactic-writing but just modified your tactic to do this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">mfld_set_subset_tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"k\">assume</span> <span class=\"n\">my_y</span> <span class=\"n\">h_my_y</span><span class=\"o\">,</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">h_my_y</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">h_my_y</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"o\">]</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">⊆</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">mfld_set_subset_tac</span>\n</code></pre></div>",
        "id": 203736022,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594657184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203736022\">said</a>:</p>\n<blockquote>\n<p>(3) Would it make sense to have a second tactic for proving that a set is a subset of another set? </p>\n</blockquote>\n<p>It's funny because at some point I wanted to do exactly this, with the exact code you posted. But then I thought it would be even better to have one single tactic, that would fire one or the other depending on the goal (inclusion or equality). I think this is essentially trivial for someone who knows a little bit of metaprogramming, which is not my case, so I uploaded the PR like that because it's already late for Friday. I'll have a look tonight.</p>",
        "id": 203738718,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594658675
    },
    {
        "content": "<p>Or maybe one of <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> 's newly-minted tacticians can do this :)</p>",
        "id": 203738793,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594658733
    },
    {
        "content": "<p>I didn't look at this PR, but my guess is you can do it with \"get the target expression\" and \"pattern match on expressions,\" both of which should be covered by video 5!</p>",
        "id": 203739064,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594658903
    },
    {
        "content": "<p>Here is the context: depending on the current goal, I want to run the code block</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">ext</span> <span class=\"n\">my_y</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">h_my_y</span><span class=\"o\">,</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">h_my_y</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">h_my_y</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>if the goal is an equality,</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"k\">assume</span> <span class=\"n\">my_y</span> <span class=\"n\">h_my_y</span><span class=\"o\">,</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">h_my_y</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">h_my_y</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span>\n</code></pre></div>\n\n\n<p>if the goal is an inclusion, and fail otherwise.</p>\n<p>If you have followed Rob's tutorial, this is yet another exercise for you :-)</p>",
        "id": 203739085,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594658922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203735801\">said</a>:</p>\n<blockquote>\n<p>(2) Here is something it can do with one <code>rw</code> hint; would it make sense to add that lemma to <code>mfld_simps</code>? </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">image_inter_source_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">mfld_set_eq_tac</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>The rule of thumb is: images are bad for automation (they involve an existential quantifier, so Lean would have to make some choice), while preimages are good. One could add a few lemmas to normalize images in <code>mfld_simps</code>, but this would be very brittle as the set should be in the precise form where the lemma would apply. For instance, if you add <code>local_homeomorph.image_inter_source_eq</code> to the simp set, then <code>mfld_set_eq_tac</code> succeeds to prove the statement you have given, but it fails to prove <code> e.symm.source ∩ e '' (e.source ∩ s) = e.symm.source ∩ e.symm ⁻¹' s</code>. So, an even better strategy is to never ever use direct images. I try to follow this rule in all the manifold files.</p>",
        "id": 203740383,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594659566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203739064\">said</a>:</p>\n<blockquote>\n<p>I didn't look at this PR, but my guess is you can do it with \"get the target expression\" and \"pattern match on expressions,\" both of which should be covered by video 5!</p>\n</blockquote>\n<p>Thanks Rob!</p>",
        "id": 203740674,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594659685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203735595\">said</a>:</p>\n<blockquote>\n<p>(1) Should it be in <code>topology.local_homeomorph</code>rather than in <code>geometry.manifold.charted_space</code>?  There might already be proofs in that file that can be carried out by the tactic.</p>\n</blockquote>\n<p>Good idea. I'll check.</p>",
        "id": 203740864,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594659765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203740383\">said</a>:</p>\n<blockquote>\n<p>The rule of thumb is: images are bad for automation (they involve an existential quantifier, so Lean would have to make some choice), while preimages are good. One could add a few lemmas to normalize images in <code>mfld_simps</code>, but this would be very brittle as the set should be in the precise form where the lemma would apply. For instance, if you add <code>local_homeomorph.image_inter_source_eq</code> to the simp set, then <code>mfld_set_eq_tac</code> succeeds to prove the statement you have given, but it fails to prove <code> e.symm.source ∩ e '' (e.source ∩ s) = e.symm.source ∩ e.symm ⁻¹' s</code>. So, an even better strategy is to never ever use direct images. I try to follow this rule in all the manifold files.</p>\n</blockquote>\n<p>Thanks, this is very instructive!</p>",
        "id": 203740972,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594659819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203740383\">said</a>:</p>\n<blockquote>\n<p>So, an even better strategy is to never ever use direct images. I try to follow this rule in all the manifold files.</p>\n</blockquote>\n<p>Maybe the linter could enforce this :).  It's overkill right now, when you are the author of 99% of the manifold material, but hopefully that will not always be the case.</p>",
        "id": 203741477,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594660053
    },
    {
        "content": "<p>I don't think I like the linter idea, everyone should be free to make his own mistakes :-)</p>",
        "id": 203742971,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594660785
    },
    {
        "content": "<p>More seriously, there are uses you cannot avoid, for instance if you want to say \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span></span></span></span> is closed\". What should be really avoided is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>⊂</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f(A) \\subset  B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span></p>",
        "id": 203744647,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594661552
    },
    {
        "content": "<p>since it is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊂</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\subset f^{-1}(B)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> which is much better behaved.</p>",
        "id": 203744694,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594661576
    },
    {
        "content": "<p>In manifolds, when you are composing with an equiv (or a local equiv), you can use equivalently <code>e '' A</code> or <code>e.symm ⁻¹' A</code>. The second one should essentially always be favored.</p>",
        "id": 203745597,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594662029
    },
    {
        "content": "<p>does this discussion imply that it's useful to add <code>image_subset_iff</code> to the simp set in this context? (that's this theorem, which already goes in the right direction)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">image_subset_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 203745860,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594662172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203740864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203735595\">said</a>:</p>\n<blockquote>\n<p>(1) Should it be in <code>topology.local_homeomorph</code>rather than in <code>geometry.manifold.charted_space</code>?  There might already be proofs in that file that can be carried out by the tactic.</p>\n</blockquote>\n<p>Good idea. I'll check.</p>\n</blockquote>\n<p>Or even in <code>data.equiv.local_equiv</code>, now that I think about it.</p>",
        "id": 203747748,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594663115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203745860\">said</a>:</p>\n<blockquote>\n<p>does this discussion imply that it's useful to add <code>image_subset_iff</code> to the simp set in this context?</p>\n</blockquote>\n<p>I would even add it globally to the simp set.</p>",
        "id": 203751071,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594664541
    },
    {
        "content": "<p>I went for</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- A very basic tactic to show that sets showing up in manifolds coincide or are included in</span>\n<span class=\"cm\">one another. -/</span>\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">mfld_set_tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"n\">do</span>\n  <span class=\"n\">goal</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">goal</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"err\">%%</span><span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">ext</span> <span class=\"n\">my_y</span><span class=\"o\">,</span>\n        <span class=\"n\">split</span><span class=\"bp\">;</span>\n        <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">h_my_y</span><span class=\"o\">,</span>\n          <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">h_my_y</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">h_my_y</span> <span class=\"o\">},</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"o\">}]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">e₁</span> <span class=\"err\">⊆</span> <span class=\"err\">%%</span><span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"k\">assume</span> <span class=\"n\">my_y</span> <span class=\"n\">h_my_y</span><span class=\"o\">,</span>\n        <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">h_my_y</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">h_my_y</span> <span class=\"o\">},</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">fail</span> <span class=\"s2\">&quot;goal should be an equality or an inclusion&quot;</span>\n  <span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Comments welcome if I did something stupid.</p>",
        "id": 203764228,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594670786
    },
    {
        "content": "<p>Pretty much exactly what I had in mind!</p>",
        "id": 203764981,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594671188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> , I have a couple of questions about your file abstracting properties of functions between charted-spaces-with-groupoids which are locally invariant.</p>",
        "id": 203767486,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594672515
    },
    {
        "content": "<p>(1) did you make this up yourself? :)  It's not in Kobayashi-Nomizu as far as I can tell.  But if there is a reference, it would be nice to include it.</p>",
        "id": 203767663,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594672591
    },
    {
        "content": "<p>(2) is there an obvious relationship of this material to other theories of locally invariant objects?  I am not really a sheaf-y person, but is it true that one can also characterize (smooth, continuous) maps between manifolds as being morphisms of ringed spaces for the (smooth, continuous) structure sheaf?</p>",
        "id": 203767946,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594672729
    },
    {
        "content": "<p>For ordinary manifold, yes. But it seems that you run into trouble for things like manifolds with corners.</p>",
        "id": 203768170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594672834
    },
    {
        "content": "<p>I can answer question 1 since I've asked Sébastien many similar questions in the past: he made it up.</p>",
        "id": 203768308,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594672909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203767663\">said</a>:</p>\n<blockquote>\n<p>(1) did you make this up yourself? :)  It's not in Kobayashi-Nomizu as far as I can tell.  But if there is a reference, it would be nice to include it.</p>\n</blockquote>\n<p>I just made up this precisely for my needs, so no reference, sorry. These things are in general so obvious and intuitive that books wouldn't bother giving the details.</p>",
        "id": 203768391,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594672929
    },
    {
        "content": "<p>For example, if my half-baked check is correct, it should be true that a <code>G</code>-invariant class of functions from <code>H</code> to a topological ring <code>R</code> (with <code>G</code> a closed-under-restriction groupoid for <code>H</code> and <code>R</code> equipped with the trivial groupoid) induces a sheaf on any space <code>M</code> modelled on <code>H</code>.</p>",
        "id": 203768439,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594672957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203767946\">said</a>:</p>\n<blockquote>\n<p>(2) is there an obvious relationship of this material to other theories of locally invariant objects?  I am not really a sheaf-y person, but is it true that one can also characterize (smooth, continuous) maps between manifolds as being morphisms of ringed spaces for the (smooth, continuous) structure sheaf?</p>\n</blockquote>\n<p>Sometimes the sheafy point of view works, sometimes it doesn't, depending on the context, if I  recall correctly. For instance, it works well for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span></span></span></span></span></span></span></span> functions, but not so well in finite smoothness. In general, I don't think it really buys anything interesting.</p>",
        "id": 203768564,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594673022
    },
    {
        "content": "<p>I am a differential geometer, so I am certainly not going to push the sheaf POV. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>  But I think at some point (not in this PR) it would be nice to have files characterizing equivalences between different POVs, eg this<br>\n<span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203768439\">said</a>:</p>\n<blockquote>\n<p>For example, if my half-baked check is correct, it should be true that a <code>G</code>-invariant class of functions from <code>H</code> to a topological ring <code>R</code> (with <code>G</code> a closed-under-restriction groupoid for <code>H</code> and <code>R</code> equipped with the trivial groupoid) induces a sheaf on any space <code>M</code> modelled on <code>H</code>.</p>\n</blockquote>\n<p>if it is true.</p>",
        "id": 203768896,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594673176
    },
    {
        "content": "<p>As stated it's false, but is has a true version.</p>",
        "id": 203769133,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594673294
    },
    {
        "content": "<p>And one more question, inspired by the sheaf POV:  probably there is a theory about the composition of a groupoid-invariant class of partial functions <code>H → H'</code> and another such class <code>H' → H''</code> ?</p>",
        "id": 203769226,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594673341
    },
    {
        "content": "<p>Yes, I'm pretty sure one can do this in the general version, and deduce like this that the composition of smooth functions is smooth.</p>",
        "id": 203769574,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594673519
    },
    {
        "content": "<p>I just pushed a new version of the PR with the generalized <code>mfld_set_tac</code> tactic, and more applications (starting in <code>local_equiv</code> and <code>local_homeomorph</code>). In <code>local_equiv</code>, the proof of</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">trans_source&#39;</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"err\">∩</span> <span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"k\">calc</span>\n    <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"err\">∩</span> <span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">))</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">preimage_inter</span><span class=\"o\">,</span> <span class=\"n\">inter_assoc</span><span class=\"o\">]</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">congr&#39;</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">inter_eq_self_of_subset_left</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source_subset_preimage_target</span> <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>becomes <code>by mfld_set_tac</code>.</p>",
        "id": 203769895,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594673664
    },
    {
        "content": "<p>Great!</p>",
        "id": 203769940,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594673690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203769226\">said</a>:</p>\n<blockquote>\n<p>And one more question, inspired by the sheaf POV:  probably there is a theory about the composition of a groupoid-invariant class of partial functions <code>H → H'</code> and another such class <code>H' → H''</code> ?</p>\n</blockquote>\n<p>One of the motivations for this would be that (I think) you can also go backwards:  given a definition of (say) smooth partial-maps from <code>H</code> to <code>ℝ</code> and from <code>H'</code> to <code>ℝ</code>, one can define smooth partial-maps from <code>H to H'</code> as those whose composition with smooth maps <code>H' → ℝ</code> is smooth as a map <code>H → ℝ</code>.  (I think.)</p>",
        "id": 203770529,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594673969
    },
    {
        "content": "<p>And this is probably the sheaf point of view.</p>",
        "id": 203770820,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594674099
    },
    {
        "content": "<p>Okay, <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> , I have another proposed tactic-writing exercise :). Maybe your <code>mfld_set_tac</code>, which currently solves goals of the form <code>s = t</code> and <code>s ⊆ t</code> (for sets), could also solve goals of the form <code>x ∈ s</code>?  With the caveat (again) that I know zero about tactic-writing, I think the algorithm could be a slight twist on what you <a href=\"#narrow/stream/144837-PR-reviews/topic/.233387.3A.20smooth.20functions.20on.20manifolds/near/203764228\">already wrote</a>:  <code>mfld_simps</code> all hypotheses of the form <code>x ∈ ...</code>, then <code>mfld_simps</code> the goal.  Here are two examples from <code>geometry.manifold.charted_space</code> that such a tactic could solve:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry</span><span class=\"bp\">.</span><span class=\"n\">manifold</span><span class=\"bp\">.</span><span class=\"n\">charted_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">local_homeomorph</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M&#39;&#39;</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M&#39;&#39;</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- adapted from structure_groupoid.compatible_of_mem_maximal_atlas</span>\n<span class=\"kn\">example</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">chart_at</span> <span class=\"n\">H</span> <span class=\"o\">((</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"err\">∩</span> <span class=\"err\">⇑</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- adapted from structomorph.trans</span>\n<span class=\"kn\">example</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">homeomorph</span> <span class=\"n\">M&#39;</span> <span class=\"n\">M&#39;&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M&#39;&#39;</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf₁</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_local_homeomorph</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M&#39;</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">((</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_local_homeomorph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n         <span class=\"n\">c&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">chart_at</span> <span class=\"n\">H</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hg₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">chart_at</span> <span class=\"n\">H</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">f₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">f₁</span><span class=\"o\">)</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203795549,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594697271
    },
    {
        "content": "<p>This is not an exercise that I am proposing for the current PR!  But I would be curious to know whether you think it is a good idea.</p>",
        "id": 203795600,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594697312
    },
    {
        "content": "<p>Here is a more subtle test case, by the way:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hef</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hex</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e&#39;</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">hef</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">hef</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> (note that the following is not strong enough):</span>\n<span class=\"cm\">begin</span>\n<span class=\"cm\">  simp only [*, -hx] with mfld_simps at hx,</span>\n<span class=\"cm\">  simp only [*] with mfld_simps,</span>\n<span class=\"cm\">end -/</span>\n</code></pre></div>",
        "id": 203796587,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594699018
    },
    {
        "content": "<p>I think we should see to what extent these new tactics can be integrated into <code>tidy</code>...</p>",
        "id": 203798630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594702221
    },
    {
        "content": "<p>Anything that \"fails fast\" when its not relevant (e.g., because it does some pattern matching on the goal) is a good candidate for inclusion in <code>tidy</code>. The other requirement is that it's \"conservative\" --- i.e. as long as \"breaking things into pieces\" doesn't count as a bad idea, it never goes down a bad track that a human would know to avoid.</p>",
        "id": 203800762,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594705598
    },
    {
        "content": "<p>There would be the possibility to merge the PR now, and review it properly afterwards. I promiss I would handle any reviewer's comment properly in this case. But it breaks all mathlib rules, so if you don't like it please don't hesitate to say it here and I will try to base Friday's talk on the branch instead!</p>",
        "id": 203880497,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594756986
    },
    {
        "content": "<p>The problem with basing it on a branch is that we're asking a lot from our beginner audience who might not know git and probably have enough trouble with lean already</p>",
        "id": 203885536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594759427
    },
    {
        "content": "<p>Oh wait, can you just point the toml to the right commit??</p>",
        "id": 203885677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594759489
    },
    {
        "content": "<p>So all they have to do is git pull and then leanproject get-m?</p>",
        "id": 203885731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594759522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> , I have been experimenting with the <code>local_invariant_prop</code> definition.  I decided to prove that being a local structomorphism was a groupoid-invariant property.  With my first definition of local structomorphism,</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_local_structomorph_within_at&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">eq_on</span> <span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n</code></pre></div>\n\n\n<p>I ran into difficulties showing that it satisfies the <code>congr</code> field of <code>local_invariant_prop</code>.  I then modified the definition to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_local_structomorph_within_at</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">interior</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">eq_on</span> <span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n</code></pre></div>\n\n\n<p>and everything worked.  Is this the desired behaviour of <code>local_invariant_prop</code>?  (I am not used to thinking about groupoid-invariant properties <em>relative to a subset</em>).</p>",
        "id": 203918169,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594790913
    },
    {
        "content": "<p>(I should have specified that I assumed the groupoid <code>G</code> was <code>closed_under_restriction</code>.)</p>",
        "id": 203919611,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594793071
    },
    {
        "content": "<p>I would change the definition to </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_local_structomorph_within_at&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">eq_on</span> <span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n</code></pre></div>\n\n\n<p>Indeed, a property within a set should only speak of the behavior of the function within this set.</p>",
        "id": 203923524,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594797994
    },
    {
        "content": "<p>Or maybe even</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_local_structomorph_within_at&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">eq_on</span> <span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n</code></pre></div>",
        "id": 203923593,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594798066
    },
    {
        "content": "<p>I ran into difficulties using your second definition.  (I didn't try the first one yet.). Suppose I want to prove the <code>left_invariance</code> property.  I am given <code>f, x, s</code>, and an element <code>e</code> of <code>G</code>, defined on a neighbourhood of <code>x</code>, which agrees on <code>s ∩ e.source</code> with <code>f</code>; also an element <code>e'</code> of <code>G</code>, whose source contains <code>f x</code> and <code>f '' s</code>. I want an element <code>e''</code> of <code>G</code>, defined on a neighbourhood of <code>x</code>, which agrees on  <code>s ∩ e''.source</code> with <code>f</code>.</p>\n<p>I could take <code>e''</code> to be <code>e.trans e'</code>, but for this to work, I need that <code>e x ∈ e'.source</code>, and the only way I could see to get this is if <code>e x = f x</code>, which is only guaranteed if <code>x ∈ s</code>.</p>\n<p>Alternatively, if <code>x</code> is not in the closure of <code>s</code>, I could take <code>e''</code> to be the restriction of the identity to a neighbourhood of <code>x</code> not intersecting <code>s</code>.  (I am using the <code>closed_under_restriction</code> property here, together with a separation axiom.)</p>\n<p>But what if <code>x</code> is in <code>(closure s) \\ s</code>?</p>",
        "id": 204014463,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594847914
    },
    {
        "content": "<p>The same argument in Lean code, in case it's easier to follow:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry</span><span class=\"bp\">.</span><span class=\"n\">manifold</span><span class=\"bp\">.</span><span class=\"n\">local_invariant_properties</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">local_homeomorph</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">structure_groupoid</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hclosed</span> <span class=\"o\">:</span> <span class=\"n\">closed_under_restriction</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">structure_groupoid</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">is_local_structomorph_within_at</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">eq_on</span> <span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n\n<span class=\"n\">include</span> <span class=\"n\">hclosed</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Let us try to prove the `left_invariance` property. -/</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">he&#39;G</span> <span class=\"o\">:</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">he&#39;</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_local_equiv</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hfx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_local_equiv</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">is_local_structomorph_within_at</span> <span class=\"n\">G</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">→</span>\n    <span class=\"n\">is_local_structomorph_within_at</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">e&#39;</span> <span class=\"err\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">is_local_structomorph_within_at</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">heG</span><span class=\"o\">,</span> <span class=\"n\">hef</span><span class=\"o\">,</span> <span class=\"n\">hex</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- a proof that works if  `x ∈ s`</span>\n    <span class=\"n\">use</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">heG</span> <span class=\"n\">he&#39;G</span> <span class=\"o\">},</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">eq_on</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp_app</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">hef</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨</span><span class=\"n\">hy</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">mfld_simps</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">eq_on</span> <span class=\"n\">at</span> <span class=\"n\">hef</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">hfx</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hef</span> <span class=\"bp\">⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hex</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- a proof that works if `x` has a neighbourhood not intersecting `s`</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">t</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">,</span>\n      <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">,</span> <span class=\"n\">hst</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">of_set</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">hclosed</span><span class=\"bp\">.</span><span class=\"n\">closed_under_restriction</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"n\">id_restr_groupoid</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">closed_under_restriction_iff_id_le</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">assumption</span><span class=\"o\">),</span>\n      <span class=\"n\">apply</span> <span class=\"n\">structure_groupoid</span><span class=\"bp\">.</span><span class=\"n\">le_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hle</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">id_restr_groupoid_mem</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hst</span><span class=\"o\">],</span> <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">contradiction</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hxt</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204015526,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594848476
    },
    {
        "content": "<p>On the other hand, your first definition works!  </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_local_structomorph_within_at&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">eq_on</span> <span class=\"n\">f</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n</code></pre></div>\n\n\n<p>I can indeed prove that it is invariant under the groupoid.  Thanks for showing me how to get rid of the weird <code>interior s</code> in my definition.</p>",
        "id": 204019352,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594851043
    },
    {
        "content": "<p>So let me go back to why I was originally curious about this.  With both of the working definitions (my second one and your first one), I had to use the <code>closed_under_restriction</code> property of the groupoid in order to prove the definition was groupoid-invariant.  (For your definition it was in the <code>is_local</code> step.)  Is that what you would expect?</p>",
        "id": 204019847,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594851423
    }
]
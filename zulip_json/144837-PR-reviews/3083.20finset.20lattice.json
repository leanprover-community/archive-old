[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3083\">#3083</a> makes <code>finset</code> use <code>lattice</code> operations instead of \"set\" operations. What do you think about this? <code>data.finset</code> now compiles but I don't want to waste time on porting the rest of <code>mathlib</code> if this is not going to be merged.</p>",
        "id": 200940737,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592252670
    },
    {
        "content": "<p>What's the advantage of this? I think it would be slightly more confusing for newbies who want to use finsets but don't want to think about a lattice, and if I remember correctly the lattice operations already work on finsets anyway</p>",
        "id": 200940990,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592252825
    },
    {
        "content": "<p>I think it's a good idea. It just means you don't need duplicates of all lemmas on lattice operations and set operations. Occasionally I can't <code>rw</code> with a lattice lemma because I've got set operations or vice versa.</p>",
        "id": 200941456,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1592253011
    },
    {
        "content": "<p>Does it mean you want to use the obscure lattice notations for set/finset intersection and union?</p>",
        "id": 200943935,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592254278
    },
    {
        "content": "<p>If you want to unify everything I would rather drop the lattice notations and use round intersection and union everywhere instead of the lattice square versions</p>",
        "id": 200944031,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592254322
    },
    {
        "content": "<p>Oh I see Gabriel also likes round notations.</p>",
        "id": 200944111,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592254367
    },
    {
        "content": "<p>Either way it sounds like a drastic change that is not drastically motivated.</p>",
        "id": 200944342,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592254476
    },
    {
        "content": "<p>I would very much prefer having integrals that work.</p>",
        "id": 200944394,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592254504
    },
    {
        "content": "<p>We have the zany lattice notation for ideals and I got used to it in the end. There are advantages of a unified approach. I get annoyed that set.preimage isn't called comap nowadays</p>",
        "id": 200945812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592255267
    },
    {
        "content": "<p>I was thinking about definitions, not notation.</p>",
        "id": 200947945,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592256351
    },
    {
        "content": "<p>The only question about using <code>∪</code> ant <code>∩</code> for lattice is what to do with <code>≤</code>/<code>&lt;</code>/<code>⊥</code> vs <code>⊆</code>/<code>⊂</code>/<code>∅</code>.</p>",
        "id": 200948117,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592256439
    },
    {
        "content": "<p>I know only one type with different interpretation of <code>≤</code> and <code>⊆</code>: <code>multiset</code>.</p>",
        "id": 200948235,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592256494
    },
    {
        "content": "<p>I think having any types with both <code>≤</code> and <code>⊆</code> is probably a bad idea: just a recipe for confusion. (I remember being dismayed stumbling on this one.) I would propose picking the important one to receive notation (whether it's <code>≤</code> and <code>⊆</code>) and just dealing with being more verbose for the other.</p>",
        "id": 200956593,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592262589
    },
    {
        "content": "<p>Whenever I have to do anything with lattices I struggle a lot with typing <code>\\lub</code> and <code>\\glb</code> because I have to mentally reconstruct which is which. It doesn't help that we think of them as <code>union</code> and <code>inter</code>, and the lattice names are <code>sup</code> and <code>inf</code>. Maybe it would help if we could also use <code>\\lunion</code> and <code>\\linter</code> for \"lattice union\" and \"lattice inter\", or something like that.</p>",
        "id": 200963627,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1592269554
    },
    {
        "content": "<p>what about <code>\\sqcap</code> and <code>\\sqcup</code>?</p>",
        "id": 200964600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592270849
    },
    {
        "content": "<p>Yeah, that works for me.</p>",
        "id": 200965030,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1592271361
    },
    {
        "content": "<p>I must confess I feel the same as Jeremy about these funny words. I guess I recognise cup as union though</p>",
        "id": 200965077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592271381
    },
    {
        "content": "<p>Oh, yeah, and when talking about lattices in ordinary mathematics I use \"meet\" and \"join.\" We give the dictionary here: <a href=\"https://avigad.github.io/mathematics_in_lean/basics.html#proving-facts-about-algebraic-structures\">https://avigad.github.io/mathematics_in_lean/basics.html#proving-facts-about-algebraic-structures</a><br>\nI put the translations there to help myself sort them out more than anyone else.</p>",
        "id": 200967946,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1592275332
    },
    {
        "content": "<p>Changing <code>sup</code> to <code>join</code> and <code>inf</code> to <code>meet</code> should not be too hard.</p>",
        "id": 200968668,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592276527
    },
    {
        "content": "<p>But I don't want to start any of these refactors until we'll agree on the goal.</p>",
        "id": 200968684,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592276566
    },
    {
        "content": "<p>I would like to maintain readability as much as possible. But uniformity pays off in the long run. And I think the symbols are similar enough that we can explain to anyone that <code>\\sqcup</code> is the symbol for union of \"set-like\" things. Then we only need to tell them that in names</p>\n<ul>\n<li><code>subset</code> becomes <code>le</code></li>\n<li><code>union</code> becomes <code>meet</code></li>\n<li><code>inter</code> becomes <code>join</code><br>\nand I think all of those are pretty self-explanatory.<br>\nThe hardest thing might be <code>empty</code> becomes <code>bot</code>...<br>\nAnd of course <code>univ</code> was already confusing to begin with, so replacing it with <code>top</code> doesn't change anything. (-;</li>\n</ul>",
        "id": 200978015,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592289488
    },
    {
        "content": "<p>We can use union and inter for meet and join though in some contexts (e.g., <code>supr</code> in <code>real</code>s or <code>ennreal</code>s) this looks funny.</p>",
        "id": 200978110,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592289607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200967946\">said</a>:</p>\n<blockquote>\n<p>I use \"meet\" and \"join.\"</p>\n</blockquote>\n<p>I mix up meet and join <del>pretty often</del> always, I guess mostly because these words don't exist in German.  In German we typically use supremum and infimum, so I prefer the current naming.</p>",
        "id": 200979714,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1592291416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200978110\">said</a>:</p>\n<blockquote>\n<p>in some contexts [...] this looks funny.</p>\n</blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>∪</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2} \\cup \\pi = \\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.13278em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg height=\"1.08em\" preserveAspectRatio=\"xMinYMin slice\" viewBox=\"0 0 400000 1080\" width=\"400em\"><path d=\"M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> doesn't look so bad, it reminds me of Dedekind cuts.</p>",
        "id": 200980268,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1592291997
    },
    {
        "content": "<p>I didn't mean to suggest that <code>meet</code> and <code>join</code> are better than <code>sup</code> and <code>inf</code>. It would help if we could reclaim <code>\\sup</code> and <code>\\inf</code> in VS Code. We already have <code>\\supseteq</code> and <code>\\infty</code> for the symbols they are assigned to now. It might help to be able to type <code>\\sqcap</code> and <code>\\sqcup</code> when working with finsets, because <code>\\cap</code> and <code>\\cup</code> are used in Latex for intersections and unions. But I can probably get used to the fact that intersection is <code>\\inf</code> because it is smaller and union is <code>\\sup</code> because it is bigger. It's just that <code>\\glb</code> and <code>\\lub</code> are horrible, because e.g. \"greatest\" and \"lower\" go in opposite directions, and I have to stop to think about which one wins.</p>",
        "id": 201001610,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1592307240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200980268\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/200978110\">said</a>:</p>\n<blockquote>\n<p>in some contexts [...] this looks funny.</p>\n</blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>∪</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2} \\cup \\pi = \\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.13278em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg height=\"1.08em\" preserveAspectRatio=\"xMinYMin slice\" viewBox=\"0 0 400000 1080\" width=\"400em\"><path d=\"M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> doesn't look so bad, it reminds me of Dedekind cuts.</p>\n</blockquote>\n<p>I guess this is tongue in cheek? I'm not a fan <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> I guess that for linear orders we want to simp this away to <code>max a b</code> as soon as possible?</p>",
        "id": 201048350,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592328526
    },
    {
        "content": "<p>I'm 60% serious.  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>⊔</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2} \\sqcup \\pi = \\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.13278em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg height=\"1.08em\" preserveAspectRatio=\"xMinYMin slice\" viewBox=\"0 0 400000 1080\" width=\"400em\"><path d=\"M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊔</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> doesn't look any better to me.  But <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∈</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">1 \\in \\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> would be too much, even for me.</p>",
        "id": 201049077,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1592328860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/201049077\">said</a>:</p>\n<blockquote>\n<p>I'm 60% serious.  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>2</mn></msqrt><mo>⊔</mo><mi>π</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\sqrt{2} \\sqcup \\pi = \\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.13278em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg height=\"1.08em\" preserveAspectRatio=\"xMinYMin slice\" viewBox=\"0 0 400000 1080\" width=\"400em\"><path d=\"M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊔</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> doesn't look any better to me.</p>\n</blockquote>\n<p>But it also doesn't look any worse, right? (At least to me...)</p>",
        "id": 201049156,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592328918
    },
    {
        "content": "<p>I completely agree.  That's why I think <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mo>∪</mo><mrow></mrow></mrow><annotation encoding=\"application/x-tex\">{}\\cup{}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord\"></span></span></span></span> is the best choice if we want to standardize, because it looks right half of the time (with sets, multisets, etc.).</p>",
        "id": 201049307,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1592328990
    },
    {
        "content": "<p>But on an abstract lattice, it looks \"wrongish\".</p>",
        "id": 201049354,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592329013
    },
    {
        "content": "<p>And the problem remains with <code>\\le</code> vs <code>\\subset</code>, right?</p>",
        "id": 201049410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592329041
    },
    {
        "content": "<p>We definitely don't want <code>0 \\subset 1</code>.</p>",
        "id": 201049426,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592329051
    },
    {
        "content": "<p>Yes, <code>⊆</code> vs. <code>≤</code> is the hard one.  How about <code>∅ ≤ A ∩ B</code>? <em>ducks</em></p>",
        "id": 201049555,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1592329121
    },
    {
        "content": "<p>I think I prefer to go full lattice notation everywhere.</p>",
        "id": 201049971,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1592329351
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∪</mo></mrow><annotation encoding=\"application/x-tex\">\\cup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∪</span></span></span></span>/<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∩</mo></mrow><annotation encoding=\"application/x-tex\">\\cap</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∩</span></span></span></span> look really wrong when they are wrong, for example, filters ordered by reverse inclusion.</p>",
        "id": 201051291,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592329953
    },
    {
        "content": "<p>Is it insane to have all the notations mean the same thing (i.e. lattice operations), and let people use different ones in different contexts?</p>",
        "id": 201101221,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592369250
    },
    {
        "content": "<p>Proof state will always use one notation.</p>",
        "id": 201101358,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592369440
    },
    {
        "content": "<p>Is this sort of thing why we have to prove everything for both additive groups and multiplicative groups?</p>",
        "id": 201101954,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592370236
    },
    {
        "content": "<p>For multiplicative and additive groups we also have rings. They use both multiplicative and additive structures.</p>",
        "id": 201102016,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592370314
    },
    {
        "content": "<p>One possible solution is to write a <code>to_additive</code>-style attribute and add it to all the <code>lattice</code> lemmas.</p>",
        "id": 201102094,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592370399
    },
    {
        "content": "<p>But then we'll have to decide which notation is better in each case.</p>",
        "id": 201102112,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592370449
    },
    {
        "content": "<p>I wouldn't mind using lattice notation everywhere.<br>\nI'm not in favor using set notation for lattices.<br>\nThe current status quo means we have to redo everything about lattices separately for sets and finsets, which is not great. There have been plenty of cases where I needed a lemma that existed for exactly one of {bUnion, supr} and I needed it for the other one.</p>",
        "id": 202152032,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593211557
    },
    {
        "content": "<p>Even worse, we need to redo lots of stuff separately for sets, finsets, and lattices.</p>",
        "id": 202155277,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593214255
    },
    {
        "content": "<p>Let me revive this thread. What are the reasons <strong>against</strong> migration of <code>set</code>s, <code>multiset</code>s and <code>finset</code>s to <code>lattice</code>?</p>",
        "id": 202356827,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593458700
    },
    {
        "content": "<p>I remember the following:</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊔</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊓</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcap</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊓</span></span></span></span> look worse than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∪</mo></mrow><annotation encoding=\"application/x-tex\">\\cup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∪</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∩</mo></mrow><annotation encoding=\"application/x-tex\">\\cap</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∩</span></span></span></span>;</li>\n<li>it's hard to remember <code>\\lub</code> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊔</span></span></span></span>.</li>\n</ul>\n<p>What else?</p>",
        "id": 202356949,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593458773
    },
    {
        "content": "<p>The second point is no longer valid after all the new additions to the translations file.</p>",
        "id": 202357129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593458888
    },
    {
        "content": "<p>point 2 has been resolved: there are now many ways to input <code>⊔</code> and <code>⨆</code>.<br>\nI think a point that is close to point 1: lattice notation is beginner unfriendly.</p>",
        "id": 202357133,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593458891
    },
    {
        "content": "<p>And defining <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f'(x)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span></span></span></span> using normed spaces and filters is very beginner friendly ;)</p>",
        "id": 202357350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593459005
    },
    {
        "content": "<p>BTW, when I first saw Lean the fact that <code>⊂</code> means <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊊</mo></mrow><annotation encoding=\"application/x-tex\">\\subsetneq</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel amsrm\">⊊</span></span></span></span> was very surprising.</p>",
        "id": 202357488,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593459084
    },
    {
        "content": "<p>There is a difference: with a good enough API you don't need to know about normed spaces &amp; filters to work with the derivative on functions <code>real -&gt; real</code>. The lattice operations on <code>set</code> <strong>is</strong> the API.<br>\n(just to be clear: I'm in favor of using lattice notation for sets over the status quo)</p>",
        "id": 202357493,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593459086
    },
    {
        "content": "<p>Can we have <code>local notation : ∪ := ⊔</code>, and use it in the set files?</p>",
        "id": 202357926,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593459312
    },
    {
        "content": "<p>Or even have it globally as an input notation in all files?</p>",
        "id": 202358070,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593459377
    },
    {
        "content": "<p>I'm afraid that might make things even more confusing if the lemmas you use are called <code>sup_comm</code> and <code>image_sup</code> (or <code>sup_comm</code> and <code>image_union</code>??).</p>",
        "id": 202358200,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593459471
    },
    {
        "content": "<p><code>image</code> and <code>preimage</code> should <em>clearly</em> be renamed to <code>map</code> and <code>comap</code>... ...<br>\n... <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span> <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 202358399,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202358200\">said</a>:</p>\n<blockquote>\n<p>I'm afraid that might make things even more confusing if the lemmas you use are called <code>sup_comm</code> and <code>image_sup</code> (or <code>sup_comm</code> and <code>image_union</code>??).</p>\n</blockquote>\n<p>Good point!</p>",
        "id": 202358501,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593459580
    },
    {
        "content": "<p>Also, what does <code>s ≤ t</code> mean to a mathematician (if anything)? Is it pointwise inequalities: <code>∀ x ∈ s, ∀ y ∈ t, x ≤ y</code>? Using lattice notation means that it has to mean <code>subset</code>...</p>",
        "id": 202358696,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593459678
    },
    {
        "content": "<p>I guess it <em>could</em> mean pointwise ineqs, but I think that's very rare.</p>",
        "id": 202359030,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459857
    },
    {
        "content": "<p>I don't think the idea that sets form a partial order w.r.t. inclusion is so alien to mathematicians, so I'd say most would guess it means subset.</p>",
        "id": 202359072,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593459879
    },
    {
        "content": "<p>It definitely helps that the lattice notation is just a pointy-squary version of the set notation.</p>",
        "id": 202359260,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459986
    },
    {
        "content": "<p>But it might take some time to get used to names like <code>le_image_sup : f '' (s ⊔ f ⁻¹' t) ≤ f '' s ⊔ t</code> (or <code>le_map_sup</code>). I do feel like we're losing something when moving from the current notation/naming to the lattice versions...</p>",
        "id": 202359637,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593460210
    },
    {
        "content": "<p>We would need an attribute like <code>to_additive</code> to create <code>union</code> lemmas from <code>sup</code> lemmas, and a notation <code>union = sup</code>. Then it would be mostly transparent to the user, but with better defeq properties.</p>",
        "id": 202359896,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593460381
    },
    {
        "content": "<p>How about having something like the <code>to_additive</code> trick, so that we can batch-duplicate lattice theorems with set names and set notation (for types that have that notation defined)?</p>",
        "id": 202359932,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1593460402
    },
    {
        "content": "<p>I was faster :)</p>",
        "id": 202359955,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593460418
    },
    {
        "content": "<p>As a small experiment, I just asked two grad students (in number theory) what <code>X \\le Y</code> for <code>X, Y</code> sets means with no hints, one guessed the partial order by inclusion, and one guessed an inequality of cardinals (i.e. exists an injection from <code>X \\to Y</code>. It might have been more realistic to pose it as <code>X, Y</code> subsets of <code>Z</code>, what does <code>X\\le Y</code> mean.</p>",
        "id": 202359960,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593460421
    },
    {
        "content": "<p>If we try the <code>to_additive</code> trick, then which notation should we use for <code>submonoid</code>s etc?</p>",
        "id": 202360184,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593460549
    },
    {
        "content": "<p>I would say: don't touch existing files. Both notations should be completely equivalent, so you can even use <code>\\le</code> at one line and <code>\\subseteq</code> at the next one.</p>",
        "id": 202360464,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593460694
    },
    {
        "content": "<p>I guess lattice operations are fine on <code>submonoids</code>, <code>opens</code>, ...<br>\nFor submonoids you don't even have <code>↑(s ⊔ t) = ↑s ∪ ↑t</code> in general</p>",
        "id": 202360500,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593460711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> As an temporary solution? Eventually we will want to name our lemmas in a consistent way (which probably means using <code>_sup_</code> instead of <code>_union_</code> everywhere)</p>",
        "id": 202360704,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593460805
    },
    {
        "content": "<p>But if we use <code>∪</code> for set, we probably also want it for <code>finset</code>...</p>",
        "id": 202360825,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593460868
    },
    {
        "content": "<p>I think that <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> is proposing to throw away <code>set/basic.lean</code> and instead tag every lemma in <code>order/lattice.lean</code> with <code>@[to_set]</code>.</p>",
        "id": 202360840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593460877
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 202360868,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593460892
    },
    {
        "content": "<p>In more specialized domains, we should settle on one of the choices. I'd say use union and subset for sets and finsets (and more generally if there is a coercion to sets satisfying <code>coe (a sup b) = coe a union coe b</code>), and order notation otherwise.</p>",
        "id": 202361099,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593461011
    },
    {
        "content": "<p>is the statement of lemma <code>union_comm</code> the same as <code>sup_comm</code>, or is it specialized to sets?</p>",
        "id": 202361278,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593461094
    },
    {
        "content": "<p>It is exactly the same statement.</p>",
        "id": 202361344,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593461133
    },
    {
        "content": "<p>(Possibly with a different pretty printer setting so that the sup is shown as a union in the tooltip)</p>",
        "id": 202361388,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593461158
    },
    {
        "content": "<p>ah ok. that would make it easier.</p>",
        "id": 202361430,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593461164
    },
    {
        "content": "<p>yeah, you probably still want different <code>has_union</code> and <code>has_sup</code> classes, and let <code>to_set</code> modify the classes as well, so that the goal/lemmas are printed the way you wrote them.</p>\n<p>I guess that could work.</p>",
        "id": 202361507,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593461219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> I agree: if you don't know X and Y are subsets of Z then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\subseteq Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> doesn't make much sense. If they're both subsets of Z then there's at most one canonical injection from X to Y and so now you're more likely to guess the inclusion.</p>",
        "id": 202361576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593461274
    },
    {
        "content": "<p>This is going to be a refactor so big that <span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span> <span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span> <span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span></p>",
        "id": 202361640,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593461293
    },
    {
        "content": "<p>I agree, it was a flawed experiment! But someone still got it right!</p>",
        "id": 202361659,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593461304
    },
    {
        "content": "<p>If we have different <code>has_sup</code> and <code>has_union</code> classes, then how can <code>union_comm</code> and <code>sup_comm</code> be the same?</p>",
        "id": 202362535,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593461853
    },
    {
        "content": "<p>I think we should just have one class.</p>",
        "id": 202362672,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593461925
    },
    {
        "content": "<p>Then what should <code>@[to_set]</code> do?</p>",
        "id": 202362705,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593461945
    },
    {
        "content": "<p>And I guess we won't be able to tell pretty-printer to consistently use <code>∪</code> for sets and finsets.</p>",
        "id": 202362762,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593461987
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">to_set</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">le_sup_right</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"err\">⊔</span> <span class=\"n\">b</span>\n</code></pre></div>\n\n\n<p>should create a theorem <code>subset_union_right</code>which is defeq to <code>le_sup_right</code>, but in which <code>notation union := sup</code> and <code>notation subseteq := \\le</code> are activated so that the tooltip shows right.</p>",
        "id": 202362928,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593462070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202362762\">said</a>:</p>\n<blockquote>\n<p>And I guess we won't be able to tell pretty-printer to consistently use <code>∪</code> for sets and finsets.</p>\n</blockquote>\n<p>I agree, but I think this is only a minor annoyance. (And it might be solvable in Lean 4).</p>",
        "id": 202363053,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593462138
    },
    {
        "content": "<p>What do you mean by \"notation ... are activated\"? AFAIK, Lean doesn't store notation with lemma statements. It uses currently active notation in <code>#print</code> etc.</p>",
        "id": 202363381,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593462311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202362535\">said</a>:</p>\n<blockquote>\n<p>If we have different <code>has_sup</code> and <code>has_union</code> classes, then how can <code>union_comm</code> and <code>sup_comm</code> be the same?</p>\n</blockquote>\n<p>with two different classes, they are not syntactically equal.<br>\nMy idea (to get the pretty printing right) is to have separate <code>has_sup</code> and <code>has_union</code> classes. Given a <code>lattice</code> you have instances to both <code>has_sup</code> and <code>has_union</code>, and the underlying maps are definitionally equal.<br>\nThen <code>@[to_set]</code> replaces all <code>sup</code>s with <code>union</code>s, in the same way that <code>to_additive</code> does it.</p>",
        "id": 202363384,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593462313
    },
    {
        "content": "<p>The lemmas will be definitionally equal, but not syntactically equal.</p>",
        "id": 202363436,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593462345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202363381\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"notation ... are activated\"? AFAIK, Lean doesn't store notation with lemma statements. It uses currently active notation in <code>#print</code> etc.</p>\n</blockquote>\n<p>ok, too bad</p>",
        "id": 202363525,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593462378
    },
    {
        "content": "<p>If we use different classes, why should we care about <code>defeq</code>?  We can make <code>@[to_set]</code> do the same as <code>@[to_additive]</code>.</p>",
        "id": 202363628,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593462450
    },
    {
        "content": "<p>we don't necessarily care about defeq.</p>",
        "id": 202363824,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593462546
    },
    {
        "content": "<p>I don't remember the start of the thread: wasn't your goal to get union defeq to to \\sup to start with?</p>",
        "id": 202364206,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593462732
    },
    {
        "content": "<p>Let's say we consider different options. The goal is to reduce code duplication.</p>",
        "id": 202364350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593462838
    },
    {
        "content": "<p>Currently we prove quite a few <code>lattice</code> lemmas for (a) <code>set</code>s; (b) <code>finset</code>s; (c) all other lattices.</p>",
        "id": 202364430,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593462861
    },
    {
        "content": "<p>Technically the simplest solution is to start using <code>≤</code>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊓</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcap</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊓</span></span></span></span> etc everywhere but this is bad for new users.</p>",
        "id": 202364677,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593462974
    },
    {
        "content": "<p>Other solutions include: (a) use a <code>@[to_additive]</code>-like attribute to transfer lemmas from <code>lattice</code> operations to <code>set</code> operations; (b) allow <code>∪</code> as a (local?) alternative syntax for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊔</span></span></span></span> and use it for <code>set</code>s and <code>finset</code>s.</p>",
        "id": 202365255,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593463296
    },
    {
        "content": "<p>From the discussion, (a) looks like the nicest solution, albeit not the easiest to implement.</p>",
        "id": 202365368,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593463340
    },
    {
        "content": "<p>The main drawback of (a) is that we'll need class names for <code>set</code> versions of everything up to <code>complete_boolean_algebra</code> and, e.g., <code>monotone</code> won't work automatically unless we define <code>has_le</code> as well.</p>",
        "id": 202365625,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593463463
    },
    {
        "content": "<p>I hope that with Lean 4 we'll be able to define a pretty-printer that uses <code>∪</code> for some types and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊔</span></span></span></span> for all other types.</p>",
        "id": 202365757,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593463553
    },
    {
        "content": "<p>So we have option (c): wait for Lean 4.</p>",
        "id": 202366072,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593463707
    },
    {
        "content": "<p>Even with Lean 4, we would need <code>@[to_set]</code> to create lemma names with union and subset instead of sup and le.</p>",
        "id": 202366263,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593463808
    },
    {
        "content": "<p>Is it a problem that <code>order.complete_lattice</code> depends on properties of sets, through <code>order.bounds</code>? On a quick look, <code>order.bounds</code> only uses finite unions and intersections, subset, empty and univ. So maybe it is o.k.</p>",
        "id": 202366413,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1593463907
    },
    {
        "content": "<p>It's easy to reorder <code>import</code>s so that <code>data/set/basic</code> will know the <em>definition</em> of <code>complete_boolean_algebra</code> and <em>lemmas</em> about <code>bounded_lattice</code>.</p>",
        "id": 202366555,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593463975
    },
    {
        "content": "<p>(done locally)</p>",
        "id": 202367358,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593464415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202366263\">said</a>:</p>\n<blockquote>\n<p>Even with Lean 4, we would need <code>@[to_set]</code> to create lemma names with union and subset instead of sup and le.</p>\n</blockquote>\n<p>It's easier to add <code>alias</code>es with custom names than to modify types.</p>",
        "id": 202367460,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593464483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202365625\">said</a>:</p>\n<blockquote>\n<p>The main drawback of (a) is that we'll need class names for <code>set</code> versions of everything up to <code>complete_boolean_algebra</code> and, e.g., <code>monotone</code> won't work automatically unless we define <code>has_le</code> as well.</p>\n</blockquote>\n<p>Well, <code>to_set</code> wouldn't have to replay the proofs (like <code>to_additive</code>) does, if we make sure that things are defeq. Then it just has to modify the name and statement, and can prove the resulting lemma by directly calling the lattice version.<br>\nSo it generates</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">subset_union_right</span> <span class=\"o\">:</span> <span class=\"n\">the</span><span class=\"bp\">-</span><span class=\"n\">statement</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_sup_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</code></pre></div>\n\n\n<p>To make this work, we have to give <code>set</code> some low-priority <code>has_le</code> and <code>has_sup</code> instances, but it would save us from duplicating the entire lattice class hierarchy for set-like notation.</p>",
        "id": 202394733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593491519
    },
    {
        "content": "<p>What's wrong with the approach \"make <code>\\cup</code> and <code>\\sqcup</code> two notations for the same operation and make <code>@[to_set]</code> work as <code>alias + autogen name</code>\"? This way we can't have good notation in the proof state but we can be sure that any lemma about <code>lattice</code>s work for <code>set</code>s even without a <code>@[to_set]</code> alias.</p>",
        "id": 202401049,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593500088
    },
    {
        "content": "<p>We still can have good notation in the input.</p>",
        "id": 202401061,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593500104
    },
    {
        "content": "<p>(and I hope that we'll be able to have a good notation in the proof state in Lean 4)</p>",
        "id": 202401078,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593500138
    },
    {
        "content": "<p>How exactly should the \"defeq\" based <code>@[to_set]</code> work? Should we add some instances like <code>has_subset.to_has_le</code> and use them when transforming the statement? Will it play nice with diamonds?</p>",
        "id": 202401693,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593500782
    },
    {
        "content": "<p>Shouldn't we remove completely <code>has_subset</code>, and use subset as a notation for le?</p>",
        "id": 202401870,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593500978
    },
    {
        "content": "<p>With the \"make <code>\\cup</code> and <code>\\sqcup</code> two notations for the same operation\" approach yes, we should. But I'm trying to understand what other options do we have, and can't understand the \"defeq\" approach <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> is talking about.</p>",
        "id": 202402028,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593501174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/3083.20finset.20lattice/near/202401870\">said</a>:</p>\n<blockquote>\n<p>Shouldn't we remove completely <code>has_subset</code>, and use subset as a notation for le?</p>\n</blockquote>\n<p>Shouldn't we completely remove <code>has_mul</code>, and use <code>*</code> as a notation for <code>has_add</code>?</p>",
        "id": 202402586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593501771
    },
    {
        "content": "<p>I guess there might be some edge cases where a type has two monoid structures</p>",
        "id": 202402610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593501802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Let's discuss lattices, not monoids. Currently there is only one rarely used type (<code>multiset</code>) with both <code>has_subset</code> and <code>has_le</code> and <code>has_le.le ≠ has_subset.subset</code>.</p>",
        "id": 202443895,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593527788
    },
    {
        "content": "<p>So rather fewer edge cases than in the */+ case.</p>",
        "id": 202444826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593528169
    },
    {
        "content": "<p>And I'm not aware of good structures involving <code>has_subset</code> on <code>multiset</code>, so we can just add a custom notation for this.</p>",
        "id": 202447128,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593529061
    },
    {
        "content": "<p>One more type with sensible <code>has_subset</code> different from <code>has_le</code>: <code>list</code>.</p>",
        "id": 202460808,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593534563
    },
    {
        "content": "<p>IIRC there is more than one reasonable (non-subset) definition of <code>≤</code> on lists.  And only one of them is well-founded (if the order on the elements is well-founded).  Maybe these should be different relations (i.e., not <code>≤</code>) anyhow.</p>",
        "id": 202461451,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1593534820
    }
]
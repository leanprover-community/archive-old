[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> what do you think about generalizing your definition of a Henselian local ring to arbitrary Henselian pairs a la <a href=\"https://stacks.math.columbia.edu/tag/09XD\">stacks#09XD</a> ?</p>\n<p>With the following lemma:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">local_map_of_le_jacobson</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.jacobson</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_local_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">ideal.jacobson</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">is_unit_iff_exists_inv</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">ideal.quotient.eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hb</span> <span class=\"o\">},</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"n\">h2</span><span class=\"o\">⟩,</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"n\">ideal.quotient.eq</span><span class=\"o\">,</span>\n    <span class=\"n\">ideal.mem_jacobson_bot</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h1</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h1.1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>and the following definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">henselian</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">jac</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.jacobson</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_henselian</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.monic</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a₀</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">f.eval</span> <span class=\"n\">a₀</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">f.derivative.eval</span> <span class=\"n\">a₀</span><span class=\"o\">))),</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">f.is_root</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">a₀</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>the proof you give in the local case will also work to show that an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>-adically complete commutative ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is Henselian (w.r.t <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>). The only missing component is to show that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>-adically complete then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is contained in the Jacobson radical.</p>",
        "id": 252700375,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631223584
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/9125\">#9125</a></p>",
        "id": 252719910,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631237334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Do you mean to have both? So <code>henselian_ring</code> and <code>henselian_local_ring</code>.<br>\nOr would the UI be to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">local_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">henselian</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">maximal_ideal</span> <span class=\"n\">R</span><span class=\"o\">)]</span>\n</code></pre></div>",
        "id": 252732790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631249892
    },
    {
        "content": "<p>(Un)related: should we rename <code>maximal_ideal</code> to <code>max_ideal</code>? Saves 4 characters.</p>",
        "id": 252732807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631249917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I was envisioning using </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">local_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">henselian</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">maximal_ideal</span> <span class=\"n\">R</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>or perhaps defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Henselian_local_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">local_ring</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">henselian</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">maximal_ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 252780117,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631277605
    },
    {
        "content": "<p>Ok, I'll add this to the PR</p>",
        "id": 252780557,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631277816
    },
    {
        "content": "<p>Concerning <code>max_ideal</code> I'm all for shorter names! I wish we could just write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">m</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.47534em;vertical-align:0em;\"></span><span class=\"mord mathfrak\">m</span></span></span></span> like normal people...</p>",
        "id": 252781381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1631278214
    }
]
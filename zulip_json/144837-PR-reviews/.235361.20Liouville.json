[
    {
        "content": "<p>I left several comments on the partial PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5361\">#5361</a>.  I am still hoping to get the <code>t2_space</code> stuff in.  In the meantime, though, I hope that the suggestions that I proposed are viewed as improvements!</p>",
        "id": 220000343,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608048351
    },
    {
        "content": "<p>After a further clean up, I pushed a version of this PR that is hopefully a step closer to being imported to mathlib.</p>\n<p>I tried to maintain lemmas with the literal statements of the initial PR, but I proved them as consequences of other lemmas that I believe are more direct.  Once I take a look at the subsequent PR, I may be in a better position to know which form is preferable.</p>\n<p>I created a separate file <code>prelims_polynomial.lean</code> containing results that do not belong to the main file of this PR and that may be scattered around.  Rather than scattering them around already, I preferred to keep them all together: these results may not be needed in the end, depending on the final shape of the main lemmas.</p>",
        "id": 220350419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608283444
    },
    {
        "content": "<p>One more step in the direction of importing this PR: I created PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5523\">#5523</a> with 4 lemmas on discrete subsets of a topological space.  The lemmas are due to Patrick, the naming is my addition: feel free to suggest better names!</p>",
        "id": 221132881,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609247398
    },
    {
        "content": "<p>Happy 2021!</p>\n<p>In the process of cleaning up this PR, I reduced one of the statements to the two lemmas below.  If anyone has any golfing tips for simplifying the arguments, I would be glad to hear them!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.irrational</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_liouville</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.mul_lt_mul_pow_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">q1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">q2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span> <span class=\"n\">a0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n    <span class=\"o\">(</span><span class=\"n\">pow_le_pow_of_le_left</span> <span class=\"n\">zero_le_two</span> <span class=\"o\">((</span><span class=\"n\">int.lt_iff_add_one_le</span> <span class=\"mi\">1</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">q1</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">a2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">le_mul_iff_one_le_left</span> <span class=\"o\">(</span><span class=\"n\">pow_pos</span> <span class=\"n\">zero_lt_two</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">((</span><span class=\"n\">int.lt_iff_add_one_le</span> <span class=\"mi\">0</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">a0</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">mul_lt_mul_right</span> <span class=\"o\">(</span><span class=\"n\">lt_trans</span> <span class=\"n\">zero_lt_one</span> <span class=\"n\">q1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">lt_of_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">lt_of_lt_of_le</span> <span class=\"n\">_</span> <span class=\"n\">a2</span><span class=\"o\">)</span> <span class=\"n\">q2</span><span class=\"o\">),</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">nat.lt_two_pow</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">irrational_of_is_liouville</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_liouville</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">irrational</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">irrational_of_ne_int_div_pos_nat</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h_b_pos</span> <span class=\"n\">h_rid</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h_rid</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">q1</span><span class=\"o\">,</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">a1</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">qR0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">exact_mod_cast</span> <span class=\"o\">(</span><span class=\"n\">lt_trans</span> <span class=\"n\">zero_lt_one</span> <span class=\"n\">q1</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">bR0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">h_b_pos</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">h_b_pos</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_sub_div</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">b0</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">qR0</span><span class=\"o\">),</span> <span class=\"n\">abs_div</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a0</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lt_div_iff</span> <span class=\"o\">(</span><span class=\"n\">abs_pos.mpr</span> <span class=\"o\">(</span><span class=\"n\">mul_ne_zero</span> <span class=\"n\">b0</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">qR0</span><span class=\"o\">))),</span> <span class=\"n\">zero_mul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_lt_div_iff</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">pow_pos</span> <span class=\"n\">qR0</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">abs_of_pos</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_pos</span> <span class=\"n\">bR0</span> <span class=\"n\">qR0</span><span class=\"o\">),</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">not_le.mpr</span> <span class=\"n\">a1</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">int.mul_lt_mul_pow_succ</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">a0</span><span class=\"o\">)</span> <span class=\"n\">q1</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">abs_pos.mpr</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">mul_pos</span> <span class=\"n\">bR0</span> <span class=\"n\">qR0</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221388503,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609572296
    },
    {
        "content": "<p>Your first lemma is about nonnegative ints. Here's my effort:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- should be in mathlib</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.lt_mul_of_pos_of_lt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">one_mul</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">hbc</span><span class=\"o\">,</span> <span class=\"n\">lt_of_lt_of_le</span>\n    <span class=\"o\">(</span><span class=\"n\">nat.lt_mul_of_pos_of_lt</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">hbc</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">nat.mul_le_mul_right</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">nat.le_succ</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.mul_lt_mul_pow_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">q1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_lt_mul_right</span> <span class=\"o\">(</span><span class=\"n\">lt_trans</span> <span class=\"n\">zero_lt_one</span> <span class=\"n\">q1</span><span class=\"o\">)],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat.lt_mul_of_pos_of_lt</span> <span class=\"n\">a0</span> <span class=\"o\">(</span><span class=\"n\">nat.lt_pow_self</span> <span class=\"n\">q1</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.mul_lt_mul_pow_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">q1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">lift</span> <span class=\"n\">a</span> <span class=\"n\">to</span> <span class=\"n\">ℕ</span> <span class=\"n\">using</span> <span class=\"n\">le_of_lt</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n  <span class=\"n\">lift</span> <span class=\"n\">q</span> <span class=\"n\">to</span> <span class=\"n\">ℕ</span> <span class=\"n\">using</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">zero_le_one</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">q1</span><span class=\"o\">),</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat.mul_lt_mul_pow_succ</span> <span class=\"n\">a0</span> <span class=\"n\">q1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Your second lemma doesn't compile for me, I don't have <code>irrational_of_ne_int_div_pos_nat</code></p>",
        "id": 221397326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609589460
    },
    {
        "content": "<p>Ah, thanks!</p>\n<p>That lemma is in data.real.irrational: I copy the beginning below!</p>\n<p>Thanks again!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.rat.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.int.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.eval</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.degree</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.interval_cases</span>\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Irrational real numbers</span>\n\n<span class=\"cm\">In this file we define a predicate `irrational` on `ℝ`, prove that the `n`-th root of an integer</span>\n<span class=\"cm\">number is irrational if it is not integer, and that `sqrt q` is irrational if and only if</span>\n<span class=\"cm\">`rat.sqrt q * rat.sqrt q ≠ q ∧ 0 ≤ q`.</span>\n\n<span class=\"cm\">We also provide dot-style constructors like `irrational.add_rat`, `irrational.rat_sub` etc.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">rat</span> <span class=\"n\">real</span> <span class=\"n\">multiplicity</span>\n\n<span class=\"sd\">/-- A real number is irrational if it is not equal to any rational number. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">irrational</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">irrational_iff_ne_rational</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">irrational</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">irrational</span><span class=\"o\">,</span> <span class=\"n\">rat.forall</span><span class=\"o\">,</span> <span class=\"n\">cast_mk</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">,</span> <span class=\"n\">set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">cast_coe_int</span><span class=\"o\">,</span> <span class=\"n\">cast_div</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">irrational_of_ne_int_div_pos_nat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"bp\">/</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">irrational</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">irrational_iff_ne_rational</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">lt_trichotomy</span> <span class=\"mi\">0</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">b_gt</span> <span class=\"bp\">|</span> <span class=\"n\">b_0</span> <span class=\"bp\">|</span> <span class=\"n\">b_lt</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">lift</span> <span class=\"n\">b</span> <span class=\"n\">to</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b_gt</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">le_of_lt</span> <span class=\"n\">b_gt</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hrid</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">b_0</span><span class=\"o\">,</span> <span class=\"n\">int.cast_zero</span><span class=\"o\">,</span> <span class=\"n\">div_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hrid</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">int.cast_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_div</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">hrid</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b.nat_abs</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">int.abs_eq_nat_abs</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">abs_of_neg</span> <span class=\"n\">b_lt</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">rat.mk_eq_div</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">cast_coe_int</span><span class=\"o\">,</span> <span class=\"n\">cast_neg</span><span class=\"o\">,</span> <span class=\"n\">int.cast_neg</span><span class=\"o\">,</span> <span class=\"n\">cast_div</span><span class=\"o\">,</span> <span class=\"n\">neg_div_neg_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">zify</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">int.abs_eq_nat_abs</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">abs_pos</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">ne_of_lt</span> <span class=\"n\">b_lt</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221402251,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609597946
    },
    {
        "content": "<p>That's not what the version in mathlib master looks like.</p>",
        "id": 221402417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609598278
    },
    {
        "content": "<p>Oh, I hadn't realized that: I simply used the version that came with the liouville PR...</p>",
        "id": 221404219,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609601492
    },
    {
        "content": "<p>Anyway, the above should work, right?  It appears to work on my computer</p>",
        "id": 221404225,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609601512
    },
    {
        "content": "<p>it doesn't work for me with mathlib master. Maybe you should merge master into the branch and fix up issues?</p>",
        "id": 221405197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609603099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221404219\">said</a>:</p>\n<blockquote>\n<p>Oh, I hadn't realized that: I simply used the version that came with the liouville PR...</p>\n</blockquote>\n<p>The version of data.real.irrational which comes with the PR we're talking about does not have <code>irrational_of_ne_int_div_pos_nat</code> either. I don't know what you posted! But it seems to me that sticking with mathlib master is a better idea.</p>",
        "id": 221405461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609603520
    },
    {
        "content": "<p>Ok, once I am back at my computer, I will <code>git pull</code> and then proceed from there!</p>\n<p>Given that we are here, what is the proof with the <code>|</code>?  From what I picked up in other threads, this might be called the \"equation compiler\"?  Or something like this?</p>",
        "id": 221405542,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609603625
    },
    {
        "content": "<p>Yeah it's the equation compiler. It's just induction or recursion, if you use it with naturals. It's <code>blah.rec</code> but with a different syntax.</p>",
        "id": 221405546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609603662
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fibonacci</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">fibonacci</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fibonacci</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If you think about it, it's done something clever here, because usual (weak) induction would not have access to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 221405600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609603721
    },
    {
        "content": "<p>I see.  So the <code>rintro ⟨⟩</code> bit in the proof above is to let Lean know that this (<code>a = 0</code>) contradicts one of the assumptions, right?</p>",
        "id": 221405686,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609603874
    },
    {
        "content": "<p>Right. The three inputs after the <code>|</code> are a,b,c, and so after the := the goal is <code>0 &lt; 0 -&gt; ...</code> and I kill it with <code>rintro ⟨⟩</code> because I know that <code>&lt;</code> on nat is defined as an inductive Prop and that there aren't any cases.</p>",
        "id": 221405764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604030
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span>\n</code></pre></div>",
        "id": 221405808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604076
    },
    {
        "content": "<p>Ok, thanks for the explanation!  It is a little imperscrutable, since in term mode, the sidebar is not particularly friendly, if you are trying to figure out how the syntax works!</p>",
        "id": 221405882,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609604220
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h_ᾰ</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>That proof is bad because it contains the character of which we should not speak, but I don't know how to name it.</p>",
        "id": 221405886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604226
    },
    {
        "content": "<p>This proof actually can be golfed away completely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>I can't find any way to use this trick with the equation compiler though.</p>",
        "id": 221405939,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609604318
    },
    {
        "content": "<p>You can always use <code>begin sorry end</code> to try and figure out what the heck is going on anywhere. The syntax is: you don't use <code>:=</code>, you use <code>|</code> and then the inputs are all the things after the colon. It's all explained in chapters 7 and 8 of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> so I have known it for a while, but I totally agree that it doesn't really seem to come up that often in proper maths!</p>",
        "id": 221405940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604319
    },
    {
        "content": "<p>Here Bryan's full stop means \"we have finished\" -- and something (I thought it was the equation compiler!) verifies that indeed there are no cases.</p>",
        "id": 221405954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604368
    },
    {
        "content": "<p>Ah, maybe it is related to the equation compiler. I just mean that I don't know how to use that in your proof of <code>nat.lt_mul_of_pos_of_lt</code>.</p>",
        "id": 221406080,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609604619
    },
    {
        "content": "<p>Ok, it is vaguely making sense although I will try to read about it in tpil to see if I understand it better!</p>\n<p>Also, the lemma <code>lt_mul_of_lt_of_one_le</code> exists for an <code>ordered_cancel_comm_monoid</code>, which I guess means that <code>*</code> is the only operation, right?</p>",
        "id": 221406150,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609604734
    },
    {
        "content": "<p>This is weird:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"c1\">-- solves the goal and suggests Try this: rintro (_ | _)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- However, the suggestion doesn't solve the goal:</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">1 goal</span>\n<span class=\"cm\">ᾰ_ᾰ: 3.succ.less_than_or_equal 0</span>\n<span class=\"cm\">⊢ 2 + 2 = 5</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221406151,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609604736
    },
    {
        "content": "<p>It doesn't solve the goal for me -- I get the funky metavariable error (I do get Goals Accomplished though!)</p>",
        "id": 221406200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604792
    },
    {
        "content": "<p>Oh, you're right. I missed the red squiggles at the end.</p>\n<p><strong>edit</strong>: I've added this example to <a href=\"https://github.com/leanprover-community/mathlib/issues/2794\">#2794</a>, which has a few other examples like this.</p>",
        "id": 221406210,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609604839
    },
    {
        "content": "<p>I have never got to the bottom of how to name that variable though. Yours is even worse than mine -- badsymbol_badsymbol!</p>",
        "id": 221406222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604862
    },
    {
        "content": "<p>Why doesn't <code>rintro (_ | h),</code> work?</p>",
        "id": 221406274,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609604921
    },
    {
        "content": "<p>The unicode name for <code>ᾰ</code> is something like \"alpha with vrachy\", where \"vrachy\" is apparently one name for that diacritic; <a href=\"https://en.wikipedia.org/wiki/Breve\">the Wikipedia article calls it \"breve\"</a>.</p>",
        "id": 221406295,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609604970
    },
    {
        "content": "<p>Oh I think it's because <code>rintro (_ | ⟨_ | _⟩)</code> isn't allowed syntax. Oh it's coming back to me now. You can't hope to do arbitrary unravellings with the <code>rintro</code> syntax, or something.</p>",
        "id": 221406305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609605001
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/rintro.20.3C.20equation.20compiler.3F/near/214405665\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rintro.20.3C.20equation.20compiler.3F/near/214405665</a></p>",
        "id": 221406466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609605219
    },
    {
        "content": "<p>Not sure whether this counts as \"being in mathlib\", but this is also a proof of that lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.lt_mul_of_pos_of_lt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">a0</span> <span class=\"n\">bc</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_lt_mul'</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_le_iff.mpr</span> <span class=\"n\">a0</span><span class=\"o\">)</span> <span class=\"n\">bc</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221406613,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605440
    },
    {
        "content": "<p>Yeah I thought the equation compiler would be a nicer way to do it but I hadn't realised there were three cases.</p>",
        "id": 221406675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609605511
    },
    {
        "content": "<p>That looks ready to PR (after moving as much as you can \"before the colon\").</p>",
        "id": 221406682,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609605542
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.lt_mul_of_pos_of_lt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">mul_lt_mul'</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_le_iff.mpr</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"n\">hbc</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">ha</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(Unfortunately, I am not at my computer, so I will not be able to make this PR, nor would I really know where to put it...)</p>",
        "id": 221406765,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605711
    },
    {
        "content": "<p>Unless one of you makes the PR, I will try to do it later!</p>",
        "id": 221406804,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605729
    },
    {
        "content": "<p>Do you know -- I think I have some kind of conceptual misunderstanding of induction here. I want to say \"OK proof by induction on a. Base case done by contradiction. Inductive step -- we know b&lt;ac and we want b&lt;(a+1)c so done because c&gt;=0\".</p>",
        "id": 221406809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609605742
    },
    {
        "content": "<p>[I'm impressed with all that lean code you're writing if you're not at your computer, by the way]</p>",
        "id": 221406822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609605775
    },
    {
        "content": "<p>In my mind, the step \"multiply by 1 works\" is important, though... no?</p>",
        "id": 221406824,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605784
    },
    {
        "content": "<p>I am at \"a\" computer, though not mine: I am using the online lean editor</p>",
        "id": 221406827,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605802
    },
    {
        "content": "<p>So I do not have the git stuff</p>",
        "id": 221406832,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605813
    },
    {
        "content": "<p><code>b&lt;ac-&gt;b&lt;(a+1)c</code> is always true, and the base case is trivial because it can't happen, so I thought we were done. Is this not a valid proof?</p>",
        "id": 221406844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609605840
    },
    {
        "content": "<p>hmmm, it kind of feels like the \"all horses are white\" proof... I need to think!  I thought that I was a professional mathematician and I am confused by this proof!</p>",
        "id": 221406914,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609605915
    },
    {
        "content": "<p>there is the assumption ha which plays a big role in the base case and then disappears: this feels wrong to me</p>",
        "id": 221406979,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606010
    },
    {
        "content": "<p>(by wrong, I mean for the induction above to work without considering the case a = 1 as well)</p>",
        "id": 221406987,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606041
    },
    {
        "content": "<p>Should this lemma be about <code>ordered_semiring </code> instead of <code>nat</code>?</p>",
        "id": 221406989,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609606055
    },
    {
        "content": "<p>Right! If I put \"0&lt;a\" in the statement P(a) we're proving by induction on a, then the inductive step needs a proof that 0&lt;d to deal with the d+1 case. But if I don't put it in, I can't prove the base case!</p>",
        "id": 221406997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606071
    },
    {
        "content": "<p>Eric we're using 0&lt;a -&gt; 1&lt;=a</p>",
        "id": 221406999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606077
    },
    {
        "content": "<p>This is already in lean for various kind of ordered monoid but under the assumption 1&lt;=a, and furthermore none of the lemmas I could find in mathlib applied to nat, so I figured I'd prove it for nat explicitly and then 1&lt;=a looked a bit daft so I changed it to 0 &lt; a</p>",
        "id": 221407054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606139
    },
    {
        "content": "<p>nat is an ordered_add_monoid but apparently not an ordered_comm_monoid</p>",
        "id": 221407060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221407060\">said</a>:</p>\n<blockquote>\n<p>nat is an ordered_add_monoid but apparently not an ordered_comm_monoid</p>\n</blockquote>\n<p>Doesn't that instance come from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.canonically_ordered_comm_semiring\">docs#nat.canonically_ordered_comm_semiring</a>?</p>",
        "id": 221407139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609606276
    },
    {
        "content": "<p>I am glad that we solved the \"induction\" proof!  It works in that way if we phrase it for <code>a.succ</code>, in which case, the base case is the multiplication by 1, and then the implication that Kevin mentions!</p>",
        "id": 221407196,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606386
    },
    {
        "content": "<p>(Also, the assumption <code>ha</code> does not play any role with <code>a.succ</code>.)</p>",
        "id": 221407204,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606425
    },
    {
        "content": "<p>?? I just assumed that 0 was causing problems and there would be an axiom failing. As far as I can see <code>nat</code> is indeed an <code>ordered_comm_monoid</code>, so in fact one can just use <code>lt_mul_of_one_le_of_lt'</code></p>",
        "id": 221407252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606483
    },
    {
        "content": "<p><code>lt_mul_of_one_le_of_lt'</code> does not unify, though, right?  Am I missing something here?</p>",
        "id": 221407272,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606552
    },
    {
        "content": "<p>I think 0 &lt; a might be defeq to 1 &lt;= a? So it might. The main issue is that either I'm making a stupid mistake (which could easily be the case -- either a maths one or a Lean one) or Lean does not have an instance of <code>ordered_comm_monoid ℕ</code>. I might be missing an import.</p>",
        "id": 221407331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606635
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib_docs/find/lt_mul_of_one_le_of_lt'\">docs#lt_mul_of_one_le_of_lt'</a> for reference)</p>",
        "id": 221407401,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609606747
    },
    {
        "content": "<p>The field <code>ordered_comm_monoid.lt_of_mul_lt_mul_left</code> doesn't hold for <code>ℕ</code>, does it?</p>",
        "id": 221407476,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609606846
    },
    {
        "content": "<p>How does the <code>0</code> in nat interact with the \"ordered_comm_monoid\" that uses <code>1</code> and multiplication?  I feel a little lost...</p>",
        "id": 221407489,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606869
    },
    {
        "content": "<p>should it be an <code>ordered_comm_monoid_with_zero</code> thing?</p>",
        "id": 221407500,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221407476\">said</a>:</p>\n<blockquote>\n<p>The field <code>ordered_comm_monoid.lt_of_mul_lt_mul_left</code> doesn't hold for <code>ℕ</code>, does it?</p>\n</blockquote>\n<p>This is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>. What's your counterexample?</p>",
        "id": 221407529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609606922
    },
    {
        "content": "<p><del>When a = 0...</del></p>",
        "id": 221407549,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606944
    },
    {
        "content": "<p>I don't have one because I can't read implications properly</p>",
        "id": 221407554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609606953
    },
    {
        "content": "<p>Ah, sorry!</p>",
        "id": 221407555,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606953
    },
    {
        "content": "<p>Strict inequality!</p>",
        "id": 221407558,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609606958
    },
    {
        "content": "<p>Does this mean that with an instance of <code>ordered_comm_monoid</code> on nat, then the lemma above is in mathlib?</p>",
        "id": 221407756,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609607243
    },
    {
        "content": "<p>I think so, I'm still doing the axiom :-) It's a long time since I played the natural number game!</p>",
        "id": 221407766,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609607281
    },
    {
        "content": "<p>Yes, the lemma is already in mathlib. When I was looking for the lemma earlier, I tried <code>lt_mul_of_one_le_of_lt</code> and <code>lt_mul_of_one_le_of_lt'</code> and neither of them worked, so I just assumed that <code>nat</code> did not satisfy the axioms of  <code>ordered_cancel_comm_monoid</code> or <code>ordered_comm_monoid</code> and proved the lemma directly for nat.</p>",
        "id": 221407965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609607539
    },
    {
        "content": "<p>I'm trying to define the instance in <code>data/nat/basic.lean</code>, but vs-code seems to really struggle when you start editing that low</p>",
        "id": 221408396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609608187
    },
    {
        "content": "<p>Do you have other files open that are much higher in the import hierarchy?</p>",
        "id": 221408459,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609608250
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nat.lt_of_mul_lt_mul_left</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">contrapose</span><span class=\"bp\">!</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">nat.mul_le_mul_left</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ordered_comm_monoid</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul_le_mul_left</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">nat.mul_le_mul_left</span> <span class=\"n\">k</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">nat.lt_of_mul_lt_mul_left</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">nat.comm_monoid</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">nat.partial_order</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.lt_mul_of_pos_of_lt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">lt_mul_of_one_le_of_lt'</span> <span class=\"n\">ha</span>\n</code></pre></div>",
        "id": 221408465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609608266
    },
    {
        "content": "<p>Yeah, editing data.nat.basic is not much fun nowadays, especially when you're just adding in a lemma because you're proving a theorem about fancy objects much lower down.</p>",
        "id": 221408476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609608299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221408459\">said</a>:</p>\n<blockquote>\n<p>Do you have other files open that are much higher in the import hierarchy?</p>\n</blockquote>\n<p>No, but I have a bunch of unsaved buffers open</p>",
        "id": 221408547,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609608388
    },
    {
        "content": "<p>Btw, this feels like \"second-order golfing\" to me...</p>",
        "id": 221408557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609608429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221408547\">said</a>:</p>\n<blockquote>\n<p>No, but I have a bunch of unsaved buffers open</p>\n</blockquote>\n<p>That might be the culprit. I usually try to just edit as few files at a time as possible, since I think the Lean server isn't actually able to \"close\" a file that it's opened in the same session.</p>",
        "id": 221408713,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609608686
    },
    {
        "content": "<p>So the \"visible files\" setting in vs-code actually means \"all buffers that were at one point visible\"?</p>",
        "id": 221408758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609608740
    },
    {
        "content": "<p>I'm not sure actually... <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> ?</p>",
        "id": 221408801,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609608824
    },
    {
        "content": "<p>It's kind of ironic that to prove the implication <code>b &lt; c → b &lt; a * c</code> it suffices to prove <code>a * b &lt; a * c → b &lt; c</code> which seems to go the wrong way!</p>",
        "id": 221408807,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609608835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221408758\">said</a>:</p>\n<blockquote>\n<p>So the \"visible files\" setting in vs-code actually means \"all buffers that were at one point visible\"?</p>\n</blockquote>\n<p>Yeah, kind of.  \"Visible files\" queues everything that is in a visible file.  If you then close a file, the proofs remain in the queue.</p>",
        "id": 221408952,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1609608987
    },
    {
        "content": "<p>Does restarting the lean server clear the queue?</p>",
        "id": 221409144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609609244
    },
    {
        "content": "<p>Yes, it should.</p>",
        "id": 221409281,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609609451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221406305\">said</a>:</p>\n<blockquote>\n<p>Oh I think it's because <code>rintro (_ | ⟨_ | _⟩)</code> isn't allowed syntax. Oh it's coming back to me now. You can't hope to do arbitrary unravellings with the <code>rintro</code> syntax, or something.</p>\n</blockquote>\n<p>The second part of this is correct, but the first isn't - <code>rintro (_ | ⟨_ | _⟩)</code> is allowed syntax, it just doesn't do what you want here. I'm thinking of closing <a href=\"https://github.com/leanprover-community/mathlib/issues/2794\">#2794</a> unless someone proposes a syntax extension that would allow writing <code>rintro ⟨(a|b), if first_case then (_|_) else ⟨_,_,_⟩⟩</code> which is the general structure of inexpressible patterns.</p>",
        "id": 221409731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609610181
    },
    {
        "content": "<p>Why is this not just <code>rintro ⟨((_|_)|⟨_, _, _⟩)⟩</code>? I clearly still don't understand this properly.</p>",
        "id": 221409880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609610400
    },
    {
        "content": "<p>If there are some cases that can't be handled, is there a way to make <code>rintro?</code> give an error message instead?</p>",
        "id": 221409949,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609610458
    },
    {
        "content": "<p>Actually in the present example the correct match is <code>rintro (_|⟨_,⟨⟩⟩),</code> which is expressible, so there might actually be a bug</p>",
        "id": 221409966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609610480
    },
    {
        "content": "<p>Here's an example of a dependent pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span> <span class=\"bp\">∨</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">ff</span><span class=\"bp\">|</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">pat</span><span class=\"o\">⟩,</span> <span class=\"c1\">-- we need pat to be two things:</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">pat</span> <span class=\"k\">with</span> <span class=\"n\">h1</span><span class=\"bp\">|</span><span class=\"n\">h2</span><span class=\"bp\">|</span><span class=\"n\">h3</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span> <span class=\"c1\">-- an alternation</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">pat</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span> <span class=\"c1\">-- but also a tuple</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221410149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609610716
    },
    {
        "content": "<p>you can't use <code>(h1|h2|h3)|⟨n, h1⟩</code> for <code>pat</code> (try it!) because this actually means \"pattern match <code>pat</code> as if it were <code>(0 &lt; 1 ∨ 2 &lt; 3 ∨ 3 &lt; 4) ∨ ∃ n, n &lt; 3</code>\" which is true of neither case</p>",
        "id": 221410226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609610853
    },
    {
        "content": "<p>Yes here I can see why there is a problem. But I can't see why there's a problem in what I was trying to do -- and I couldn't name my variable either! Is this also expected?</p>",
        "id": 221410285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609610951
    },
    {
        "content": "<p>the first level pattern match is actually <code>_|&lt;_,ha&gt;</code> where <code>ha</code> is the one that is actually in the context</p>",
        "id": 221410348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611033
    },
    {
        "content": "<p>that's because <code>nat.less_than_or_equal</code> is an inductive type with two cases, where the first has one constructor argument and the second has two, the second of which is what appears in the context</p>",
        "id": 221410385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611110
    },
    {
        "content": "<p>Could we have another syntax (maybe <code>a |' b</code> for consistency with the <code>∘'</code> notation for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.dcomp\">docs#function.dcomp</a>) meaning \"use <code>a</code> if it is type-correct else use <code>b</code>\"?</p>",
        "id": 221410431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609611135
    },
    {
        "content": "<p>Using <code>cases</code> makes this confusing because the first case is immediately proven impossible so you don't see it, and the second case has a variable that has been <code>subst</code>'d away so you also don't see it</p>",
        "id": 221410452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611171
    },
    {
        "content": "<p>but rcases requires that you actually give names according to the original shape of the inductive, to make it more predictable</p>",
        "id": 221410469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611232
    },
    {
        "content": "<p>Is there any way to name the hypothesis you get in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- no h in sight</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>?</p>",
        "id": 221410470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609611239
    },
    {
        "content": "<p>Yes, <code>_|&lt;_,h&gt;</code></p>",
        "id": 221410514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611256
    },
    {
        "content": "<p>That's not two pattern matches, it's one</p>",
        "id": 221410516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611264
    },
    {
        "content": "<p>an inductive pattern match is a alt-of-tuples in general</p>",
        "id": 221410526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611285
    },
    {
        "content": "<p>I gave up too early!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">)⟩),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221410542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609611318
    },
    {
        "content": "<p>lol wait till I tell my maths chums that <code>(_|⟨_,(_|_)⟩)</code> is a proof that 1&lt;=3</p>",
        "id": 221410556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609611347
    },
    {
        "content": "<p>by contradiction</p>",
        "id": 221410604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609611370
    },
    {
        "content": "<p>You can actually put any pattern other than a name or underscore in for <code>h</code> to complete the proof. I generally prefer to use <code>&lt;&gt;</code></p>",
        "id": 221410606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611394
    },
    {
        "content": "<p>hence <code>rintro (_|⟨_,⟨⟩⟩),</code></p>",
        "id": 221410624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609611432
    },
    {
        "content": "<p>That would be a great entry for the \"guess the theorem statement given the proof\" competition</p>",
        "id": 221410627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609611450
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,⟨⟩⟩)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221410636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609611473
    },
    {
        "content": "<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib/issues/5576\">#5576</a></p>",
        "id": 221412443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609614088
    },
    {
        "content": "<p>Thanks! I had run into this \"<code>rcases?</code> not working\" thing several times.</p>",
        "id": 221412494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609614133
    },
    {
        "content": "<p>There was a more basic problem with it than I thought, some variable was just not getting passed along as expected</p>",
        "id": 221412521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609614190
    },
    {
        "content": "<p>the stuff about dependent pattern matching is mostly a red herring since that doesn't come up in these examples</p>",
        "id": 221412534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609614221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, do you plan to PR that <code>ordered_comm_monoid nat</code> instance?</p>",
        "id": 221420803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609626546
    },
    {
        "content": "<p>I planned on waiting for someone to tell me what I was doing wrong</p>",
        "id": 221438739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609658741
    },
    {
        "content": "<p>Because surely it's already there</p>",
        "id": 221438748,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609658756
    },
    {
        "content": "<blockquote>\n<p>Because surely it's already there</p>\n</blockquote>\n<p>This is how I always feel when I use Lean...</p>",
        "id": 221439790,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609660576
    },
    {
        "content": "<blockquote>\n<p>That's not what the version in mathlib master looks like.</p>\n</blockquote>\n<p>I could not get to the bottom of what is in <code>master</code> and what is not, but I removed the invocation to the lemma <code>irrational_of_ne_int_div_pos_nat</code>.  Below is the second proof, in case anyone is interested in some more golfing!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">irrational_of_is_liouville</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_liouville</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">irrational</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h_b_pos</span> <span class=\"n\">cop</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">is_liouville</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">q1</span><span class=\"o\">,</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">a1</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">qR0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">exact_mod_cast</span> <span class=\"o\">(</span><span class=\"n\">lt_trans</span> <span class=\"n\">zero_lt_one</span> <span class=\"n\">q1</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">bR0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">h_b_pos</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">h_b_pos</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_sub_div</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">b0</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">qR0</span><span class=\"o\">),</span> <span class=\"n\">abs_div</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a0</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lt_div_iff</span> <span class=\"o\">(</span><span class=\"n\">abs_pos.mpr</span> <span class=\"o\">(</span><span class=\"n\">mul_ne_zero</span> <span class=\"n\">b0</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"n\">qR0</span><span class=\"o\">))),</span> <span class=\"n\">zero_mul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_lt_div_iff</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">pow_pos</span> <span class=\"n\">qR0</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">abs_of_pos</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_pos</span> <span class=\"n\">bR0</span> <span class=\"n\">qR0</span><span class=\"o\">),</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">not_le.mpr</span> <span class=\"n\">a1</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">int.mul_lt_mul_pow_succ</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">a0</span><span class=\"o\">)</span> <span class=\"n\">q1</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">abs_pos.mpr</span> <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">mul_pos</span> <span class=\"n\">bR0</span> <span class=\"n\">qR0</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221447494,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609674546
    },
    {
        "content": "<p>I would be curious to know how to avoid the <code>change</code>, or at least, making it more \"discreet\".  Ideally, I would not want to even see what happens between the <code>cases</code> and <code>change</code>.</p>",
        "id": 221447513,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609674596
    },
    {
        "content": "<p>Ah, thanks Kevin!  (I believe that you were addressing to me in the other thread!)</p>",
        "id": 221447564,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609674670
    },
    {
        "content": "<p>You can <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/real/irrational.lean\">look on GitHub</a> to get a definitive answer as to what <code>master</code> looks like. Or just switch to <code>master</code> on the bottom left of VS code and then pull.</p>",
        "id": 221447565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609674677
    },
    {
        "content": "<p>I am now only using the very first lemma from <code>data.real.irrational</code>, which also appears in <code>master</code>!</p>",
        "id": 221447568,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609674702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/221438748\">said</a>:</p>\n<blockquote>\n<p>I planned on waiting for someone to tell me what I was doing wrong</p>\n<p>Because surely it's already there</p>\n</blockquote>\n<p>I think the fact that a few of us weren't able to find it here is good enough motivation to open a PR. There are already too many lemmas that appear in Zulip and never make it to mathlib (not to mention all the ones in various <code>for_mathlib</code> folders in various repos...).</p>",
        "id": 221460201,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609693379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I won't get to this today now, feel free to PR.</p>",
        "id": 221462516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609696234
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5645\">#5645</a></p>",
        "id": 221794545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609953440
    },
    {
        "content": "<p>^ now merged</p>",
        "id": 222122354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610138163
    },
    {
        "content": "<p>Dear All,</p>\n<p>I just pushed a newer version of PR <a href=\"https://github.com/leanprover-community/mathlib/issues/4301\">#4301</a>.  Many lemmas in the file <code>analysis/transcendental/liouville_constant</code> could be moved to different files, but I am doubtful that they could be useful for other theorems.  What is the standard approach?  Should I still scatter them across mathlib?</p>\n<p>Thanks!</p>",
        "id": 224593213,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1612024297
    },
    {
        "content": "<p>Eric suggested using a more \"metric space\" approach to the definition of <code>is_liouville</code>.  While working on this, I had also tried out a similar approach.  The statements are all relatively easy to prove with either definition.  I ended up going with the \"classical\" definition (see below).</p>\n<p>If anyone is seriously thinking of formalizing some continued fractions stuff (à la Khinchin), they may have a serious preference for a specific one.  I personally do not mind much, since the definition is used very superficially in the Liouville story.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- classical</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_liouville</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- Eric's \"ordered\" suggestion</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_liouville</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Ioo</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- a \"topological\" definition</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_liouville</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">metric.ball</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">q.2</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 224602608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1612037243
    },
    {
        "content": "<p>I don't know much about continued fractions, but we have have a bunch about them in mathlib already.</p>",
        "id": 224602677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1612037328
    },
    {
        "content": "<p>Ok, so then it does not matter much what definition we use!</p>\n<p>In fact, might there already be a version of the <code>is_liouville</code> definition?</p>",
        "id": 224603366,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1612038309
    },
    {
        "content": "<blockquote>\n<p>Ok, so then it does not matter much what definition we use!</p>\n</blockquote>\n<p>Of course this is the real answer. All three versions should be available and it shouldn't matter which is the definition</p>",
        "id": 224603603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612038684
    },
    {
        "content": "<p>that said, in the \"classical\" version it seems a little circumspect to say <code>0 &lt; abs (x - a / b)</code> instead of <code>x != a / b</code></p>",
        "id": 224603649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612038733
    },
    {
        "content": "<p>Ok, I nothing else, I will at least change <code>0 &lt; abs (x - a / b)</code> to <code>x != a / b</code>!  Not tonight, though!</p>",
        "id": 224605692,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1612041736
    },
    {
        "content": "<p>A quick update.</p>\n<p>First, the definition of <code>is_liouville</code> is now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_liouville</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Second, in the current usage, the definition spills out in three places:</p>\n<ol>\n<li>when proving that a Liouville number is not rational;</li>\n<li>when proving that a Liouville number is transcendental (using 1);</li>\n<li>when arguing that, for any natural <code>m</code> with <code>2 &lt; m</code>, the sum of the series</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∑'</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">m</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>satisfies the definition.</p>\n<p>Thus, any change in the definition only needs to be adapted in these three lemmas: this is a very minor change!</p>\n<p>I will keep the definition with <code>≠</code> and <code>abs</code> (the one in this post), since it is the one that is already in the file.  If anyone has an even tenuous argument to prefer a different definition, let me know!</p>",
        "id": 224627955,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1612076477
    },
    {
        "content": "<p>One more step in the Liouville saga: I created PR <a href=\"https://github.com/leanprover-community/mathlib/issues/6158\">#6158</a> that only introduces the definition of Liouville numbers and proves that they are irrational.</p>\n<p>A proof of their transcendence is forth-coming, but this is a small PR, which hopefully can get merged!</p>",
        "id": 225954541,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613026847
    },
    {
        "content": "<p>One more step: PR <a href=\"https://github.com/leanprover-community/mathlib/issues/6201\">#6201</a>.</p>\n<p>This PR contains three lemmas, two specific for Liouville and one about membership in an <code>Icc</code>.  The two lemmas are somewhat technical.  They lead directly to the proof of transcendence of Liouville numbers.  I left out the proof of transcendence to keep the PR short: as it is, it add 79 lines (including a few doc-strings).</p>\n<p>In case it helps, below you can see the proof of transcendence, based on the results in the PR: I will create a PR with the <del>lemma</del> theorem below, once the version in the current PR stabilizes.</p>\n<p>As usual, comments, suggestions, improvements and general chat are more than welcome!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">transcendental</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">liouville_x</span> <span class=\"o\">:</span> <span class=\"n\">liouville</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_transcendental</span> <span class=\"n\">ℤ</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">f0</span><span class=\"o\">,</span> <span class=\"n\">ef0</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">replace</span> <span class=\"n\">ef0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f.map</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">aeval_def</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">eval_map</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ef0</span> <span class=\"o\">},</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">exists_pos_real_of_irrational_root</span> <span class=\"n\">liouville_x.irrational</span> <span class=\"n\">f0</span> <span class=\"n\">ef0</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">pow_unbounded_of_one_lt</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">lt_add_one</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">a1</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">liouville_x</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">f.nat_degree</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">zero_lt_one.trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">int.cast_one</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">int.cast_lt.mpr</span> <span class=\"n\">b1</span> <span class=\"o\">}),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">lt_irrefl</span> <span class=\"o\">((</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lt_div_iff'</span> <span class=\"o\">(</span><span class=\"n\">pow_pos</span> <span class=\"n\">b0</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">_</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">lt_div_iff'</span> <span class=\"n\">hA</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"n\">_</span> <span class=\"n\">a1</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul_of_nonneg_right</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mul_nonneg</span> <span class=\"o\">(</span><span class=\"n\">pow_nonneg</span> <span class=\"n\">b0.le</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">abs_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hn.le.trans</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">pow_le_pow_of_le_left</span> <span class=\"n\">zero_le_two</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">int.cast_two.symm.le.trans</span> <span class=\"o\">(</span><span class=\"n\">int.cast_le.mpr</span> <span class=\"o\">(</span><span class=\"n\">int.add_one_le_iff.mpr</span> <span class=\"n\">b1</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">lift</span> <span class=\"n\">b</span> <span class=\"n\">to</span> <span class=\"n\">ℕ</span> <span class=\"n\">using</span> <span class=\"n\">zero_le_one.trans</span> <span class=\"n\">b1.le</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b.pred</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_pred_eq_of_pos</span> <span class=\"o\">(</span><span class=\"n\">zero_lt_one.trans</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">div_le_iff</span> <span class=\"n\">hA</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">int.coe_nat_lt.mp</span> <span class=\"n\">b1</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226148913,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613142839
    },
    {
        "content": "<p>I have a general comment on the style: in a perfect world, Lean proofs should be as readable as proofs one would write in a math article (ok, for some papers that doesn't mean a lot :-). So, anything that can help to follow the stream of arguments is welcome, be it comments, or <code>obtain</code> statements instead of <code>rcases</code> (to announce what you are getting from the rcases), or additional <code>have</code> to show where you are going, or <code>suffices</code>, or whatever: it helps a lot to say what you are doing instead of applying a sequence of tactics to the main goal without every showing how it looks like currently.</p>\n<p>(I don't think everyone here is on this readability line, but most people probably (hopefully? :-))</p>",
        "id": 226152664,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1613144285
    },
    {
        "content": "<p>My personal preference would be to add comments: I find that Lean seems to like very much tactics such as <code>refine</code> and <code>exact</code>, progressively less <code>rw</code>, <code>have</code>, <code>obtain</code>, <code>apply</code>, <code>convert</code>.</p>\n<p>If you want, I can add comments just before the \"important\" steps, explaining what they achieve.  Would that be reasonable?</p>",
        "id": 226153458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613144614
    },
    {
        "content": "<p>Yes, that's perfectly reasonable. As in papers, people have different ways of writing, and that's normal!</p>",
        "id": 226153952,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1613144871
    },
    {
        "content": "<p>I totally agree with Sébastien and my experiments with verbose tactics for teaching make me think we could write <em>much</em> more readable tactic proofs, even without modifying existing tactics.</p>",
        "id": 226154340,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1613145027
    },
    {
        "content": "<p>Can any of the inequality manipulation be done with <code>calc</code> here? That's my reaction when seeing a lot of <code>.trans</code> terms.</p>",
        "id": 226154705,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613145189
    },
    {
        "content": "<p>Would this style of comments be good?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_pos_real_of_irrational_root</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">irrational</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f0</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">eval</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">b.succ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b.succ</span><span class=\"o\">)))</span> <span class=\"bp\">*</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"c1\">-- fR is f viewed as a polynomial with ℝ coefficients.</span>\n  <span class=\"n\">set</span> <span class=\"n\">fR</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"c1\">-- fR is non-zero, since f is non-zero.</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">fR0</span> <span class=\"o\">:</span> <span class=\"n\">fR</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">fR0</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">map_injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ne</span>\n    <span class=\"n\">f0</span> <span class=\"o\">(</span><span class=\"n\">fR0.trans</span> <span class=\"o\">(</span><span class=\"n\">polynomial.map_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span>\n<span class=\"c1\">-- reformulating assumption fa: α is a root of fR.</span>\n  <span class=\"k\">have</span> <span class=\"n\">ar</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">fR.roots.to_finset</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">finset.mem_coe.mpr</span> <span class=\"o\">(</span><span class=\"n\">multiset.mem_to_finset.mpr</span> <span class=\"o\">((</span><span class=\"n\">mem_roots</span> <span class=\"n\">fR0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">is_root.def.mpr</span> <span class=\"n\">fa</span><span class=\"o\">))),</span>\n<span class=\"c1\">-- Since the fR has finitely many roots, there is a closed interval centered at α such that α is</span>\n<span class=\"c1\">-- the only root of fR in the interval.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ζ</span><span class=\"o\">,</span> <span class=\"n\">z0</span><span class=\"o\">,</span> <span class=\"n\">U</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">exists_closed_ball_inter_eq_singleton_of_discrete</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">discrete_of_t1_of_finite</span> <span class=\"n\">_</span> <span class=\"n\">ar</span><span class=\"o\">,</span>\n<span class=\"c1\">-- Since fR is continuous, it is bounded on the interval above.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">xm</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h_x_max_range</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">is_compact.exists_forall_ge</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">compact_Icc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"n\">ζ</span><span class=\"o\">))</span>\n    <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sub_lt_self</span> <span class=\"n\">α</span> <span class=\"n\">z0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">lt_add_of_pos_right</span> <span class=\"n\">α</span> <span class=\"n\">z0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">⟩</span>\n    <span class=\"o\">(</span><span class=\"n\">continuous_abs.comp</span> <span class=\"n\">fR.derivative.continuous_aeval</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuous_on</span><span class=\"o\">,</span>\n<span class=\"c1\">-- Use the key lemma above: we are left to show that</span>\n<span class=\"c1\">-- 1: denominators are positive</span>\n<span class=\"c1\">-- 2: the polynomial fR is Lipschits at α</span>\n<span class=\"c1\">-- 3: the weird inequality of Liouville type with powers of the denominators.</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">exists_one_le_pow_mul_dist</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">fR.eval</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">ζ</span>\n    <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">fR.derivative.eval</span> <span class=\"n\">xm</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">z0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">a</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"c1\">-- 1: the denominators are positive -- essentially by definition;</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">one_le_pow_of_one_le</span> <span class=\"o\">((</span><span class=\"n\">le_add_iff_nonneg_left</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">a.cast_nonneg</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">},</span> <span class=\"c1\">--simp</span>\n<span class=\"c1\">-- 2: the polynomial fR is Lipschits at α -- as it's derivative continuous;</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">closed_ball_Icc</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n<span class=\"c1\">-- apply the Mean value theorem: the bound on the derivative comes from differentiability.</span>\n    <span class=\"n\">refine</span> <span class=\"n\">convex.norm_image_sub_le_of_norm_deriv_le</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">fR.differentiable_at</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">fR.deriv</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hM</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">convex_Icc</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hy</span> <span class=\"o\">(</span><span class=\"n\">mem_Icc_iff_abs_le.mp</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">mem_closed_ball_self</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">α</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">z0</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n<span class=\"c1\">-- 3: weird, Liouville-like inequality.</span>\n  <span class=\"o\">{</span> <span class=\"k\">show</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">α</span> <span class=\"n\">fR</span> <span class=\"bp\">-</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">fR</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">zero_sub</span><span class=\"o\">,</span> <span class=\"n\">abs_neg</span><span class=\"o\">],</span>\n<span class=\"c1\">-- key observation: the right-hand side of the inequality is an *integer*.  Therefore,</span>\n<span class=\"c1\">-- if its absolute value is not at least one, then it vanishes.  Proceed by contradiction</span>\n    <span class=\"n\">refine</span> <span class=\"n\">one_le_pow_mul_abs_eval_div</span> <span class=\"o\">(</span><span class=\"n\">int.coe_nat_succ_pos</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"c1\">-- If the evaluation of the polynomial vanishes, then we found a root of fR that is rational.</span>\n<span class=\"c1\">-- We know that α is the only root of fR in our interval, and α is irrational: follow your nose.</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">irrational_iff_ne_rational</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ha</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">mem_singleton_iff.mp</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_coe.mp</span> <span class=\"o\">(</span><span class=\"n\">multiset.mem_to_finset.mpr</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mem_roots</span> <span class=\"n\">fR0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">is_root.def.mpr</span> <span class=\"n\">hy</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226155685,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613145569
    },
    {
        "content": "<p>If so, I can produce similar comments for other proofs.</p>",
        "id": 226155742,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613145588
    },
    {
        "content": "<p>Unindenting the comments like that leads to weird code-folding in vs-code, so I'd be inclined to indent them to align with the code</p>",
        "id": 226157581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613146325
    },
    {
        "content": "<p>I think they should match indentation</p>",
        "id": 226157602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613146335
    },
    {
        "content": "<p>Comments indented above!</p>",
        "id": 226161242,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613147924
    },
    {
        "content": "<p>Comments in <code>{}</code> should probably match the local indentation too</p>",
        "id": 226161835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613148186
    },
    {
        "content": "<p>I sometimes use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"c1\">-- comment</span>\n  <span class=\"n\">first</span> <span class=\"n\">line</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- comment</span>\n  <span class=\"n\">second</span> <span class=\"n\">line</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>for comments associated to the first line of a block</p>",
        "id": 226162053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613148270
    },
    {
        "content": "<p>I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- comment</span>\n<span class=\"o\">{</span> <span class=\"n\">first</span> <span class=\"n\">line</span><span class=\"o\">,</span>\n  <span class=\"bp\">...</span>\n</code></pre></div>\n<p>is also fine but is better for describing the whole branch</p>",
        "id": 226162137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613148312
    },
    {
        "content": "<p>I think that, accidentally, the commenting above already matches these conventions.<br>\nA comment of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"c1\">-- comment</span>\n  <span class=\"o\">{</span> <span class=\"n\">tactics</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>applies to the whole branch, otherwise it applies almost exactly to the following tactic.</p>",
        "id": 226163316,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613148774
    },
    {
        "content": "<p>Is the consensus that adding these comments makes the PR better?  Should I systematically add similar comments to the longer proofs in the PR?</p>",
        "id": 226163650,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613148918
    },
    {
        "content": "<p>Lipschits → Lipschitz, but now I can roughly follow the proof, so that's nice</p>",
        "id": 226164212,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1613149150
    },
    {
        "content": "<p>Great: thanks for the typo and the feedback!<br>\n[Typo corrected.]</p>",
        "id": 226164407,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613149217
    },
    {
        "content": "<p>I think that's great! One thing you could add in the <code>obtain</code>s is to give the type explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ζ</span><span class=\"o\">,</span> <span class=\"n\">z0</span><span class=\"o\">,</span> <span class=\"n\">U</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ζ</span><span class=\"o\">,</span> <span class=\"bp\">...</span>   <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">exists_closed_ball_inter_eq_singleton_of_discrete</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">discrete_of_t1_of_finite</span> <span class=\"n\">_</span> <span class=\"n\">ar</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>where the <code>...</code> should be filled with the type: then the reader knows exactly what <code>z0</code> and <code>U</code> are.</p>",
        "id": 226165209,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1613149525
    },
    {
        "content": "<p>Now with explicit Type assignments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_pos_real_of_irrational_root</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">irrational</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f0</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">eval</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">b.succ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b.succ</span><span class=\"o\">)))</span> <span class=\"bp\">*</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- fR is f viewed as a polynomial with ℝ coefficients.</span>\n  <span class=\"n\">set</span> <span class=\"n\">fR</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- fR is non-zero, since f is non-zero.</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">fR0</span> <span class=\"o\">:</span> <span class=\"n\">fR</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">fR0</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">map_injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">int.cast_inj.mp</span> <span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ne</span>\n    <span class=\"n\">f0</span> <span class=\"o\">(</span><span class=\"n\">fR0.trans</span> <span class=\"o\">(</span><span class=\"n\">polynomial.map_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- reformulating assumption fa: α is a root of fR.</span>\n  <span class=\"k\">have</span> <span class=\"n\">ar</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">fR.roots.to_finset</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">finset.mem_coe.mpr</span> <span class=\"o\">(</span><span class=\"n\">multiset.mem_to_finset.mpr</span> <span class=\"o\">((</span><span class=\"n\">mem_roots</span> <span class=\"n\">fR0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">is_root.def.mpr</span> <span class=\"n\">fa</span><span class=\"o\">))),</span>\n  <span class=\"c1\">-- Since the fR has finitely many roots, there is a closed interval centered at α such that α is</span>\n  <span class=\"c1\">-- the only root of fR in the interval.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ζ</span><span class=\"o\">,</span> <span class=\"n\">z0</span><span class=\"o\">,</span> <span class=\"n\">U</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ζ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">closed_ball</span> <span class=\"n\">α</span> <span class=\"n\">ζ</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">fR.roots.to_finset</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">exists_closed_ball_inter_eq_singleton_of_discrete</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">discrete_of_t1_of_finite</span> <span class=\"n\">_</span> <span class=\"n\">ar</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Since fR is continuous, it is bounded on the interval above.</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">xm</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">xm</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">xm</span> <span class=\"bp\">∈</span> <span class=\"n\">Icc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"n\">ζ</span><span class=\"o\">)),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span>\n    <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">Icc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">derivative</span> <span class=\"n\">fR</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">xm</span> <span class=\"o\">(</span><span class=\"n\">derivative</span> <span class=\"n\">fR</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n    <span class=\"n\">is_compact.exists_forall_ge</span> <span class=\"o\">(</span><span class=\"n\">compact_Icc</span><span class=\"o\">)</span>\n    <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sub_lt_self</span> <span class=\"n\">α</span> <span class=\"n\">z0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">lt_add_of_pos_right</span> <span class=\"n\">α</span> <span class=\"n\">z0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">⟩</span>\n    <span class=\"o\">(</span><span class=\"n\">continuous_abs.comp</span> <span class=\"n\">fR.derivative.continuous_aeval</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuous_on</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Use the key lemma `exists_one_le_pow_mul_dist`: we are left to show that</span>\n  <span class=\"c1\">-- 1: denominators are positive</span>\n  <span class=\"c1\">-- 2: the polynomial fR is Lipschitz at α</span>\n  <span class=\"c1\">-- 3: the weird inequality of Liouville type with powers of the denominators.</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">exists_one_le_pow_mul_dist</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">fR.eval</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">ζ</span>\n    <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">fR.derivative.eval</span> <span class=\"n\">xm</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">z0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">a</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- 1: the denominators are positive -- essentially by definition;</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">one_le_pow_of_one_le</span> <span class=\"o\">((</span><span class=\"n\">le_add_iff_nonneg_left</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">a.cast_nonneg</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- 2: the polynomial fR is Lipschits at α -- as it's derivative continuous;</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">closed_ball_Icc</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- apply the Mean value theorem: the bound on the derivative comes from differentiability.</span>\n    <span class=\"n\">refine</span> <span class=\"n\">convex.norm_image_sub_le_of_norm_deriv_le</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">fR.differentiable_at</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">fR.deriv</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hM</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">convex_Icc</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hy</span> <span class=\"o\">(</span><span class=\"n\">mem_Icc_iff_abs_le.mp</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">mem_closed_ball_self</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">α</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">z0</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- 3: weird, Liouville-like inequality.</span>\n  <span class=\"o\">{</span> <span class=\"k\">show</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">α</span> <span class=\"n\">fR</span> <span class=\"bp\">-</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">fR</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">zero_sub</span><span class=\"o\">,</span> <span class=\"n\">abs_neg</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- key observation: the right-hand side of the inequality is an *integer*.  Therefore,</span>\n    <span class=\"c1\">-- if its absolute value is not at least one, then it vanishes.  Proceed by contradiction</span>\n    <span class=\"n\">refine</span> <span class=\"n\">one_le_pow_mul_abs_eval_div</span> <span class=\"o\">(</span><span class=\"n\">int.coe_nat_succ_pos</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- If the evaluation of the polynomial vanishes, then we found a root of fR that is rational.</span>\n    <span class=\"c1\">-- We know that α is the only root of fR in our interval, and α is irrational: follow your nose.</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">irrational_iff_ne_rational</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ha</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">mem_singleton_iff.mp</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_coe.mp</span> <span class=\"o\">(</span><span class=\"n\">multiset.mem_to_finset.mpr</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mem_roots</span> <span class=\"n\">fR0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">is_root.def.mpr</span> <span class=\"n\">hy</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226167966,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613150628
    },
    {
        "content": "<p>By the way, thank you all for your contributions!  I will annotate the PR and push the outcome.</p>",
        "id": 226168224,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613150725
    },
    {
        "content": "<p>I pushed the annotated version of the PR.  I hope that this helps with the review and the further enjoyment of the proofs!</p>",
        "id": 226172375,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613152278
    },
    {
        "content": "<p>Honestly, it is extra work to annotate, but it is also gratifying to explain stuff without having to justify it in too much details... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 226172581,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613152357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.235361.20Liouville/near/226172581\">said</a>:</p>\n<blockquote>\n<p>Honestly, it is extra work to annotate, but it is also gratifying to explain stuff without having to justify it in too much details... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I never miss an opportunity to emphasize I see this as part of our great goals: I don't want formalized mathematics to <em>replace</em> sloppy explanations, I want them to allow me to write even sloppier and nicer to read explanations without fear.</p>",
        "id": 226173312,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1613152651
    },
    {
        "content": "<p>Just to say that this is exactly how I write the proofs I show the undergraduates, see e.g. <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/cfce84efd51a5f34fd13b5aaf58250845d1d33f3/src/week_4/solutions/Part_C_topology.lean#L144-L291\">yesterday's lecture</a> on topology done the old-fashioned way.</p>",
        "id": 226173524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613152730
    },
    {
        "content": "<p>Ah, thanks Kevin: I will take inspiration!</p>",
        "id": 226173907,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613152874
    },
    {
        "content": "<p>To be quite honest I think that this is the way to write formalised mathematics. The only reason I don't write it like this in mathlib is that I just copy how other people write it, and nobody wrote it like this in 2018. I think it's a great idea to have proofs like this in mathlib, and if people aren't going to object this is great news.</p>",
        "id": 226174076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613152937
    },
    {
        "content": "<p>Mathlib in 2017 contained a very large number of very short term mode proofs and far fewer longer tactic mode proofs, because of the nature of what was there (we still had 2000+ lines of data.multiset.basic but we didn't have e.g. the complex numbers). But now the entire nature of the library has changed so it's not unreasonable to imagine that the proof style can change too.</p>",
        "id": 226174304,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613153037
    },
    {
        "content": "<p>I can sympathize with the fact that a one-line term-mode proof of a conclusion that is essentially equivalent to the hypothesis may not require a commented proof.  However, I do agree with you Kevin: following an informal proof along a formalized one is very useful, at least to me!</p>",
        "id": 226174672,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613153192
    },
    {
        "content": "<p>I think that as soon as the proofs have some math content it is a very good idea to comment them. (I should do this more.) But of course all the silly boring simp-lemmas should be golfed into oblivion. They are just there because the API needs them, not to enlighten the reader.</p>",
        "id": 226174696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613153213
    },
    {
        "content": "<p>For those who cannot get enough of annotated Liouville proofs, I also PRed a proof that a Liouville number is transcendental: <a href=\"https://github.com/leanprover-community/mathlib/issues/6204\">#6204</a>!</p>",
        "id": 226177820,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1613154802
    }
]
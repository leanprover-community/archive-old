[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> has made a really nice PR with the definition of bilinear forms. At some point in the theory, you need to konw that <code>2</code> is invertible in the base ring. We need to make a design choice here. I would like to have some more eyes and brains on this code. Will the current approach play well, or should we try something else?</p>",
        "id": 194963719,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587576040
    },
    {
        "content": "<p>½ is such a fundamental thing. Maybe it even makes sense to add a type class specifically for this.</p>",
        "id": 194972204,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587579997
    },
    {
        "content": "<p>I agree. Characteristic different from <code>2</code> is an assumption that shows up really often (notably when dealing with quadratic forms :)</p>",
        "id": 194972814,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587580306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/194972204\" title=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/194972204\">said</a>:</p>\n<blockquote>\n<p>½ is such a fundamental thing. Maybe it even makes sense to add a type class specifically for this.</p>\n</blockquote>\n<p>I like the notation!</p>",
        "id": 194973202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587580468
    },
    {
        "content": "<p>½ or <code>2 ≠ 0</code>?</p>",
        "id": 194982845,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1587585124
    },
    {
        "content": "<p>Probably ½</p>",
        "id": 194982889,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1587585149
    },
    {
        "content": "<p>You need ½ for this quadratic forms business (e.g., Z[½] is fine even though it's not a field, but Z is not even though 2 ≠ 0). But it's not clear to me how to organize it with respect to the algebraic hierarchy.</p>",
        "id": 194983593,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587585489
    },
    {
        "content": "<p>I mean, obviously you need some axioms about ½</p>",
        "id": 194983638,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587585509
    },
    {
        "content": "<p><code>is_unit 2</code>?</p>",
        "id": 194984876,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1587586090
    },
    {
        "content": "<p>Or <code>½ * 2 = 2 * ½ = 1</code> if we want to allow computable instances (probably yes).</p>",
        "id": 194984942,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1587586128
    },
    {
        "content": "<p>So, maybe we add <code>has_half</code> as a class that only captures the data of the term and enables the notation (like <code>has_zero</code> and <code>has_one</code>) and another class</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">two_invertible</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">has_half</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">half_mul_two</span> <span class=\"o\">:</span> <span class=\"err\">½</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">two_mul_half</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"err\">½</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>What do people think of this idea? (In particular, I'd like to know what <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> thinks.)</p>",
        "id": 195017190,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587615189
    },
    {
        "content": "<p>(I don't know if <code>semiring R</code> can be weakened... you need <code>1</code>, <code>2</code> and <code>*</code>. So you probably need <code>has_one</code>, <code>has_mul</code> and <code>has_add</code>? Maybe also <code>has_zero</code>?</p>",
        "id": 195017253,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587615268
    },
    {
        "content": "<p>Why not parameterize this over <code>2</code>?</p>",
        "id": 195017915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587616259
    },
    {
        "content": "<p>like <code>invertible a</code> for numeral <code>a</code></p>",
        "id": 195017922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587616272
    },
    {
        "content": "<p>I'm not a fan of the notation though. It's a bit hard to see in a monospace font</p>",
        "id": 195017932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587616315
    },
    {
        "content": "<p>plus it's yet another way to express this constant, making simp normal form more complicated</p>",
        "id": 195017987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587616377
    },
    {
        "content": "<p>I like the idea of parametrising. We need a \"characteristic does not divide the order of G\" class, and <code>invertible (fintype.card G)</code> seems pretty good.</p>",
        "id": 195018195,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587616687
    },
    {
        "content": "<p>Is there any reasonable definition of <code>has_div</code> for Z[1/2] that does some suitable truncation?</p>",
        "id": 195018199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587616692
    },
    {
        "content": "<p>I would really like to be able to use <code>1 / 2</code> if possible. <code>rat.cast</code> already does division by zero sometimes if you are in a ring with the wrong characteristic</p>",
        "id": 195018292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587616839
    },
    {
        "content": "<p>I would propose <code>(a * 2^b) / (c * 2^d)</code> (where a and c are odd) evaluates to <code>2^(b-d) * (a / c)</code> with the division evaluated in Z</p>",
        "id": 195018574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587617301
    },
    {
        "content": "<p>that should give the correct result in all reasonable cases, returns 0 on division by 0, and is a kind of p-adic approximation otherwise</p>",
        "id": 195018593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587617378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> So what would your definition of <code>invertible a</code> be? If you want to be able to compute with it (which seems useful, say over finite fields, or the rationals), then we need to record data. But that means that over a generic field of characteristic zero, there will be \"another way\" to express the constant <code>ainv</code>.</p>",
        "id": 195022397,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623232
    },
    {
        "content": "<p>Or can that be avoided?</p>",
        "id": 195022402,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623243
    },
    {
        "content": "<p>it's just proof relevant <code>is_unit</code></p>",
        "id": 195022407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623262
    },
    {
        "content": "<p>I actually thought this already existed</p>",
        "id": 195022416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623278
    },
    {
        "content": "<p>We have <code>units R</code></p>",
        "id": 195022470,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623286
    },
    {
        "content": "<p>But I still don't follow how you want to avoid the extra way of expressing <code>1/a</code>.</p>",
        "id": 195022481,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623319
    },
    {
        "content": "<p>well I want to use <code>has_div</code> to write it, although that is probably an \"extra way\" no matter how you slice it</p>",
        "id": 195022492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623357
    },
    {
        "content": "<p>In general you will not have <code>has_div</code> or <code>has_inv</code> on the ring you are interested in. (Say <code>polynomial (zmod p)</code>)</p>",
        "id": 195022504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623370
    },
    {
        "content": "<p>There is always a way to define it, although it might be noncomputable</p>",
        "id": 195022520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623398
    },
    {
        "content": "<p>But I'm not sure if we want to go noncomputable here.</p>",
        "id": 195022570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623418
    },
    {
        "content": "<p>the main important thing is that the function actually has a unique answer, i.e. no rings where there are two candidates for 1/2</p>",
        "id": 195022574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623427
    },
    {
        "content": "<p>but I think this is impossible in some relatively high generality</p>",
        "id": 195022590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623454
    },
    {
        "content": "<p>that is, <code>a + a = b + b</code> implies <code>a = b</code></p>",
        "id": 195022606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623487
    },
    {
        "content": "<p>If <code>(1/2) * 2 = 1</code> and <code>2 * (1/2) = 1</code>, then <code>(1/2)</code> is unique</p>",
        "id": 195022672,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623537
    },
    {
        "content": "<p>yeah, at least in semirings it works</p>",
        "id": 195022680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623554
    },
    {
        "content": "<p>Which is good enough, I guess?</p>",
        "id": 195022696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623572
    },
    {
        "content": "<p>But I think that either you are working in a concrete ring, in which case you can set up <code>1 / 2</code> to refer to this element if it exists, or you are in some general situation and you can posit the existence of such an element using <code>invertible 2</code></p>",
        "id": 195022728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623634
    },
    {
        "content": "<p>maybe even skipping the notation, just <code>u : units R</code> and <code>u = 2</code></p>",
        "id": 195022781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623674
    },
    {
        "content": "<p>Given an instance of <code>invertible 2</code>, how do you want to refer to the element that is the inverse of <code>2</code>?</p>",
        "id": 195022804,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623702
    },
    {
        "content": "<p><code>invertible.inv 2</code> presumably</p>",
        "id": 195022825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623732
    },
    {
        "content": "<p>or <code>I.inv</code> where <code>I : invertible 2</code> if it's not a class</p>",
        "id": 195022831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623750
    },
    {
        "content": "<p>And what would the definition of <code>I.inv x</code> be?</p>",
        "id": 195022864,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623763
    },
    {
        "content": "<p>pull it out of the struct</p>",
        "id": 195022875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623771
    },
    {
        "content": "<p>Ok, so <code>invertible 2</code> records data? It's not a <code>Prop</code>. Or am I misunderstanding you?</p>",
        "id": 195022893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623805
    },
    {
        "content": "<p>no props</p>",
        "id": 195022895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623811
    },
    {
        "content": "<p><code>is_unit</code> is already around if you want the prop</p>",
        "id": 195022914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587623842
    },
    {
        "content": "<p>Yup, certainly</p>",
        "id": 195022919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623851
    },
    {
        "content": "<p>I think I would like <code>invertible</code> to be a class, and I think I would like to have notation for <code>invertible.inv</code>.</p>",
        "id": 195022995,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587623910
    },
    {
        "content": "<p>I can't think of anything good, so perhaps a local notation using your funny 1/2 symbol will suffice</p>",
        "id": 195023180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587624148
    },
    {
        "content": "<p>I like <code>⅟</code> <a href=\"https://en.wiktionary.org/wiki/%E2%85%9F\" title=\"https://en.wiktionary.org/wiki/%E2%85%9F\">https://en.wiktionary.org/wiki/%E2%85%9F</a></p>",
        "id": 195023570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624621
    },
    {
        "content": "<p>Admittedly, this seems to depend on your font a bit, but <code>⅟2</code> and <code>⅟n</code> seem to read okish.</p>",
        "id": 195023593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624671
    },
    {
        "content": "<p>It's better in the Zulip \"write-your-post\" window, then when it's rendered after posting.</p>",
        "id": 195023620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624713
    },
    {
        "content": "<p>Can we prove that <code>1/2</code> is unique?</p>",
        "id": 195023683,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624776
    },
    {
        "content": "<p>Depends on your axioms</p>",
        "id": 195023699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624806
    },
    {
        "content": "<p>can we construct a semiring with two <code>1/2</code>s?</p>",
        "id": 195023711,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624829
    },
    {
        "content": "<p>What are your axioms on <code>1/2</code>?</p>",
        "id": 195023774,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624888
    },
    {
        "content": "<p>2(1/2) = 1</p>",
        "id": 195023778,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624898
    },
    {
        "content": "<p>Is it a bi-inverse? Or only one-sided?</p>",
        "id": 195023781,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624902
    },
    {
        "content": "<p>oh no</p>",
        "id": 195023788,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624907
    },
    {
        "content": "<p>I didn't realized it wasn't commutative</p>",
        "id": 195023792,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624916
    },
    {
        "content": "<p>Your semiring? It is always noncommutative. Only rings are commutative.</p>",
        "id": 195023807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624937
    },
    {
        "content": "<p>is there a semiring with left 1/2 but not right 1/2?</p>",
        "id": 195023832,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624956
    },
    {
        "content": "<p>I guess Z&lt;X&gt;/(2X-1) or something like that</p>",
        "id": 195023876,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624969
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> In a commutative setup <code>coe : units R → R</code> is injective. Lean knows this.</p>",
        "id": 195023878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624970
    },
    {
        "content": "<p>(removed)</p>",
        "id": 195023891,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587624985
    },
    {
        "content": "<p>Exactly, so I suppose we require that it is a bi-inverse.</p>",
        "id": 195023905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587624999
    },
    {
        "content": "<p>do we have R&lt;X&gt;?</p>",
        "id": 195023917,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625017
    },
    {
        "content": "<p>Do we want it?</p>",
        "id": 195023932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587625035
    },
    {
        "content": "<p>I don't even know where to start if not do it completely stupidly (quotient of inductive)</p>",
        "id": 195023941,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625040
    },
    {
        "content": "<p>what's the other stupid construction that makes it live one universe higher?</p>",
        "id": 195024122,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625191
    },
    {
        "content": "<p>using the universal property Hom(R&lt;X&gt;,S) = S</p>",
        "id": 195024181,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625211
    },
    {
        "content": "<p>I think <code>2*x = x+x = x*2</code> holds in any semiring?</p>",
        "id": 195024349,
        "sender_full_name": "David Wärn",
        "timestamp": 1587625372
    },
    {
        "content": "<p>oh right</p>",
        "id": 195024370,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625403
    },
    {
        "content": "<p>ok that also implies unicity</p>",
        "id": 195024394,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625425
    },
    {
        "content": "<p>Hooray! Thanks for that observation <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span></p>",
        "id": 195024446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587625448
    },
    {
        "content": "<p>yeah, every <code>\\u (n : nat)</code> is in the center of the ring</p>",
        "id": 195024779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587625745
    },
    {
        "content": "<p>I don't think the mathematicians here care about non-commutative rings</p>",
        "id": 195024860,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625807
    },
    {
        "content": "<p>well they need to get over it because they will in 6 months</p>",
        "id": 195024878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587625827
    },
    {
        "content": "<p>what's happening in 6 months?</p>",
        "id": 195024891,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1587625852
    },
    {
        "content": "<p>they decide to work on something that needs noncommutative rings</p>",
        "id": 195024920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587625876
    },
    {
        "content": "<p>and then we have to do a big refactoring project</p>",
        "id": 195024943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587625900
    },
    {
        "content": "<p>Group rings are coming</p>",
        "id": 195025847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587626577
    },
    {
        "content": "<p>And if the group is finite (an important special case, even if you're interested in the Langlands philosophy, because Galois groups are a limit of finite groups) then you'll want to be able to say \"and assume the order of the group is invertible in the base field\"</p>",
        "id": 195025979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587626689
    },
    {
        "content": "<p>So the consensus until now seems to favour an <code>invertible a</code> typeclass, which is also my preferred option.</p>",
        "id": 195027977,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587628326
    },
    {
        "content": "<p>My suggestion is to decouple the proposition from the notation, i.e. have a <code>has_inv_of a</code> class which provides <code>inv_of a</code> (notation: <code>⅟ a</code>?) and <code>invertible a</code> which asserts the relevant equation(s). Perhaps split it into <code>left_invertible</code> and <code>right_invertible</code>?</p>",
        "id": 195027986,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587628342
    },
    {
        "content": "<p>I'm not sure we need a notation typeclass for this</p>",
        "id": 195028007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587628368
    },
    {
        "content": "<p>I would be happy to attach the notation simply to the lawful <code>invertible a</code> typeclass</p>",
        "id": 195028029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587628389
    },
    {
        "content": "<p>I'm thinking that inverses come up in cases where the operation is not <code>*</code>, e.g. for a matrix or for an arrow in a category</p>",
        "id": 195028065,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587628420
    },
    {
        "content": "<p>I think once you get to <code>left_invertible</code> or things other than <code>*</code>, you should just have a hypothesis</p>",
        "id": 195028117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587628448
    },
    {
        "content": "<p>we aren't even abbreviating much at this point</p>",
        "id": 195028134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587628464
    },
    {
        "content": "<p>For me the main point of a typeclass in this area is to be able to talk about \"a field of characteristic not equal to 2 or 3\" when the inverses to 2 and 3 are not the focus of the theorem</p>",
        "id": 195028171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587628521
    },
    {
        "content": "<p>Note that in the basic theory of elliptic curves, \"a field of characteristic not equal to 2 or 3\" is a very common assumption.</p>",
        "id": 195029477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587629418
    },
    {
        "content": "<p>Ring of matrices is a non-commutative ring that I care about.</p>",
        "id": 195029622,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1587629527
    },
    {
        "content": "<p>I mean, <code>linear_map.End</code>.</p>",
        "id": 195029749,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1587629634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195024860\" title=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195024860\">said</a>:</p>\n<blockquote>\n<p>I don't think the mathematicians here care about non-commutative rings</p>\n</blockquote>\n<p>Kenny... after all this time, you still can't recognize when Kevin keeps repeating some absurd stuff he doesn't really believe in?</p>",
        "id": 195034212,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587632623
    },
    {
        "content": "<p>Any number theorist knows that all rings are commutative...unless expressly stated otherwise.</p>",
        "id": 195041833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587637456
    },
    {
        "content": "<p>When I lectured basic homological algebra in Algebra IV a few years ago, I didn't want to talk about abelian categories, so I decided to just talk about the category of R-modules for some fixed commutative ring R. It took a while for me to realise that I never used commutativity of R at all! I was actually quite surprised to find out that R-modules were an abelian category even if R was not an abelian monoid :-)</p>",
        "id": 195042033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587637579
    },
    {
        "content": "<p><a href=\"https://gist.github.com/Vierkantor/e73209684c16b725e29880de7443c9f2\" title=\"https://gist.github.com/Vierkantor/e73209684c16b725e29880de7443c9f2\">I have made a start on an <code>invertible</code> typeclass</a>. One good feature would be to automatically infer <code>invertible (3 : ℚ)</code>. I've tried using <code>invertible (bit0 _)</code> and <code>invertible (bit1 _)</code>, but I can't figure out how to formulate the correct instance for <code>invertible (bit1 a)</code>: we need at least that <code>a ≠ -1/2</code>.</p>",
        "id": 195046433,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587640897
    },
    {
        "content": "<p>Maybe if we had a class that provided the value 1/2...</p>",
        "id": 195047148,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587641402
    },
    {
        "content": "<p>When all you have is a <del>hammer</del> typeclass inference, everything looks like a<del> nail</del>n instance:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span> <span class=\"n\">numeral</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">numeral</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">as_nat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe_eq</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">as_nat</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">coe_as_nat_eq</span> <span class=\"o\">[</span><span class=\"n\">numeral</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">numeral</span><span class=\"bp\">.</span><span class=\"n\">as_nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">numeral</span><span class=\"bp\">.</span><span class=\"n\">coe_eq</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">numeral_zero</span> <span class=\"o\">:</span> <span class=\"n\">numeral</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">numeral_one</span> <span class=\"o\">:</span> <span class=\"n\">numeral</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span> <span class=\"mi\">1</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">numeral_bit0</span> <span class=\"o\">[</span><span class=\"n\">numeral</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">numeral</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">numeral</span><span class=\"bp\">.</span><span class=\"n\">as_nat</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">coe_as_nat_eq</span> <span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">numeral_bit1</span> <span class=\"o\">[</span><span class=\"n\">numeral</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">numeral</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">numeral</span><span class=\"bp\">.</span><span class=\"n\">as_nat</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">coe_as_nat_eq</span> <span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">bit1_nonzero</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">numeral</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bit1</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_ne_zero</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">bit1_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">numeral</span><span class=\"bp\">.</span><span class=\"n\">as_nat</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">coe_as_nat_eq</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">numeral</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">invertible_bit1_of_char_zero</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">numeral</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">(</span><span class=\"n\">bit1_nonzero</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"err\">⅟</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"err\">⅟</span> <span class=\"mi\">37</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"err\">⅟</span> <span class=\"mi\">256</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 195048874,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587642548
    },
    {
        "content": "<p>It suffices to have a typeclass for <code>ge_zero</code></p>",
        "id": 195049157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642738
    },
    {
        "content": "<p><code>nonneg</code> is shorter</p>",
        "id": 195049206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587642767
    },
    {
        "content": "<p>but actually I think I would rather just have instances for 2 and 3</p>",
        "id": 195049230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642783
    },
    {
        "content": "<p>That type class is <code>[fact (0 ≤ n)]</code>, right?</p>",
        "id": 195049238,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587642789
    },
    {
        "content": "<p><code>nonneg</code> assumes an order on the ring though</p>",
        "id": 195049246,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587642800
    },
    {
        "content": "<p>Q has an order fyi</p>",
        "id": 195049253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642808
    },
    {
        "content": "<p>Duh</p>",
        "id": 195049267,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587642815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> How about <code>zmod 5</code>?</p>",
        "id": 195049286,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587642827
    },
    {
        "content": "<p>this isn't true in general... it's true when <code>invertible n</code></p>",
        "id": 195049307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642842
    },
    {
        "content": "<p>what about zmod 5?</p>",
        "id": 195049405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642892
    },
    {
        "content": "<p>What about <code>ℂ</code>?</p>",
        "id": 195049465,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587642926
    },
    {
        "content": "<p>If you have <code>char_zero</code> then there is no need to play around with invertible assumptions</p>",
        "id": 195049492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642950
    },
    {
        "content": "<p>But for representation theory you probably just want to assume you have an alg closed field where |G| is invertible</p>",
        "id": 195049569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587642979
    },
    {
        "content": "<p>and you can do that, with a hypothesis</p>",
        "id": 195049608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587642993
    },
    {
        "content": "<p>who cares how it gets inferred</p>",
        "id": 195049621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587643000
    },
    {
        "content": "<p>I don't think we should be trying to come up with some fancy typeclass mechanism to prove that 7 is invertible in zmod 41</p>",
        "id": 195049687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587643049
    },
    {
        "content": "<p>that's what <code>norm_num</code> is for</p>",
        "id": 195049717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587643075
    },
    {
        "content": "<p>Dang, I was just going to propose writing a fancy metaprogram to take the definition of <code>prime</code> and turn it into a pile of type class instances that test primality Prolog-style.</p>",
        "id": 195049904,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587643189
    },
    {
        "content": "<p>this is absolutely possible, and definitely a bad idea</p>",
        "id": 195049992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587643210
    },
    {
        "content": "<p>I have seen a few examples of these kinds of programs, and they fail surprisingly early because the typeclass depth limit is not calibrated well for them</p>",
        "id": 195050069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587643256
    },
    {
        "content": "<p>I love the way that this started off as a question about 1/2 and has become a conversation about typeclass depth limit.</p>",
        "id": 195050154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587643312
    },
    {
        "content": "<p>Can we make this work?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num_basic</span> <span class=\"o\">:=</span>\n<span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">norm_num</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">loc</span><span class=\"bp\">.</span><span class=\"n\">ns</span> <span class=\"o\">[</span><span class=\"n\">none</span><span class=\"o\">])</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num_basic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_cancel</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mul_inv_cancel</span> <span class=\"n\">h</span> <span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</pre></div>",
        "id": 195051634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644066
    },
    {
        "content": "<p>auto params in typeclass instances currently don't work, but I think this should be fixed in the C++</p>",
        "id": 195051677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644100
    },
    {
        "content": "<p>there are reasons for this decision but I don't think they are very good</p>",
        "id": 195051705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644126
    },
    {
        "content": "<p>There was a big discussion about invoking tactics from type class search, let me see if I can find it.</p>",
        "id": 195051719,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644145
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/instances.20and.20parameters\" title=\"#narrow/stream/113488-general/topic/instances.20and.20parameters\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/instances.20and.20parameters</a> ?</p>",
        "id": 195051834,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587644221
    },
    {
        "content": "<p>Right, specifically starting at <a href=\"#narrow/stream/113488-general/topic/instances.20and.20parameters/near/178609338\" title=\"#narrow/stream/113488-general/topic/instances.20and.20parameters/near/178609338\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/instances.20and.20parameters/near/178609338</a> (but it's just a few messages down)</p>",
        "id": 195051869,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644262
    },
    {
        "content": "<p>I no longer recall what the outcome of that discussion was, though</p>",
        "id": 195051883,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644276
    },
    {
        "content": "<p>Haven't we been told that in Lean 4 it will definitely not be possible to run tactics from inside typeclass search?</p>",
        "id": 195052122,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587644416
    },
    {
        "content": "<p>the linked discussion seems to say the opposite</p>",
        "id": 195052160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644454
    },
    {
        "content": "<p>but I think if you follow it (much) farther, thing became murkier?</p>",
        "id": 195052184,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644477
    },
    {
        "content": "<p>I don't really remember now though</p>",
        "id": 195052191,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644481
    },
    {
        "content": "<p>I'm mostly curious how costly it would be to implement this in lean 3</p>",
        "id": 195052214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644508
    },
    {
        "content": "<p>(costly in terms of development work, not runtime)</p>",
        "id": 195052229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644518
    },
    {
        "content": "<p>I guess the issue was whether you want to be able to backtrack out of tactics that fail</p>",
        "id": 195052291,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644548
    },
    {
        "content": "<p>e.g. zmod n being a field only when n is prime</p>",
        "id": 195052319,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644569
    },
    {
        "content": "<p>I think that it should be implemented in the most straightforward way: tactics get called synchronously in the middle of the search</p>",
        "id": 195052328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644581
    },
    {
        "content": "<p>this puts some constraints on the tactics to not misbehave too badly but I think this is reasonable for a rarely used feature</p>",
        "id": 195052402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644625
    },
    {
        "content": "<p>Anyways, I don't think this approach helps for this PR</p>",
        "id": 195052559,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587644714
    },
    {
        "content": "<p>we might also consider an opt in marker on classes to allow auto params, so that most regular instance searches guarantee no tactic calls</p>",
        "id": 195052576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644726
    },
    {
        "content": "<p>For this PR, we just need an instance <code>invertible (2 : Q)</code>, or perhaps <code>[char_zero A] : invertible (2 : A)</code></p>",
        "id": 195052757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644828
    },
    {
        "content": "<p>maybe we will get another instance for 3 when people start working with elliptic curves</p>",
        "id": 195052829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587644880
    },
    {
        "content": "<p>Only if they choose to focus on Weierstrass form...</p>",
        "id": 195053883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587645468
    },
    {
        "content": "<p>I've updated <a href=\"https://gist.github.com/Vierkantor/e73209684c16b725e29880de7443c9f2\" title=\"https://gist.github.com/Vierkantor/e73209684c16b725e29880de7443c9f2\">the gist</a> to only include the non-controversial parts. Any suggestions before I turn it into a PR?</p>",
        "id": 195054197,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587645609
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> The stuff on division rings should maybe be generalised to <code>group_with_zero</code>?</p>",
        "id": 195054497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587645796
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/2504\" title=\"https://github.com/leanprover-community/mathlib/pull/2504\">Created PR #2504</a></p>",
        "id": 195062342,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587649429
    },
    {
        "content": "<p>I see in the PR that you explain how to deduce invertibility of some elements (for instance <code>-a</code>) from the invertibility of <code>a</code>, but I think this mightcreate problems down the road. For instance, in a field, <code>-1</code> could be invertible because it is the neg of <code>1</code> which is invertible, but also because it is nonzero and therefore invertible. With a prop, this is never an issue, but with data this will be a problem if the inverses you get following different paths are not defeq. </p>\n<p>This is already the case in groups, where you have the two instances</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">invertible_of_group</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_self</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mul_inv_self</span> <span class=\"n\">a</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>and </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">invertible_one</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span> <span class=\"bp\">_</span> <span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>Since <code>1</code> and <code>1⁻¹</code> are not defeq, this gives you two conflicting values for the inverse of <code>1</code>.</p>\n<p>I guess the solution here is to <em>not</em> declare all these as instances, only as defs, and let the user activate the ones he needs when necessary. Opinions of type classes experts welcome!</p>",
        "id": 195066068,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587651042
    },
    {
        "content": "<p>I think it will not be a problem, because I think these should <em>not</em> be considered simp normal form expressions, and there should be lemmas rewriting <code>inv 2 = 1 / 2</code> in division rings and so on.</p>",
        "id": 195066523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651231
    },
    {
        "content": "<p>So the only time an <code>inv</code> will appear in a statement is if it is in a general context and that's the only way to obtain the element in question. Of course no one is going to use <code>inv 1</code> directly, it will only appear as <code>inv a</code>, applied in a context with <code>a := 1</code>, and then the simp lemma will trigger and it becomes <code>1</code></p>",
        "id": 195067040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651423
    },
    {
        "content": "<p>What about <code>inv (-4)</code> in <code>ℤ[1/2]</code>? It could appear as <code>- (inv 2) * (inv 2)</code> or <code>(inv 2) * (-inv 2)</code> depending on the chosen path, and I don't expect any reasonable simp normal form here.</p>",
        "id": 195067385,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587651571
    },
    {
        "content": "<p>It will be <code>- 1/4</code></p>",
        "id": 195067473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651606
    },
    {
        "content": "<p>with division in Z[1/2]</p>",
        "id": 195067501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651620
    },
    {
        "content": "<p><code>inv 2</code> is not the canonical way of referring to 1/2 in Z[1/2]</p>",
        "id": 195067640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651671
    },
    {
        "content": "<p>it would be some constructor, <code>Z_one_half.one_half</code></p>",
        "id": 195067715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651700
    },
    {
        "content": "<p>This only make sense if you can craft a division with nice enough properties, otherwise we should not declare a <code>has_div</code> instance here.</p>",
        "id": 195067731,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587651708
    },
    {
        "content": "<p>I mentioned the divison on Z[1/2] above</p>",
        "id": 195067767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651722
    },
    {
        "content": "<p>Yes, but I am not sure I was convinced it behaves nicely enough...</p>",
        "id": 195067840,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587651746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195018574\" title=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195018574\">said</a>:</p>\n<blockquote>\n<p>I would propose <code>(a * 2^b) / (c * 2^d)</code> (where a and c are odd) evaluates to <code>2^(b-d) * (a / c)</code> with the division evaluated in Z</p>\n</blockquote>",
        "id": 195067844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651748
    },
    {
        "content": "<p>You could make any ring in which 2 was invertible into a Z[1/2]-algebra and then make all your decisions in Z[1/2]</p>",
        "id": 195067862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587651758
    },
    {
        "content": "<p>I don't really care if it returns 37 on bad inputs in this case</p>",
        "id": 195067901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651777
    },
    {
        "content": "<p>I would be actively for this decision</p>",
        "id": 195067930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587651791
    },
    {
        "content": "<p>I think that the gain of being able to write <code>1/4</code> outweighs the mess of numbers like <code>1/5</code></p>",
        "id": 195068062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651853
    },
    {
        "content": "<p>Btw, the simp lemma in the PR is currently</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">inv_of_one</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"err\">⅟</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>\n\n\n<p>and I don't know which instance it uses. It should probably be</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">inv_of_one</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"err\">⅟</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"bp\">...</span> <span class=\"kn\">end</span>\n</pre></div>",
        "id": 195068101,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587651869
    },
    {
        "content": "<p>I don't think it is a question about <code>simp</code>. I mean in the bilinear forms PR, the choice of 1/2 is embedded in further constructions like the discriminant of a quadratic form. If you end up with the discriminant of the same form but with two definitionally different 1/2s, aren't you going to be in a bit of trouble?</p>",
        "id": 195068181,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587651906
    },
    {
        "content": "<p>It should be <code>{_:invertible 1}</code> if you want to make it agnostic to the instance</p>",
        "id": 195068198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587651912
    },
    {
        "content": "<p>Yes, even better</p>",
        "id": 195068255,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587651940
    },
    {
        "content": "<p>(actually, I know which instance it uses, because only one of them is <code>rfl</code> <span aria-label=\"mischievous\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"mischievous\">:mischievous:</span> )</p>",
        "id": 195068477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587652025
    },
    {
        "content": "<p>If I understand correctly the goal of this typeclass, it is not to deduce automatically invertibility, only to provide an inverse to some fixed number, say <code>2</code> or <code>3</code>. Why not remove all these instances and turn them into defs?</p>",
        "id": 195068499,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587652032
    },
    {
        "content": "<p>I agree that this is not something we need a bunch of instances for</p>",
        "id": 195068550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587652053
    },
    {
        "content": "<p>OK <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> Which <code>instance</code>s should stay that way? Definitely <code>invertible 2</code>, <code>invertible 3</code>. Also <code>invertible 1</code>, <code>invertible -(a)</code>?</p>",
        "id": 195070058,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587652651
    },
    {
        "content": "<p>I'm not sure we will ever need any instances besides <code>invertible 2</code>, <code>invertible 3</code>, and <code>invertible (\\u n)</code> under some assumptions</p>",
        "id": 195070265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587652719
    },
    {
        "content": "<p>so the last one isn't even really an instance</p>",
        "id": 195070375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587652758
    },
    {
        "content": "<p>It's really a ring structure assumption, like <code>char_zero</code>, so it's fine if it is fairly rigid</p>",
        "id": 195070470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587652793
    },
    {
        "content": "<p>Too few instances is easier to deal with than too many instances, so I would keep it simple to start</p>",
        "id": 195071732,
        "sender_full_name": "Reid Barton",
        "timestamp": 1587653251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195018574\" title=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195018574\">said</a>:</p>\n<blockquote>\n<p>I would propose <code>(a * 2^b) / (c * 2^d)</code> (where a and c are odd) evaluates to <code>2^(b-d) * (a / c)</code> with the division evaluated in Z</p>\n</blockquote>\n<p>To play this game in <code>R[1/2]</code>, you need to have some kind of division on <code>R</code>. If you start from a nice and natural example such as <code>R = ℤ[√-5]</code>, I don't think you will be able to cook up such a natural division.</p>",
        "id": 195072590,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587653557
    },
    {
        "content": "<p>Because R isn't a UFD, you have real problems deciding what a quotient and a remainder are (the \"remainder\" cannot be made to be smaller than the thing you're dividing by, for any reasonable concept of size)</p>",
        "id": 195073678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587654002
    },
    {
        "content": "<p>Yes, I didn't choose my example completely at random :)</p>",
        "id": 195073779,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587654029
    },
    {
        "content": "<p>here's a perfectly natural definition, that works on any ring and gives the right division by 0: <code>if h : is_unit x then classical.some h else 0</code></p>",
        "id": 195076680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587655104
    },
    {
        "content": "<p>this can be a <code>def</code> for <code> has_div</code> in case you feel like using division notation</p>",
        "id": 195076768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587655153
    },
    {
        "content": "<p>Then you get two conflicting notations on the integers.</p>",
        "id": 195076840,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587655191
    },
    {
        "content": "<p>but in statements you stick to things like <code>inv 2</code> to keep the choices canonical</p>",
        "id": 195076850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587655195
    },
    {
        "content": "<p>you wouldn't use that definition on the integers</p>",
        "id": 195076921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587655215
    },
    {
        "content": "<p>it's not a blanket instance, it's an opt in def</p>",
        "id": 195076953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587655231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195076921\" title=\"#narrow/stream/144837-PR-reviews/topic/.232480.20bilinear.20forms/near/195076921\">said</a>:</p>\n<blockquote>\n<p>you wouldn't use that definition on the integers</p>\n</blockquote>\n<p>Some of us wouldn't use the current <code>/</code> on the integers either ;-)</p>",
        "id": 195077233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587655362
    },
    {
        "content": "<p>So... shall we merge the PR? Currently there are only instances for <code>2</code> and <code>3</code>.</p>",
        "id": 195077246,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587655367
    },
    {
        "content": "<p>I am fully aware that not all rings have the luxury of nice values when you start dividing by weird things. But that doesn't matter, we are not new to totalized functions</p>",
        "id": 195077277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587655384
    },
    {
        "content": "<p>I've kicked the bilinear forms PR onto the queue.</p>",
        "id": 195169722,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587723959
    }
]
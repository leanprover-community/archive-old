[
    {
        "content": "<p>Moving the PR comments to Zulip since the discussion started getting long. We want to be able to somehow move between two structures:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">abelian</span> <span class=\"kn\">extends</span> <span class=\"n\">preadditive</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">has_finite_products</span> <span class=\"o\">:</span> <span class=\"n\">has_finite_products</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_kernels</span> <span class=\"o\">:</span> <span class=\"n\">has_kernels</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_cokernels</span> <span class=\"o\">:</span> <span class=\"n\">has_cokernels</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">normal_mono</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mono</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"n\">normal_mono</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">normal_epi</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">epi</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"n\">normal_epi</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">non_preadditive_abelian</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">has_zero_object</span> <span class=\"o\">:</span> <span class=\"n\">has_zero_object</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"o\">:</span> <span class=\"n\">has_zero_morphisms</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_kernels</span> <span class=\"o\">:</span> <span class=\"n\">has_kernels</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_cokernels</span> <span class=\"o\">:</span> <span class=\"n\">has_cokernels</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_finite_products</span> <span class=\"o\">:</span> <span class=\"n\">has_finite_products</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">has_finite_coproducts</span> <span class=\"o\">:</span> <span class=\"n\">has_finite_coproducts</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">normal_mono</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mono</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"n\">normal_mono</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">normal_epi</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">epi</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"n\">normal_epi</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Going from <code>abelian</code> to <code>non_preadditive_abelian</code> is easy. Going the other way is the tricky part. There is a proof of the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">preadditive</span> <span class=\"o\">[</span><span class=\"n\">non_preadditive_abelian</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">preadditive</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"c\">/-</span><span class=\"cm\"> 700 lines omitted -/</span>\n</code></pre></div>\n\n\n<p>but when we try to use this result we run into a typeclass issues in the following declaration:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">abelian</span> <span class=\"o\">[</span><span class=\"n\">non_preadditive_abelian</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">abelian</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">has_finite_products</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">has_kernels</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">has_cokernels</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">normal_mono</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">normal_mono</span><span class=\"o\">,</span>\n  <span class=\"n\">normal_epi</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">normal_epi</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">non_preadditive_abelian</span><span class=\"bp\">.</span><span class=\"n\">preadditive</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>The problem is in the details: <code>has_kernels</code> requires an instance of <code>has_zero_morphisms</code>. For <code>abelian</code>, this instance comes from <code>preadditive</code>, but for <code>non_preadditive_abelian</code>, it is an explicit argument. So the <code>has_kernels</code> instance from <code>non_preadditive_abelian</code> is slightly different from what's required for <code>abelian</code>, which is why the line <code>has_kernels := infer_instance</code> fails.</p>",
        "id": 202570889,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1593611433
    },
    {
        "content": "<p>Interesting. Presumably we could (unpleasantly) use the fact that <code>has_zero_morphisms</code> is a subsingleton. (e.g. by using something like <code>convert infer_instance, ...</code>)</p>",
        "id": 202634542,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593645282
    },
    {
        "content": "<p>But generally the answer here is meant to be \"allow different instances, and carry around proofs that they agree\". The proofs part here would be empty, because of the subsingleton property. That is --- can we just add a _separate_ <code>has_zero_morphisms</code> instance to <code>preadditive</code>?</p>",
        "id": 202634625,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593645349
    },
    {
        "content": "<p>I haven't tested this, but I'm afraid adding a <code>has_zero_morphisms</code> to <code>preadditive</code> will result in two <code>has_zero</code> instances, so we will end up with the same problem, just in a different place.</p>",
        "id": 202650023,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1593665272
    },
    {
        "content": "<p>Yup... we would have two <code>0</code>s in every homset, provably equal, but not defeq.</p>",
        "id": 202652572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593669180
    },
    {
        "content": "<p>If we really want to fix this, then we need to unfold all the data in <code>preadditive</code>, maybe even the group structure, instead of simply <code>[add_group (X \\hom Y)]</code>. And then we can piece everything together again when we derive</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">\\</span><span class=\"n\">hom</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n<span class=\"c1\">-- etc</span>\n</code></pre></div>",
        "id": 202652658,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593669303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive/near/202634542\">said</a>:</p>\n<blockquote>\n<p>Interesting. Presumably we could (unpleasantly) use the fact that <code>has_zero_morphisms</code> is a subsingleton. (e.g. by using something like <code>convert infer_instance, ...</code>)</p>\n</blockquote>\n<p>Indeed, this compiles <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">abelian</span> <span class=\"o\">:</span> <span class=\"n\">abelian</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">has_finite_products</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">has_kernels</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_kernels</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">infer_instance</span><span class=\"o\">),</span>\n  <span class=\"n\">has_cokernels</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_cokernels</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">infer_instance</span><span class=\"o\">),</span>\n  <span class=\"n\">normal_mono</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">introsI</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">normal_mono</span> <span class=\"n\">f</span> <span class=\"o\">},</span>\n  <span class=\"n\">normal_epi</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">introsI</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">normal_epi</span> <span class=\"n\">f</span> <span class=\"o\">},</span>\n  <span class=\"bp\">..</span><span class=\"n\">non_preadditive_abelian</span><span class=\"bp\">.</span><span class=\"n\">preadditive</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 202653310,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1593670170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive/near/202652658\">said</a>:</p>\n<blockquote>\n<p>If we really want to fix this, then we need to unfold all the data in <code>preadditive</code>, maybe even the group structure, instead of simply <code>[add_group (X \\hom Y)]</code>.</p>\n</blockquote>\n<p>Hm, I find it hard to guess whether that would be worth the effort.</p>",
        "id": 202653382,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1593670240
    },
    {
        "content": "<p>Same here</p>",
        "id": 202653411,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670288
    },
    {
        "content": "<p>It sounds like we're on track again. I'm happy with this solution --- although would like to add a comment explaining why the <code>convert</code>s are there, are why Lean can handle the goals.</p>",
        "id": 202653922,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593670986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.233247.20every.20abelian.20category.20is.20preadditive/near/202653922\">said</a>:</p>\n<blockquote>\n<p>It sounds like we're on track again. I'm happy with this solution --- although would like to add a comment explaining why the <code>convert</code>s are there, are why Lean can handle the goals.</p>\n</blockquote>\n<p>I've added such a comment <a href=\"https://github.com/leanprover-community/mathlib/pull/3247/files#diff-a5f61fc06b4f1dfce77cfed40ab42e71R502\">here</a>.</p>",
        "id": 202654774,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1593672016
    }
]
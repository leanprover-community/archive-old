[
    {
        "content": "<p>I would like to add the following code to <code>group_theory/submonoid/membership.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Exponentiation map from natural numbers to powers. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">pow</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">powers</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Logarithms from powers to natural numbers. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">log</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">powers</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.find</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">mem_powers_iff</span> <span class=\"n\">p.val</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">p.prop</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">pow_log_eq_self</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">powers</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pow</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">nat.find_spec</span> <span class=\"n\">p.prop</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pow_right_injective_iff_pow_injective</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">pow</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.coe_injective.of_comp_iff</span> <span class=\"o\">(</span><span class=\"n\">pow</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">log_pow_eq_self</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">pow</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">pow_right_injective_iff_pow_injective.mp</span> <span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"n\">pow_log_eq_self</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">log_pow_int_eq_self</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x.nat_abs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">pow</span> <span class=\"n\">x</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">log_pow_eq_self</span> <span class=\"o\">(</span><span class=\"n\">int.pow_right_injective</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>Is there a way to avoid defining new functions <code>pow</code> and <code>log</code>?</p>\n<p>I need these functions to define dyadic numbers which in turn are used in surreal numbers. </p>\n<p>Thanks,</p>",
        "id": 250724460,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1629955876
    },
    {
        "content": "<p>It seems like it should be possible to just use the usual power function and just define a discrete log function under the assumption that the element p is in gpowers of n. <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/order_of_element.html\">https://leanprover-community.github.io/mathlib_docs/group_theory/order_of_element.html</a> seems like a good place for it to me.</p>",
        "id": 250733473,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1629962513
    },
    {
        "content": "<p>The target needs to be <code>powers n</code> so can't use the vanilla <code>^</code> function but I could just replace the <code>pow</code> with its definition <code>⟨n ^ m, m, rfl⟩</code> everywhere.</p>",
        "id": 250809341,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1629998915
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 250809804,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1629999089
    },
    {
        "content": "<p>Why does the target need to be <code>powers n</code>?</p>",
        "id": 250810354,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1629999305
    },
    {
        "content": "<p>To be clear I mean something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.order_of_element</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.lattice</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"sd\">/-- Logarithms from powers to natural numbers. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">log</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">Inf</span> <span class=\"o\">({</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">pow_log_eq_self</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">set.nonempty</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.Inf_mem</span> <span class=\"n\">hp</span>\n</code></pre></div>",
        "id": 250812691,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1630000304
    },
    {
        "content": "<p>The function is always defined, its just a junk value if there is no such power</p>",
        "id": 250812805,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1630000337
    },
    {
        "content": "<p>If you want computability this might not be the right thing</p>",
        "id": 250812862,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1630000357
    },
    {
        "content": "<p>But it does have some nice advantages, e.g. you could now prove the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.order_of_element</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.modeq</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"sd\">/-- Logarithms from powers to natural numbers. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">log</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">Inf</span> <span class=\"o\">({</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">pow_log_eq_self</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">set.nonempty</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.Inf_mem</span> <span class=\"n\">hp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">log_pow</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"bp\">≡</span> <span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">order_of</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>whereas before the functions <code>log n</code> and <code>log (n^h)</code> had different domains</p>",
        "id": 250814000,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1630000834
    },
    {
        "content": "<p>One last thing, under the hood these are basically the same functions, <code>nat.Inf</code> is implemented using <code>nat.find</code> it just does a case split on whether the thing it wants even exists first and returns 0 otherwise.</p>",
        "id": 250814358,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1630000961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.238870/near/250810354\">said</a>:</p>\n<blockquote>\n<p>Why does the target need to be <code>powers n</code>?</p>\n</blockquote>\n<p>Eventually I need \"integers localized away from 2\" and there is a localization function defined on <code>powers n</code>.</p>",
        "id": 250885852,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1630042750
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/localization.away\">docs#localization.away</a></p>",
        "id": 250886057,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1630042948
    },
    {
        "content": "<p>I'll see if I can do without using <code>powers n</code> but right now this is the code (in <a href=\"https://github.com/leanprover-community/mathlib/issues/7843\">#7843</a>) where I'm using these functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The map `dyadic_map` sends ⟦⟨m, 2^n⟩⟧ to m • half ^ n. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">dyadic_map</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">localization</span> <span class=\"o\">(</span><span class=\"n\">submonoid.powers</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">surreal</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient.lift_on'</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">×</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"bp\">•</span> <span class=\"n\">pow_half</span> <span class=\"o\">(</span><span class=\"n\">submonoid.log</span> <span class=\"n\">x.2</span><span class=\"o\">))</span> <span class=\"bp\">$</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">m₁</span><span class=\"o\">,</span> <span class=\"n\">n₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">m₂</span><span class=\"o\">,</span> <span class=\"n\">n₂</span><span class=\"o\">⟩</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">n₃</span><span class=\"o\">,</span> <span class=\"n\">y₃</span><span class=\"o\">,</span> <span class=\"n\">hn₃</span><span class=\"o\">⟩,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">localization.r_iff_exists.mp</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_mul_right_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a₁</span><span class=\"o\">,</span> <span class=\"n\">ha₁</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">n₁.prop</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a₂</span><span class=\"o\">,</span> <span class=\"n\">ha₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">n₂.prop</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hn₁</span> <span class=\"o\">:</span> <span class=\"n\">n₁</span> <span class=\"bp\">=</span> <span class=\"n\">submonoid.pow</span> <span class=\"mi\">2</span> <span class=\"n\">a₁</span> <span class=\"o\">:=</span> <span class=\"n\">subtype.ext</span> <span class=\"n\">ha₁.symm</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hn₂</span> <span class=\"o\">:</span> <span class=\"n\">n₂</span> <span class=\"bp\">=</span> <span class=\"n\">submonoid.pow</span> <span class=\"mi\">2</span> <span class=\"n\">a₂</span> <span class=\"o\">:=</span> <span class=\"n\">subtype.ext</span> <span class=\"n\">ha₂.symm</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hn₁</span><span class=\"o\">,</span> <span class=\"n\">hn₂</span><span class=\"o\">,</span> <span class=\"n\">submonoid.log_pow_int_eq_self</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">submonoid.log_pow_int_eq_self</span> <span class=\"n\">h₂</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">dyadic_aux</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">ha₁</span><span class=\"o\">,</span> <span class=\"n\">ha₂</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">nat.one_le_pow</span> <span class=\"n\">y₃</span> <span class=\"mi\">2</span> <span class=\"n\">nat.succ_pos'</span><span class=\"o\">,</span>\n    <span class=\"n\">linarith</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 250886268,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1630043166
    },
    {
        "content": "<p>Thanks for the suggestions above!</p>",
        "id": 250886276,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1630043177
    },
    {
        "content": "<p>Another option instead of using <code>Inf</code> to find either an exact match or zero would be to copy nat.sqrt and define <code>nat.log x y</code> as the largest <code>n</code> such that <code>x^n ≤ y</code>; although that would require an ordered structure.</p>",
        "id": 250892649,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630048433
    },
    {
        "content": "<p>I'm finding it difficult to not use <code>powers n</code>. The entire localization API relies on it.</p>",
        "id": 250962908,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1630084217
    }
]
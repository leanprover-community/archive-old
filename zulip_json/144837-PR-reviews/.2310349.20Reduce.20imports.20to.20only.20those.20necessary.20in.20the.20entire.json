[
    {
        "content": "<p>Out of curiosity, how much time does your tool need to run on the entire library?</p>",
        "id": 261639206,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637069043
    },
    {
        "content": "<p>Right now its:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">real</span>    <span class=\"mi\">45</span><span class=\"n\">m6</span><span class=\"o\">,</span><span class=\"mi\">682</span><span class=\"n\">s</span>\n<span class=\"n\">user</span>    <span class=\"mi\">525</span><span class=\"n\">m1</span><span class=\"o\">,</span><span class=\"mi\">633</span><span class=\"n\">s</span>\n<span class=\"n\">sys</span>     <span class=\"mi\">0</span><span class=\"n\">m23</span><span class=\"o\">,</span><span class=\"mi\">632</span><span class=\"n\">s</span>\n</code></pre></div>\n<p>(on 20 cpu cores)</p>",
        "id": 261639353,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637069116
    },
    {
        "content": "<p>I still have some ideas to speed it up a bit, but I'm not sure it will ever be less than a couple of hours on a single core</p>",
        "id": 261639457,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637069163
    },
    {
        "content": "<p>So it's too big to be run by the linter, but reasonable to run by hand once a week.</p>",
        "id": 261639482,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637069179
    },
    {
        "content": "<p>Yeah that's exactly the sort of thing we were hoping for</p>",
        "id": 261639534,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637069210
    },
    {
        "content": "<p>Did I mention it's awesome, by the way? :-)</p>",
        "id": 261639656,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637069270
    },
    {
        "content": "<p>Am I right in thinking that this PR removes both imports which aren't used at all (fantastic), and imports which are used but already imported transitively (a previous topic of contention)? For instance, <code>algebra.algebra.basic</code> no longer imports <code>algebra.module.basic</code>, which I'm almost certain isn't indicating that the former didn't use the latter.</p>",
        "id": 261639803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637069314
    },
    {
        "content": "<p>Yes, that's right.</p>",
        "id": 261639968,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637069384
    },
    {
        "content": "<p>Is it true that it could increase the number of imports for a given file. E.g., if files A, B were imported in C and D imported C but actually only needed A, B this will swap out D's import of C for A, B?</p>",
        "id": 261640077,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637069419
    },
    {
        "content": "<p>Again, that's right</p>",
        "id": 261640121,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637069441
    },
    {
        "content": "<p>Wow that's great. This is very cool.</p>",
        "id": 261640135,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637069448
    },
    {
        "content": "<p>It also sorts the imports I see <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 261640139,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637069452
    },
    {
        "content": "<p>The previous contention was in <a href=\"#narrow/stream/144837-PR-reviews/topic/.235823/near/223455162\">this thread</a>. I'd argue it should leave transitive imports alone, and only prune unused ones, as the transitively-redundant imports frequently stop being redundant when things move, and without them you have a tiresome game of \"hunt the lemma\" to find which import you need to add back.</p>",
        "id": 261640336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637069541
    },
    {
        "content": "<p>wow, this looks amazing!</p>",
        "id": 261641826,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1637070233
    },
    {
        "content": "<p>I don't really see why we should keep the transitive imports, if we still have the tool and run it once a week. It would mean that when working on a branch, we would never remove imports even if pruning the file (because getting the imports right is hard), and so the problem of hunting a lemma in a dependent file should never appear.</p>",
        "id": 261642161,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637070377
    },
    {
        "content": "<p>Yeah I'm just reiding the original objections way back in that thread and they seem to stem from </p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>Reid Barton: Now imagine A defines a, B defines b and imports A even though it doesn't use it, and someone wanting to write a module C wants to use both a and b. The natural thing to do in general is to import both A and B (otherwise you might have to carefully track down transitive imports to see that actually one is redundant).\n\nReid Barton: This creates a syntactically unnecessary import of A in C.\n\nReid Barton: Now suppose someone later notices that B doesn't actually use A at all, so B may as well not import A.\n\nReid Barton: If you still have the import of A in C, then C will continue to work. If you removed it, however, because it was syntactically unnecessary, now you broke C by changing B, and you have to figure out what module C was supposed to be importing that provided a.\n</code></pre></div>\n<p>if we now have a (coming soon to Zulip) tool that in the situation that <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> describes \"Now suppose someone later notices that B doesn't actually use A at all, so B may as well not import A.\" automatically creates a sed script for you that removes the <code>A</code> import from <code>B</code> _and_ adds the <code>A</code> import to all <code>C</code>s that need it still, does this problem go away?</p>",
        "id": 261642692,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637070595
    },
    {
        "content": "<p>Concerning \"hunt the lemma\". This PR was constructed as follows:</p>\n<ol>\n<li>Write a bunch of meta code that collects info about declarations, their dependencies, and the import graph into some DAGs.</li>\n<li>Do computations on the DAGs and output a sed-script that replaces imports by minimalized imports</li>\n<li>Run the sed-script.</li>\n</ol>",
        "id": 261642821,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637070632
    },
    {
        "content": "<p>The tooling in 1 (+ a bit of 2) can be easily extended and modified to provide user-commands of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">find_home</span> <span class=\"n\">my_lemma</span>\n</code></pre></div>",
        "id": 261642904,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637070671
    },
    {
        "content": "<p>This is on our todo list. It would make the \"hunt for the correct import\" a lot easier.</p>",
        "id": 261642965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637070698
    },
    {
        "content": "<p>I guess what I'm missing is why there is any advantage at all to removing the import of <code>A</code> in <code>C</code> in the above scenario</p>",
        "id": 261643374,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637070872
    },
    {
        "content": "<p>As far as I can see, with this script in the toolbox, there is also no advantage in keeping it.</p>",
        "id": 261643474,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637070926
    },
    {
        "content": "<p><a href=\"https://github.com/alexjbest/dag-tools\">https://github.com/alexjbest/dag-tools</a></p>",
        "id": 261643498,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637070938
    },
    {
        "content": "<p>The downside is you have to know about the script and run the script and wait for it to finish</p>",
        "id": 261643582,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637070965
    },
    {
        "content": "<p>or just don't remove any import. And wait for the maintainers to do it for you, once a week, in the most efficient way.</p>",
        "id": 261643683,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637071005
    },
    {
        "content": "<p>ah I'm confused about something then</p>",
        "id": 261643720,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071024
    },
    {
        "content": "<p>This is not a linter! So we're not forcing people to write PRs with minimal imports.</p>",
        "id": 261643828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637071079
    },
    {
        "content": "<p>Right so another issue is breakage in external consumers</p>",
        "id": 261643832,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071080
    },
    {
        "content": "<blockquote>\n<p>I guess what I'm missing is why there is any advantage at all to removing the import of <code>A</code> in <code>C</code> in the above scenario</p>\n</blockquote>\n<p>It lets you reduce the imports of the split file much quicker.</p>",
        "id": 261643877,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071086
    },
    {
        "content": "<p>What split file?</p>",
        "id": 261643925,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071111
    },
    {
        "content": "<p>I guess I'm talking about a slightly different scenario</p>",
        "id": 261644000,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071154
    },
    {
        "content": "<p>I've been doing that by hand and despising the transitive imports.</p>",
        "id": 261644022,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261642161\">said</a>:</p>\n<blockquote>\n<p>It would mean that when working on a branch, we would never remove imports even if pruning the file (because getting the imports right is hard), and so the problem of hunting a lemma in a dependent file should never appear.</p>\n</blockquote>\n<p>This situation still arises when trying to reverse the direction of an import, where you do still need to remove imports manually</p>",
        "id": 261644142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637071210
    },
    {
        "content": "<p>Another reason is that you want docgen to not lie to you and give you two files very far apart as close in the import tree</p>",
        "id": 261644149,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071211
    },
    {
        "content": "<p>Yes exactly, Eric, but it'll still be much quicker.</p>",
        "id": 261644266,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071241
    },
    {
        "content": "<p>I think the advantages of this reduction (build time) far outweigh these potential issues when removing transitive imports.  Note that we already have these issues today, just to a lesser degree.  I don't think anybody adds unnecessary imports unless they need a lemma that's not already imported.</p>",
        "id": 261644298,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1637071252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261644149\">said</a>:</p>\n<blockquote>\n<p>give you two files very far apart as close in the import tree</p>\n</blockquote>\n<p>I don't really understand what this means, but of course docgen could just remove imports that are implied by transitivity itself</p>",
        "id": 261644347,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261644298\">said</a>:</p>\n<blockquote>\n<p>I think the advantages of this reduction (build time)</p>\n</blockquote>\n<p>But removing imports that are implied by transitivity doesn't affect build time, right?</p>",
        "id": 261644407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071299
    },
    {
        "content": "<p>Yeah that's what I was about to say, but nobody has taken over that yet</p>",
        "id": 261644414,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071302
    },
    {
        "content": "<p>Otherwise, I would be totally on board</p>",
        "id": 261644429,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261643498\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/alexjbest/dag-tools\">https://github.com/alexjbest/dag-tools</a></p>\n</blockquote>\n<p>Oops I posted this link without changing the visibility settings</p>",
        "id": 261644439,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637071309
    },
    {
        "content": "<p>And there's still the problem of <code>.default</code> files...</p>",
        "id": 261644531,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>, my understanding is that keeping / pruning imported-but-transitive imports should be a fairly straightforward thing to adjust in the script, so it's not an all or nothing choice</p>",
        "id": 261644550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637071344
    },
    {
        "content": "<blockquote>\n<p>I don't anybody adds an unnecessary import</p>\n</blockquote>\n<p>Beginners do, because they aren't quite aware of transitivity, so they add each file they pick a lemma from one by one without trying to reduce them.</p>",
        "id": 261644625,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071393
    },
    {
        "content": "<p>I think that really this \"beginner\" behavior is the correct one, and relying on transitivity is questionable</p>",
        "id": 261644680,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071421
    },
    {
        "content": "<p>I don't think there are too many authors of mathlib files conciously adding transitive imports in a way that makes it maximally useful to future file splitters anyway</p>",
        "id": 261644712,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637071437
    },
    {
        "content": "<p>Because relying on transitivity means that the entire import structure is part of the external API.</p>",
        "id": 261644763,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261644149\">said</a>:</p>\n<blockquote>\n<p>Another reason is that you want docgen to not lie to you and give you two files very far apart as close in the import tree</p>\n</blockquote>\n<p>If you're using \"imports by\" to find \"extensions of the theory in this file\" rather than just \"critical import paths\", the current behavior can be helpful.<br>\n<span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261644531\">said</a>:</p>\n<blockquote>\n<p>And there's still the problem of <code>.default</code> files...</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/lean/pull/645\">https://github.com/leanprover-community/lean/pull/645</a> is my attempt to expose the information to doc-gen</p>",
        "id": 261644784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637071455
    },
    {
        "content": "<p>Ah great! Nice to hear</p>",
        "id": 261644866,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071493
    },
    {
        "content": "<p>Yeah, but transitive imports are not even theory extension-relevant... Most of the time, they are quite random.</p>",
        "id": 261644991,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261644712\">said</a>:</p>\n<blockquote>\n<p>I don't think there are too many authors of mathlib files conciously adding transitive imports in a way that makes it maximally useful to future file splitters anyway</p>\n</blockquote>\n<p>Many of the useful transitive imports are the ones that got left behind in a refactor, as those often link to where the core ideas were developed before more dependencies were pulled in that made them redundant</p>",
        "id": 261645348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637071685
    },
    {
        "content": "<p>I'd argue imports are the wrong place to put this information. The correct place (which incidentally is more visible and less technical-sounding) is the module docstring.</p>",
        "id": 261645403,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071712
    },
    {
        "content": "<p>I agree in practice it's random whether or not \"redundant\" imports get added (basically if you're going to use both <code>A</code> and <code>B</code> and <code>B</code> imports <code>A</code>, then it depends on which of <code>A</code> and <code>B</code> you discovered that you needed first) but the ones that we do end up with make the library easier to refactor</p>",
        "id": 261645407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637071715
    },
    {
        "content": "<p>For having refactored and split convexity files, no not really.</p>",
        "id": 261645538,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637071786
    },
    {
        "content": "<p>The script can easily output a list of all files that contain direct dependencies of decls in a given file <code>X.lean</code>. So it could also \"add\" all direct dependencies to the <code>import</code> block.</p>",
        "id": 261645674,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637071832
    },
    {
        "content": "<p>It seems to me that this import reduction would speed up the local <code>lean --make ...</code> workflow.</p>\n<p>E.g., sometimes I alter a file that is lowish in the import hierarchy and then resume working on something higher up. In this situation I sometimes run <code>lean --make src/higher/up/file</code> and get just the oleans I need but I do end up building a bunch of oleans that I don't need because of the imports, right?</p>",
        "id": 261645690,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637071838
    },
    {
        "content": "<blockquote>\n<p>The script can easily output a list of all files that contain direct dependencies of decls in a given file <code>X.lean</code>. So it could also \"add\" all direct dependencies to the <code>import</code> block.</p>\n</blockquote>\n<p>I think every file would start with <code>import logic.basic</code> then.</p>",
        "id": 261645886,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1637071927
    },
    {
        "content": "<p>Yes, that's kind of why I think the script should just leave alone the imports that it knows are already transitively imported, since either extreme is probably less useful than the ocassionally useful ad-hoc imports we have today.</p>",
        "id": 261646028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637071994
    },
    {
        "content": "<p>But certainly having a mode of the script that did that would be useful, and then a human could prune it to \"interesting\" imports</p>",
        "id": 261646086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637072021
    },
    {
        "content": "<p>Or we just make a blacklist of \"dumb\" imports like logic.basic</p>",
        "id": 261646109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637072034
    },
    {
        "content": "<p>And mostly do not show useless imports on docgen</p>",
        "id": 261646172,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637072049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261646172\">said</a>:</p>\n<blockquote>\n<p>And mostly do not show useless imports on docgen</p>\n</blockquote>\n<p>I suspect what constitutes \"useful\" in docgen is probably worthy of its own Zulip topic / github issue. The current behavior is only the way it is because it was better than nothing at all.</p>",
        "id": 261646350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637072149
    },
    {
        "content": "<p>docgen currently shows <code>init.default</code> as an import on every file so it is not like the list is that high quality currently. I don't think I ever noticed this list of imports before.</p>",
        "id": 261646447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637072182
    },
    {
        "content": "<p>I use it all the time and, yes, <code>init.default</code> being there is annoying, but I end up mentally filtering it because it's always there anyway.</p>",
        "id": 261646748,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637072325
    },
    {
        "content": "<p>Anyways I agree with Eric's comments. Normal programming languages have some kind of control over export lists and/or re-exporting imported names, which forces you to think about the public API of your modules. In Lean we don't have this so we end up relying on implicit re-exports a lot, which in turn means we don't generally provide an \"official\" way to import a collection of related things (though <code>.default</code> files are sort of like this). In principle I like Johan's idea to add explicit imports for whatever the module uses explicitly, but I worry that mathlib isn't really organized in a way to do this cleanly (I think there will be a lot more stuff than <code>logic.basic</code> imported \"everywhere\").</p>",
        "id": 261647778,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637072754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>, is the change Reid and I are advocating for relatively straightforward to implement?</p>",
        "id": 261647913,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637072808
    },
    {
        "content": "<p>It's not so easy to \"merge and add it later\", because after we merge we throw away all the imports that the change would preserve, with no easy path to add them back</p>",
        "id": 261648016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637072867
    },
    {
        "content": "<p>Unfortunately I don't think its trivial to do so, I've been thinking about this could work a bit and I think you need to keep track of more data in the algorithm, currently we keep a list of original transitive imports, and updated \"correct\" imports and work up the dag removing imports as needed (note that what were originally transitive imports can become non-transitive), this is all done in parallel where possible, you'd need to track the original syntactic imports too (rather than just their transitive closure) so you want another dag carried through the whole loop, and I don't know if there is a performance hit there yet with the increased memory usage. Maybe its possible to just do everything at the end instead? But it all requires some effort.<br>\nI've spent a lot of energy on this so I don't know if I really have the time / mental energy / inclination when I could be working on other stuff to go and add this feature debug it to ensure its actually correct and prepare another PR (with the inevitable tweaking that will be needed), especially as my perception is that the transitive imports in mathlib files aren't really that useful data/well thought out anyway.<br>\nIf someone else wants to take it on feel free, you probably don't actually need to modify the tool as you just need to compute the import dag before and after this change, find the syntactic imports before that are still transitive imports after and just add them back in to each file (this will reorder still), but once again I personally still don't find the issue as big enough want to take on myself, there are many more actual features I'd like to implement, e.g. splitting files, finding homes for lemmas etc.<br>\nI guess I still don't have a compelling enough example of how the old transitive imports are useful</p>",
        "id": 261649745,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637073609
    },
    {
        "content": "<p>So I picked one of the smaller files near the start of the PR to look at (this is the whole file with comments removed for brevity):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.invertible</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.field</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.char_p.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">section</span> <span class=\"n\">field</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">invertible_of_ring_char_not_dvd</span>\n  <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">not_dvd</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">ring_char</span> <span class=\"n\">K</span> <span class=\"bp\">∣</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">not_dvd</span> <span class=\"o\">((</span><span class=\"n\">ring_char.spec</span> <span class=\"n\">K</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">not_ring_char_dvd_of_invertible</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">ring_char</span> <span class=\"n\">K</span> <span class=\"bp\">∣</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">ring_char.spec</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ne.def</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nonzero_of_invertible</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">invertible_of_char_p_not_dvd</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">K</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">not_dvd</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">not_dvd</span> <span class=\"o\">((</span><span class=\"n\">char_p.cast_eq_zero_iff</span> <span class=\"n\">K</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">invertible_of_pos</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">pos_iff_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h.out</span>\n<span class=\"kd\">end</span> <span class=\"n\">field</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">division_ring</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">invertible_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">(</span><span class=\"n\">nat.cast_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_ne_zero</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">invertible_two</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">invertible_three</span> <span class=\"o\">:</span> <span class=\"n\">invertible</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">invertible_of_nonzero</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"kd\">end</span> <span class=\"n\">division_ring</span>\n</code></pre></div>",
        "id": 261649827,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637073641
    },
    {
        "content": "<p>The PR removes the imports <code>algebra.invertible</code> and <code>algebra.field</code> (which are where <code>invertible</code> and <code>field</code> are defined respectively) and adds an import of <code>data.nat.choose</code> (which doesn't appear to be used explicitly anywhere, but maybe I overlooked it).</p>",
        "id": 261649972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637073705
    },
    {
        "content": "<p>Which file is this?</p>",
        "id": 261650097,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637073746
    },
    {
        "content": "<p>sorry! <code>algebra.char_p.invertible</code></p>",
        "id": 261650121,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637073758
    },
    {
        "content": "<p>This is just my subjective opinion, but the old import list makes a lot more sense than the new import list. (Obviously <code>algebra.invertible</code> and <code>algebra.field</code> have to be imported transitively anyways.)</p>",
        "id": 261650759,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637074021
    },
    {
        "content": "<p>Hm this could be an actual bug / merge mistake by me then</p>",
        "id": 261650843,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637074066
    },
    {
        "content": "<p>Maybe also related--<code>data.nat.choose</code> was removed as an import of <code>algebra.char_p.basic</code> in favor of more specific imports</p>",
        "id": 261651088,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637074176
    },
    {
        "content": "<p><code>data.nat.choose</code> is a default-style file so potentially special cased somehow</p>",
        "id": 261651386,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637074291
    },
    {
        "content": "<p>Putting aside <code>data.nat.choose</code>, I think the main question here is whether it is good or bad for a file in which every declaration involves <code>invertible</code> to explicitly import <code>algebra.invertible</code>.</p>",
        "id": 261652050,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637074527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261649745\">said</a>:</p>\n<blockquote>\n<p>I guess I still don't have a compelling enough example of how the old transitive imports are useful</p>\n</blockquote>\n<p>Basically, the set of modules that <code>B</code> imports (and hence implicitly re-exports) is an implementation detail of <code>B</code>--this whole tool is justified by that view, because it's saying that if <code>B</code> imports but doesn't actually use <code>A'</code> then we should remove the import of <code>A'</code> in <code>B</code>. Now if <code>C</code> uses <code>A</code> and <code>B</code> but <code>B</code> happens to also import <code>A</code> then removing the import of <code>A</code> in <code>C</code> makes <code>C</code> contingent on this implementation detail of <code>B</code>.</p>",
        "id": 261655985,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637075908
    },
    {
        "content": "<blockquote>\n<p>the set of modules that B imports (and hence implicitly re-exports) is an implementation detail of B</p>\n</blockquote>\n<p>In the case of Lean this is really not true.  The transitively imported modules are very much a part of the public API.  It's not even enough to ignore them by convention, some re-exported items can't be easily ignored at all (for example type-class instances, simp lemmas, etc.).</p>",
        "id": 261656458,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1637076083
    },
    {
        "content": "<p>(Note: I'd also personally prefer if we didn't have this re-exporting behavior.  But it's there for better or for worse.)</p>",
        "id": 261656650,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1637076144
    },
    {
        "content": "<p>But in practice we don't behave as though the re-exports are part of the API, for example, if we split <code>B</code> into <code>B</code> and <code>B'</code>, nobody is suggesting that we should leave imports in <code>B</code> if they are only needed in <code>B'</code>.</p>",
        "id": 261658793,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637076905
    },
    {
        "content": "<p>From the perspective of a client of <code>B</code>, the sensible thing to do is to explicitly import our other dependencies even if <code>B</code> might happen to re-export them. Of course mathlib is not very stable anyways and it's hard to avoid ever accidentally relying on implicit re-exports, but it's better not to go looking for trouble.</p>",
        "id": 261659075,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637076996
    },
    {
        "content": "<p>Or in a programming context, we might switch out an implementation using lists for one using rbtrees. Now either we continue to re-export lists forever or we break a client that relied on the implicit list re-export. I don't see how this is workable, and it seems to me that Lean 4 will eventually need some form of re-export control</p>",
        "id": 261660150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637077382
    },
    {
        "content": "<p>So my argument would be that for now, we should have some socially constructed notion of what a module is \"supposed\" to export and treat it as such for the purpose of deciding what imports we need</p>",
        "id": 261660386,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637077464
    },
    {
        "content": "<p>and that currently, the redundant imports in mathlib are the best approximation we have to this information and it would be harmful to throw that information away</p>",
        "id": 261660478,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637077519
    },
    {
        "content": "<p>I confess I for one am beginning to switch sides and lean toward Eric and Reid's POV now.</p>",
        "id": 261660784,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637077632
    },
    {
        "content": "<p>I'm worried that including transitive imports will lead to enormous import lists, once we start doing serious math.  When we prove the Atiyah-Singer index theorem, will we import modules, vector bundles, manifolds, characteristic classes, Fredholm operators, the Laplacian, the heat kernel, Clifford algebras, pseudodifferential operators, ... all in one file?</p>",
        "id": 261661810,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637078017
    },
    {
        "content": "<p>Well maybe we'll do the original cobordism theory proof avoid avoid he heat kernels ;-)</p>",
        "id": 261661974,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637078067
    },
    {
        "content": "<p>Anyway, surely in such a file there is no reason to say <code>import linear_algebra.basic</code>.</p>",
        "id": 261662037,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637078089
    },
    {
        "content": "<p>One reason I've found in favour of removing all transitive imports is that it makes it easier to do the actually interesting step of import reduction, which certainly can't be done by a script: splitting apart files when only a small fraction of a file requires an expensive import.</p>\n<p>If I suspect that a file should be split, e.g. because there are some expensive imports required only for a few declarations near the end, the easiest way to verify this is to delete imports one at a time, checking where the first error appears in the file.</p>\n<p>This analysis is much more tedious if some of the imports are already imported transitively.</p>",
        "id": 261704131,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637095432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261704131\">said</a>:</p>\n<blockquote>\n<p>which certainly can't be done by a script: splitting apart files when only a small fraction of a file requires an expensive import.</p>\n</blockquote>\n<p>Ooh, we actually had some ideas that could maybe find such files. But we don't have any code yet. Maybe it won't work.</p>",
        "id": 261704496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637095595
    },
    {
        "content": "<p>This step is the key one if the end goal is reducing total compile time!</p>",
        "id": 261704778,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637095756
    },
    {
        "content": "<p>Hmm, I thought it'd be the other way around. If you have dependencies A → B → C, and most of A depends on C, but only a little bit on B, wouldn't it be easier to discover that if A imports both B and C explicitly?</p>",
        "id": 261705105,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1637095951
    },
    {
        "content": "<p>I agree, if you remove all imports implied by transitivity like in this PR, the result may well be a single \"expensive\" import, and now you have to play hunt the lemma for everything if you want to try removing it.</p>",
        "id": 261705964,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637096407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261705105\">said</a>:</p>\n<blockquote>\n<p>Hmm, I thought it'd be the other way around. If you have dependencies A → B → C, and most of A depends on C, but only a little bit on B, wouldn't it be easier to discover that if A imports both B and C explicitly?</p>\n</blockquote>\n<p>This is not what it's about. Have you tried reducing imports yourself? What happens most often is that the transitive imports in intermediate files clutter your imports list and you take 10 more minutes to reduce them to bits.<br>\nThe fast way of reducing imports is to replace them by their imports (if <code>A</code> imports <code>B</code> and <code>C</code>, you replace <code>import A</code> by <code>import B import C</code>). Transitive imports break that as you can replace them by their imports all the way down (if <code>A</code> imports <code>B</code> and <code>B</code> imports <code>C</code>, you can replace <code>B</code> by <code>C</code> and <code>C</code> by its imports, etc... and never notice that <code>B</code> was not even needed in the first place). The correct thing to do to counter this is to try deleting every import one by one (or with a dichotomy to go a bit faster), which doubles the amount of file recompilation required.</p>",
        "id": 261706405,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637096596
    },
    {
        "content": "<p>In particular, transitive imports are not shortcuts, they are dead ends.</p>",
        "id": 261706568,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637096660
    },
    {
        "content": "<p>Yaël I have no idea what you are trying to say, can you explain another way?</p>",
        "id": 261707070,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637096931
    },
    {
        "content": "<p>One thing that many languages do when you want to import just small pieces of some module is allowing partial imports, like <code>from a.b import x, y, z</code>. It may even contribute to some contextualization just from reading imports. This approach, I think, talks more with the elimination of transitive imports as an attempt to make things more explicit and minimal (\"minimal\" in the sense that you're carrying out as little context as you need)</p>",
        "id": 261707709,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637097260
    },
    {
        "content": "<p>Yaël's system seems to be: replace import by its imports, see what breaks (as it imports the same things bar that new file). Transitive imports can break this strategy as you think you're removing imports, but you're not.</p>",
        "id": 261707929,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1637097381
    },
    {
        "content": "<p>I assume we're in the case where nothing breaks. I don't understand why transitive imports affect this strategy.</p>",
        "id": 261708002,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637097439
    },
    {
        "content": "<p>I assume you should always try to \"expand\" the \"last\" imports, and then if there are transitive imports you will notice it because you have two copies of <code>import C</code> and you can just delete one.</p>",
        "id": 261708144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637097505
    },
    {
        "content": "<p>(I also think this method is kind of misguided because your dependency <code>A</code> may import stuff that only gets used in its proofs, and isn't relevant to clients of <code>A</code>. I agree it works though. The \"correct\" method is to play hunt-the-lemma with everything you actually use.)</p>",
        "id": 261708400,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637097649
    },
    {
        "content": "<p>I'm more interested in <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s scenario because this is a situation where I understand the motivation (splitting  off part of a large file which has imports not needed by the rest of the file) but I come to the opposite conclusion.</p>",
        "id": 261708972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637097920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261708400\">said</a>:</p>\n<blockquote>\n<p>(I also think this method is kind of misguided because your dependency <code>A</code> may import stuff that only gets used in its proofs, and isn't relevant to clients of <code>A</code>. I agree it works though. The \"correct\" method is to play hunt-the-lemma with everything you actually use.)</p>\n</blockquote>\n<p>But... you aren't gonna check 500 lemmas, are you? Are you also willing to play the even harder \"hunt-the-instance\" or \"hunt-the-simp-lemma\"?</p>",
        "id": 261709141,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637097988
    },
    {
        "content": "<p>You only have to check 500 lemmas if you end up needing 500 imports. The simp lemma/class instance/etc. problem is the hard one, and for that it's good to keep a copy of the original file around to see how it works if you get stuck, but optimistically the simp lemmas/instances should come along with the associated definitions (orphans are bad)</p>",
        "id": 261709337,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098083
    },
    {
        "content": "<p>Uh, have you ever reduced imports that way?</p>",
        "id": 261709579,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637098207
    },
    {
        "content": "<p>Yes</p>",
        "id": 261709758,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098305
    },
    {
        "content": "<p>when splitting off part of a module</p>",
        "id": 261709840,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098327
    },
    {
        "content": "<p>My strategy (which I think is the same as Yael's, so hopefully I'm just restating) is:</p>\n<ul>\n<li>For each import, see if removing it results in no errors. If no errors, remove that import.</li>\n<li>Now, for each import, replace that import by its own imports, and see what breaks. If nothing, keep the replacement. If it breaks something, decide if the broken chunk makes sense to move to another file.</li>\n</ul>",
        "id": 261709889,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098350
    },
    {
        "content": "<p>The advantage of this strategy is that you can implement it without much thought: you don't need to look at lemmas at all until after errors appears.</p>",
        "id": 261709973,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098400
    },
    {
        "content": "<p>If you killed transitive dependencies in the file you're working on then the first step is much more likely to result in an error</p>",
        "id": 261710030,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098432
    },
    {
        "content": "<p>The problem with this strategy is that if you skip the first step, you may find an endless chain of replacements of an import by its imports, because actually the import was transitively imported.</p>",
        "id": 261710039,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098436
    },
    {
        "content": "<p>But meanwhile you can always ignore transitive dependencies in whatever you are doing in the second step, so you can't possibly come out ahead by having removed them</p>",
        "id": 261710099,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098452
    },
    {
        "content": "<p>You don't literally mean an <em>endless</em> chain, do you? I hope mathlib's modules are well-founded <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 261710179,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098503
    },
    {
        "content": "<p>Sorry. :-) Only bounded below by <code>logic.basic</code>.</p>",
        "id": 261710245,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098542
    },
    {
        "content": "<p>When you say \"for each import\", do you mean you are doing this to every import at once? Or just one?</p>",
        "id": 261710322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098572
    },
    {
        "content": "<p>The problem is \"ignore transitive dependencies\" is not something I know how to do, without either keeping the import tree in my head, or deleting imports one by one to see what made no difference.</p>",
        "id": 261710328,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098578
    },
    {
        "content": "<p>No, I mean remove one import at a time (in the first bullet), or replace one import by its imports at a time (in the second bullet).</p>",
        "id": 261710363,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098610
    },
    {
        "content": "<p>So if you could always guess one of the imports that was maximal among the set of all imports of the current file then there would be no problem, right?</p>",
        "id": 261710417,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098648
    },
    {
        "content": "<p>I still don't see where the problem is... maybe you can give an example?</p>",
        "id": 261710450,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098664
    },
    {
        "content": "<p>I think I want a slightly stronger condition: I want to be able to identify all the maximal imports. Because I'm going to try removing/replacing them one after the other until I find something that suggests a valuable refactor.</p>",
        "id": 261710567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098716
    },
    {
        "content": "<p>Well if you replaced one, then anything else that was maximal before is still maximal.</p>",
        "id": 261710622,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098753
    },
    {
        "content": "<p>There's no fundamental problem. I'm just pointing out that my/Yael's algorithm is cheaper to implement if someone has already removed all transitive imports, because then the step in the first bullet point is not needed.</p>",
        "id": 261710668,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098780
    },
    {
        "content": "<p>That's not true is it? consider import diamonds (<code>A</code> imports <code>B</code> and <code>C</code>, which both import <code>D</code>--now after expanding <code>A</code> and then <code>B</code>, you have both <code>C</code> and <code>D</code> in your imports)</p>",
        "id": 261710864,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637098882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261710622\">said</a>:</p>\n<blockquote>\n<p>Well if you replaced one, then anything else that was maximal before is still maximal.</p>\n</blockquote>\n<p>Yes. I was just referring to your statement \"if you could always guess one of the imports that was maximal\". If I only have an oracle that identifies a single maximal import, if I investigate that and decide I want to keep it, I don't know how to continue. That is, I want to iterate over all maximal imports.</p>",
        "id": 261710994,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637098951
    },
    {
        "content": "<p>Yes thanks Scott you're understanding me.</p>",
        "id": 261711180,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637099054
    },
    {
        "content": "<p>Have you tried using Zorn's Lemma?</p>",
        "id": 261711198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637099060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261710864\">said</a>:</p>\n<blockquote>\n<p>That's not true is it? consider import diamonds (<code>A</code> imports <code>B</code> and <code>C</code>, which both import <code>D</code>--now after expanding <code>A</code> and then <code>B</code>, you have both <code>C</code> and <code>D</code> in your imports)</p>\n</blockquote>\n<p>Indeed. Once you make multiple expansions you may have transitive imports again. I was mostly imagining the situation where it is rare to proceed past a first expansion: I would typically either reject the first expansion, or go make a PR. :-)</p>",
        "id": 261711203,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099065
    },
    {
        "content": "<p>OK I guess I have no idea what you're talking about either <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 261711235,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637099092
    },
    {
        "content": "<p>OK. It's not a big deal. If there is a vote about having more or fewer transitive imports in mathlib I would happily abstain. :-)</p>",
        "id": 261711324,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099149
    },
    {
        "content": "<p>I thought we were talking about a situation like this:<br>\nWe have a long file that we want to split off part of, and we assume that there are some imports that are only needed by the part that's going to be split off.</p>",
        "id": 261711390,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637099174
    },
    {
        "content": "<p>Would it be possible to end up in a situation in which you could remove one of two imports but not both at the same time, but then removing one would take you to a better (smaller?) list of imports than if you removed the other?</p>",
        "id": 261711484,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637099230
    },
    {
        "content": "<p>After the split we want to reduce the imports of the original file. That's way easier to do if you didn't delete them all because they were implied by the later modules that the split off part imported.</p>",
        "id": 261711526,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637099257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261711484\">said</a>:</p>\n<blockquote>\n<p>Would it be possible to end up in a situation in which you could remove one of two imports but not both at the same time, but then removing one would take you to a better (smaller?) list of imports than if you removed the other?</p>\n</blockquote>\n<p>Yes that happens all the time.</p>",
        "id": 261711544,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637099269
    },
    {
        "content": "<p>Ah, no. I'm talking about a different situation --- I am trying to identify, with very little thought, potential splits that can be made.</p>",
        "id": 261711638,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099311
    },
    {
        "content": "<p>I'm <em>not</em> worried about the task of cleaning up after actually making the split.</p>",
        "id": 261711662,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099326
    },
    {
        "content": "<p>i.e. if I were writing a helpful script for my task, its output would be something like:<br>\n\"Suggestion: if you don't mind moving the last 37% of file X/Y/Z.lean to a new home, you can remove the import A.B.C\"</p>",
        "id": 261711841,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099417
    },
    {
        "content": "<p>If the script were to group imports as something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- fully reduced imports</span>\n<span class=\"kn\">import</span> <span class=\"n\">foo</span>\n<span class=\"kn\">import</span> <span class=\"n\">bar.baz</span>\n\n<span class=\"c1\">-- redundant transitive imports</span>\n<span class=\"kn\">import</span> <span class=\"n\">foo.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">bar.basic</span>\n</code></pre></div>\n<p>then you could always comment out the entire second block when trying to do the type of refactor Scott suggests, and then add them back when you're done</p>",
        "id": 261711909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637099462
    },
    {
        "content": "<p>That's true. I would not argue that this is worth doing. On the other hand, if you leave out the comments and just have the convention that a newline separates the groups (and the social convention that this is a robot's problem, and you can write whatever you like), then it would be rather lightweight.</p>",
        "id": 261712322,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099668
    },
    {
        "content": "<p>Suppose docgen only lists imports that are not implied by other imports by transitivity and you use that instead of the actual import list in the file, does that help with the Scott-Yaël method?</p>",
        "id": 261713109,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637100021
    },
    {
        "content": "<p>The asymmetry here is that it's fairly trivial for any automated tool to just ignore redundant imports, but if you throw them away from the source files then  you can't get them back.</p>",
        "id": 261713346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637100124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261711662\">said</a>:</p>\n<blockquote>\n<p>I'm <em>not</em> worried about the task of cleaning up after actually making the split.</p>\n</blockquote>\n<p>One can imagine that this task is currently easy in practice because the stuff that we will later want to split off tends to get added to the bottom of the file and have its imports added to the existing ones (even if they make the existing imports redundant), but if we go deleting all those redundant imports then suddenly the process of making the split is not so easy.</p>",
        "id": 261713896,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637100420
    },
    {
        "content": "<p>This is a fair point. In any case when there are transitive imports it's not particularly more difficult for the Yael/Scott method (particularly if doc-gen can help), so I'll count myself as convinced.</p>",
        "id": 261715012,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637100959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261713896\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261711662\">said</a>:</p>\n<blockquote>\n<p>I'm <em>not</em> worried about the task of cleaning up after actually making the split.</p>\n</blockquote>\n<p>One can imagine that this task is currently easy in practice because the stuff that we will later want to split off tends to get added to the bottom of the file and have its imports added to the existing ones (even if they make the existing imports redundant), but if we go deleting all those redundant imports then suddenly the process of making the split is not so easy.</p>\n</blockquote>\n<p>As mentioned before my argument is that we should have tooling to help us do splits effectively, and that we are quite close to having it. Indeed right now you can split, copy the imports to both files and then either run this tool on each file, or rely on someone running this weekly. I appreciate that's not a 100% trivial but relying on everyone to put a \"good\" representative selection of transitive imports when there is no guideline / consensus that this is the right thing to be doing doesn't seem that effective either.</p>",
        "id": 261715150,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637101029
    },
    {
        "content": "<p>That said, I have been preparing a version with transitive imports preserved (+- epsilon as always, its hard to make a PR that touches 1000 files without a few things slipping through the cracks), I hope that will be more widely accepted</p>",
        "id": 261715303,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637101096
    },
    {
        "content": "<p>To add to this, if this is something we as a community want to encourage (treating the explicit imports as part of the external API of a file) then we should add some doc pages describing best practices for this</p>",
        "id": 261715614,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637101245
    },
    {
        "content": "<p>I agree that a tool can be of great help as a means to minimize efforts and barriers for other people who want to contribute but then have to adjust their PRs with formatting rules that could be made by the machine. Optimizing imports and formatting files could also be made automatic with the use of <a href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\">git hooks</a>, in particular the <code>pre-commit</code> one</p>",
        "id": 261716118,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1637101497
    },
    {
        "content": "<p>To be clear, I'm not advocating that people go out of their way to <em>add</em> redundant imports--certainly not with the current state of Lean/mathlib. I think in the interest of minimizing human efforrt, people should just write whatever imports they would naturally write to get their module to compile, and that will be a reasonably good approximation to the \"correct\" import set. Also in the interest of minimizing human effort, we shouldn't discard the information of which imports they wrote because it will make it easier to refactor the file later.</p>\n<p>I understand there is some degree of tension between having a \"natural\" set of imports, and removing imports in order to minimize recompilations/critical path of the build. And thanks for working on this by the way--the conversation has been focused on the redundant imports but removing the genuinely unused imports is a great improvement. I sort of entered this conversation on the wrong foot perhaps, because I was pinged in connection with the redundant import issue.</p>",
        "id": 261716625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637101730
    },
    {
        "content": "<p>Well I did ping you <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 261717190,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637101992
    },
    {
        "content": "<p>Ok I have refreshed the branch with a new version that mostly doesn't remove transitive imports, and works better in general, at least the example Reid picked earlier of <code>char_p/invertible</code> now does the right thing.</p>",
        "id": 261743054,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637124072
    },
    {
        "content": "<p>Some lines got reordered in the mess which is a bit unfortunate</p>",
        "id": 261743079,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637124109
    },
    {
        "content": "<p>There is still something strange with the PR. For instance, in the first file of the diff (<code>abel_ruffini</code>), it adds one import, without removing any. I don't see how this should be possible, if the algorithm is: replace unused imports by the smallest necessary imports, and don't remove imports that are used but not necessary.</p>",
        "id": 261751431,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637134696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Maybe one of the existing imports was importing stuff that it didn't use. (I didn't check.)</p>",
        "id": 261751464,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637134748
    },
    {
        "content": "<p>No import is removed in this example, so they are all necessary.</p>",
        "id": 261751482,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637134781
    },
    {
        "content": "<p>Could it just be that one of the current imports is not actually needed, and the script \"replaced\" it with some transitive import, but then left that current import in place because of the recent change in response to the request to not remove transitive imports?</p>",
        "id": 261751745,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637135085
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"c1\"># on the branch</span>\nrg <span class=\"s2\">\"import ring_theory.eisenstein_criterion\"</span>\narchive/100-theorems-list/16_abel_ruffini.lean\n<span class=\"m\">8</span>:import ring_theory.eisenstein_criterion\n</code></pre></div>",
        "id": 261751765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637135129
    },
    {
        "content": "<p>It is currently the only file that imports the Eisenstein criterion</p>",
        "id": 261751771,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637135142
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"c1\"># on master</span>\nrg <span class=\"s2\">\"import ring_theory.eisenstein_criterion\"</span>\nsrc/field_theory/polynomial_galois_group.lean\n<span class=\"m\">10</span>:import ring_theory.eisenstein_criterion\n</code></pre></div>",
        "id": 261751818,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637135168
    },
    {
        "content": "<p>So the script removed <code>eisenstein</code> from <code>poly_galois_group</code>, but realised that it should then add the import to <code>abel_ruffini</code> because there it's actually using <code>eisenstein</code>.</p>",
        "id": 261751859,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637135242
    },
    {
        "content": "<p>Ah, thanks for the clarification. The script has to be really clever! (more clever than me, at least :-)</p>",
        "id": 261752366,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637135742
    },
    {
        "content": "<p>Well, it mainly has to have a global view of mathlib (-;</p>",
        "id": 261752541,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637135892
    },
    {
        "content": "<p>I'd be in favor of merging this very quickly, since it will bitrot instantaneously, and now that it shouldn't be controversial. But since there was a big discussion, I'd like other people to check that they're also happy!</p>",
        "id": 261753616,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637136759
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 261753800,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637136918
    },
    {
        "content": "<p>Looks great, thanks! What did you end up doing with the transitive imports - did you put them below the necessary ones, or just mix both lists? Either is fine, as we can change that later, no information has been lost; but there are a few places where the imports don't look sorted any more</p>",
        "id": 261757927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637139871
    },
    {
        "content": "<p>Maybe that's just a merge conflict, which we can solve by just rerunning the script after this gets merged</p>",
        "id": 261757978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637139922
    },
    {
        "content": "<p>I think we should also merge this quickly.<br>\nI'm a little sad we're not removing transitive imports (for the same reasons others have mentioned). I think <em>most</em> transitive imports aren't intentionally stated explicitly, it just so happened during multiple refactors.</p>",
        "id": 261761813,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1637142332
    },
    {
        "content": "<p>We can always remove transitive imports later if we change our mind, but once we remove them we can't easily add back the ones that we currently have; so regardless of whether they're good or bad, it makes sense to handle them separately</p>",
        "id": 261765472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637144460
    },
    {
        "content": "<p>I mixed the lists in the end, but as you say, now they are preserved it should be easy to separate them if desired in another pr</p>",
        "id": 261768156,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637146145
    },
    {
        "content": "<p>I'm happy to merge as is, but perhaps <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> should take one last look</p>",
        "id": 261768365,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637146258
    },
    {
        "content": "<p>There are some oddities with added <code>tactic.*</code> imports, I see this is semi-manual anyways so would it be okay if I make a branch with some more cleanup?</p>",
        "id": 261788807,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637158336
    },
    {
        "content": "<p>Sure! You can just push directly to that branch</p>",
        "id": 261789344,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637158565
    },
    {
        "content": "<p>I agree some cleanups are needed, my plan was to make them in followups</p>",
        "id": 261789387,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637158586
    },
    {
        "content": "<p>And yes tactic* is never removed at the moment as this is quite difficult to automatically work out which tactics are used (probably one can do this with the ast export but thats just a whole extra layer of complexity), hence they are \"added\" a lot when they were there transitively.</p>",
        "id": 261789646,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637158702
    },
    {
        "content": "<p>there's really a large number of files where the only change was to reorder imports, I'm guessing it's at least 25% of all the files touched</p>",
        "id": 261791691,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637159508
    },
    {
        "content": "<p>hm the script itself wasn't meant to do that, it probably happened due to me doing things in two stages (one with a more advanced check)</p>",
        "id": 261792697,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637159926
    },
    {
        "content": "<p>I'll try and revert  some</p>",
        "id": 261792712,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637159935
    },
    {
        "content": "<p>Are you changing anything in a branch? I'll fix these based off sed6 and push, just want to make sure we don't clash</p>",
        "id": 261793246,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637160195
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/10349/files#diff-7d4c3526d625e820fa942e2fe444349ccb8c2199032e9303a26a737cce3d414d\">https://github.com/leanprover-community/mathlib/pull/10349/files#diff-7d4c3526d625e820fa942e2fe444349ccb8c2199032e9303a26a737cce3d414d</a><br>\nI think this change is bad, because it will tend to make <code>interval_cases</code> not work for new users for mysterious reasons (the instances it needs are in those imports, and there's no other reason to import those files or way to find them)</p>",
        "id": 261794232,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637160624
    },
    {
        "content": "<p>I am currently in the middle of a giant <code>git add -p</code></p>",
        "id": 261794266,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637160639
    },
    {
        "content": "<p>where I'm manually judging whether the changes were just reorderings, which usually isn't too hard...</p>",
        "id": 261794439,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637160702
    },
    {
        "content": "<p>Yes I agree</p>",
        "id": 261795438,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637161095
    },
    {
        "content": "<p>Ok I'll wait to see the result then <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> thanks!</p>",
        "id": 261795536,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637161142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261794232\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/10349/files#diff-7d4c3526d625e820fa942e2fe444349ccb8c2199032e9303a26a737cce3d414d\">https://github.com/leanprover-community/mathlib/pull/10349/files#diff-7d4c3526d625e820fa942e2fe444349ccb8c2199032e9303a26a737cce3d414d</a><br>\nI think this change is bad, because it will tend to make <code>interval_cases</code> not work for new users for mysterious reasons (the instances it needs are in those imports, and there's no other reason to import those files or way to find them)</p>\n</blockquote>\n<p>This is one of the few changes that made tests fail, I manually reverted something similar for control/traversible where the tactic (almost) works without the lemmas in scope, but it certainly violates the principle of least surprise to be able to import a tactic that doesn't function without additional imports</p>",
        "id": 261795894,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637161272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261795894\">said</a>:</p>\n<blockquote>\n<p>I manually reverted something similar for control/traversible where the tactic (almost) works without the lemmas in scope</p>\n</blockquote>\n<p>Which tactic?</p>",
        "id": 261796366,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637161484
    },
    {
        "content": "<p>The derive handler for traversible</p>",
        "id": 261796561,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637161565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261794439\">said</a>:</p>\n<blockquote>\n<p>where I'm manually judging whether the changes were just reorderings, which usually isn't too hard...</p>\n</blockquote>\n<p>Is it worth a warmup PR that just sorts all imports in all files?</p>",
        "id": 261796576,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637161573
    },
    {
        "content": "<p>That should be a straightforward python script that doesn't need any knowledge of the lean import graph</p>",
        "id": 261796629,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637161598
    },
    {
        "content": "<p>Definitely not, currently too much hand holding (of the import optimizer) is required so introducing merge conflicts just makes more work</p>",
        "id": 261796661,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637161613
    },
    {
        "content": "<p>It might have been a good idea before starting this but not in the current state yeah</p>",
        "id": 261796702,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637161627
    },
    {
        "content": "<p>By the way I forget--is it theoretically possible for reordering imports to cause a file to break?</p>",
        "id": 261798034,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637162172
    },
    {
        "content": "<p>Yes, it can affect the order of <code>ext</code> lemmas</p>",
        "id": 261798381,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637162285
    },
    {
        "content": "<p>And probably <code>instance</code>s, <code>simp</code> lemmas, ...</p>",
        "id": 261798413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637162295
    },
    {
        "content": "<p><del>More simply, I think a lean metaprogram can ask \"is this imported yet\", and fail if its not</del> (I'm not so sure about this)</p>",
        "id": 261798486,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637162330
    },
    {
        "content": "<p>Yes, and its not just theoretical, I think at least once when fixing things up last night I reordered imports for this reason</p>",
        "id": 261798903,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637162470
    },
    {
        "content": "<p>Though most of them are just mistakes in the way I applied the tools</p>",
        "id": 261798946,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637162489
    },
    {
        "content": "<p>I'm also making similar changes to <code>tactic.equiv_rw</code> and <code>tactic.tfae</code> to make them re-export stuff they morally depend on</p>",
        "id": 261837718,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637178385
    },
    {
        "content": "<p>actually every version of <code>tactic.tfae</code> I found imports <code>data.list.tfae</code>, so I don't know why the script added <code>data.list.tfae</code> as an import to a couple of other modules</p>",
        "id": 261838566,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637178718
    },
    {
        "content": "<p>Huh thats weird yeah</p>",
        "id": 261839118,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637178932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> <a href=\"https://github.com/leanprover-community/mathlib/tree/rwbarton-imports\">branch#rwbarton-imports</a> is my current state, it is on top of your PR, with a smaller diff to master</p>",
        "id": 261840774,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637179516
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 261840800,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637179533
    },
    {
        "content": "<p>still building it locally but I expect it should succeed</p>",
        "id": 261840808,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637179536
    },
    {
        "content": "<p>Ok, I'll take a look and pull it into my branch then, we have to wait for CI eventually anyways</p>",
        "id": 261840930,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637179582
    },
    {
        "content": "<p>There's still some weird stuff like <code>data.rat.enumerable</code> had its import list reduced like</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-import data.rat</span>\n import set_theory.cardinal\n</code></pre></div>\n<p>because \"obviously\" we have <code>set_theory.cardinal</code> -&gt; <code>data.nat.enat</code> -&gt; <code>tactic.norm_num</code> -&gt; <code>data.rat.cast</code>, I didn't fix this or look for other things like it but now the diff is more reviewable</p>",
        "id": 261841248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637179723
    },
    {
        "content": "<p>Right I also did a merge with master, wasn't on purpose but I guess it is okay</p>",
        "id": 261841334,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637179754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310349.20Reduce.20imports.20to.20only.20those.20necessary.20in.20the.20entire/near/261791691\">said</a>:</p>\n<blockquote>\n<p>I'm guessing it's at least 25% of all the files touched</p>\n</blockquote>\n<p>this guess was stunningly accurate <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 261841559,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637179837
    },
    {
        "content": "<p>oh was it, I didn't even notice haha</p>",
        "id": 261842008,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637180056
    },
    {
        "content": "<p>It builds <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 261856167,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637186358
    },
    {
        "content": "<p>I recalculated one stat: now the longest import chain is only 130 (from ~139)</p>",
        "id": 261865675,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637191717
    },
    {
        "content": "<p>Is it worth running the speedbot on this PR to see if it improves compilation speeds?</p>",
        "id": 261865784,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1637191800
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, would you mind running the benchmark bot?</p>",
        "id": 261866094,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637191947
    },
    {
        "content": "<p>Its plausible that it might speed up a little bit on a build of all of mathlib, but partial recompilation is where there is the most potential gain, I'm not sure how much time in a mathlib build is wasted just waiting around if you only have a couple of cores.</p>\n<p>Edit: actually thinking about it more I'm even more quite curious, there are definitely a few things that will have decreased (e.g. simp sets and typeclasses instances in the environment) that will affect build speed, so I have no idea what the affect is</p>",
        "id": 261866133,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637191972
    },
    {
        "content": "<p>Just the fact that you've reduced the longest chain should have an effect, as well.</p>",
        "id": 261867909,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637193323
    },
    {
        "content": "<p>I just started a benchmark for this PR against current master.</p>",
        "id": 261920749,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1637238828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> did the benchmark finish already?</p>",
        "id": 261990002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637269271
    },
    {
        "content": "<p>Just now, I did two runs per commit. No difference whatsoever, both commits (2f3b18529a81046a890dae6ef52dbad851e56707 and 6e4d6b3f7d3733781df4bf704b5878f18295ddb6) take 1h50m (on my Desktop, so not the usual build bot) with 4 threads.</p>",
        "id": 261990325,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1637269429
    },
    {
        "content": "<p>Thanks! Well, in some sense that was expected. Because for a full compile, threads weren't idling too much anyways.</p>",
        "id": 262028605,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637299411
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span> Shall we merge this?</p>",
        "id": 262028607,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637299419
    },
    {
        "content": "<p>Ooh, it looks like Reid's branch isn't merged into this branch yet. <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> could you please do that?</p>",
        "id": 262048773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637317181
    },
    {
        "content": "<p>Should we pull it off the queue?</p>",
        "id": 262050501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637318306
    },
    {
        "content": "<p>Sorry, GH is trolling me <em>again</em></p>",
        "id": 262051581,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637319027
    },
    {
        "content": "<p>I'm very sure I hit F5 on the page, and it didn't show me the updates.</p>",
        "id": 262051611,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637319040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> So no, we don't need to pull it off the queue. All is fine.</p>",
        "id": 262051628,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637319055
    },
    {
        "content": "<p><img alt=\":merge:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18527.png\" title=\"merge\"></p>",
        "id": 262057808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323467
    },
    {
        "content": "<p>I'm looking at the diff just now, and what the hell is going on with the alphabetical order?</p>",
        "id": 262269972,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637541834
    },
    {
        "content": "<p>I can't tell what rule the algorithm followed to order the imports. It got some right, but most wrong.</p>",
        "id": 262270024,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637541877
    },
    {
        "content": "<p>I think at that time it was approximately necessary imports first alphabetised then transitive, but I'm not 100% sure. Certainly in the end a fair bit of manual tweaking was done too, so I wouldn't claim the imports were put in any specific order anymore</p>",
        "id": 262271658,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637544329
    },
    {
        "content": "<p>Some things like the archive were just done by hand as making the one fix there was easier than teaching the tool about the archive directory</p>",
        "id": 262271712,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637544403
    }
]
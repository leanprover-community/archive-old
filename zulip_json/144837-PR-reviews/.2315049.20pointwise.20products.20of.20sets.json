[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib/pull/15049\">#15049</a> I try to add some lemmas about the existing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.monoid\">docs#set.monoid</a> structure, regarding the effect of <code>list.prod</code>.</p>\n<p>What I want to say is \"<code>a</code> is in the product of the sets in <code>l</code> iff there is a list whose members are elements of the corresponding set\"; but this notion of \"corresponding\" feels annoying due to having to mention the lists are the same lenght.</p>\n<p>One way I came up with is instead to have a single list containing both the elements and the sets, and then state that the original list is just a projection on the new one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_list_prod</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l.prod</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">↥</span><span class=\"n\">s</span><span class=\"o\">),</span>\n    <span class=\"n\">list.prod</span> <span class=\"o\">(</span><span class=\"n\">l'.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">sigma.snd</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">l'.map</span> <span class=\"n\">sigma.fst</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>the nice thing about this approach is that the second half of the existential can be immediately rewritten by.</p>",
        "id": 291045377,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658933378
    },
    {
        "content": "<p>(this is all really a tangent; what I care about is just <code>a ∈ s ^ n</code>, but <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> requested I generalize to when the elements of the product are not all the same)</p>",
        "id": 291045502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658933410
    }
]
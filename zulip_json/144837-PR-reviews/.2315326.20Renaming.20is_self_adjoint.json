[
    {
        "content": "<p>This will accumulate merge conflicts rather quickly (thanks Anatole for letting me know of the first one), so I'd like to discuss this rather sooner than later</p>",
        "id": 290297710,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658350641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span>  I am fine with this change and think it makes sense (I'll look carefully at the PR today sometime), but can you add a detailed description to the PR explaining precisely what you are changing and why it is necessary? That way (a) there will be a clear history in the git log, and (b) for those unfamiliar with the area they will understand the distinction clearly which should make it easier to review.</p>",
        "id": 290409460,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1658425478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> Have you considered defining <code>is_self_adjoint</code> in the context of a general star-ring?  So it would be the unbundled version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/self_adjoint\">docs#self_adjoint</a> ?  I guess this would still let you use dot notation for lemmas <code>is_self_adjoint.foo</code>, and it would deduplicate the continuous-linear and linear theory.</p>",
        "id": 290794962,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658771532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290297710\">said</a>:</p>\n<blockquote>\n<p>This will accumulate merge conflicts rather quickly (thanks Anatole for letting me know of the first one),</p>\n</blockquote>\n<p>Indeed, I think there are a few more lemmas that need to be renamed now that <a href=\"https://github.com/leanprover-community/mathlib/pull/15470\">#15470</a> is merged.</p>",
        "id": 290795200,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658771664
    },
    {
        "content": "<p>I guess my grand plan would be rather to do the unbounded operator theory first and then deduce the bounded operators as a special case. This would make it impossible to use abstract notions of self-adjointness. In the bounded case the adjoint is naturally a bounded operator, whereas for finite dimensional vector spaces it might be annoying to do everything with <code>continuous_linear_map</code>s so I am not sure how to avoid duplications completely.</p>",
        "id": 290805406,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658776318
    },
    {
        "content": "<p>I agree that for the unbounded operator theory, <code>is_self_adjoint</code> (to be renamed <code>is_symmetric</code>) is the useful concept.  But the thing which you propose in the future to call <code>is_self_adjoint</code>, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A (not necessarily bounded) operator `A` on an inner product space is self-adjoint iff</span>\n<span class=\"sd\">  `A` is equal to its adjoint. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_self_adjoint</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">A.adjoint</span> <span class=\"bp\">=</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>the right context here is star-rings, right?</p>",
        "id": 290805808,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658776538
    },
    {
        "content": "<p>yes</p>",
        "id": 290805977,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658776631
    },
    {
        "content": "<p>So should we move that definition in your PR to the file<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/star/self_adjoint.html\">https://leanprover-community.github.io/mathlib_docs/algebra/star/self_adjoint.html</a><br>\n?</p>",
        "id": 290819439,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658783689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290805808\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A (not necessarily bounded) operator `A` on an inner product space is self-adjoint iff</span>\n<span class=\"sd\">  `A` is equal to its adjoint. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_self_adjoint</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">A.adjoint</span> <span class=\"bp\">=</span> <span class=\"n\">A</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Do we really need a second version of this? We already have <code>x ‚àà self_adjoint (E ‚ÜíL[ùïú] E)</code>, no...?</p>",
        "id": 290840111,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1658799415
    },
    {
        "content": "<p>Right, there's an argument about whether the second (unbundled) version should exist, but if we do add it, I think it should be in the same file and mathematical setting as the bundled version!</p>",
        "id": 290840223,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658799547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290795200\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290297710\">said</a>:</p>\n<blockquote>\n<p>This will accumulate merge conflicts rather quickly (thanks Anatole for letting me know of the first one),</p>\n</blockquote>\n<p>Indeed, I think there are a few more lemmas that need to be renamed now that <a href=\"https://github.com/leanprover-community/mathlib/pull/15470\">#15470</a> is merged.</p>\n</blockquote>\n<p>I've (hopefully) fixed all merge conflicts. The diff looks rather complicated because the proofs can be improved with the new <code>is_self_adjoint</code>, now it is possible to rewrite everything in terms of the adjoint and <code>simp</code> helps there a bit.</p>",
        "id": 290870110,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658829196
    },
    {
        "content": "<p>I am afraid that the dedup to remove <code>is_self_adjoint</code> in favor of <code>self_adjoint R</code> might not be doable at the moment. In the abstract setting the adjoint is only defined over one ring and <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> 's recent additions crucially use that <code>A.adjoint : F -&gt; E</code> for <code>A : E -&gt; F</code>.</p>",
        "id": 290903438,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658846523
    },
    {
        "content": "<p>For instance I don't see how <code>conj_orthogonal_projection</code> can be proved in a sensible way with <code>self_adjoint R</code></p>",
        "id": 290903704,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658846654
    },
    {
        "content": "<p>on a related note, we then should also redefine <code>is_positive</code> in an abstract way (there exists a square root), but proving the equality to the current definition requires the spectral theorem for bounded self-adjoint operators <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 290904416,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658846981
    },
    {
        "content": "<p>it builds successfully now</p>",
        "id": 290908843,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658848731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290903438\">said</a>:</p>\n<blockquote>\n<p>I am afraid that the dedup to remove <code>is_self_adjoint</code> in favor of <code>self_adjoint R</code> might not be doable at the moment. In the abstract setting the adjoint is only defined over one ring and <span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> 's recent additions crucially use that <code>A.adjoint : F -&gt; E</code> for <code>A : E -&gt; F</code>.</p>\n</blockquote>\n<p>This is a good point. I think this means that we shouldn't use <code>star</code> to mean <code>adjoint</code> <del>, and that we have to keep the <code>is_self_adjoint</code> definition</del></p>",
        "id": 290936579,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658860130
    },
    {
        "content": "<p>Unless we want to make a theory of \"pairs of algebras with a <code>star</code> sending each algebra to the other\" <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 290936764,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658860205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290904416\">said</a>:</p>\n<blockquote>\n<p>on a related note, we then should also redefine <code>is_positive</code> in an abstract way (there exists a square root), but proving the equality to the current definition requires the spectral theorem for bounded self-adjoint operators <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n</blockquote>\n<p>I'm not a big fan of having definitions which need huge theorems to even be useful, because although I don't know about this particular case, in a lot of cases you have to develop both theorie anyway to show they are equivalent</p>",
        "id": 290936964,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658860313
    },
    {
        "content": "<p>It would be useful, since it is very easy to show that the abstract definition implies the concrete one (if you have a square root <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>B</mi><mo>‚àó</mo></msup><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A = B^* B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> you immediately see that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">‚ü®</mo><mi>A</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">‚ü©</mo><mo>=</mo><mo stretchy=\"false\">‚ü®</mo><mi>B</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>B</mi><mi>x</mi><mo stretchy=\"false\">‚ü©</mo><mo>‚â•</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\langle A x, x \\rangle = \\langle B x, B x\\rangle \\geq 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">‚ü®</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">‚ü©</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">‚ü®</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">‚ü©</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚â•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>), it is just that showing the converse direction uses (at least to my knowledge) the spectral theorem via the functional calculus (you construct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mi>A</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{A}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1133em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9267em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">A</span></span></span><span style=\"top:-2.8867em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1133em;\"><span></span></span></span></span></span></span></span></span>).</p>",
        "id": 290937569,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658860574
    },
    {
        "content": "<p>but I was really serious about that remark, even though it might happen eventually since the C*-people might prefer to have an abstract definition of non-negative operators.</p>",
        "id": 290937832,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658860700
    },
    {
        "content": "<p>I will <em>definitely</em> have an abstract definition (likely via the spectrum) for nonnegative operators. My goal is to keep the C*-algebra theory independent of representation as much as possible. I find it analogous to the situation in linear algebra where you want to avoid choosing a basis in developing most of the theory in a nice way.</p>",
        "id": 290938676,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1658861107
    },
    {
        "content": "<p>Is there a quick way to prove that the sum of two positive operators is positive using the abstract definition. If yes that we could switch to it, otherwise I think this is a pretty strong reason of keeping the concrete definition at least before we are able to prove this about the abstract definitoon.</p>",
        "id": 290938940,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658861253
    },
    {
        "content": "<p>Although I'm not sure I understand the comment about A : E -&gt; F. Even if you have an adjoint defined in this context, the operator can't be selfadjoint. Or am I missing the point?</p>",
        "id": 290938961,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1658861267
    },
    {
        "content": "<p>We cannot replace <code>A.adjoint</code> by <code>star A</code> everywhere, because the adjoint is more general. Nothing about self-adjointness here</p>",
        "id": 290939074,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658861316
    },
    {
        "content": "<p>There is an abstract way, yes, but no it's not as simple as with the inner product. To be clear, I'm not advocating getting rid of the concrete definition, only emphasizing that we will have an abstract one too.</p>",
        "id": 290939175,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1658861397
    },
    {
        "content": "<p>Also, quick disclaimer : as usual, I am learning some of the math while doing them in Lean, so it is completely possible that I am doing some things wrong <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 290939445,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658861524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/290939074\">said</a>:</p>\n<blockquote>\n<p>We cannot replace <code>A.adjoint</code> by <code>star A</code> everywhere, because the adjoint is more general. Nothing about self-adjointness here</p>\n</blockquote>\n<p>That said, why can't we use the general self adjointness then ? I agree it would be annoying to use because one would have to constantly switch between <code>star</code> and <code>adjoint</code> all the time, but this is doable, right ?</p>",
        "id": 290939588,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658861608
    },
    {
        "content": "<p>hm, you might be right and I was a bit too eager with removing things. Give me a second for a less invasive dedup.</p>",
        "id": 290939823,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658861727
    },
    {
        "content": "<p>I guess all one needs is <code>mem_self_adjoint_iff</code> with rhs being <code>A.adjoint = A</code> and everything should work just fine</p>",
        "id": 290940084,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658861826
    },
    {
        "content": "<p>it works, and the stuff I have to do to fix all the files is rather easy</p>",
        "id": 290942258,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658862780
    },
    {
        "content": "<p>but it is really sad to not have dot-notation</p>",
        "id": 290942604,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658862938
    },
    {
        "content": "<p>and it is a bit more annoying to write down since you have to be explicit about the spaces</p>",
        "id": 290942811,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658863034
    },
    {
        "content": "<p>If I use a completely bundled approach (i.e., using <code>A : self_adjoint (..)</code>), then all lemmas that show that certain operators are self-adjoint become definitions, right?</p>",
        "id": 290944843,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658863995
    },
    {
        "content": "<p>Hmmm I'm not sure about doing this, it smells coercion hell. Do you think the fact that it brings back dot notation is worth the trouble ?</p>",
        "id": 290945320,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658864229
    },
    {
        "content": "<p>But if you do this yes, everything becomes definitions</p>",
        "id": 290945353,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658864246
    },
    {
        "content": "<p>I am not sure about this either, but the version with mem looks really messy</p>",
        "id": 290945776,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658864456
    },
    {
        "content": "<p>Yes it's always the same balance to find between unifying things and making things easy to write. There is the same problem with the morphism refactor, where we lost some of the dot notation and have to be much more explicit because Lean can't guess that when we want to consider a continuous linear map as a linear map it is obviously between the same spaces and with the same base field</p>",
        "id": 290946076,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658864580
    },
    {
        "content": "<p>I really don't have a good answer</p>",
        "id": 290946101,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658864592
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Conjugating preserves self-adjointness -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">adjoint_conj'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">self_adjoint</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">self_adjoint</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">A</span> <span class=\"k\">with</span> <span class=\"n\">A</span> <span class=\"n\">hA</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">S</span><span class=\"bp\">‚Ä†</span> <span class=\"bp\">‚àò</span><span class=\"n\">L</span> <span class=\"n\">A</span> <span class=\"bp\">‚àò</span><span class=\"n\">L</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_self_adjoint_iff</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hA</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"n\">adjoint_comp</span><span class=\"o\">,</span> <span class=\"n\">adjoint_adjoint</span><span class=\"o\">,</span> <span class=\"n\">add_subgroup.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_linear_map.comp_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- Conjugating preserves self-adjointness -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">adjoint_conj</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"n\">self_adjoint</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">‚Ä†</span> <span class=\"bp\">‚àò</span><span class=\"n\">L</span> <span class=\"n\">A</span> <span class=\"bp\">‚àò</span><span class=\"n\">L</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">self_adjoint</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_self_adjoint_iff</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hA</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"n\">adjoint_comp</span><span class=\"o\">,</span> <span class=\"n\">adjoint_adjoint</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_linear_map.comp_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>these are the two different versions</p>",
        "id": 290946458,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658864768
    },
    {
        "content": "<p>For <code>A : self_adjoint (E ‚ÜíL[ùïú] E)</code> and <code>x : E</code> the coercion <code>A x</code> works just fine</p>",
        "id": 290946562,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658864847
    },
    {
        "content": "<p>If we use the unbundled version, then we have a worse variant of the <code>is_self_adjoint</code> definition (without dot-notation and less portable), but the bundled variant adds a bit of boilerplate to each proof that needs to unfold the self-adjointness condition. I could live with both variants, but I only want to change it once :-D</p>",
        "id": 290947245,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658865210
    },
    {
        "content": "<p>There's also the option of keeping <code>is_self_adjoint</code> for convenience but defining it in terms of <code>self_adjoint</code></p>",
        "id": 290947731,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658865448
    },
    {
        "content": "<p>Maybe it is time for a poll ?</p>",
        "id": 290947746,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658865458
    },
    {
        "content": "<p>/poll How to define self-adjoint operators<br>\nNew definition: <code>A.is_self_adjoint</code><br>\nAbstract definition, unbundled: <code>A ‚àà self_adjoint (E ‚ÜíL[ùïú] E)</code><br>\nAbstract definition, bundled: <code>A : self_adjoint (E ‚ÜíL[ùïú] E)</code></p>",
        "id": 290948112,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658865607
    },
    {
        "content": "<p>I always forget that polls don't support backticks..</p>",
        "id": 290948224,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658865656
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span></p>",
        "id": 290948347,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658865714
    },
    {
        "content": "<p>The way I see it, the main disadvantage of the new definition is that we will have to convert between the two versions whenever we use both lemmas that are specifically about self-adjoint operators and lemmas that are about self-adjoint elements of an abstract algebra.</p>",
        "id": 290977770,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1658886224
    },
    {
        "content": "<p>Reasoning for my vote: we want a bundled version so that we can, for instance, make the selfadjoint operators into a real vector space under certain circumstances. While this is still possible with the unbundled approach, I don't think it's as nice. However, we also want the unbundled version because there are times when you just want the predicate (so that not all theorems that prove something is selfadjoint have to be defs; that could get old quickly). And as mentioned above, it would be nice not to need to switch between the two (abstract and concrete) all the time.</p>",
        "id": 290983586,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1658892605
    },
    {
        "content": "<p>Yes, the advantage for option 2 is that we can bundle on the fly, right ? Although it would only be a subgroup, not a submodule.</p>",
        "id": 290983627,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1658892708
    },
    {
        "content": "<p>This LGTM but I figured <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> might want to have a look one more time so I've delegated it to him.</p>",
        "id": 291029490,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1658926704
    },
    {
        "content": "<p>I'm agnostic, more or less.  There is precedent for having both a propositional <code>is_self_adjoint</code> and a subgroup <code>self_adjoint</code>.  Compare e.g. <code>is_unit</code> and <code>units</code>.  But I think this makes sense only if we commit to keeping up the parallel theories and writing a lot of support for both versions.</p>",
        "id": 291059974,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658937322
    },
    {
        "content": "<p>I am starting to wonder whether this whole discussion becomes easy to settle once we have unbounded operators. there we will need a new definition (because there is no algebraic structure) and for bounded operators we then have the concrete version for <code>linear_pmap</code> and the abstract version using the fact that <code>continuous_linear_map</code> is a <code>star_ring</code>.</p>",
        "id": 291069485,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1658937890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/291059974\">said</a>:</p>\n<blockquote>\n<p>I'm agnostic, more or less.  There is precedent for having both a propositional <code>is_self_adjoint</code> and a subgroup <code>self_adjoint</code>.  Compare e.g. <code>is_unit</code> and <code>units</code>.  But I think this makes sense only if we commit to keeping up the parallel theories and writing a lot of support for both versions.</p>\n</blockquote>\n<p>If <code>is_unit</code> is a <code>set</code> instead of a predicate, we'd be able to write <code>r : is_unit R</code> and <code>r</code> would be a term of the (\"bundled\") subtype, because we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.has_coe_to_sort\">docs#set.has_coe_to_sort</a>. The main advantage of using <code>r : units R</code> is that <code>units</code> carries the data of an inverse, which doesn't seem to apply here.</p>\n<p>Now <code>self_adjoint</code> is a <code>subgroup</code>, which is <code>set_like</code>, and we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like.has_coe_to_sort\">docs#set_like.has_coe_to_sort</a>, so both expressions <code>A ‚àà self_adjoint (E ‚ÜíL[ùïú] E)</code> and <code>A : self_adjoint (E ‚ÜíL[ùïú] E)</code> should already be supported, but I'm not sure how dot notations work for them. If <code>self_adjoint</code> carries other structures, I think we'd want to make it the strongest substructure possible (e.g. <code>submodule</code>).</p>",
        "id": 291072039,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658938928
    },
    {
        "content": "<p>I am rather confused on how to proceed given that the poll is rather indecisive</p>",
        "id": 291296183,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659084110
    },
    {
        "content": "<p>I've just re-read this entire thread, and it's rather confusing (to me), so I'm going to try and summarize and put it into a coherent form.</p>\n<ol>\n<li>The current <code>inner_product_space.is_self_adjoint</code> is misnamed, and is being changed in this PR to <code>linear_map.is_symmetric</code>. There seem to be no complaints about this change.</li>\n<li>We currently have <code>self_adjoint R</code> as an <code>add_subgroup</code> of a star add group <code>R</code>.</li>\n<li>This allows us to talk about <code>A : self_adjoint R</code> as a bundled selfadjoint element, and <code>A ‚àà self_adjoint R</code> as the unbundled predicate.</li>\n<li>While the former allows for both bundled and unbundled versions, it can be extremely verbose when <code>R</code> is, for example, <code>E ‚ÜíL[ùïú] E</code>, and it precludes dot notation, both of which can be inconvenient.</li>\n<li>\n<p>Consequently, the current PR defines a new predicate <code>continuous_linear_map.is_self_adjoint</code> which solves the verbosity and dot notation problems, but:<br>\n  a. introduces a new predicate, separate from <code>A ‚àà self_adjoint R</code>,<br>\n  b. is only defined for <code>continuous_linear_map</code>s, not even <code>linear_map</code>s, so perhaps it should be migrated to the context of <code>star_ring</code>s and defined in terms of <code>star</code> rather than <code>adjoint</code>.</p>\n</li>\n<li>\n<p>The poll on which things to prefer was indecisive.</p>\n</li>\n</ol>",
        "id": 291617802,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659380119
    },
    {
        "content": "<p>After thinking much more about all this, I propose the following, which I <em>think</em> may appease most everyone, but it's entirely possible I'm missing the mark.</p>\n<ol>\n<li>Create a new definition to live in <code>algebra/star/self_adjoint</code>:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_self_adjoint</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">non_unital_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">star</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>This will allow for dot notation, and for deduplicating selfadjointness of linear_maps versus continuous_linear_maps</li>\n<li>We keep the bundled type <code>self_adjoint R</code> (because we want it to put various structures on it). Optionally, we redefine the carrier in terms of the new <code>is_self_adjoint</code> predicate (I'm not sure if this would be useful or worth doing).</li>\n<li>Crucially, we then make a note which says to prefer <code>A.is_self_adjoint</code> over <code>A ‚àà self_adjoint R</code> and we migrate existing uses of the latter to the former.</li>\n</ol>\n<p>Thoughts?</p>",
        "id": 291617848,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659380144
    },
    {
        "content": "<p>Thanks Jireh for summarizing. I am not sure whether we need a new definition at all. My guess is that a mixture of using the unbundled and bundled version will be more than sufficient (i.e., using the unbundled version where having a definition seems overly complicated). But I am not completely sure whether this works as smoothly as I imagine.</p>",
        "id": 291619748,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659380985
    },
    {
        "content": "<p>To be honest, if everything I said above is true, I think having the new definition will be nicer (provided it is generalized to star_ring to encompass both linear_map and continuous_linear_map). The access to dot notation and less verbosity seem like sufficient benefit for the minor change of preferring <code>A.is_self_adjoint</code> to <code>A ‚àà self_adjoint R</code>.</p>",
        "id": 291620961,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659381615
    },
    {
        "content": "<p>The summary seems exactly accurate to me.  I am mildly in favour of having both <code>is_self_adjoint</code> and <code>self_adjoint</code>, and if this is implemented, I am furthermore mildly in favour of<br>\n<span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/291617848\">said</a>:</p>\n<blockquote>\n<p>Optionally, we redefine the carrier in terms of the new <code>is_self_adjoint</code> predicate (I'm not sure if this would be useful or worth doing).</p>\n</blockquote>",
        "id": 291645458,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659395621
    },
    {
        "content": "<p>Actually, one point.  Having <code>is_self_adjoint</code> indeed \"enables dot notation\", but it's not that it allows <code>A : E ‚ÜíL[ùïú] E</code> to have the dot notation <code>A.is_self_adjoint</code>.  Rather, it's that in any setting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">non_unital_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>it allows <code>ha : is_self_adjoint a</code> to be a dot-notation input into theorems <code>is_self_adjoint.blah</code>.  Right?</p>",
        "id": 291645720,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659395835
    },
    {
        "content": "<p>Yes</p>",
        "id": 291646798,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1659396750
    },
    {
        "content": "<p>So if everyone is happy with this solution, I will move <code>is_self_adjoint</code> to <code>star_ring</code> everything this evening.</p>",
        "id": 291682638,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659430809
    },
    {
        "content": "<p>Just to make sure: I am correct in assuming that lemmas like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">bit0_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">self_adjoint</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bit0</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">self_adjoint</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">hx.bit0</span>\n</code></pre></div>\n<p>should not exist?</p>",
        "id": 291743241,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659462286
    },
    {
        "content": "<p>I would think those should not exist. I can't see why we would want them.</p>",
        "id": 291758031,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659468989
    },
    {
        "content": "<p>It also seems like we already have this lemma for general add_subgroups, no reason to have the version specialized to this particular add_subgroup.</p>",
        "id": 291758815,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659469397
    },
    {
        "content": "<p>Really, we should have a <code>bit0_mem</code> lemma for every instance of <code>add_mem_class</code>.</p>",
        "id": 291821925,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1659518546
    },
    {
        "content": "<p>It seems that the PR builds again and is ready for more reviews</p>",
        "id": 291873481,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659543121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, can you explain why that's important?</p>",
        "id": 291921436,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659561395
    },
    {
        "content": "<p>Thanks Jireh for reviewing and I am happy to help on your quest for <code>non_unital_mathlib</code></p>",
        "id": 291982804,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659604388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/291921436\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span>, can you explain why that's important?</p>\n</blockquote>\n<p>(Sorry for the late response!) I didn't mean that this PR should have that, just that an <code>add_mem_class</code> version of <code>bit0_mem</code> would be useful to have - something to put on someone's TODO list (along with other generalizations to subobject classes)</p>",
        "id": 292340126,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1659907175
    },
    {
        "content": "<p>Discussion continues on this PR (cc <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> ).  Here's my attempt to summarize where we are at.</p>\n<p>The PR now contains three separate changes.</p>\n<ol>\n<li>Rename <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_space.is_self_adjoint\">docs#inner_product_space.is_self_adjoint</a> to <code>linear_map.is_symmetric</code></li>\n<li>Introduce <code>is_self_adjoint</code> in the context of star-rings, a Prop version of the existing (bundled) <a href=\"https://leanprover-community.github.io/mathlib_docs/find/self_adjoint\">docs#self_adjoint</a></li>\n<li>Rewrite several existing theories (notably in <code>inner_product_space/positive</code> and <code>inner_product_space/rayleigh</code>) to use the new, star-ring <code>is_self_adjoint</code> rather than the old <code>inner_product_space.is_self_adjoint</code> which is now being renamed <code>is_symmetric</code>.</li>\n</ol>\n<p>The first two changes are not controversial but the third change is controversial.</p>",
        "id": 292492397,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659990638
    },
    {
        "content": "<p>My own opinion is that we should not carry out the change (3). The condition <code>is_symmetric</code> is more lightweight than <code>is_self_adjoint</code>,* since it doesn't depend on the construction of the adjoint.  So it requires fewer imports (well, it used to require fewer imports -- there was a move of material in <a href=\"https://github.com/leanprover-community/mathlib/pull/15281\">#15281</a> which put everything in the same place, but I propose reverting that move).  It is also more general, since it applies to linear maps, rather than to continuous linear maps.</p>\n<p>*I am writing throughout using the new terminology, for clarity.</p>",
        "id": 292493187,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659991053
    },
    {
        "content": "<p>On the other hand, Moritz says in favor of (3)</p>\n<blockquote>\n<p>the whole point why I made this refactor is that I find that this goes too much against the mathematical standards. Technically you could say that the spectral theorem holds for bounded symmetric operators, but nobody does that.</p>\n</blockquote>",
        "id": 292493314,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659991117
    },
    {
        "content": "<p>But maybe this is a difference of subfields?  For example, in Evans' book on elliptic PDE, which is the context where I use this kind of thing, he uses \"symmetric elliptic operators\" (in this same sense -- elliptic operators whose associated bilinear form is symmetric) rather than phrasing in terms of adjoints of partially-defined operators (which from what Moritz has been saying is more common in the literature he knows).</p>",
        "id": 292493882,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659991401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> , responding here to your latest GitHub comment:</p>\n<blockquote>\n<p>Also, I don't really see the value in adding a definition <code>linear_map.is_positive</code>, but maybe you have a good reason for that. There might be an argument that it is necessary for the finite dimensional case, because we don't want to talk about <code>continuous_linear_map</code>s in finite dimensions.</p>\n</blockquote>\n<p>Yes, the finite dimensional case was my idea, although I can see that such a change would be outside the scope of this PR.</p>",
        "id": 292494037,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659991478
    },
    {
        "content": "<p>Heather, you mean the PDE book or is there special book by Evans on elliptic PDEs?</p>",
        "id": 292494417,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659991721
    },
    {
        "content": "<p>I think the reason I am in favor of the <code>is_symmetric T</code> + <code>‚àÄ x, T.re_apply_inner_self x</code> definition for <code>is_positive</code> here (aside from the fact that it also applies to <code>linear_map</code>), is that it is not \"mixing concrete and abstract.\" What I mean is that I would expect at some point to have another definition for <code>is_positive</code> which amounts to something like <code>is_self_adjoint T ‚àß is_R_or_C.re '' (spectrum ùïú T) ‚äÜ set.Ici 0</code>. (or something like this). The current definition in the PR as <code>is_self_adjoint T ‚àß ‚àÄ x, T.re_apply_inner_self x</code> seems to mix the two ideas.</p>\n<p>That being said, I am certainly willing to hear arguments in favor of the mixed approach. However, I'm not sure why you (Moritz) say:</p>\n<blockquote>\n<p>I am sorry if I come across as too stubborn on this, I only think that reverting to is_symmetric for <code>continuous_linear_map</code> would make this whole PR completely useless.</p>\n</blockquote>\n<p>I think this PR has value even with reverting this.</p>\n<p>All that being said, I am actually rather ambivalent about which way this ultimately goes. I am completely in favor of (1) and (2) that Heather listed above, but (3) I am ultimately okay either way.</p>",
        "id": 292495269,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659992134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/292494417\">said</a>:</p>\n<blockquote>\n<p>Heather, you mean the PDE book or is there special book by Evans on elliptic PDEs?</p>\n</blockquote>\n<p>I found it in the PDE book. He actually defines symmetric as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo>‚àó</mo></msup><mo>=</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A^* = A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></p>",
        "id": 292496361,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659992640
    },
    {
        "content": "<p>p. 639</p>",
        "id": 292496416,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659992650
    },
    {
        "content": "<p>so his symmetry is not the symmetry that you mean because he only defines it for continuous linear operators (which is really weird).</p>",
        "id": 292496609,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659992744
    },
    {
        "content": "<p>He does not care about unbounded operators (which is bad because his operators are unbounded), but I guess the reason why he gets away with it is because he only uses the spectral theorem for compact operators (applied to the resolvent). Even this is sketchy because if you don't choose boundary conditions - say you take the Laplacian on a bounded domain as an operator <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mi>c</mi><mi mathvariant=\"normal\">‚àû</mi></msubsup><mo>‚Üí</mo><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">C_c^\\infty \\to L^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9303em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> - then the resolvent set is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> and your resolvent is not defined anywhere. So his whole definitions work because he just takes Dirichlet boundary conditions and this implies that his operator is actually self-adjoint.</p>",
        "id": 292498190,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659993614
    },
    {
        "content": "<p>Jireh, I agree the definition as it is now is weird and I have no very good way to solve that at the moment. I guess I would be fine with reverting that the <code>is_positive</code> for the sake of the PR getting merged and knowing that we find a better solution later on.</p>",
        "id": 292499668,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659994445
    },
    {
        "content": "<p>If we revert all the <code>is_self_adjoint T</code> to <code>is_symmetric (T : E ‚Üí‚Çó[ùïú] E)</code> then the only thing gained from the PR is that the old <code>is_self_adjoint</code> is renamed to <code>is_symmetric</code> (ok, that is good), but we added a definition (<code>is_self_adjoint</code>) that is never used at all and we would loose dot-notation again.</p>",
        "id": 292500022,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659994663
    },
    {
        "content": "<p>(I find it quite funny that Evans defines <code>is_symmetric</code> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo>‚àó</mo></msup><mo>=</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A^* = A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and the current mathlib defines <code>is_self_adjoint</code> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">‚ü®</mo><mi>A</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">‚ü©</mo><mo>=</mo><mo stretchy=\"false\">‚ü®</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>A</mi><mi>y</mi><mo stretchy=\"false\">‚ü©</mo></mrow><annotation encoding=\"application/x-tex\">‚ü®A x, y‚ü© = ‚ü® x, A y‚ü©</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">‚ü®</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">‚ü©</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">‚ü®</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">‚ü©</span></span></span></span>)</p>",
        "id": 292500242,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659994784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> I was thinking more of e.g. the discussion at pp 335-6 (maybe this is ambiguous across editions, but Section 6.5.1, \"Eigenvalues of symmetric elliptic operators\").  Here he has a second-order elliptic operator L, which is symmetric and unbounded as an operator on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>H</mi><mn>0</mn><mn>1</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">H^1_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.4519em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>; this symmetry is really <code>is_symmetric</code> in your terminology.  And then for fixed boundary conditions he builds an operator on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">L^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> which he calls formally <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">L^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚àí</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>; this is symmetric and compact (because of the Rellich-Kondrachov compactness theorem) and he applies the spectral theorem to it.</p>",
        "id": 292508592,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659999947
    },
    {
        "content": "<p>Anyway, I mention Evans' book as a data point for how I am used to thinking about these things -- isn't it useful to have theory for symmetric, unbounded operators?</p>",
        "id": 292508940,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1660000209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/292500022\">said</a>:</p>\n<blockquote>\n<p>we would loose dot-notation again.</p>\n</blockquote>\n<p>This point I don't quite follow, by the way.</p>",
        "id": 292508970,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1660000245
    },
    {
        "content": "<p>Anyway, in terms of concrete differences between the approaches:  Maybe one difference is that I propose to put <code>is_symmetric</code> in a different file from the adjoint and then to make some attempt to reserve the adjoint to later in the import hierarchy, whereas for you this is not really worth the effort.</p>",
        "id": 292509986,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1660000977
    },
    {
        "content": "<p>Yes and no, symmetric unbounded operators are useful in the sense that they are usually what you start with (Laplacian without choosing boundary conditions), but you want to have self-adjoint operators, because the spectral theorem only holds for self-adjoint operators (well for normal operators, but let's not get into that). So one really big part of mathematical physics is showing that certain symmetric operators are (essentially) self-adjoint. Of course we want to have the definition of symmetric operators in mathlib, but you cannot use it to prove anything about the spectrum or eigenvalues.</p>",
        "id": 292510021,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660001007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/292509986\">said</a>:</p>\n<blockquote>\n<p>Anyway, in terms of concrete differences between the approaches:  Maybe one difference is that I propose to put <code>is_symmetric</code> in a different file from the adjoint and then to make some attempt to reserve the adjoint to later in the import hierarchy, whereas for you this is not really worth the effort.</p>\n</blockquote>\n<p>I have no problems with that. I would rather not have it in the basics file, because this is too long already.</p>",
        "id": 292510125,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660001100
    },
    {
        "content": "<p>VSCode tends to crash my laptop if I open files that are significant longer than 1000 lines</p>",
        "id": 292510234,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660001191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/292508970\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/292500022\">said</a>:</p>\n<blockquote>\n<p>we would loose dot-notation again.</p>\n</blockquote>\n<p>This point I don't quite follow, by the way.</p>\n</blockquote>\n<p>Technically you can, but then everything is in the wrong namespace <code>linear_map.is_symmetric</code>, but the map was actually defined as a <code>continuous_linear_map</code> that got coerced into a <code>linear_map</code> for the <code>is_symmetric</code> property.</p>",
        "id": 292510561,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660001443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/292510021\">said</a>:</p>\n<blockquote>\n<p>Of course we want to have the definition of symmetric operators in mathlib, but you cannot use it to prove anything about the spectrum or eigenvalues.</p>\n</blockquote>\n<p>Maybe I don't follow ... it's certainly possible to do this if you want to (see <a href=\"https://github.com/leanprover-community/mathlib/blob/b5cf0af69f065f116018f8cab61405aae5adbb7b/src/analysis/inner_product_space/spectrum.lean#L569\">one version</a> of the spectral theorem from <a href=\"https://arxiv.org/abs/2202.05360\">https://arxiv.org/abs/2202.05360</a>, before we changed it to use the adjoint)</p>",
        "id": 292510569,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1660001449
    },
    {
        "content": "<p>you assume <code>variables [cplt : complete_space E] {T : E ‚ÜíL[ùïú] E} (hT : is_self_adjoint (T : E ‚Üí‚Çó[ùïú] E))</code>, right? This is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo>‚àó</mo></msup><mo>=</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A^* = A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></p>",
        "id": 292510715,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660001596
    },
    {
        "content": "<p>so I would argue that your operator is secretly self-adjoint.</p>",
        "id": 292510839,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660001676
    },
    {
        "content": "<p>I see -- you mean, for good <em>theorems</em> you need <code>‚ÜíL[ùïú]</code>, i.e. the context in which the criteria are equivalent.</p>",
        "id": 292512955,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1660003319
    },
    {
        "content": "<p>There's one more issue that hasn't been adressed yet: wouldn't it make more sense to define <code>is_symmetric</code> and <code>is_self_adjoint</code> (if we do end up defining the latter) for <code>linear_map_class</code> rather than <code>linear_map</code>s? Certainly we would want to avoid having to coerce continuous linear maps, linear isometries, etc, into <code>linear_map</code>s all the time.</p>",
        "id": 292539757,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1660033416
    },
    {
        "content": "<p>maybe then we want a class <code>linear_pmap_class</code> and we define <code>is_symmetric</code> and <code>is_self_adjoint</code> for that.</p>",
        "id": 292544054,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660036423
    },
    {
        "content": "<p>Heather, essentially yes. for the compact operator spectral theorem the compactness (which implies <code>‚ÜíL[ùïú]</code>) is the crucial point. for the general spectral theorem you don't need <code>‚ÜíL[ùïú]</code>, but the results are better if you assume it (\"spectral theorem for bounded operators\").</p>",
        "id": 292544361,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660036588
    },
    {
        "content": "<p>when defining <code>continuous_linear_pmap</code> I thought about a possible <code>linear_pmap_class</code>, but since the domain is not fixed I did not know how to define it</p>",
        "id": 292544706,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660036767
    },
    {
        "content": "<p>so my view on the PR (but I am of  course biased in favor of it) is that does not solve all issues, but it improves the situation significantly and makes it so that later refactors are way easier to do. If Heather has really strong opinions on the condition in <code>is_positive</code> as I said I would be change it there, just to do be done with it (even though I think <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> might have also strong opinions on that). For the Rayleigh quotient, I am more stubborn, because it will eventually end up being defined for <code>linear_pmap</code> and <code>is_self_adjoint</code>, so reverting it to <code>is_symmetric</code> does not gain anything.</p>",
        "id": 292546940,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660037731
    },
    {
        "content": "<p>Sorry for the delay. For the case of positive operators, what bothers me is not so much heavy imports but rather the fact that the whole file currently works in non complete spaces, and I‚Äôm not sure having a cleaner phrasing would be worth adding this restriction. But in cases where completeness is needed anyway I don‚Äôt think we should be too strict about prioritizing minimal imports over consistency and readability</p>",
        "id": 292609246,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660061647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> that's a nice idea, but perhaps for a future PR? I think this one is doing enough already. </p>\n<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I'm inclined to accept this as is. What do you think?</p>",
        "id": 292654039,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660077645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Fair enough!</p>",
        "id": 292656646,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1660078752
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, unless you strenuously object, I'll just merge this.</p>",
        "id": 293347702,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660459613
    },
    {
        "content": "<p>I'm still a bit annoyed by the fact that positiveness now only works in complete spaces, but I think we can just discuss it separately because otherwise this PR seems good.</p>",
        "id": 293372790,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660477481
    },
    {
        "content": "<p>So I'd be in favor of merging it</p>",
        "id": 293372813,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660477501
    },
    {
        "content": "<p>And maybe creating an issue mentionning the discussion about positive operators in the comments of the PR</p>",
        "id": 293373060,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660477673
    },
    {
        "content": "<p>one sidenote: Anatole, you wrote that Bourbaki define positive as self-adjoint plus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>A</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>&gt;</mo><mo>‚â•</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">&lt;Ax ,x&gt; \\geq 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;‚â•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. Is that for bounded operators and if not is it self-adjoint or symmetric?</p>",
        "id": 293423796,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660497738
    },
    {
        "content": "<p>I just saw that the PR has merge conflicts. I will fix them later today (I am in a train atm)</p>",
        "id": 293428373,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660500385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2315326.20Renaming.20is_self_adjoint/near/293423796\">said</a>:</p>\n<blockquote>\n<p>one sidenote: Anatole, you wrote that Bourbaki define positive as self-adjoint plus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mi>A</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>&gt;</mo><mo>‚â•</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">&lt;Ax ,x&gt; \\geq 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;‚â•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. Is that for bounded operators and if not is it self-adjoint or symmetric?</p>\n</blockquote>\n<p>Their definition is for bounded operators and their condition is indeed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>u</mi><mo>‚àó</mo></msup><mo>=</mo><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u^* = u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>, which makes sense since they don't care about the non-complete case</p>",
        "id": 293434237,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660504558
    },
    {
        "content": "<p>ok, then the correct generalization is to <code>is_self_adjoint</code> for <code>linear_pmap</code>. Actually I was thinking about defining it for a <code>linear_pmap_class</code> (which we don't have yet, but after a discussion with Jireh, I was convinced that we should) and this would include the non-complete case (consider the operator as a partially defined operator on the completion)</p>",
        "id": 293435054,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660505208
    },
    {
        "content": "<p>Ok I'm happy with that</p>",
        "id": 293435644,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660505676
    },
    {
        "content": "<p>Note: before we dive headlong into making that <code>linear_pmap_class</code> (which we should definitely do!), we should have a discussion about how to implement it, because I'm reasonably sure it won't be able to extend <code>fun_like</code> in any nice way. </p>\n<p>So maybe we want to have a <code>pfun_,like</code> class hierarchy. Perhaps we don't, but I think we should outline the various partial function situations that commonly arise and see if there is any shot at unifying them, or if it isn't worth the effort to make a general framework.</p>",
        "id": 293440613,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660509577
    },
    {
        "content": "<p>Now that this is merged, it unlocks <a href=\"https://github.com/leanprover-community/mathlib/pull/15682\">#15682</a> where <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> suggested moving <code>is_symmetric</code> to a new file sitting between <code>basic</code> and <code>projection</code>. Since it's been a while, I just wanted to make sure everyone is still on board for that? cc <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span></p>",
        "id": 293783405,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660677282
    },
    {
        "content": "<p>in the medium term I hope that <code>is_symmetric</code> is part of <code>inner_product_space/linear_pmap</code>, but for the short term it certainly does not hurt to move it into its own file</p>",
        "id": 293783733,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660677403
    },
    {
        "content": "<p>do you want to do the move or should I?</p>",
        "id": 293783881,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1660677467
    },
    {
        "content": "<p>I'll do it</p>",
        "id": 293784628,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1660677746
    }
]
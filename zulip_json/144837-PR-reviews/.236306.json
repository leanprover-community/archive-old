[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> in this PR you decided to make <code>f</code> in <code>open_embedding.to_local_homeomorph</code> explicit, as you write in the introduction. I use <code>open_embedding.to_local_homeomorph</code> quite a lot in my unpublished code, and this modification makes my code more complicated, so I was wondering: why did you decide to do it?</p>",
        "id": 232413321,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1617105806
    },
    {
        "content": "<p>My only reason is that Lean pretty prints <code>(h : open_embedding f).to_local_homeomorph</code> as <code>_.to_local_homeomorph</code> if <code>h</code> is a nontrivial term.</p>",
        "id": 232466234,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617125820
    },
    {
        "content": "<p>Why this makes the code more complicated? It should be something like <code>h.to_local_homeomorph _</code> instead of <code>h.to_local_homeomorph</code>.</p>",
        "id": 232466321,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617125863
    },
    {
        "content": "<p>If this is inconvenient in real life examples, then possibly we should revert to <code>{f}</code>.</p>",
        "id": 232466478,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617125925
    },
    {
        "content": "<p>This sounds like the <code>is_basis</code> thing that came up before, where we decided to stick with <code>{}</code> - but perhaps the arguments there don't apply here</p>",
        "id": 232470185,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617127374
    },
    {
        "content": "<p>Well nothing terrible but I just find it a bit more clumsy. Often <code>h.to_local_homeomorph</code> is chained to something else and having to repeat <code>f</code> and putting parenthesis each time makes it a bit less readable. This is a typical example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">open_embedding.continuous_mul</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→*</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">*</span> <span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">continuous_iff_continuous_at</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">embedding_mul</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x.fst</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x.snd</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">h.to_local_homeomorph</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">monoid_hom.map_mul</span><span class=\"o\">,</span> <span class=\"n\">open_embedding.target</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">mem_range_self</span> <span class=\"o\">(</span><span class=\"n\">x.fst</span> <span class=\"bp\">*</span> <span class=\"n\">x.snd</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_at.comp</span> <span class=\"o\">((</span><span class=\"n\">h.to_local_homeomorph</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuous_inv_fun.continuous_at</span>\n    <span class=\"o\">(</span><span class=\"n\">mem_nhds_sets</span> <span class=\"o\">(</span><span class=\"n\">h.to_local_homeomorph</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">open_target</span> <span class=\"n\">h'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">continuous_mul.continuous_at.comp</span>\n    <span class=\"o\">(</span><span class=\"n\">h.continuous.continuous_at.prod_map</span> <span class=\"n\">h.continuous.continuous_at</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">open_embedding.continuous_mul</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→*</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">*</span> <span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">continuous_iff_continuous_at</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">embedding_mul</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x.fst</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x.snd</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">h.to_local_homeomorph.target</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">monoid_hom.map_mul</span><span class=\"o\">,</span> <span class=\"n\">open_embedding.target</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">mem_range_self</span> <span class=\"o\">(</span><span class=\"n\">x.fst</span> <span class=\"bp\">*</span> <span class=\"n\">x.snd</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_at.comp</span> <span class=\"o\">(</span><span class=\"n\">h.to_local_homeomorph.continuous_inv_fun.continuous_at</span>\n    <span class=\"o\">(</span><span class=\"n\">mem_nhds_sets</span> <span class=\"n\">h.to_local_homeomorph.open_target</span> <span class=\"n\">h'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">continuous_mul.continuous_at.comp</span>\n    <span class=\"o\">(</span><span class=\"n\">h.continuous.continuous_at.prod_map</span> <span class=\"n\">h.continuous.continuous_at</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232470415,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1617127453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.236306/near/232466234\">said</a>:</p>\n<blockquote>\n<p>My only reason is that Lean pretty prints <code>(h : open_embedding f).to_local_homeomorph</code> as <code>_.to_local_homeomorph</code> if <code>h</code> is a nontrivial term.</p>\n</blockquote>\n<p>Probably this is a stronger reason than mine to go back to curly brackets</p>",
        "id": 232470827,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1617127604
    }
]
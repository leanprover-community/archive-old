[
    {
        "content": "<p>I opened a pull request for the rewrite_search tactic. This is a feature that a number of people like <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> and <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> worked on for a while in a branch. This pull request is kind of a subset of about a quarter of the functionality of that branch; some of the configuration flags are removed and data structures are simplified. Scott suggested this approach of getting a subset merged into master so here's my take. Basically the idea is that it automatically searches for chains of rewrites to prove an equality goal.</p>",
        "id": 215146749,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1604089797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238605\">@Kevin Lacker</span> Thank you so much for reviving this! I left a ton of minor cosmetic comments. Someone with more experience in tactic writing should review the content.</p>",
        "id": 215176922,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604124874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> you had questions about the performance of <code>rb_map string</code> vs <code>rb_map expr</code> and I thought it would be easier to follow up here. I don't have a fancy performance test, I am just timing how long it takes to recompile the one file of unit tests. Originally I didn't realize that <code>rb_map expr</code> would work at all, because I assumed that &lt; wasn't defined on expressions. I still don't really know where lean is getting the comparator from. Is that something that should be just as fast as string comparison? I was assuming that string comparisons would be fast because the vm manages to do those in C++, and that other comparisons were probably not fast, but I am not too expert on this.</p>",
        "id": 218901286,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607122298
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.lt\">docs#expr.lt</a> says Compares expressions, ignoring binder names, and sorting by hash, its defined in C++</p>",
        "id": 218905880,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607125850
    },
    {
        "content": "<p>hmmm. it doesn't seem like it should be drastically slower than a string comparison</p>",
        "id": 218906090,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126087
    },
    {
        "content": "<p>or at least, it seems like the time should still be dominated by lean interactions and not by the c++ code</p>",
        "id": 218906115,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126128
    },
    {
        "content": "<p>but, it's certainly slower on this recompilation. i'll try profiling and seeing if anything else becomes apparent</p>",
        "id": 218906194,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126195
    },
    {
        "content": "<p>yeah if the hash is created at expression creation time then it should really be faster</p>",
        "id": 218906229,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126258
    },
    {
        "content": "<p>So I don't have time tonight to experiment, but yes, my instinct was that <code>expr.lt</code> should be faster than <code>pp</code> + string comparison. <code>expr.lt</code> is used a lot in many places, it isn't slow. And <code>pp</code> needs to traverse the whole <code>expr</code>.</p>",
        "id": 218906277,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126285
    },
    {
        "content": "<p>maybe this actually is short circuiting with some expressions that have pp equality but not hash equality</p>",
        "id": 218906287,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126319
    },
    {
        "content": "<p>this isn't too intertwined with the code, fortunately, this map is only directly accessed in a few places</p>",
        "id": 218906293,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126337
    },
    {
        "content": "<p>Right, the possible downside to <code>expr.lt</code> is that it's a very strict comparison, it doesn't even take alpha or beta equivalence into account. In particular, if you have the \"same\" expr with different type class instances or an unreduced lambda application, it won't match.</p>",
        "id": 218906488,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126531
    },
    {
        "content": "<p>But \"pp equivalence\" is an inherently hacky notion of equivalence.</p>",
        "id": 218906496,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126552
    },
    {
        "content": "<p>I didn't even look, does the tactic specify pp options somehow? Or can you change the behavior of <code>rewrite_search</code> by setting <code>pp.implicit</code> to true before calling it?</p>",
        "id": 218906546,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126606
    },
    {
        "content": "<p>no, it doesn't specify pp options</p>",
        "id": 218906573,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607126632
    },
    {
        "content": "<p>Ideally things would be matched up to defeq with a low reducibility setting. This isn't too expensive. But doing this to match keys in a map forces O(n) lookups.</p>",
        "id": 218906650,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126722
    },
    {
        "content": "<p><code>linarith</code>, <code>ring</code>, etc bite the bullet. But I think <code>rewrite_search</code> does way way more lookups.</p>",
        "id": 218906682,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238605\">Kevin Lacker</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/218906287\">said</a>:</p>\n<blockquote>\n<p>maybe this actually is short circuiting with some expressions that have pp equality but not hash equality</p>\n</blockquote>\n<p>This would be interesting to know and pretty easy to check, just print the full exprs (or just whether they're equal) when you find a match. I wonder how often they're different.</p>",
        "id": 218906861,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607126932
    },
    {
        "content": "<p>OK the difference comes up when rewrite_search is solving this problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constants</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test_algebra</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rewrite_search</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">left_distrib</span><span class=\"o\">,</span> <span class=\"n\">right_distrib</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The graph search ends up with two nodes that both <code>pp</code> to <code>a * (b * d) + a * (c * d)</code>, but they don't compare to equal</p>",
        "id": 219113310,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607363405
    },
    {
        "content": "<p>it reproduces with similar arithmetic too: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">simpler_test</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rewrite_search</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>some sort of equality notion is not caught by the straight <code>=</code> operator there. I don't know enough about the forms of equivalence to immediately intuit what's going on here, though</p>",
        "id": 219113922,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607363694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> any idea what this could be?</p>",
        "id": 219114014,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607363742
    },
    {
        "content": "<p>curiously, it <em>does</em> eventually find a solution! it just takes much longer</p>",
        "id": 219114100,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607363771
    },
    {
        "content": "<p>(when requiring exact equality rather than pp)</p>",
        "id": 219114120,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607363785
    },
    {
        "content": "<p>It's almost certainly a difference in type class instances. The expressions are definitionally equal but take different routes to finding <code>has_add rat</code> or something like that. The <code>pp</code> version succeeds on this example when it thinks the two terms match, right?</p>",
        "id": 219127661,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607369863
    },
    {
        "content": "<p>yeah</p>",
        "id": 219127901,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607369983
    },
    {
        "content": "<p>Ideally we'd have some kind of hash on <code>expr</code> that ignores type class arguments. It could be implemented but I don't know how bad the performance hit would be.</p>",
        "id": 219127913,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607369993
    },
    {
        "content": "<p>I really think that the <code>pp</code> version is going to hit a lot of false positives. Numerals and coercions are just two common examples where different things pretty print the same.</p>",
        "id": 219128043,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370059
    },
    {
        "content": "<p>that's true, i mean this tactic is going to fail lots of the time</p>",
        "id": 219128080,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370079
    },
    {
        "content": "<p>what exactly is a \"type class argument\"</p>",
        "id": 219128114,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370097
    },
    {
        "content": "<p>my heuristic here is, if I have to write c++ to make it fast, then I want to punt until lean 4 exists</p>",
        "id": 219128195,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370122
    },
    {
        "content": "<p><code>has_add.add : Pi {T : Type}, [has_add T] -&gt; T -&gt; T -&gt; T</code> infers the argument of type <code>has_add T</code> using type class resolution. That's the \"type class argument.\"</p>",
        "id": 219128380,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370221
    },
    {
        "content": "<p>The idea being, it's generally (not always) safe to ignore those when comparing terms because there's usually one unique instance up to defeq.</p>",
        "id": 219128532,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370279
    },
    {
        "content": "<p>Which isn't true for regular implicit arguments, which are also ignored by <code>pp</code>.</p>",
        "id": 219128596,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370310
    },
    {
        "content": "<p>so if everything mentioned in this problem is just a rational constant, why would anything be type-class-resolving differently</p>",
        "id": 219128667,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370353
    },
    {
        "content": "<p>Who knows what instances appear after you're rewritten with some generic lemmas. You can <code>set_option pp.implicit true</code> to see how those expressions differ.</p>",
        "id": 219128936,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370458
    },
    {
        "content": "<p>Oh, wait, maybe you can't, changing the <code>pp</code> options will probably change the behavior of <code>rewrite_search</code> right now. Which is another issue.</p>",
        "id": 219128994,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370482
    },
    {
        "content": "<p>it should be the single lemma <code>add_assoc</code> here</p>",
        "id": 219129034,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370487
    },
    {
        "content": "<p>well, i can add it to figure things out i believe</p>",
        "id": 219129141,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370533
    },
    {
        "content": "<p>mm, i guess i can't set_option from within a tactic? hmm</p>",
        "id": 219129238,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370584
    },
    {
        "content": "<p>is there a way to call <code>pp</code> with a fixed set of options, rather than paying attention to the global <code>set_option</code> stuff</p>",
        "id": 219129521,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370707
    },
    {
        "content": "<p>For example, see the change in the <code>has_add nat</code> instance here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.implicit</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.notation</span> <span class=\"n\">false</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219129629,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370750
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pp_using\">docs#pp_using</a></p>",
        "id": 219129708,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370795
    },
    {
        "content": "<p>Not exactly sure how it works.</p>",
        "id": 219129722,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607370807
    },
    {
        "content": "<p>ugh, what a mess</p>",
        "id": 219129946,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370931
    },
    {
        "content": "<p>so the rewrite is doing something like, replacing the addition with \"we know nat has addition because it's a semigroup\" but deduping only happens later</p>",
        "id": 219129985,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607370955
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you have any thoughts about this? It's not unrelated to what we did in <code>ring</code> and <code>linarith</code> parsing. Basically, if you want to match exprs up to defeq you can't use <code>rb_map</code> or any hash-based method, each lookup has to be O(n). Not a problem in those cases because it's outweighed by the rest of the tactic, but here there are way more lookups happening.</p>",
        "id": 219130090,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371000
    },
    {
        "content": "<p>How important is it to work up to defeq?</p>",
        "id": 219130181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371044
    },
    {
        "content": "<p>rw doesn't</p>",
        "id": 219130185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371049
    },
    {
        "content": "<p>Syntactic eq is too strong, as in Kevin's example above. It's not for the sake of rewrite but for figuring out when to stop the algorithm -- you're working on a rhs and a lhs and want to stop when they're defeq.</p>",
        "id": 219130272,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371091
    },
    {
        "content": "<p>if I understand correctly, if you have statement a and you want to prove statement b and theorem c does it, you can write <code>by rw c</code> because somewhere in there, there's a defeq happening</p>",
        "id": 219130327,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371123
    },
    {
        "content": "<p>But you have many branches on each side and need to check against all of htem.</p>",
        "id": 219130335,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371126
    },
    {
        "content": "<p>You can save the defeq test for when it looks pretty close?</p>",
        "id": 219130396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371157
    },
    {
        "content": "<p>\"looks pretty close\" by what measure? pp equality?</p>",
        "id": 219130460,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371193
    },
    {
        "content": "<p>sure</p>",
        "id": 219130474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371200
    },
    {
        "content": "<p>That's not so different from what it's doing now (with different failure behavior when defeq fails I guess) but it feels really hacky.</p>",
        "id": 219130588,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371239
    },
    {
        "content": "<p>if that's what rewrite search is using to explore the space then it's already available</p>",
        "id": 219130602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371249
    },
    {
        "content": "<p>what's already available</p>",
        "id": 219130630,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371261
    },
    {
        "content": "<p>If you have some other metric like tree diffing that would work too</p>",
        "id": 219130680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371283
    },
    {
        "content": "<p>I'm sure the ML folks have thought about this problem</p>",
        "id": 219130716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371304
    },
    {
        "content": "<p>This version of rewrite_search doesn't use string edit distance like the one Scott showed years ago. AFAIK this comparison is the only place where string comparisons would be used.</p>",
        "id": 219130746,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371320
    },
    {
        "content": "<p>what does it use?</p>",
        "id": 219130807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371332
    },
    {
        "content": "<p>the ML folks do a lot of mapping things onto strings, and then reimporting the eventual proof into the theorem prover to double check that the string conversion worked ok</p>",
        "id": 219130837,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371344
    },
    {
        "content": "<p>\"Do all the rewrites until the two sides are the same\"</p>",
        "id": 219130843,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371346
    },
    {
        "content": "<p>so no guidance at all?</p>",
        "id": 219130873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371362
    },
    {
        "content": "<p>for what it's worth, the PR used to use edit distance. it's just faster to scrap that</p>",
        "id": 219130875,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371363
    },
    {
        "content": "<p>it's just breadth-first searching from both LHS and RHS</p>",
        "id": 219130969,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371404
    },
    {
        "content": "<p>from what I recall of Scott's original version, he thought that was pretty important on the larger examples because of the exponential growth of possible moves</p>",
        "id": 219130982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371412
    },
    {
        "content": "<p>I would be happy to have an example where this was the case</p>",
        "id": 219131076,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219130982\">said</a>:</p>\n<blockquote>\n<p>from what I recall of Scott's original version, he thought that was pretty important on the larger examples because of the exponential growth of possible moves</p>\n</blockquote>\n<p>Which was my broader comment reviewing the PR, I don't really see how this scales, but I'm trying to work with what we have.</p>",
        "id": 219131100,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371458
    },
    {
        "content": "<p>My impression is, with the current architecture of rb_maps using pp equality, it's hard to recover and continue from a false match.</p>",
        "id": 219131483,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371644
    },
    {
        "content": "<p>It is possible to code up a comparison that ignores implicit args but that sounds like a lot of pure lean processing, it may be worse than just calling defeq all the time</p>",
        "id": 219131548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371679
    },
    {
        "content": "<p>I think it's hard, but I also don't have a any example of a false match, and it's far more common to simply fail because the search doesn't find anything</p>",
        "id": 219131598,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371686
    },
    {
        "content": "<p>this PR is based on Scott's original branch, so I originally had all the edit distance code. the problem is, lean string processing is so slow, it ends up spending most of the time calculating string diffs</p>",
        "id": 219131696,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131483\">said</a>:</p>\n<blockquote>\n<p>My impression is, with the current architecture of rb_maps using pp equality, it's hard to recover and continue from a false match.</p>\n</blockquote>\n<p>Hashmaps already face this issue. The solution is to store all putatively-equal expressions, and linear search through them with the more accurate test</p>",
        "id": 219131741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607371777
    },
    {
        "content": "<p>this is a solvable problem - stick any diffing logic in C++, use a data structure like a priority queue - but I dont' want to mess around with c++ components pre lean 4</p>",
        "id": 219131826,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131548\">said</a>:</p>\n<blockquote>\n<p>It is possible to code up a comparison that ignores implicit args but that sounds like a lot of pure lean processing, it may be worse than just calling defeq all the time</p>\n</blockquote>\n<p>But it isn't just the cost of calling defeq all the time, it's O(n) defeqs vs O(log n) hash comparisons. It will definitely make things scale even worse.</p>",
        "id": 219131837,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131741\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219131483\">said</a>:</p>\n<blockquote>\n<p>My impression is, with the current architecture of rb_maps using pp equality, it's hard to recover and continue from a false match.</p>\n</blockquote>\n<p>Hashmaps already face this issue. The solution is to store all putatively-equal expressions, and linear search through them with the more accurate test</p>\n</blockquote>\n<p>This is maybe the \"reliable and doable\" solution.</p>",
        "id": 219131884,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371858
    },
    {
        "content": "<p>Use pp equality as a first pass and then check defeq to confirm, then you can keep going if you hit a false positive match.</p>",
        "id": 219131934,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371891
    },
    {
        "content": "<p>I promise that when people start using this they're going to find examples and come to Zulip saying \"why did rewrite_search fail here?\"</p>",
        "id": 219132043,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371947
    },
    {
        "content": "<p>I would be so excited to respond to that complaint in zulip</p>",
        "id": 219132064,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371959
    },
    {
        "content": "<p>If there's not a good story to tell in response, there will be a neverending stream of this question.</p>",
        "id": 219132094,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607371976
    },
    {
        "content": "<p>right now I don't have any examples of this problem happening though</p>",
        "id": 219132114,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607371989
    },
    {
        "content": "<p>how about, we get this code in, and then once one person runs into this problem in the wild i'll make it fail over to defeq</p>",
        "id": 219132152,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607372017
    },
    {
        "content": "<p>This is why SMT folks care about completeness of the search algorithm. It's not because completeness itself is that great but rather when you throw heuristics together it fails in weird ways and they have to deal with questions they don't want to answer</p>",
        "id": 219132289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607372090
    },
    {
        "content": "<p>If you can add something that detects when the mismatch happens, I'm willing to consider it!</p>",
        "id": 219132411,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607372161
    },
    {
        "content": "<p>And gives a reasonable error message, that is.</p>",
        "id": 219132503,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607372198
    },
    {
        "content": "<p>is there a sane way to construct an example where this happens, that two expressions are pp equal but not defeq?</p>",
        "id": 219132533,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607372221
    },
    {
        "content": "<p>the only way I could think of was to create some new sort of object that had this property</p>",
        "id": 219132564,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607372239
    },
    {
        "content": "<p>but, maybe there's some normal situation where this happens</p>",
        "id": 219132659,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607372282
    },
    {
        "content": "<p>It comes up routinely in questions from users</p>",
        "id": 219132716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607372308
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails:  f ↑0 = f ↑0</span>\n</code></pre></div>",
        "id": 219132749,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607372330
    },
    {
        "content": "<p>usually they rewrote their goal by some lemma and got a non-canonical instance</p>",
        "id": 219132770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607372345
    },
    {
        "content": "<p>or they unfolded something they shouldn't have</p>",
        "id": 219132781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607372355
    },
    {
        "content": "<p>are those functions supposed to be equal, or not equal</p>",
        "id": 219132814,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607372378
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 219132902,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607372406
    },
    {
        "content": "<p>the two coerced zeros are equal but not defeq</p>",
        "id": 219132908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607372411
    },
    {
        "content": "<p>I'd expect rewrite_search to be able to prove this goal (with the right lemmas in scope anyway)</p>",
        "id": 219132990,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607372464
    },
    {
        "content": "<p>it would be great if you could turn off pretty printing just for coe, as that's going to be a big contributor to pp false positives</p>",
        "id": 219133013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607372477
    },
    {
        "content": "<p>it's definitely a hack. hmm. maybe i should write essentially a custom pp here, just to map things onto a string in such a way that string equality is expected to be defeq. how do I \"get at the parts\" of an expr? is there a reasonable way to write lean code that does this without like adding some custom thing to every type</p>",
        "id": 219133398,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607372686
    },
    {
        "content": "<p>I'd skip the strings completely. Yes, you can deconstruct an expr, it's an inductive type (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr/src\">src#expr</a>). You can tell which arguments are type class arguments using the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/binder_info\">docs#binder_info</a> argument to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi/src\">src#expr.pi</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.lam/src\">src#expr.lam</a> . Doing this from scratch is just slightly less than straightforward I think. Not sure off the top of my head if there's an api in mathlib to help.</p>",
        "id": 219133959,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607372966
    },
    {
        "content": "<p>You can just strip the type class arguments out completely and construct a (badly typed) expr, then hash that.</p>",
        "id": 219134018,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607373001
    },
    {
        "content": "<p>what about turning it into a pexpr?</p>",
        "id": 219134090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373025
    },
    {
        "content": "<p>is that a thing?</p>",
        "id": 219134102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373029
    },
    {
        "content": "<p>You can't (easily) deelaborate, no...</p>",
        "id": 219134211,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607373088
    },
    {
        "content": "<p>A badly typed expr and a pexpr are the same thing.</p>",
        "id": 219134252,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607373112
    },
    {
        "content": "<p>the only reason I'd use a string is that AFAICT I can't efficiently use a regular int32 in lean. so if I want something to be the key of a hash table, the best thing is a string</p>",
        "id": 219134262,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373115
    },
    {
        "content": "<p><code>lemma test_pp_heuristic : idf (0 : ℕ) = idf (0 : ℚ) := by rewrite_search [nat.cast_zero, rat.cast_zero]</code> just works</p>",
        "id": 219134389,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373157
    },
    {
        "content": "<p>I need a better example that does not work with the status quo</p>",
        "id": 219134410,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373167
    },
    {
        "content": "<p>what about, two expressions that are <em>not</em> equal, but their <code>pp</code> is equal. that would bork the existing algorithm. is there some way to naturally construct examples of that?</p>",
        "id": 219134524,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373222
    },
    {
        "content": "<p>Okay, I don't know why that succeeds based on my understanding of rewrite_search from the review, but:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>shouldn't be provable.</p>",
        "id": 219135031,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607373475
    },
    {
        "content": "<p>lol lean has too many coercions</p>",
        "id": 219135149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373525
    },
    {
        "content": "<p>There's a coercion from <code>fin n</code> to nat? Is that because it's now a subtype or was it always there?</p>",
        "id": 219135257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607373571
    },
    {
        "content": "<p>It has always been there but it was made the recommended idiom around july</p>",
        "id": 219135420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373645
    },
    {
        "content": "<p>over things like fin.val</p>",
        "id": 219135437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373656
    },
    {
        "content": "<p>it is a subtype, so it's not unreasonable</p>",
        "id": 219135470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373685
    },
    {
        "content": "<p>in fact in retrospect it seems good that we have <code>fin</code> and <code>zmod</code> as separate things since they have different algebraic roles</p>",
        "id": 219135569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373725
    },
    {
        "content": "<p>how does one actually prove that? (I dont know what <code>fin</code> is, sorry)</p>",
        "id": 219135637,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373756
    },
    {
        "content": "<p><code>fin n</code> is the set of numbers less than <code>n</code></p>",
        "id": 219135649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373768
    },
    {
        "content": "<p>how is 2 in <code>fin 1</code> then</p>",
        "id": 219135676,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373783
    },
    {
        "content": "<p><code>fin 1 = {0}</code> so it's not hard to figure out what <code>2 : fin 1</code> is</p>",
        "id": 219135677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373783
    },
    {
        "content": "<p>I will give you one guess :)</p>",
        "id": 219135738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373811
    },
    {
        "content": "<p>failures get turned into zeros like 1 - 2 ?</p>",
        "id": 219135767,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373831
    },
    {
        "content": "<p>it's not actually failure, it's wraparound</p>",
        "id": 219135844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373848
    },
    {
        "content": "<p>either that or it works like Z_2</p>",
        "id": 219135849,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373850
    },
    {
        "content": "<p>er, like Z_1</p>",
        "id": 219135874,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373866
    },
    {
        "content": "<p>ok, I got it on the third guess</p>",
        "id": 219135887,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373874
    },
    {
        "content": "<p>There is no way the way the lean parser works right now to make <code>3 : fin 5</code> ok but not <code>7 : fin 5</code></p>",
        "id": 219135951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373909
    },
    {
        "content": "<p>so addition just wraps around, making it almost <code>zmod n</code></p>",
        "id": 219136032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373960
    },
    {
        "content": "<p>ok great so <code>(2 : fin 1)</code> should <code>pp</code> to <code>2</code> but actually it's zero</p>",
        "id": 219136063,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607373963
    },
    {
        "content": "<p>yes</p>",
        "id": 219136080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607373968
    },
    {
        "content": "<p>it's not like we can evaluate it though, 2 is a perfectly good representation for that number</p>",
        "id": 219136173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607374033
    },
    {
        "content": "<p>Here's another (contrived) example that doesn't use coercions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">classical.prop_decidable</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">ℕ</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- g 0 = g 0</span>\n</code></pre></div>",
        "id": 219136529,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607374247
    },
    {
        "content": "<p>OK here is something that fails now but could succeed if it continued the search:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test_pp_heuristic</span> <span class=\"o\">:</span> <span class=\"n\">idf</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">idf</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rewrite_search</span> <span class=\"o\">[</span><span class=\"n\">rat.cast_zero</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_zero</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I think the reason the previous one didn't work is that the algorithm doesn't actually test if the LHS and RHS are equal. so it doesn't get caught up by the trivial match and it finds something that works with casts</p>",
        "id": 219136774,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607374414
    },
    {
        "content": "<p>(idf is the identity function, i already had something named f in this test file)</p>",
        "id": 219136801,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607374435
    },
    {
        "content": "<p>OK yeah this is probably more common than i expected since it will come up in coercions and coercions seem like an area where it's exhausting to think of all the details and you might want a rewrite_search.  i'll try to make this actually work, and failing that I will at least put a nice error message</p>",
        "id": 219137373,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607374715
    },
    {
        "content": "<p>slightly less contrived:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">type_of</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">type_of</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"bp\">≠</span> <span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">type_of</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 219137872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607374971
    },
    {
        "content": "<blockquote>\n<p>I think the reason the previous one didn't work is that the algorithm doesn't actually test if the LHS and RHS are equal. so it doesn't get caught up by the trivial match and it finds something that works with casts</p>\n</blockquote>\n<p>I'm not quite sure what this means -- I thought the algorithm checked after each rewrite whether the new expression was in the map corresponding to the other side of the equality.</p>",
        "id": 219143765,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607378051
    },
    {
        "content": "<p>But clearly my mental model is wrong so I'll have to look at the code again to sort myself out.</p>",
        "id": 219143878,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607378111
    },
    {
        "content": "<p>I mean it doesn't check whether the LHS and RHS are themselves equal. it initializes the graph with them. then all the subsequent nodes have a different insertion path</p>",
        "id": 219143936,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607378144
    },
    {
        "content": "<p>Oh, I see</p>",
        "id": 219144022,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607378178
    },
    {
        "content": "<p>so if you try to prove <code>x = x</code> with rewrite search i don't think it will find the \"no rewrites needed\" rewrite.</p>",
        "id": 219144064,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607378214
    },
    {
        "content": "<p>That's an important edge case, hah. If people use <code>linarith</code> to prove <code>0 &lt; 1</code> they'll also use <code>rewrite_search</code> instead of <code>refl</code>!</p>",
        "id": 219144095,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607378233
    },
    {
        "content": "<p>sigh you are probably right. <span aria-label=\"rolling eyes\" class=\"emoji emoji-1f644\" role=\"img\" title=\"rolling eyes\">:rolling_eyes:</span> then the explainer needs a special case too</p>",
        "id": 219144234,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607378297
    },
    {
        "content": "<p>i'll add a test for that</p>",
        "id": 219144314,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607378352
    },
    {
        "content": "<p>There's a thread somewhere on Zulip with examples of people abusing tactics, it's horrifying</p>",
        "id": 219144486,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607378430
    },
    {
        "content": "<p>In this particular case it seems legitimate to me. Sometimes <code>refl</code>isn't obvious at all.</p>",
        "id": 219144590,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607378492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219144486\">said</a>:</p>\n<blockquote>\n<p>There's a thread somewhere on Zulip with examples of people abusing tactics, it's horrifying</p>\n</blockquote>\n<p><a href=\"#narrow/stream/113489-new-members/topic/natural.20number.20game.20%28https.3A.2F.2Ftinyurl.2Ecom.2Fnatgame1234%29/near/179726016\">This post</a> comes to mind.</p>",
        "id": 219144736,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1607378553
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234841.20rewrite_search/near/219144590\">said</a>:</p>\n<blockquote>\n<p>In this particular case it seems legitimate to me. Sometimes <code>refl</code>isn't obvious at all.</p>\n</blockquote>\n<p>The problem here is only with obvious <code>refl</code>s, when the two sides pretty print the same.</p>",
        "id": 219144840,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1607378604
    },
    {
        "content": "<p>OK using <code>defeq</code> after it finds <code>pp</code> matches is in</p>",
        "id": 219285235,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1607475157
    },
    {
        "content": "<p><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> this one is in!!!</p>",
        "id": 221769232,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609941426
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238605\">@Kevin Lacker</span> <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> thanks a lot!</p>",
        "id": 221769237,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609941433
    }
]
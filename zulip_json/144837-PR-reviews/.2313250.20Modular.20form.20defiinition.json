[
    {
        "content": "<p>(deleted)</p>",
        "id": 303530338,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665527040
    },
    {
        "content": "<p>Per one of Moritz' comment on this PR, I think there is a different approach that might be considered for this PR. In particular, I don't think it is quite necessary to realize <code>weakly_modular_form</code> as a submodule of <code>ℍ → ℂ</code>, and similarly for the others. Personally, I think it would make more sense to define the following structures:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">weakly_modular_form</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">slash_action_eq'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">modular_form</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol'</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bdd_at_infty'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_bounded_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">cusp_form</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol'</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_zero_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">fun_like</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ℍ</span><span class=\"o\">,</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">slash_action_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">modular_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bdd_at_infty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_bounded_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">cusp_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_zero_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"bp\">𝕜</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">cusp_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">modular_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"o\">(</span><span class=\"n\">weakly_modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">modular_form_class</span> <span class=\"o\">(</span><span class=\"n\">modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">cusp_form_class</span> <span class=\"o\">(</span><span class=\"n\">cusp_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>After this (and some other boilerplate you should add that comes with the hom class setup) you can provide module instances for <code>weakly_modular_form</code>, <code>modular_form</code> and <code>cusp_form</code>, which is straightforward. You can also provide a graded multiplication operation on relevant types too. And finally, you can take the direct sum of <code>modular_form Γ</code> and put a graded ring structure on it. </p>\n<p>All this being said, I'm not a number theorist, and I don't know much about modular forms. I'm posting this on Zulip so there can be discussion around it.</p>",
        "id": 303533157,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665528686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> has marked this topic as unresolved.</p>",
        "id": 303533295,
        "sender_full_name": "Notification Bot",
        "timestamp": 1665528789
    },
    {
        "content": "<p>The approach described above should definitely be multiple PRs (although I think this PR should be split into multiple pieces as is anyway).</p>",
        "id": 303533308,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665528797
    },
    {
        "content": "<p>Note that <span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> already has the graded ring structure done (deferred to a different PR), so your proposal (which sounds reasonable to me) is just a different route to that.</p>",
        "id": 303533408,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665528833
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13250#issuecomment-1272409520\">https://github.com/leanprover-community/mathlib/pull/13250#issuecomment-1272409520</a></p>",
        "id": 303533552,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665528888
    },
    {
        "content": "<p>Yes, I realized that. Thanks.</p>",
        "id": 303533564,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665528894
    },
    {
        "content": "<p>The above is mainly about uniformity of design with respect to other parts of mathlib, but also what I think will be easiest to work with.</p>",
        "id": 303533662,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665528963
    },
    {
        "content": "<p>Question: Does <code>modular_form_class</code>, the top of that tree, only need to exist if it is anticipated that there will be further extensions to it?  Or should it exist anyway?</p>",
        "id": 303533837,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665529087
    },
    {
        "content": "<p>You mean <code>cusp_form_class</code>?</p>",
        "id": 303534376,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665529412
    },
    {
        "content": "<p>Either way, yes, it should still exist.</p>",
        "id": 303534518,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665529504
    },
    {
        "content": "<p>Sorry, yes.</p>",
        "id": 303534528,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665529512
    },
    {
        "content": "<p>What is the purpose of having the \"top of the tree\" class?  (This is my crash course in <code>fun_like</code>.)</p>",
        "id": 303534564,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665529541
    },
    {
        "content": "<p>The purpose is that what you think is the top of the tree is usually not <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But yes indeed we add those mostly to have a uniform design and avoid confusing the end user even more.</p>",
        "id": 303535624,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665530364
    },
    {
        "content": "<p>That's how you know that hom's of the leaf node of the tree also have all the properties of all lower nodes.</p>\n<p>For example, let's say you have two homs, <code>hom1</code> and <code>hom2</code> extends <code>hom1</code> (as an example, think of <code>add_monoid_hom</code> and <code>ring_hom</code>). These have associated classes <code>hom1_class</code> and <code>hom2_class</code>, where the latter extends the former, and <code>hom1</code> is an instance of <code>hom1_class</code> and similarly for <code>hom2</code> and <code>hom2_class</code>.</p>\n<p>Now, let's say you prove a lemma that holds for <code>f : hom1</code>. Likely it generalizes to anything where <code>f : F</code> and <code>F</code> has an instance of <code>hom1_class</code>. Then you take some <code>g : hom2</code>. You would like to say that this lemma automatically holds for <code>g</code>, and if you phrased it in terms of <code>hom1_class</code>, then it does! The reason is that <code>hom2</code> has a <code>hom2_class</code> instance which means it has a <code>hom1_class</code> instance, so the lemma applies.</p>\n<p>You could technically avoid this by providing directly a <code>hom1_class</code> instance for <code>hom2</code>, but that would be bad (just in case what you thought was the top of the tree <del>really</del> <em>eventually</em> isn't).</p>",
        "id": 303535771,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665530458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303535624\">said</a>:</p>\n<blockquote>\n<p>The purpose is that what you think is the top of the tree is usually not <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303535771\">said</a>:</p>\n<blockquote>\n<p>just in case what you thought was the top of the tree <del>really</del> <em>eventually</em> isn't</p>\n</blockquote>\n<p>I think this is the answer I was after: there's a belief that everything will get specialized further some day.  I guess I don't see now what that's going to be for <code>cusp_form</code>, but undoubtedly that's just an invitation to eat my words in 10 months.</p>",
        "id": 303546059,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665537757
    },
    {
        "content": "<p>Yeah, I see what you mean. The other reason is uniformity of API. And probably to piggy back on that, even if <code>cusp_form</code> really is a leaf forever, you don't want people to look at that and say, \"oh, it's a leaf so they don't provide the associated hom class, I'll do that with my hom class which is also a leaf,\" but that one doesn't end up being a leaf.</p>",
        "id": 303547858,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665539393
    },
    {
        "content": "<p>Whilst I definitely agree that the space of modular forms should be a type not a term, I'll say again here that in the literature \"weakly modular\" usually implies meromorphic (and in particular differentiable, and not C-valued).</p>\n<p>Another issue with the whole approach of the PR is that really this is not the correct generality, but I have not mentioned this until now for fear of derailing this PR even more. I think that if Sebastian Gouezel were writing this definition he'd define the notion of a modular form for any discrete subgroup of SL(2, real) and if you do it this way then the theory of cusps and boundedness is far more delicate -- the cusps correspond to parabolic elements of the subgroup. I'd refrained from mentioning this until now because ultimately the most used kinds of modular forms are the ones coming from subgroups of SL2(Z) where the cusps are just the rationals and this is what we have right now, so this is very much a \"perfect is the enemy of good\" comment, but using general discrete Fuchsian groups of the first kind is what one should really be doing here rather than subgroups of SL(2,int).</p>",
        "id": 303575664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665560883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303533157\">said</a>:</p>\n<blockquote>\n<p>Per one of Moritz' comment on this PR, I think there is a different approach that might be considered for this PR. In particular, I don't think it is quite necessary to realize <code>weakly_modular_form</code> as a submodule of <code>ℍ → ℂ</code>, and similarly for the others. Personally, I think it would make more sense to define the following structures:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">weakly_modular_form</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">slash_action_eq'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">modular_form</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol'</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bdd_at_infty'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_bounded_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">cusp_form</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol'</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_zero_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">fun_like</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ℍ</span><span class=\"o\">,</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">slash_action_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">modular_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bdd_at_infty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_bounded_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">cusp_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℍ'</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_zero_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"bp\">𝕜</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">cusp_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">modular_form_class</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">weakly_modular_form_class</span> <span class=\"o\">(</span><span class=\"n\">weakly_modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">modular_form_class</span> <span class=\"o\">(</span><span class=\"n\">modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">cusp_form_class</span> <span class=\"o\">(</span><span class=\"n\">cusp_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>After this (and some other boilerplate you should add that comes with the hom class setup) you can provide module instances for <code>weakly_modular_form</code>, <code>modular_form</code> and <code>cusp_form</code>, which is straightforward. You can also provide a graded multiplication operation on relevant types too. And finally, you can take the direct sum of <code>modular_form Γ</code> and put a graded ring structure on it. </p>\n<p>All this being said, I'm not a number theorist, and I don't know much about modular forms. I'm posting this on Zulip so there can be discussion around it.</p>\n</blockquote>\n<p>Ok so let me see how this would go. Every time I make something higher up I make it as a structure and a class and then it should be easy to make the new definitions inherit old properties?</p>",
        "id": 303575885,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665560975
    },
    {
        "content": "<p>I agree about the weakly modular usually implying meromorphic, but I didnt know if we had meromorphic yet? I could just call it something else?</p>",
        "id": 303576060,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665561058
    },
    {
        "content": "<p>but going back to the proposed approach, <code>cusp_forms</code> aren't the top as eventually we'll want things like <code>eigenform</code>, <code>newform</code>, <code>primitive</code> and so on. Similarly there will be more branching lower down, such as using <code>weakly modular</code> to define <code>maass forms</code> and so on. This is a probably a silly question,  but will this branching cause any issues?</p>",
        "id": 303576414,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665561223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303575664\">said</a>:</p>\n<blockquote>\n<p>Whilst I definitely agree that the space of modular forms should be a type not a term, I'll say again here that in the literature \"weakly modular\" usually implies meromorphic (and in particular differentiable, and not C-valued).</p>\n<p>Another issue with the whole approach of the PR is that really this is not the correct generality, but I have not mentioned this until now for fear of derailing this PR even more. I think that if Sebastian Gouezel were writing this definition he'd define the notion of a modular form for any discrete subgroup of SL(2, real) and if you do it this way then the theory of cusps and boundedness is far more delicate -- the cusps correspond to parabolic elements of the subgroup. I'd refrained from mentioning this until now because ultimately the most used kinds of modular forms are the ones coming from subgroups of SL2(Z) where the cusps are just the rationals and this is what we have right now, so this is very much a \"perfect is the enemy of good\" comment, but using general discrete Fuchsian groups of the first kind is what one should really be doing here rather than subgroups of SL(2,int).</p>\n</blockquote>\n<p>How about I promise to do the refactor when someone wants to think about these other subgroups? :P</p>",
        "id": 303577730,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665561811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303575664\">said</a>:</p>\n<blockquote>\n<p>Another issue with the whole approach of the PR is that really this is not the correct generality, [..]</p>\n</blockquote>\n<p>I agree, but I also want to see the definition of modular forms in mathlib sooner than later. On the other hand, it would be really good to have all the hyperbolic geometry in mathlib and refactoring it later sounds very painful.</p>",
        "id": 303578986,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1665562329
    },
    {
        "content": "<p>The solution which occurred to me when I was thinking about this issue privately was to stick with SL2Z for now and use <code>automorphic_form</code> to do the general Fuchsian group case. Let's perhaps not derail the discussion any further, I think Chris' response is the pragmatic one :-)</p>",
        "id": 303580422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665563012
    },
    {
        "content": "<p>In fact one response to Moritz' observation is that instead of doing SL_2 we should be working with an arbitrary connected reductive group over a global field, and just sticking to SL_2 will make refactoring it later very painful as well. This of course would also be a way to put back the development of modular forms by 5 years. I guess my vision right now is modular forms via SL_2(Z), then later automorphic forms for Fuchian subgroups of SL_2(R), and then a theorem saying that they're isomorphic when the Fuchsian subgroup is a congruence subgroup of SL_2(Z), and then of course later on automorphic forms for G and a theorem saying that when G is an inner form of GL_2 which is split at infinity we recover automorphic forms for Fuchsian subgroups of SL_2(R).  This is a great example of when the \"correct generality\" is in some sense far too general and we need to make some decisions about where to draw lines.</p>",
        "id": 303611399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665575925
    },
    {
        "content": "<p>One other direction is wrt the weights. At the moment its an integer, but eventually we might want more general weights. But this is maybe something I can build in now by making the definitions depend on a choice of <code>slash_action</code> ?</p>",
        "id": 303623547,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665580147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303611399\">said</a>:</p>\n<blockquote>\n<p>In fact one response to Moritz' observation is that instead of doing SL_2 we should be working [..]</p>\n</blockquote>\n<p>I'll just rename these to <code>birkbeck_modular_forms</code> and when we do it in complete generally we can just coerce them into <code>actual_modular_forms</code> <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 303625212,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665580718
    },
    {
        "content": "<p><code>old_fashioned_modular_forms</code>. More general weights is a very different kettle of fish. There are vector-valued forms and there are also half-integral weight forms but vector valued forms are a bit niche and half integral weight forms are an analytic theory (there is no algebraic analogue as far as I know) so I'm very happy to wait until later for those things.</p>",
        "id": 303629398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665581868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313250.20Modular.20form.20defiinition/near/303576060\">said</a>:</p>\n<blockquote>\n<p>I agree about the weakly modular usually implying meromorphic, but I didnt know if we had meromorphic yet? I could just call it something else?</p>\n</blockquote>\n<p>Why don't you use <code>mdifferentiable</code> for this condition? I.e. move it from the <code>modular_form</code>/<code>cusp_form</code> to the <code>weakly_modular_form</code>.</p>",
        "id": 303629935,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665582056
    },
    {
        "content": "<p>I guess I could do that, but maybe we want to save the name <code>weakly_modular_form</code> for the meromorphic ones? I think maybe I shouldn't call this property <code>weakly_modular</code> and instead call it something else.</p>",
        "id": 303630757,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1665582320
    },
    {
        "content": "<p>Oh sorry, I misread -- meromorphic not holomorphic.  Disregard!</p>",
        "id": 303631319,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665582557
    },
    {
        "content": "<p>By the way, there is <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions\">kind of a roadmap</a> for meromorphic functions, which will be accessible after <a href=\"https://github.com/leanprover-community/mathlib/pull/15331\">#15331</a>.  I had been thinking of doing this anyway.</p>",
        "id": 303631710,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1665582699
    },
    {
        "content": "<p>Ok so I'm a bit confused about how to use these new structures/classes. I defined <code>slash_invariant_form</code> and <code>slash_invariant_form_class</code> and I proved some instances on these spaces (in particular on the structure not the class) and then I want to prove similar instances for <code>modular_forms</code> say. How can I use the fact that this extends <code>slash_invariant_form</code> to help do this? Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">slash_invariant_form</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">slash_action_eq'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">slash_invariant_form_class</span> <span class=\"kd\">extends</span> <span class=\"n\">fun_like</span> <span class=\"n\">F</span> <span class=\"n\">ℍ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">slash_action_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">slash_invariant_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">--Say I have a proof of this</span>\n\n<span class=\"c1\">--Can I use this to make the following easier (i.e. only prove that `mdifferentible` and `bdd_` behaves well?</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">modular_form</span> <span class=\"kd\">extends</span> <span class=\"n\">slash_invariant_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hol'</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℍ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bdd_at_infty'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SL</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ℤ</span><span class=\"o\">)),</span> <span class=\"n\">is_bounded_at_im_infty</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">∣</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">]))</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">modular_form.has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">modular_form</span> <span class=\"bp\">Γ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Do I just need to do the proof again? Or should I be proving these instances for the classes?</p>",
        "id": 306086071,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1666719485
    },
    {
        "content": "<p>Ok so I've made the changes to the definitions to make them <code>fun_like</code>. One thing that has come up which I don't know how to fix (mainly because I dont understand the error) is that the linter is giving the following error :<code>slash_invariant_form_class.to_fun_like - The following arguments become metavariables. argument 2: (Γ : subgroup (matrix.special_linear_group (fin 2) ℤ)), argument 3: (k : ℤ)</code>. Any ideas how to fix this/what it means? (I dont really know what a metavariable is)</p>",
        "id": 308640728,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1667930186
    },
    {
        "content": "<p>I guess the issue is that when typeclass search goes looking for <code>fun_like</code> it doesn't know which <code>k</code> to look for when deriving <code>fun_like</code> from <code>slash_invariant_form_class</code>, the usual solution to this sort of thing is to make <code>k</code> an <code>out_param int</code> rather than an int, at least for the instance, I have no idea if that really makes sense in context though!</p>",
        "id": 308644019,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667931240
    },
    {
        "content": "<p>OK I see, let me try that then. Thanks!</p>",
        "id": 308744647,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1667985181
    },
    {
        "content": "<p><code>out_param</code> is meaningless on instances, it only means things on typeclass indices (IIRC)</p>",
        "id": 310101186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668467871
    },
    {
        "content": "<p>Indeed: the <code>out_param</code> mechanism is used to determine which parts of a typeclass search goal become variables. So it only applies when a new search goal is started.</p>",
        "id": 310175605,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1668510024
    }
]
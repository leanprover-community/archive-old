[
    {
        "content": "<p>The linter is complaining about some universe levels:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>/- Checking 27 declarations (plus 68 automatically generated ones) in the current file with 23 linters -/</p>\n<p>/- The <code>check_univs</code> linter reports: -/<br>\n/- THE STATEMENTS OF THE FOLLOWING DECLARATIONS HAVE BAD UNIVERSE LEVELS. This usually means that there is a <code>max u v</code> in the declaration where neither <code>u</code> nor <code>v</code> occur by themselves. Solution: Find the type (or type bundled with data) that has this universe argument and provide the universe level explicitly. If this happens in an implicit argument of the declaration, a better solution is to move this argument to a <code>variables</code> command (where the universe level can be kept implicit).<br>\nNote: if the linter flags an automatically generated declaration <code>xyz._proof_i</code>, it means that<br>\nthe universe problem is with <code>xyz</code> itself (even if the linter doesn't flag <code>xyz</code>) -/<br>\n#check @category_theory.presheaf.fork_map._proof_1 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.first_map._proof_2 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.first_map._proof_4 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.first_map._proof_1 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.second_map._proof_4 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.second_map._proof_1 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.second_map._proof_2 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf'._proof_4 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf'._proof_3 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf'._proof_5 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf_for_is_sheaf_for'._proof_11 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf_for_is_sheaf_for'._proof_5 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf_for_is_sheaf_for'._proof_10 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf_for_is_sheaf_for'._proof_3 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf_for_is_sheaf_for'._proof_12 /- universes [u₁, v₁] only occur together. -/<br>\n#check @category_theory.presheaf.is_sheaf_for_is_sheaf_for'._proof_4 /- universes [u₁, v₁] only occur together. -/</p>\n</div></div>\n<p>How should we proceed here?</p>",
        "id": 257235399,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634057600
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 257235421,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634057608
    },
    {
        "content": "<p>Is the complaint valid? From a brief read it looks like <code>fork_map</code> does have the universe arguments in different parts, even though they're implicit. Or maybe I'm misunderstanding what the point of this linter is</p>",
        "id": 257236171,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1634057885
    },
    {
        "content": "<p>The universes are declared in the variables for the section as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">v₁</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">grothendieck_topology</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">presieve</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 257236287,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634057941
    },
    {
        "content": "<p>So yes it seems that they're in different parts -- the <code>v_1</code> is in <code>category.{v_1} C</code> and the <code>u_1</code> is in <code>C : Type u_1</code>.</p>",
        "id": 257236356,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634057970
    },
    {
        "content": "<p>I don't really know what this linter is supposed to check for...</p>",
        "id": 257236401,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634057988
    },
    {
        "content": "<p>For reference, the type signature of <code>fork_map</code> is <code>P.obj (op U) ⟶ first_obj R P</code></p>",
        "id": 257236593,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058036
    },
    {
        "content": "<p>and <code>first_obj : A</code></p>",
        "id": 257236621,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058050
    },
    {
        "content": "<p>Maybe it's really only the <code>category_theory.presheaf.fork_map._proof_XX</code> that have the issue? In which case it's not really a problem right?</p>",
        "id": 257236981,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634058196
    },
    {
        "content": "<p>The linter claims that if it flags <code>_proof_</code> then the definition itself is apparently the problem</p>",
        "id": 257237161,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1634058263
    },
    {
        "content": "<p>I think that's right <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fork_map._proof_1</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">has_products</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_3</span> <span class=\"n\">u_1</span><span class=\"o\">)),</span>\n    <span class=\"n\">has_limits_of_shape</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n</code></pre></div>",
        "id": 257237215,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058291
    },
    {
        "content": "<p>right, C isn't appearing in this proof for whatever reason</p>",
        "id": 257237336,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634058345
    },
    {
        "content": "<p>I assume all of these <code>???._proof_??</code> are proofs that <code>A</code> has some sort of limits.</p>",
        "id": 257237366,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058361
    },
    {
        "content": "<p>In that case I think the linter note is misleading</p>",
        "id": 257237470,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1634058397
    },
    {
        "content": "<p>I'll just add some <code>nolints</code></p>",
        "id": 257237508,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058413
    },
    {
        "content": "<p>Agreed, though perhaps whoever made this linter could chime in?</p>",
        "id": 257237626,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1634058479
    },
    {
        "content": "<p>Hmm.... another question is where and how the <code>nolint</code>'s should be added.</p>",
        "id": 257238096,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058653
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[nolint check_univs]</span>\n<span class=\"kd\">def</span> <span class=\"n\">fork_map</span> <span class=\"o\">:</span> <span class=\"n\">P.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">first_obj</span> <span class=\"n\">R</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>and the linter still complains about <code>fork_map._proof_1</code></p>",
        "id": 257238209,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058703
    },
    {
        "content": "<p>Can you add the attribute specifically to that proof after the definition?</p>",
        "id": 257238437,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1634058789
    },
    {
        "content": "<p>Yeah, I can do that</p>",
        "id": 257238837,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634058959
    },
    {
        "content": "<p>It doesn't seem very robust, though</p>",
        "id": 257239021,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634059039
    },
    {
        "content": "<p>Right, I shouldn't ever have to write <code>_proof_??</code></p>",
        "id": 257239191,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634059096
    },
    {
        "content": "<p>Is there a way to turn of a linter for all declarations in a specific section?</p>",
        "id": 257239324,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634059154
    },
    {
        "content": "<p>it should be really be called <code>_proо̆f_??</code></p>",
        "id": 257239568,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634059238
    },
    {
        "content": "<p>I think it would be reasonable to exclude <code>_proof_*</code> from the linter.  (That is, in general.  Add a check to the linter.)</p>",
        "id": 257239948,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634059386
    },
    {
        "content": "<p>The linter should not be disabled for the section, and <code>fork_map</code> shouldn't be <code>nolint</code> either.</p>",
        "id": 257240200,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634059470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.239675.20generalize.20universes.20for.20sheaves/near/257237215\">said</a>:</p>\n<blockquote>\n<p>I think that's right <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> :</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fork_map._proof_1</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">has_products</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_3</span> <span class=\"n\">u_1</span><span class=\"o\">)),</span>\n    <span class=\"n\">has_limits_of_shape</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The reason this is a bad lemma (or would be if it wasn't just an abbreviation to make the definition of <code>fork_map</code> smaller) is the following: if you wrote <code>fork_map._proof_1 J</code> for some <code>J : Type u</code>, then Lean would first instantiate the type with universe metavariables like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fork_map._proof_1</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">has_products</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span><span class=\"n\">u_3</span> <span class=\"bp\">?</span><span class=\"n\">u_1</span><span class=\"o\">)),</span>\n    <span class=\"n\">has_limits_of_shape</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>Then it would make sure that the type of <code>J</code> is defeq to the argument type of <code>fork_map._proof_1</code>.  That is, unify <code>Type u</code> and <code>Type (max ?u_3 ?u_1)</code>.  And this is where it fails, since there is no good canonical solution to make <code>u</code> and <code>max ?u_3 ?u_1</code> equal.  (Some possible assignments would be <code>?u_1 := u, ?u_3 = u</code> or <code>?u_1 := 0, ?u_3 := u</code> or <code>?u_1 := u, ?u_3 := 0</code>).</p>",
        "id": 257240988,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634059771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Oh, I understand that.</p>",
        "id": 257241421,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634059925
    },
    {
        "content": "<p>But it's not an issue in this particular case, since, as you say, it's an abbreviation used in the definition of <code>fork_map</code>.</p>",
        "id": 257241468,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634059949
    },
    {
        "content": "<p>And the linter doesn't complain about <code>fork_map</code> itself (as it should be!)</p>",
        "id": 257241583,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634060001
    },
    {
        "content": "<p>It would probably take me too much time to figure out how to modify the linter to ignore declarations named <code>*._proof_*</code>. I think it was <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> who wrote the <code>check_univs</code> linter?</p>",
        "id": 257241809,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634060083
    },
    {
        "content": "<p>I think that</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/src/tactic/lint/misc.lean b/src/tactic/lint/misc.lean</span>\n<span class=\"gh\">index e12c37fba9..2f04ca1f2e 100644</span>\n<span class=\"gd\">--- a/src/tactic/lint/misc.lean</span>\n<span class=\"gi\">+++ b/src/tactic/lint/misc.lean</span>\n<span class=\"gu\">@@ -303,6 +303,8 @@ a higher universe level than `α`.</span>\n meta def check_univs (d : declaration) : tactic (option string) := do\n   let l := d.type.univ_params_grouped.union d.value.univ_params_grouped,\n   let bad := bad_params l,\n<span class=\"gi\">+  -- autogenerated subproof declarations can and may contain \"bad\" universe parameters</span>\n<span class=\"gi\">+  if \"proof\" ∈ d.to_name.to_string.split_on '_' then return none else</span>\n   if bad.empty then return none else return $ some $ \"universes \" ++ to_string bad ++\n   \" only occur together.\"\n</code></pre></div>\n<p>should do it</p>",
        "id": 257244008,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634060965
    },
    {
        "content": "<p>But this is cargo</p>",
        "id": 257244024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634060973
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/9676\">#9676</a></p>",
        "id": 257244189,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061027
    },
    {
        "content": "<p>But what If I make up a theorem called <code>proof_one_is_proof_two</code> with bad universes?</p>",
        "id": 257244209,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634061036
    },
    {
        "content": "<p>That's a risk</p>",
        "id": 257244314,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061076
    },
    {
        "content": "<p>fair enough. I guess the linter won't catch every little thing, but it's a good compromise IMO</p>",
        "id": 257244379,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634061104
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ rg <span class=\"s2\">\"^theorem.*proof\"</span>\nsrc/logic/basic.lean\n<span class=\"m\">689</span>:theorem proof_irrel_heq <span class=\"o\">{</span>p q : Prop<span class=\"o\">}</span> <span class=\"o\">(</span>hp : p<span class=\"o\">)</span> <span class=\"o\">(</span>hq : q<span class=\"o\">)</span> : <span class=\"nv\">hp</span> <span class=\"o\">==</span> hq :<span class=\"o\">=</span>\n\nsrc/data/erased.lean\n<span class=\"m\">42</span>:theorem out_proof <span class=\"o\">{</span>p : Prop<span class=\"o\">}</span> <span class=\"o\">(</span>a : erased p<span class=\"o\">)</span> : p :<span class=\"o\">=</span> out a\n\narchive/imo/imo2006_q3.lean\n<span class=\"m\">90</span>:theorem subst_proof₁ <span class=\"o\">(</span>x y z s : ℝ<span class=\"o\">)</span> <span class=\"o\">(</span>hxyz : x + y + <span class=\"nv\">z</span> <span class=\"o\">=</span> <span class=\"m\">0</span><span class=\"o\">)</span> :\n<span class=\"m\">111</span>:theorem proof₁ <span class=\"o\">{</span>a b c : ℝ<span class=\"o\">}</span> :\n<span class=\"m\">118</span>:theorem proof₂ <span class=\"o\">(</span>M : ℝ<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 257244520,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061158
    },
    {
        "content": "<p>With <code>lemma</code> there are no occurences</p>",
        "id": 257244596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061197
    },
    {
        "content": "<p>Isn't there some notion of an \"internal\" declaration, one whose last name part starts with <code>_</code></p>",
        "id": 257244836,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634061301
    },
    {
        "content": "<p>you're not supposed to use those directly, so it doesn't matter if you would have to specify universe levels to do so</p>",
        "id": 257244895,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634061324
    },
    {
        "content": "<p>Gabriel fixed it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"c1\">-- autogenerated subproof declarations can and may contain \"bad\" universe parameters</span>\n  <span class=\"k\">if</span> <span class=\"n\">d.to_name.last.starts_with</span> <span class=\"s2\">\"_proof_\"</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span> <span class=\"k\">else</span>\n</code></pre></div>\n<p>on github</p>",
        "id": 257245088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061402
    },
    {
        "content": "<p>I think we still want the linter for equation lemmas (which have <code>_eqn_1</code> etc.)</p>",
        "id": 257245090,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634061402
    },
    {
        "content": "<p><code>d.to_name.is_internal</code></p>",
        "id": 257245163,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634061435
    },
    {
        "content": "<p>hmm, because simp/rw will try to apply them and then get stuck?</p>",
        "id": 257245225,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634061459
    },
    {
        "content": "<p>Yes!</p>",
        "id": 257245276,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634061482
    },
    {
        "content": "<p>Not sure if that can actually happen though (if the main declaration already passes the linter).</p>",
        "id": 257245400,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634061522
    },
    {
        "content": "<p>Is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">check_univs</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- autogenerated subproof declarations can and may contain \"bad\" universe parameters</span>\n<span class=\"k\">if</span> <span class=\"n\">d.to_name.last.starts_with</span> <span class=\"s2\">\"_proof_\"</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span> <span class=\"k\">else</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">d.type.univ_params_grouped.union</span> <span class=\"n\">d.value.univ_params_grouped</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">bad</span> <span class=\"o\">:=</span> <span class=\"n\">bad_params</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">bad.empty</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span> <span class=\"k\">else</span>\n    <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"s2\">\"universes \"</span> <span class=\"bp\">++</span> <span class=\"n\">to_string</span> <span class=\"n\">bad</span> <span class=\"bp\">++</span> <span class=\"s2\">\" only occur together.\"</span>\n</code></pre></div>\n<p>better from a performance perspective?</p>",
        "id": 257245407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061524
    },
    {
        "content": "<p>I guess it doesn't matter much, but it moves the check to the start.</p>",
        "id": 257245430,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061535
    },
    {
        "content": "<p>Right, it doesn't matter.  It's already fast enough.</p>",
        "id": 257245464,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634061550
    },
    {
        "content": "<p>Why not just test for <code>d.to_name.is_internal</code> and for <code>_proof_</code>?</p>",
        "id": 257245482,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634061556
    },
    {
        "content": "<p>That conjunction is equivalent to the current test.</p>",
        "id": 257245662,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634061610
    },
    {
        "content": "<p>Well, non-internal names shouldn't start with <code>_</code>, so checking for <code>is_internal</code> seems redundant</p>",
        "id": 257245685,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634061614
    },
    {
        "content": "<p>Ah good point</p>",
        "id": 257245719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634061624
    },
    {
        "content": "<p>(<code>name.is_internal</code> is literally defined as \"some component starts with an underscore\" btw)</p>",
        "id": 257245778,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634061642
    },
    {
        "content": "<p>I'll add <a href=\"https://github.com/leanprover-community/mathlib/issues/9676\">#9676</a> as a dependency to my PR</p>",
        "id": 257245942,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634061717
    },
    {
        "content": "<p>If <a href=\"https://github.com/leanprover-community/mathlib/issues/9675\">#9675</a> passes CI, that's a good test that <a href=\"https://github.com/leanprover-community/mathlib/issues/9676\">#9676</a> does what it intends to do.</p>",
        "id": 257247424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634062293
    },
    {
        "content": "<p>FYI: Linting passed on <a href=\"https://github.com/leanprover-community/mathlib/issues/9675\">#9675</a> (the dependent issue is the only thing left)</p>",
        "id": 257272841,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634073078
    },
    {
        "content": "<p>Checking the <code>_proof_</code> parts is definitely intentional. <br>\nThe reason was that the linter found many bad lemmas only because the <code>_proof_i</code> sublemmas were bad: the proof of the main lemma was not bad, because it applies the bad <code>_proof_i</code> lemma to the individual universes.</p>\n<p>This example is very troubling though, it means that the lemma itself can be fine, even though it generated bad <code>_proof_i</code> lemmas. Let me investigate if there is a better fix than \"turn off the linter for all <code>_proof_i</code> lemmas.</p>",
        "id": 257349934,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634125048
    },
    {
        "content": "<p>Do you have an example of a bad lemma where the linter only detected the badness via a <code>_proof_i</code> lemma?<br>\nAlso, does it matter at all whether the main declaration is a lemma or a definition?</p>",
        "id": 257352153,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634126252
    },
    {
        "content": "<p>I guess if <code>main._proof_i</code> is bad but ignored, then <code>main</code> will be considered \"not bad\", since it relies on <code>main._proof_i</code> which is now considered \"good\" by decree.</p>",
        "id": 257352442,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634126397
    },
    {
        "content": "<p>Sorry, I should read more carefully. This is exactly what Floris also said.</p>",
        "id": 257352645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634126462
    },
    {
        "content": "<p>I don't understand why the right-hand side of the main declaration matters at all (especially if it is a lemma!). I thought the issue was with Lean inferring universe variables at a use site, and that process should only depend on the type and not the right-hand side.</p>",
        "id": 257352761,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634126515
    },
    {
        "content": "<p>What about a simple def like <code>def {u v} foo : Type (max u v) := ulift.{v} pempty.{u}</code>? This will trigger the linter if it ignores the RHS</p>",
        "id": 257353267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634126743
    },
    {
        "content": "<p>I can imagine examples of lemmas where the proof requires two universes but they only appear together in the statement</p>",
        "id": 257353452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634126815
    },
    {
        "content": "<p>Doesn't <code>foo.{u, v}</code> count as \"not appearing together\"?</p>",
        "id": 257353646,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634126888
    },
    {
        "content": "<p>here I'm talking about <code>foo</code> itself being flagged</p>",
        "id": 257353719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634126923
    },
    {
        "content": "<p>But you were talking about a definition.</p>",
        "id": 257353784,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634126952
    },
    {
        "content": "<p>every def has distinct universe parameters, by definition</p>",
        "id": 257353785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634126952
    },
    {
        "content": "<p>If <code>foo</code> was a lemma, it would be a bad lemma and its type should be <code>Type u</code> instead.  (which subsumes the bad version)</p>",
        "id": 257353863,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634127000
    },
    {
        "content": "<p>FWIW, the original culprit <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presheaf.fork_map\">docs#category_theory.presheaf.fork_map</a> is a definition not a lemma (unless it changed in the PR, which seems unlikely)</p>",
        "id": 257354016,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127059
    },
    {
        "content": "<p>(If a statement of a lemma only mentions <code>max u v</code> but not <code>u</code> or <code>v</code> separately, then you can just substitute <code>v := u</code> and get a better version.)</p>",
        "id": 257354025,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634127065
    },
    {
        "content": "<p>I suppose that's fair. So then the rule is to ignore the RHS for lemmas (or rather, things of <code>Prop</code> type) but not defs?</p>",
        "id": 257354100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127111
    },
    {
        "content": "<blockquote>\n<p>The reason was that the linter found many bad lemmas only because the _proof_i sublemmas were bad: the proof of the main lemma was not bad, because it applies the bad _proof_i lemma to the individual universes.</p>\n</blockquote>\n<p>The <code>_proof_i</code> auxiliary declarations are only generated for definitions, not lemmas.</p>",
        "id": 257354116,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634127120
    },
    {
        "content": "<p>I'm wondering if there is a way to analyze the <code>_proof_i</code> lemmas as if they were inlined into their parent</p>",
        "id": 257354242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127173
    },
    {
        "content": "<p>so they aren't penalized for using two universes together as long as they are used separately in <code>_proof_j</code> or in the main declaration</p>",
        "id": 257354300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127209
    },
    {
        "content": "<p>They <em>are</em> bad lemmas, but it's okay here because they will only be used in this one place and lean went to the trouble of passing the universe parameters correctly</p>",
        "id": 257354467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127286
    },
    {
        "content": "<p>Yes, I was also thinking of strengthening the linter to not check the values (RHSs) of theorems.</p>",
        "id": 257354549,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634127332
    },
    {
        "content": "<p>Mario's <code>foo</code> is in a gray area where some uses of <code>foo</code> will be ambiguous (e.g. <code>cardinal.mk foo</code>) while others won't (I guess, hard to come up with a specific example). I'm not quite sure what direction you're arguing, are you saying the linter currently flags it but shouldn't?</p>",
        "id": 257354598,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127362
    },
    {
        "content": "<p>But I don't understand how this is an example of what I was asking about, namely a definition that the linter would accept if it ignores the RHS but reject if it looks at the RHS.</p>",
        "id": 257354751,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127426
    },
    {
        "content": "<p>I would guess that most uses of <code>foo</code> will need explicit universes, because it has universe variables in the type that don't appear in any arguments</p>",
        "id": 257354765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127433
    },
    {
        "content": "<p>That's true just as well for <code>ordinal</code> and <code>cardinal</code></p>",
        "id": 257354806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.239675.20generalize.20universes.20for.20sheaves/near/257352153\">said</a>:</p>\n<blockquote>\n<p>Do you have an example of a bad lemma where the linter only detected the badness via a <code>_proof_i</code> lemma?<br>\nAlso, does it matter at all whether the main declaration is a lemma or a definition?</p>\n</blockquote>\n<p>See <a href=\"https://github.com/leanprover-community/mathlib/runs/3332764188\">https://github.com/leanprover-community/mathlib/runs/3332764188</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/8677\">https://github.com/leanprover-community/mathlib/pull/8677</a></p>",
        "id": 257354822,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634127463
    },
    {
        "content": "<p>I see. From my perspective, the problem is that the linter ever looks at the RHS at all.</p>",
        "id": 257355037,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127553
    },
    {
        "content": "<p>Mario's <code>foo</code> is allowed. I think definitions like that are used in mathlib.</p>",
        "id": 257355081,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634127577
    },
    {
        "content": "<p>If it didn't, then it would have caught the old <code>uniform_space_of_compact_t2</code> as only using universe variables together.</p>",
        "id": 257355109,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.239675.20generalize.20universes.20for.20sheaves/near/257355081\">said</a>:</p>\n<blockquote>\n<p>Mario's <code>foo</code> is allowed. I think definitions like that are used in mathlib.</p>\n</blockquote>\n<p>Hmm are there really? How hard would it be to modify the linter to ignore the RHS and see what it reports?</p>",
        "id": 257355282,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127658
    },
    {
        "content": "<p>We can always mark things like Mario's <code>foo</code> with <code>nolint</code> if we want to allow them... overall, I think that would result in something easier to understand</p>",
        "id": 257355357,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634127695
    },
    {
        "content": "<p>easy, let me do that</p>",
        "id": 257355370,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634127700
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Is it possible to make the analysis compositional enough to go over multiple definitions at once? For example, you analyze <code>bar._proof_1.{u, v}</code> and see that <code>u</code> and <code>v</code> are only used together. Normally this would be flagged, but since it is a <code>proof_i</code> we instead record this fact and when analyzing <code>bar</code> and get to the application <code>bar._proof_1.{u, v}</code> we pretend it says <code>thing.{max u v}</code> instead, i.e. it counts as a use of u and v together, so as long as <code>u</code> and <code>v</code> are used separately somewhere else we're okay but the call itself is not enough to make them separate</p>",
        "id": 257355539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634127771
    },
    {
        "content": "<p>I don't think that when folding a function over the environment, I can guarantee that <code>bar._proof_1</code> is visited before <code>bar</code>. But it's definitely possible (though maybe a little tricky) when checking <code>bar</code> to unfold all <code>bar._proof_i</code>'s and just not check the <code>bar._proof_i</code>'s by themselves</p>",
        "id": 257355983,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634127946
    },
    {
        "content": "<p>Reid's solution is easier though, if it works well enough</p>",
        "id": 257356202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634128036
    },
    {
        "content": "<p>Ok, Reid's suggestion has few positives. I don't know which of them are false positives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- C:\\Users\\Floris\\.elan\\toolchains\\leanprover-community--lean---3.33.0\\lib\\lean\\library\\init\\core.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">unification_hint</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [u_1, u_2] only occur together. -/</span>\n\n<span class=\"c1\">-- d:\\projects\\mathlib2\\src\\category_theory\\category\\Cat.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">category_theory.Cat</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n\n<span class=\"c1\">-- d:\\projects\\mathlib2\\src\\category_theory\\category\\Groupoid.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">category_theory.Groupoid</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n\n<span class=\"c1\">-- d:\\projects\\mathlib2\\src\\category_theory\\category\\Quiv.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">category_theory.Quiv</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n\n<span class=\"c1\">-- d:\\projects\\mathlib2\\src\\model_theory\\basic.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">first_order.language</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n\n<span class=\"c1\">-- d:\\projects\\mathlib2\\src\\set_theory\\ordinal.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">ordinal.univ</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">cardinal.univ</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n\n<span class=\"c1\">-- d:\\projects\\mathlib2\\src\\set_theory\\zfc.lean</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">pSet.embed</span> <span class=\"c\">/-</span><span class=\"cm\"> universes [v, u] only occur together. -/</span>\n</code></pre></div>",
        "id": 257356350,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634128094
    },
    {
        "content": "<p>they are all false positives, but it's pretty limited</p>",
        "id": 257356481,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634128165
    },
    {
        "content": "<p><code>unification_hint</code> is a true positive</p>",
        "id": 257356539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634128197
    },
    {
        "content": "<p>not that it matters much</p>",
        "id": 257356629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634128223
    },
    {
        "content": "<p><code>first_order.language</code> is also a true positive (and <code>nolint</code> right now)</p>",
        "id": 257356672,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634128242
    },
    {
        "content": "<p>Now I think I misunderstood the point of the <code>foo</code> example. The idea would be that <code>foo</code> is intended to be used with explicit universe parameters, right? Not that it would only be used in ways where the universe parameters could be inferred.<br>\nIn that case, maybe it is better anyways to explicitly acknowledge this (using <code>nolint</code>) rather than leaving it up to the linter to guess our intent.</p>",
        "id": 257356736,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634128278
    },
    {
        "content": "<p>The use of two universes in <code>first_order.language</code> is clearly deliberate, but it seems unnecessary</p>",
        "id": 257356973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634128393
    },
    {
        "content": "<p>All the other examples look like they should be <code>nolint</code>ed explicitly</p>",
        "id": 257357143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634128469
    },
    {
        "content": "<p>Note that Reid's suggestion doesn't 100% solve the problem: I noticed in the titular PR <a href=\"https://github.com/leanprover-community/mathlib/issues/9675\">#9675</a> that some of the <code>_proof_i</code> declarations actually occur in the type of the definition (this seems to happen for type-class instances, for some reason). So it's still possible to make a definition with a type with bad universes, but if a <code>_proof_i</code> occurs in the type, then it will not be flagged as such because the <code>_proof_i</code> declaration has \"separated\" all universe variables</p>",
        "id": 257357220,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634128506
    },
    {
        "content": "<p>What happens if we ignore the <code>_proof_i</code> <em>constants</em> in the linter?  (That is, don't count <code>foo._proof_1.{u,v}</code> as separating <code>u</code> and <code>v</code>?)</p>",
        "id": 257357392,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634128588
    },
    {
        "content": "<p>Nice idea! That should work, and be a little easier.</p>",
        "id": 257357524,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634128658
    },
    {
        "content": "<p>Shall I just merge Johan's fix (so that this PR can move forward), and then write my fix on top of that?</p>",
        "id": 257357998,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634128854
    },
    {
        "content": "<p>Won't that cause false positives?</p>",
        "id": 257358842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634129280
    },
    {
        "content": "<p>It seems that CI passed on <a href=\"https://github.com/leanprover-community/mathlib/issues/9675\">#9675</a>...</p>",
        "id": 257358950,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1634129319
    },
    {
        "content": "<p>No, because Johan's fix makes the linter weaker, and then with my fix I'll nolint the false positives</p>",
        "id": 257358958,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634129322
    },
    {
        "content": "<p>(that was a response to Gabriel's suggestion, btw)</p>",
        "id": 257359019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634129361
    },
    {
        "content": "<p>Ignoring the <code>_proof_i</code> constants is actually closer to the intent of the linter: the unifier probably can't use them to infer the universe levels anyhow due to proof irrelevance.  Either you're using a different proof anyhow, or the unifier just skips the subterm.</p>",
        "id": 257359251,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634129450
    },
    {
        "content": "<p>does that apply more generally to all subterms that are proofs (but not necessarily <code>_proof</code>s)?</p>",
        "id": 257359454,
        "sender_full_name": "Reid Barton",
        "timestamp": 1634129528
    },
    {
        "content": "<p>I would say yes, just like the RHS of lemmas.</p>",
        "id": 257361467,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634130368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.239675.20generalize.20universes.20for.20sheaves/near/257245090\">said</a>:</p>\n<blockquote>\n<p>I think we still want the linter for equation lemmas (which have <code>_eqn_1</code> etc.)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> do you agree we can turn off the new version of the linter on equation lemmas. I think it's impossible for a definition to pass the linter but a corresponding equation lemma to fail the linter?</p>",
        "id": 257361965,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634130591
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/9698\">#9698</a></p>",
        "id": 257362060,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634130618
    },
    {
        "content": "<p>My guess is it should be fine, but I wouldn't be surprised if there were corner cases (well-founded recursion maybe?).</p>",
        "id": 257362215,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634130677
    },
    {
        "content": "<p>I think <code>_match</code> declarations also fall under \"automatically generated\", so it won't check equation lemmas there at all.</p>",
        "id": 257362486,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634130790
    },
    {
        "content": "<p>I <em>think</em> in equation lemmas we always have the definition itself on the LHS with all the universes separately, so I expect that equation lemmas always pass.</p>",
        "id": 257362538,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634130814
    },
    {
        "content": "<p>For top-level definitions, yes.  However the auxiliary definitions for the matches are ignored by the linter in the new PR.</p>",
        "id": 257363687,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1634131285
    },
    {
        "content": "<p>but that might be desirable: maybe we want to write a match that doesn't use all universe levels</p>",
        "id": 257369196,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634133360
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> How would you like to coordinate <a href=\"https://github.com/leanprover-community/mathlib/issues/9675\">#9675</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/9698\">#9698</a> ? Would you like me to add <a href=\"https://github.com/leanprover-community/mathlib/issues/9698\">#9698</a> as a dependency for <a href=\"https://github.com/leanprover-community/mathlib/issues/9675\">#9675</a> ?</p>",
        "id": 257369624,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634133499
    },
    {
        "content": "<p>I think they're independent of each other, neither one has to be a dependency of the other.</p>",
        "id": 257369721,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634133539
    },
    {
        "content": "<p>You're not expecting additional <code>nolint</code>'s to be necessary?</p>",
        "id": 257369837,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634133586
    },
    {
        "content": "<p>no, the declarations you changed should be accepted by the new linter</p>",
        "id": 257370058,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1634133636
    },
    {
        "content": "<p>Great</p>",
        "id": 257370105,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634133655
    }
]
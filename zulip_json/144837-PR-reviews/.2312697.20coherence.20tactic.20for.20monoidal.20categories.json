[
    {
        "content": "<p>Let me give the current status and the future prospect. I defined a tactic that solves any coherence equalities in monoidal categories (and bicategories) such as <code>(λ_ (𝟙_ C)).hom = (ρ_ (𝟙_ C)).hom</code>. See <a href=\"https://github.com/leanprover-community/mathlib/blob/87f95660226fdb8960917020d13f6a41eb7a8102/test/coherence.lean#L42\">test/coherence.lean</a> for more examples. </p>\n<p>This is useful, but I feet that it is too limited in some situation. I want <code>coherence</code> tactic to be able to prove the equalities involving <code>congr</code> and <code>assoc</code> with respect to composition, e.g. <code>f ≫ (λ_ (𝟙_ C)).hom = f ≫ (ρ_ (𝟙_ C)).hom</code> and <code>f ≫ g ≫ (λ_ (𝟙_ C)).hom = (f ≫ g) ≫ (ρ_ (𝟙_ C)).hom</code>. This may require a little more programming ability though.</p>",
        "id": 277157273,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1648652068
    },
    {
        "content": "<p>The version described in the second paragraph is now in <a href=\"https://github.com/leanprover-community/mathlib/pull/13125\">#13125</a>. <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span>, any chance you'd be interested in upgrading this so it handles bicategories as well?</p>",
        "id": 277521658,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1648896033
    },
    {
        "content": "<p>Wonderful! I would like to upgrade it so that it can also handle bicategories.</p>",
        "id": 277523836,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1648898790
    },
    {
        "content": "<p>Let me make one comment. I think it is useful to fix a simp normal form of \"non-structural morphisms\" when using coherence tactics. Then we don't need manual rewriting using the naturality of associators, etc. For example, the following two non-structural morphisms are related by some associators, and we want to use either of them when applying <code>coherence</code>. In <a href=\"https://github.com/leanprover-community/mathlib/tree/bicategory-simp-normal-form\">branch#bicategory-simp-normal-form</a>, I use the former expression as the simp normal form (this experiment is for bicategories, not monoidal categories though), and I found it works well.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span> <span class=\"bp\">⊗</span> <span class=\"o\">(((</span><span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">_</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span> <span class=\"bp\">⊗</span> <span class=\"o\">(((</span><span class=\"n\">Y</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"o\">(((</span><span class=\"n\">f</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">⊗</span> <span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span> <span class=\"bp\">⟶</span> <span class=\"n\">_</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y</span> <span class=\"bp\">⊗</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">f</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span> <span class=\"bp\">⊗</span> <span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 277524916,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1648900248
    },
    {
        "content": "<p>I've read <code>liftable_prefixes</code> tactic in <a href=\"https://github.com/leanprover-community/mathlib/pull/13125\">#13125</a>, and I found that it performs what we need in surprisingly short lines. Very great!</p>",
        "id": 277525785,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1648901372
    }
]
[
    {
        "content": "<p>I am currently submitting my work on manifolds to mathlib. The first PR is <a href=\"https://github.com/leanprover-community/mathlib/issues/1359\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1359\">#1359</a>, but other ones are coming along the way. The current final state of things can be seen in  <a href=\"https://github.com/sgouezel/mathlib/tree/manifold9\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/tree/manifold9\">https://github.com/sgouezel/mathlib/tree/manifold9</a>. In the summary of <a href=\"https://github.com/leanprover-community/mathlib/issues/1359\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1359\">#1359</a>, I have added a list of what is coming next, but let me copy it here. Any comment or advice on design decisions or API is welcome in this stream.</p>\n<p>Here is the summary of what is coming next:</p>\n<ul>\n<li><code>src/topology/local_homeomorph</code>: local homeomorphisms (just like local equivs, but with open source and target, and continuous functions between them).</li>\n<li><code>geometry/manifold/fiber_bundle</code>: fiber bundles (where the fiber is a topological space, the base is a topological space, and local trivializations are formulated using local homeos). Useful to define the tangent bundle later on.</li>\n<li><code>geometry/manifold/manifold</code>: define a manifold modelled on a general topological space (where the charts are given by local homeos). Define groupoids of local homeos, and specify what it means for a manifold to have this groupoid as structure groupoid.<br>\n*<code>geometry/manifold/smooth_manifold_with_boundary</code>: as a particular case of manifolds, define smooth manifolds with boundary, where the model space is a normed vector space (or a nice subset of such a vector space, for instance a half space), where the coordinate changes are smooth.<br>\n*<code>geometry/manifold/basic_smooth_bundle</code>: define a specific kind of smooth vector bundles over a smooth manifold (the bundle should be trivial in the charts of the manifold), and use this machinery to define the tangent bundle (applications to differential forms or riemannian metrics should be easy, but are not done yet), as a smooth manifold.<br>\n*<code>geometry/manifold/mderiv.lean</code>: the differential of a map between manifolds, as a map between tangent spaces. Follows the API for derivatives (and is defeq to the standard derivative when the manifold is a vector space, as it should be -- to get this was an important guidance in the choice of definitions).</li>\n</ul>",
        "id": 174364812,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567000765
    },
    {
        "content": "<p>This is glorious. Actual maths are about to enter the world of proof assistants!</p>",
        "id": 174364959,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567000855
    },
    {
        "content": "<p>About names (which are important for navigation):</p>\n<ul>\n<li>don't you want to rename <code>fiber_bundle</code> to <code>topological_fiber_bundle</code>? </li>\n<li>In <code>smooth_manifold_with_boundary</code>, do I understand correct that you include corners? If yes then the name is a bit misleading. You could either make it longer (including \"corners\") or shorter (dropping \"with_boundary\")</li>\n</ul>",
        "id": 174365145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567000979
    },
    {
        "content": "<p>In <code>mderiv</code>, it's a bit sad to see continuity as requirement for differentiability. Can't you check differentiability in nicely related charts (with the image of the source chart contained in the target chart)? Is this related to your defeq constraint?</p>",
        "id": 174365314,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001083
    },
    {
        "content": "<p>I guess I will get some complaints here on Zulip about definitions such as</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">smooth_manifold_with_boundary</span> <span class=\"o\">(</span><span class=\"err\">ùïÇ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">ùïÇ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">normed_space</span> <span class=\"err\">ùïÇ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">model_with_boundary</span> <span class=\"err\">ùïÇ</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">manifold</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"kn\">extends</span>\n  <span class=\"n\">has_groupoid</span> <span class=\"n\">H</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"err\">‚ä§</span> <span class=\"err\">ùïÇ</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>If there are tricks to get a better API or a better use of typeclasses, I will be happy to hear about them!</p>",
        "id": 174365339,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001098
    },
    {
        "content": "<p>All the <code>out_param</code> are here so that you can just talk about the <code>k</code>-derivative of <code>f : M -&gt; M'</code> and Lean will find all by itself the smooth manifold structures on <code>M</code> and <code>M'</code>...</p>",
        "id": 174365480,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001177
    },
    {
        "content": "<p>This looks like a very general class that could have less hairy specializations making people happier</p>",
        "id": 174365481,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001177
    },
    {
        "content": "<p><code>out_param</code> magic is a difficult dark art where success can be asserted only after a lot of API usage</p>",
        "id": 174365553,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001230
    },
    {
        "content": "<blockquote>\n<p>In <code>mderiv</code>, it's a bit sad to see continuity as requirement for differentiability. Can't you check differentiability in nicely related charts (with the image of the source chart contained in the target chart)? Is this related to your defeq constraint?</p>\n</blockquote>\n<p>There is really something tricky going on here: if your function is not continuous, then its image will typically not be contained in a chart. So you really need continuity if you want to be able to define differentiability. In the Isabelle paper on manifolds, they face the same issue, and they also have to include continuity in the definition of differentiability. And I guess any precise enough mathbook should also do it!</p>",
        "id": 174365670,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001301
    },
    {
        "content": "<p>The definition I had in mind was: f is differentiable at x if there is a chart domain U containing x and a chart domain V containing the image of U such that the obvious composition is differentiable at the chart image of x. Is it junk?</p>",
        "id": 174365878,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001429
    },
    {
        "content": "<blockquote>\n<p>This looks like a very general class that could have less hairy specializations making people happier</p>\n</blockquote>\n<p>Yes, there should be a specialization <code>smooth_manifold k E M</code> where <code>H = E</code>. With a notation, everything is fine. With a class extending the previous one, I don't know how to get instances right.</p>",
        "id": 174365936,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001477
    },
    {
        "content": "<blockquote>\n<p>The definition I had in mind was: f is differentiable at x if there is a chart domain U containing x and a chart domain V containing the image of U such that the obvious composition is differentiable at the chart image of x. Is it junk?</p>\n</blockquote>\n<p>It's clearly equivalent, but this definition is more complicated to work with (you need to construct your <code>V</code> when you check differentiability, at least when you build the API)</p>",
        "id": 174366096,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001567
    },
    {
        "content": "<blockquote>\n<ul>\n<li>don't you want to rename <code>fiber_bundle</code> to <code>topological_fiber_bundle</code>? </li>\n</ul>\n</blockquote>\n<p>No strong opinion on this. According to wikipedia, a fiber bundle is by default a topological one, but I agree that most often we think of a smooth one.</p>",
        "id": 174366274,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001658
    },
    {
        "content": "<p>Anyway, this definition is clearly part of the private API. What matters is that the definition matches the classical definition on open subsets of the model space and that a function on a submanifold is differentiable iff it extends as a differentiable function on a neighborhood (this covers in particular smooth functions on submanifolds of the model space).</p>",
        "id": 174366389,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001740
    },
    {
        "content": "<p>About fiber bundle, I think adding \"topological\" avoids confusion for very little cost</p>",
        "id": 174366492,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001778
    },
    {
        "content": "<p>At least in the file name</p>",
        "id": 174366509,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567001791
    },
    {
        "content": "<blockquote>\n<ul>\n<li>In <code>smooth_manifold_with_boundary</code>, do I understand correct that you include corners? If yes then the name is a bit misleading. You could either make it longer (including \"corners\") or shorter (dropping \"with_boundary\")</li>\n</ul>\n</blockquote>\n<p>Yes, I include corners. In the beginning, I had the shorter version, but then I decided I wanted to keep it for the boundaryless version. I agree that <code>smooth_manifold_with_corners</code> is better, but it might look frightening. Or <code>extended_smooth_manifold</code> (less scary, but less precise as one doesn't know what the extension refers to). I guess I'll go for <code>smooth_manifold_with_corners</code>, less ambiguity is better.</p>",
        "id": 174366539,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567001811
    },
    {
        "content": "<p><a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/mderiv.lean#L709-L710\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/mderiv.lean#L709-L710\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/mderiv.lean#L709-L710</a> may be the first statement that I can recognize, but I like it.</p>",
        "id": 174367047,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002126
    },
    {
        "content": "<p>Functoriality is beautiful, especially when it hides all the mess of the definitions.</p>",
        "id": 174367153,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567002222
    },
    {
        "content": "<p>Funny you say that, I was thinking about the tangent functor. It's a big weird that the construction of the tangent bundle and mderiv are in separate file. A file <code>tangent_functor.lean</code> would be easier to find (but may be 2000 lines long...)</p>",
        "id": 174367275,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002298
    },
    {
        "content": "<blockquote>\n<p>the differential of a map between manifolds, as a map between tangent spaces. Follows the API for derivatives (and is defeq to the standard derivative when the manifold is a vector space, as it should be -- to get this was an important guidance in the choice of definitions).</p>\n</blockquote>\n<p>Why do the last few lemmas of mderiv.lean suggest this is not a defeq?</p>",
        "id": 174367413,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002373
    },
    {
        "content": "<p>Funny you say that: at the beginning, it was the other way around, with first the construction of <code>mderiv</code>and then deriving the tangent bundle from it. But the construction was a little bit ad hoc, and I would have needed to redo everything to construct differential forms or riemannian metrics. I decided that to get a general machinery would be more efficient (and indeed the general machinery is not really longer than the direct construction using <code>mderiv</code>, surprisingly).</p>",
        "id": 174367569,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567002474
    },
    {
        "content": "<p>I meant you could end the first file at <a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/basic_smooth_bundle.lean#L255\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/basic_smooth_bundle.lean#L255\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/basic_smooth_bundle.lean#L255</a></p>",
        "id": 174367728,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002551
    },
    {
        "content": "<p>and move the end to <code>mderiv.lean</code>, renamed <code>tangent_functor.lean</code></p>",
        "id": 174367780,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002589
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>the differential of a map between manifolds, as a map between tangent spaces. Follows the API for derivatives (and is defeq to the standard derivative when the manifold is a vector space, as it should be -- to get this was an important guidance in the choice of definitions).</p>\n</blockquote>\n<p>Why do the last few lemmas of mderiv.lean suggest this is not a defeq?</p>\n</blockquote>\n<p>You are right, it's not a defeq. But it's the same map, and in particular the domain of definition of the linear map is the same space (i.e., not the vector space for the first one and a crazy quotient or a crazy space of derivations for the second one).</p>",
        "id": 174367794,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567002600
    },
    {
        "content": "<p>The crazy space of derivation is crazy algebraic geometry bullshit anyway. And you didn't restrict to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span></span></span></span> anyway, right?</p>",
        "id": 174367923,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002671
    },
    {
        "content": "<blockquote>\n<p>I meant you could end the first file at <a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/basic_smooth_bundle.lean#L255\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/basic_smooth_bundle.lean#L255\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/basic_smooth_bundle.lean#L255</a></p>\n</blockquote>\n<p>Yes I could, but the file would become super-long. I was more planning of including the other constructions (differential forms, metrics) also in <code>basic_smooth_bundle</code> .</p>",
        "id": 174367964,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567002710
    },
    {
        "content": "<p>I guess crazy quotient refer to space of smooth curves modulo the same speed relation? This is a nice relation but indeed you only get a isomorphism in the vector space case</p>",
        "id": 174368057,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002758
    },
    {
        "content": "<p>You'll need to split off tensor bundles in all cases</p>",
        "id": 174368098,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002789
    },
    {
        "content": "<p>I'd like to read more about how you avoided those definitions of the tangent bundle but still remained functorial</p>",
        "id": 174368234,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567002886
    },
    {
        "content": "<blockquote>\n<p>The crazy space of derivation is crazy algebraic geometry bullshit anyway. And you didn't restrict to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span></span></span></span> anyway, right?</p>\n</blockquote>\n<p>Well, it works perfectly well in any smoothness, but typeclass inference doesn't like it when there is an additional unspecified parameter of smoothness. And if you want to talk about <code>C^k</code> functions on a <code>C^r</code> manifold, then you would need to infer automatically inequalities like <code>k &lt;= r</code>, which looks like a daunting task. So I only give the definition for <code>C^oo</code> manifolds for simplicity.</p>",
        "id": 174368297,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567002930
    },
    {
        "content": "<blockquote>\n<p>I guess crazy quotient refer to space of smooth curves modulo the same speed relation? This is a nice relation but indeed you only get a isomorphism in the vector space case</p>\n</blockquote>\n<p>Yes, that's the most intuitive definition but not the easiest to work with in a formal way.</p>",
        "id": 174368374,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567002969
    },
    {
        "content": "<p>I'm confused about the smoothness answer. I think there are different discussions. Defining the tangent space using derivations does <em>not</em> work in finite regularity, you get infinite dimensional tangent space in all cases. Then you say you used a definition that could work in the finite differentiability case, except that Lean would make it harder?</p>",
        "id": 174368476,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567003074
    },
    {
        "content": "<blockquote>\n<p>I'd like to read more about how you avoided those definitions of the tangent bundle but still remained functorial</p>\n</blockquote>\n<p>It's just a hack, that should make both computer scientists and mathematicians crazy. It's explained in the docstring of <a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/fiber_bundle.lean\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/fiber_bundle.lean\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/fiber_bundle.lean</a></p>",
        "id": 174368582,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567003144
    },
    {
        "content": "<blockquote>\n<p>Then you say you used a definition that could work in the finite differentiability case, except that Lean would make it harder?</p>\n</blockquote>\n<p>Yes, that's it. My definition works in any smoothness, but it's easier to use for Lean in infinite smoothness.</p>",
        "id": 174368700,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567003217
    },
    {
        "content": "<p>This fiber bundle hack is really shocking. I'll need time to stomach it</p>",
        "id": 174369474,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567003721
    },
    {
        "content": "<p>So, if I have a map <code>p : E ‚Üí B</code>, I cannot tell Lean that it is a fibre bundle. Do I understand that correctly?</p>",
        "id": 174371736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567004983
    },
    {
        "content": "<p>I guess it is not too hard to construct the relevant fibre bundle and characterize its relation to <code>p</code>? Anyhow, it looks like a nice solution to me.</p>",
        "id": 174375591,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1567007257
    },
    {
        "content": "<p>Probably yes, but I imagine that it would be nice to have good API for this. Otherwise it will become frustrating rather soon.</p>",
        "id": 174376306,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567007677
    },
    {
        "content": "<p>For example, I would like <code>prod.fst</code> and <code>prod.snd</code> to both be fibre bundles</p>",
        "id": 174376363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567007712
    },
    {
        "content": "<p>Indeed, I have only implemented the bundled version of fiber bundles, but one could also need the unbundled version <code>is_fiber_bundle p</code>, where <code>p : E -&gt; B</code> is a map between topological spaces and all the standard properties hold. For what I wanted to do, the bundled version is more efficient (in particular since it builds the total space of the bundle and its topology for me).</p>",
        "id": 174380354,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567010576
    },
    {
        "content": "<p>Many things with fiber bundles seem easier to do with the bundled version, by the way (fibered products, pullbacks, K-theory, characteristic classes...).</p>",
        "id": 174380458,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567010673
    },
    {
        "content": "<p>Just to say that this sort of technical conversation involving expert mathematicians trying to formalise serious stuff in mathlib is such a joy to see -- it is something we were so far from 2 years ago and it's very exciting to see it happening in Lean. Thank you Sebastien and thank you also Patrick for keeping a very close eye on what he is doing.</p>",
        "id": 174382055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1567011847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> But in this case the bundled version is not (close to being defeq to) <code>{p // is_fiber_bundle p}</code>.</p>",
        "id": 174383393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567012820
    },
    {
        "content": "<p>So it might be even harder to apply a \"bundled fact\" to an unbundled fibre bundle than the usual (un)bundling dance</p>",
        "id": 174383453,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567012870
    },
    {
        "content": "<p>From the unbundled version you can construct a bundled version (using all the possible trivializations), from which you can get an unbundled version which will be isomorphic to the original one, but definitely not defeq, I agree.</p>",
        "id": 174385175,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567014090
    },
    {
        "content": "<blockquote>\n<p>It's explained in the docstring of <a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/fiber_bundle.lean\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/fiber_bundle.lean\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/fiber_bundle.lean</a></p>\n</blockquote>\n<p>This seems to have disappeared? I get a 404.</p>",
        "id": 174411476,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1567036165
    },
    {
        "content": "<p>new link: <a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/topological_fiber_bundle.lean\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/topological_fiber_bundle.lean\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/topological_fiber_bundle.lean</a></p>",
        "id": 174413945,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1567038969
    },
    {
        "content": "<p>Yes, sorry for the inconvenience but the name change was a request of the referee here on Zulip :)</p>",
        "id": 174432397,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567065931
    },
    {
        "content": "<p>S√©bastien, I thought a bit more about your topological fiber bundle hack, and I think this is a pretty serious issue, and such a decision should be given really serious consideration. Having a trustworthy type checker is wonderful, but formalization will always involve human deciding whether the bit of formalized math they are looking at has anything to do with what is in their head and has the same name.</p>\n<p>For people who don't know about manifolds, let me try an analogy. An elementary version of what S√©bastien did would be to start <code>rat.lean</code> with <code>def ‚Ñö : Type := ‚Ñï</code>, then write 500 lines defining algebraic operations on <code>‚Ñö</code> (secretly using your favorite enumeration of <code>‚Ñö</code> to import the usual operations), and then write 1000 lines proving that <code>‚Ñö</code>, endowed with these operation is a field of characteristic zero, and it uniquely embeds into every field of characteristic zero, or some other property aiming to convince the reader that <code>‚Ñö</code> is the field there are thinking of, and provide an API to manipulate its elements. </p>\n<p>This is not to be confused with the divide by zero or the rooster and butterflies scandals. Those shock mathematicians, but are only extensions of what we would do. Here there is no intersection with real world.</p>\n<p>I think the goal of having the tangent bundle to a vector space <code>E</code> equal (not even definitionaly) to <code>E √ó\nE</code> is not worth this. Even in sloppy real world math we write an isomorphism sign here. When I dream of manifolds in a proof assistant, I rather see <code>to_manifold</code>, a variation on the <code>to_additive</code> tactic that would turn lemmas about open subsets of vector spaces (or, better, of affine spaces) into lemmas about manifolds. This I think would have been a much nicer guide.</p>",
        "id": 174619552,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567260849
    },
    {
        "content": "<p>Some more context. A fiber bundle above a space <code>B</code> with fiber <code>E</code> is a space <code>Z</code> with a projection on the base, such that all its fibers are homeomorphic to <code>E</code> (plus a local triviality condition that I will omit in the discussion). The usual way to construct a fiber bundle is to have local trivializations, and to say what happens when one changes trivialization. I.e., one has a space <code>I</code> of local trivializations, and open sets <code>O_i</code>, and for each <code>i</code> and <code>j</code> and each <code>x ‚àà O_i ‚à© O j</code> one has homeomorphisms <code>\\phi_{ij}(x)</code> of <code>E</code>, that satisfy a (compatibility) cocycle condition. Then the space of the fiber bundle is constructed by gluing above each <code>x</code> copies of <code>E</code> indexed by those <code>i</code> where <code>x ‚àà O_i</code>, where the gluing is made using the <code>\\phi_{ij}</code>. So the fiber above <code>x</code> is isomorphic to <code>E</code>, but not canonically (each choice of some <code>i</code> gives an isomorphism between the fiber and <code>E</code>).</p>\n<p>What I do is that I avoid the gluing completely and use choice instead, choosing one specific isomorphism above <code>x</code> to identify the fiber above <code>x</code> with <code>E</code> -- this amounts to choosing one preferred trivialization at each point. Which means that in practice the total space of my bundle is just <code>B √ó E</code> (this definitely makes sense mathematically, the total space of the fiber bundle is in bijection with <code>B √ó E</code>, although non-canonically). </p>\n<p>The claim is that the construction is much shorter this way (no need to define all the identifications, to show that the fiber defined as a quotient has a vector space structure, a topological space structure, and so on). And also it avoids a lot of DTT hell further on, as all fibers are the same to Lean (although this is completely hidden from the user by the API).</p>\n<p>I knew that this would make mathematicians scream (because the definition I use is certainly not \"the right one\"), and computer scientists also because I use choice where it is not needed. (In fact, choice is not apparent in my development, as the very definition of fiber bundle takes a preferred trivialization at each point -- this is a way to express that the <code>O_i</code> cover the base). But I have really thought this through, and in the end if you don't like the definition you just need to use the API (just like I don't even know how rationals are defined in Lean, as a type of coprime pairs of integers or as a quotient).</p>",
        "id": 174620835,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567263097
    },
    {
        "content": "<blockquote>\n<p>Some more context. A fiber bundle above a space <code>B</code> with fiber <code>E</code> is a space <code>Z</code> with a projection on the base, such that all its fibers are homeomorphic to <code>E</code> (plus a local triviality condition that I will omit in the discussion). The usual way to construct a fiber bundle</p>\n</blockquote>\n<p>There is something crucial here. You are talking about <em>constructing</em> a fiber bundle. I'm talking about defining fiber bundles. There could be a nice mathematical definition and a crazy constructor. Then the constructor can be as crazy as you like it.</p>\n<blockquote>\n<p>Which means that in practice the total space of my bundle is just <code>B √ó E</code> (this definitely makes sense mathematically, the total space of the fiber bundle is in bijection with <code>B √ó E</code>, although non-canonically). </p>\n</blockquote>\n<p>This is why I took the example of <code>‚Ñö</code> defined as <code>‚Ñï</code> equipped with some weird operations. There are indeed bijections from <code>‚Ñö</code> to <code>‚Ñï</code>, but I wouldn't say it \"makes sense mathematically\".</p>",
        "id": 174621039,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567263377
    },
    {
        "content": "<p>Well, there has to be a definition of <code>‚Ñö</code> in Lean. And it has to be some definition like that, and one should choose the definition that is the most convenient to prove things about it. That's what I tried to do for fiber bundles.</p>",
        "id": 174621105,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567263489
    },
    {
        "content": "<p>Did you at least prove that your \"fiber bundles\" are actual fiber bundles?</p>",
        "id": 174621199,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567263671
    },
    {
        "content": "<p>Yes, I construct a family of local trivializations <code>\\psi_i</code>, which are local homeomorphisms, and such that the initial <code>phi_{ij}</code>is the composition <code>\\psi_i o \\psi_j^{-1}</code>. This is all the point of the construction: to put a topology on the total space of the bundle and check that everything works out as it should.</p>",
        "id": 174621340,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567263917
    },
    {
        "content": "<p>Maybe I should insist again that I'm thrilled that manifolds are arriving to Lean, and I know you are a much better mathematician and formalizer than I am. But I really fear the hiatus between maths and formalizing math is too wide here.</p>",
        "id": 174621473,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567264116
    },
    {
        "content": "<p>Why not defining actual fiber bundles then? And provide a crazy constructor.</p>",
        "id": 174621492,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567264178
    },
    {
        "content": "<p>Honestly, I don't think the hiatus is that big. In ergodic theory, it is very common to start from an arbitrary bundle and to trivialize it (measurably) on a set of full measure. Again, I am just choosing one isomorphism with <code>E</code> in each fiber, among all those that naturally exist. And this is all about the constructor, that you can forget about just like the specific definition of <code>‚Ñö</code> .</p>\n<p>I did not define actual fiber bundles because the actual definition is terribly messy, and I didn't need it.</p>",
        "id": 174621626,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567264387
    },
    {
        "content": "<p>Most constructions (pullback, fibered product, and so on) are also much easier to do in terms of the constructor, by the way.</p>",
        "id": 174621756,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567264658
    },
    {
        "content": "<p>I have reworked a little bit the terminology, and I agree the new version looks much better. Now, I have a predicate <code>is_topological_fiber_bundle</code>, which corresponds to what you think (and I prove that the first and second projections in a direct product satisfy this predicate). And I have a structure <code>topological_fiber_bundle_core</code> (but I could rename it to <code>topological_fiber_bundle_pkg</code> or whatever you like), from which I can construct a total space and a projection, and I prove that these satisfy <code>is_topological_fiber_bundle</code>. In particular, I have made it clear that this trick I use with choice is only for constructing a fiber bundle from a <code>topological_fiber_bunde_core</code>. New version at <a href=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/topological_fiber_bundle.lean\" target=\"_blank\" title=\"https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/topological_fiber_bundle.lean\">https://github.com/sgouezel/mathlib/blob/manifold9/src/geometry/manifold/topological_fiber_bundle.lean</a> . <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> , does it look better like that, and do you still see possible improvements?</p>",
        "id": 174669060,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567357587
    },
    {
        "content": "<p>I had a quick look, and it certainly looks better. I'm don't understand how you encode structure groups though. Will this come later?</p>",
        "id": 174673731,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567365816
    },
    {
        "content": "<p>In a <code>is_topological_fiber_bundle</code>, there is no structure group. In a <code>topological_fiber_bundle_core</code>, it is already there as one can start from a structure in which the coordinate change live in a smaller group than all the homeos of <code>F</code>, and then this will be respected in the construction of the fiber bundle.</p>",
        "id": 174674019,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567366298
    },
    {
        "content": "<p>Maybe I should have written that I'd like to see how you can do <code>is_bundle_with_group</code> on top of that</p>",
        "id": 174674203,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567366663
    },
    {
        "content": "<p>It's so ironic that each time I explain dependent type to anyone, I always say: it's very simple, it's like a fiber bundle...</p>",
        "id": 174674987,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1567367925
    },
    {
        "content": "<blockquote>\n<p>Maybe I should have written that I'd like to see how you can do <code>is_bundle_with_group</code> on top of that</p>\n</blockquote>\n<p>You could have a <code>Prop</code> defining this, requiring the existence of a family of local trivializations for which the change of coordinates in the fibers all belong to a given group. But I think I would rather go a different way, with more data, as follows: I would register a manifold structure on the total space of the bundle, with model space <code>B \\times F</code> (this is the data), and then having some structure group means that the coordinate changes belong to some groupoid of <code>B \\times F</code> (with the identity in the basis, and your preferred group in the fiber). In this way, this fits nicely with the existing infrastructure.</p>",
        "id": 174693623,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567404608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Will this framework be general enough to also do complex holomorphic manifolds?</p>",
        "id": 175087583,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567792472
    },
    {
        "content": "<p>I think so</p>",
        "id": 175091849,
        "sender_full_name": "Reid Barton",
        "timestamp": 1567795272
    },
    {
        "content": "<p>Take k = C, E = H = C^n, and use the groupoid of holomorphic functions (once you define those)</p>",
        "id": 175092007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1567795373
    },
    {
        "content": "<blockquote>\n<p>Take k = C, E = H = C^n, and use the groupoid of holomorphic functions (once you define those)</p>\n</blockquote>\n<p>Yes. And holomorphic functions are already defined in this setting, as they are just the <code>C^1</code> functions :)</p>",
        "id": 175095241,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1567797575
    },
    {
        "content": "<p>Fantastic!</p>",
        "id": 175095406,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1567797712
    },
    {
        "content": "<p>It's so exciting seeing the manifolds PRs coming in. :-)</p>",
        "id": 175229041,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1568024119
    },
    {
        "content": "<p>Can I ask, <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>, how you would anticipate modelling stratified spaces?</p>\n<p>Will we just be able to say: a sequence of closed subsets S_0 &lt; S_1 &lt; ... &lt; S_n = M, so that S_{k+1} \\setminus S_k is a (k+1)-dimensional submanifold of M?</p>",
        "id": 175229416,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1568024599
    },
    {
        "content": "<p>I am not sure of what definition of stratified space you mean. In the definition I have in mind, the global space can be singular, and only the intermediate pieces are nice, so you can't say that you have submanifolds of an ambient manifold. But you could for instance say that you have a manifold structure on each <code>S_{k+1} \\setminus S_k</code> as a subtype. Or a sequence of manifolds that embed in your space, with compatibility conditions. The only way to work out the most efficient definition would be to start proving theorems!</p>",
        "id": 175233587,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1568029335
    }
]
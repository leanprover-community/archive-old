[
    {
        "content": "<p>Hello, my PR about Gram-Schmidt is awaiting review for over a week, may I ask for someone have a look on it?</p>",
        "id": 277909149,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649177369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"471791\">@Jiale Miao</span> Thanks for the ping. I left some minor comments.</p>",
        "id": 277909796,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649177670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thank you! I saw these comments and they are really helpful, I have fixed them <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 277911336,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649178272
    },
    {
        "content": "<p>I showed how to golf the orthogonality proof using strong induction.</p>",
        "id": 277921183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649182377
    },
    {
        "content": "<p>Can you generalize the indexing type to a arbitrary well-ordered type (which will then include <code>‚Ñï</code> but also <code>fin n</code>), by taking as definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Gram-Schmidt process -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">gram_schmidt</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">orthogonal_projection</span>\n    <span class=\"o\">(</span><span class=\"n\">submodule.span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">$</span> <span class=\"n\">gram_schmidt</span> <span class=\"bp\">‚àò</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">I</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">i.2</span><span class=\"o\">]}</span>\n</code></pre></div>\n<p>We would need to replace <code>submodule.span</code> with the \"completed span\". Does something like that exist? cc <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span></p>",
        "id": 277924310,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649183586
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.topological_closure\">docs#submodule.topological_closure</a></p>",
        "id": 277924907,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649183781
    },
    {
        "content": "<p>Is that what you want?</p>",
        "id": 277924940,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649183793
    },
    {
        "content": "<p>It sounds like you are making a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis\">docs#hilbert_basis</a>, right?</p>",
        "id": 277928564,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1649185302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"471791\">@Jiale Miao</span> Would you want to generalize in that direction?</p>",
        "id": 277928931,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649185446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thank you for your comments! I am not very familiar with that part, but I think I would have a try on it first. I would be appreciate if you can give me more hints here<span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 277930212,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649186018
    },
    {
        "content": "<p>Hmm, I'm currently unsure if we want to do a very general version, or whether we want two versions...</p>",
        "id": 277930890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649186345
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> or <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> can indicate what they think is best.</p>",
        "id": 277930941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649186380
    },
    {
        "content": "<p>(I'm an algebraist, so I've only ever needed the finite version... <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>)</p>",
        "id": 277930971,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649186398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"471791\">@Jiale Miao</span> Ooh, if this is on the undergrad list, please update <code>undergrad.yaml</code> (-;</p>",
        "id": 277932980,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649187476
    },
    {
        "content": "<p>I just took a look at the PR. I think it would make sense to have the following:</p>\n<ol>\n<li>A version only slightly generalized from what currently exists, where we replace <code>‚Ñï</code> with an encodable type. Although if people think we really only want <code>‚Ñï</code>, I could likely be convinced. Pretty much everything should be able to be translated as is. However, there could be an addendum to the effect that if the space is complete, then the closure of the span of (linearly independent) <code>f : ‚Ñï ‚Üí E</code> has the gram-schmidt collection as a Hilbert basis, as Heather suggested. (This addendum could be a separate PR.)</li>\n<li>For an arbitrary well-ordered type, we would need the underlying space to be complete so that the closure of the span of an initial segment is  a complete space, which would then allow you to have the orthogonal projection onto that subspace. This is the reason to keep the two separate (so that the simpler version doesn't need completeness). I've never needed Gram-Schmidt for an uncountable collection before, <del>but it might be handy</del> (see below). In any case, this should definitely be a separate PR.</li>\n</ol>",
        "id": 277933235,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649187619
    },
    {
        "content": "<p>Actually, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I just realized why I've never worked with gram-schmidt for anything other than <code>‚Ñï</code>. It's because it isn't well-behaved. Take the ordinal <code>œâ + 1</code> and define <code>f : (œâ + 1) ‚Üí ‚Ñì¬≤(‚Ñï)</code> (sorry, I'm not too familiar with actual mathlib notation here) by setting <code>f n</code> to be the standard basis vector and then define the last vector to be any element of <code>‚Ñì¬≤(‚Ñï)</code> with infinite support. Then this collection will be linearly independent, but the last vector of the gram-schmidt process will be zero.</p>",
        "id": 277934202,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649188119
    },
    {
        "content": "<p>If you wanted it to behave nicely in greater generality, then the assumption shouldn't be that the collection is linearly independent, but that each vector is not in the closure of the span of the previous ones, but this condition is significantly less nice to work with.</p>",
        "id": 277934646,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649188375
    },
    {
        "content": "<p>Generalizing from <code>‚Ñï</code> to an encodable type would be nice if it's easy to do (I think it is but maybe there are surprises...). I think a Hilbert basis version can wait for a subsequent PR though!</p>",
        "id": 277935135,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1649188629
    },
    {
        "content": "<p>If nothing else, it would be nice if this were easy to use on <code>fin n</code></p>",
        "id": 277937610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649189733
    },
    {
        "content": "<p>Hello, I am wondering would that be possible for another PR to generalize a more general version?</p>",
        "id": 278468498,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649597795
    },
    {
        "content": "<p>Are you having trouble generalizing to an encodable type? If so, where are you having issues?</p>",
        "id": 278474423,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649605193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I am hitting trouble on a few questions. As suggested, I tried to generalize from N to an encodable type, but I have no idea on how to formalize following things : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">lemma</span> <span class=\"n\">span_gram_schmidt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">gram_schmidt</span> <span class=\"bp\">ùïú</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">Iic</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">Iic</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n <span class=\"kd\">lemma</span> <span class=\"n\">gram_schmidt_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h‚ÇÄ</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚àò</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)))</span> <span class=\"o\">:</span>  <span class=\"n\">gram_schmidt</span> <span class=\"bp\">ùïú</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>here is me new definition with encodable of gram schmidt : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">gram_schmidt_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"bp\">‚àë</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">orthogonal_projection</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"bp\">‚àô</span> <span class=\"n\">gram_schmidt_aux</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">i.prop</span><span class=\"o\">]}</span>\n\n<span class=\"sd\">/-- Gram-Schmidt process -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">gram_schmidt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span>\n  <span class=\"o\">:=</span> <span class=\"n\">gram_schmidt_aux</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(((</span><span class=\"n\">decode‚ÇÇ</span> <span class=\"n\">Œπ</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get_or_else</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">encode</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Could somebody give me any hints on that?</p>",
        "id": 278489668,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649624622
    },
    {
        "content": "<p>Read <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 278489917,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649624940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>  Thank you! better now :)</p>",
        "id": 278490007,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649625084
    },
    {
        "content": "<p>I think the way to go would be to define it for a type with a linear order, so that not much changes in the actual code. The well-foundedness proof might then need extra stuff like encodability but hopefully that's it.</p>",
        "id": 278490790,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1649626155
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"471791\">@Jiale Miao</span> Let us know how it goes. Otherwise we can just focus on the current version, and do tweaks and generalizations on a follow-up PR.</p>",
        "id": 278518416,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1649663367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thank you!  I am currently working on generalizing from N to an encodable type as suggested. But I feel unapproachable when I tried to deal with questions above and also some reviewers suggested other possible like well order or linear order, so I am not sure what's going on next?</p>",
        "id": 278521669,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649665644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span>  Thank you for your suggestions! I will try to use the definition of  <code>gram_schmidt</code>in a linear order and see how it's going.</p>",
        "id": 278522549,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649666089
    },
    {
        "content": "<p>Could someone give me any hints on definition of gram-schmidt with linear order here? <br>\nI tried to use suggestion above : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Gram-Schmidt process -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">gram_schmidt</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">orthogonal_projection</span>\n    <span class=\"o\">(</span><span class=\"n\">submodule.span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">$</span> <span class=\"n\">gram_schmidt</span> <span class=\"bp\">‚àò</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">I</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">i.2</span><span class=\"o\">]}</span>\n</code></pre></div>\n<p>but I don't know how to deal with completeness here :(<br>\nAlso, do I replace the old version with this new definition or I keep both two here?</p>",
        "id": 278565746,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649688940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"471791\">@Jiale Miao</span> give me until the end of the day to try and outline the ideas. I'm not feeling the best, so I won't be able to get to it until later. I know there was a lot that was originally suggested, but then we decided that most of it should wait until later (if we do it at all). I will make clear exactly what the goal is.</p>",
        "id": 278577975,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649693730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  Thank you for your reply! I do feel a little confused with what should I go next here.  :-)</p>",
        "id": 278579182,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649694275
    },
    {
        "content": "<p>I might have some time to look at this tomorrow</p>",
        "id": 278579225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649694298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  Thank you! :-)</p>",
        "id": 278579476,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649694414
    },
    {
        "content": "<p>Waiting for some suggestions here... <span aria-label=\"robot\" class=\"emoji emoji-1f916\" role=\"img\" title=\"robot\">:robot:</span></p>",
        "id": 278697540,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649772408
    },
    {
        "content": "<p>Sorry, I was feeling too bad to get anything done yesterday. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> When I sat down to do this today I realized that I think we might have some useful API missing for encodable types. In particular, while I know we don't want a <code>has_well_founded</code> instance for encdoable types, it might be nice to pull back the natural well order on ‚Ñï vie the <code>encode</code> map. I saw <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure\">docs#measure</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_wf\">docs#measure_wf</a>, but it would be nice if there were a bit more API around it. For example, if <code>Œπ</code> is encodable, and <code>n : Œπ</code>, it would be nice if we had <code>{i : Œπ | i &lt; n}</code> as a finset, where <code>&lt;</code> is the pullback. Am I missing this API, or does it just not exist? If it doesn't, is there are reason, or should I develop it?</p>",
        "id": 278698244,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649772736
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.Iio\">docs#finset.Iio</a></p>",
        "id": 278698458,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649772843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>, encodable types aren't locally finite though right?</p>",
        "id": 278698637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649772923
    },
    {
        "content": "<p>Unless they have an <code>le</code> that agrees with their encoding</p>",
        "id": 278698676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649772936
    },
    {
        "content": "<p>They should be under the pullback order, right?</p>",
        "id": 278698686,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649772941
    },
    {
        "content": "<p>Yeah, exactly</p>",
        "id": 278698688,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649772942
    },
    {
        "content": "<p>Is <code>[linear_order I] [locally_finite I]</code> the generalization we want?</p>",
        "id": 278698806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649772971
    },
    {
        "content": "<p>I don't think we need that. All we want to do is pullback the order from ‚Ñï. (not for all encodable types, just locally for this gram-schmidt)</p>",
        "id": 278698880,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773009
    },
    {
        "content": "<p>I think all we care about is <code>‚Ñï</code> and <code>fin n</code>, really</p>",
        "id": 278698916,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773032
    },
    {
        "content": "<p>Sure, but it sounds like right now we're leaning towards <code>encodable I</code>?</p>",
        "id": 278698956,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649773049
    },
    {
        "content": "<p>In my opinion <code>[linear_order I] [locally_finite I]</code> is nicer, because it uses the \"obvious\" order on the type</p>",
        "id": 278699019,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649773077
    },
    {
        "content": "<p>And you can always turn <code>encodable I</code> into those typeclasses by applying the pullback order</p>",
        "id": 278699103,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649773099
    },
    {
        "content": "<p>What about <code>Œ± \\hookright ‚Ñï</code>?</p>",
        "id": 278699119,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773107
    },
    {
        "content": "<p>That way, you can control the order in which orthogonalisation happens.</p>",
        "id": 278699191,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , don't we still need a well-order so that we can define the gram-schmidt process by induction?</p>",
        "id": 278699215,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773154
    },
    {
        "content": "<p>Ah, you need <code>order_bot I</code> too</p>",
        "id": 278699411,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649773224
    },
    {
        "content": "<p>I believe that's still not what you want, because ordinals aren't locally finite.</p>",
        "id": 278699547,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773295
    },
    {
        "content": "<p><del>I think this wouldn't work for <code>fin n</code> because we don't have these type classes, right?</del></p>",
        "id": 278699562,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312857.20Gram-Schmidt.20Ortho/near/278699547\">said</a>:</p>\n<blockquote>\n<p>I believe that's still not what you want, because ordinals aren't locally finite.</p>\n</blockquote>\n<p>But they're encodable? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.encodable\">docs#ordinal.encodable</a><br>\nThat doesn't sound right to me</p>",
        "id": 278699676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649773345
    },
    {
        "content": "<p>That link doesn't work</p>",
        "id": 278699775,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773390
    },
    {
        "content": "<p>Are they?</p>",
        "id": 278699797,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773401
    },
    {
        "content": "<p>Only certain ordinals should be encodable.</p>",
        "id": 278699803,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773406
    },
    {
        "content": "<p>We do not mean ordinals, we mean <code>ordinal</code>, Jireh.</p>",
        "id": 278699862,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312857.20Gram-Schmidt.20Ortho/near/278699547\">said</a>:</p>\n<blockquote>\n<p>I believe that's still not what you want, because ordinals aren't locally finite.</p>\n</blockquote>\n<p>I have no idea what you mean by this</p>",
        "id": 278699912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649773443
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>œâ</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, \\omega]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œâ</span><span class=\"mclose\">]</span></span></span></span> is infinite.</p>",
        "id": 278699967,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773475
    },
    {
        "content": "<p>But can't <code>ordinal</code> still be uncountable? So there can't be an encoding?</p>",
        "id": 278700097,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773542
    },
    {
        "content": "<p>Yeah, my point was that it failed even more badly <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 278700199,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649773584
    },
    {
        "content": "<p>Gram-Schmidt does not apply to omega+1 right? You can't take the limit at the limit ordinal. Is there any example of a situation where G-S does something meaningful which isn't fin n or nat? Or am I missing something?</p>",
        "id": 278701181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649773977
    },
    {
        "content": "<p>FYI: <code>fin n</code> does not have an <code>order_bot</code> instance. I guess this is just an oversight.</p>",
        "id": 278701225,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649773997
    },
    {
        "content": "<p>Maybe fin 0 has no bot ;-)</p>",
        "id": 278701268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649774017
    },
    {
        "content": "<p><code>fin (n + 1)</code> does!</p>",
        "id": 278701280,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649774025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, right, I gave this example a while ago. In order for it to do something interesting you don't need linear independence, you need the stronger condition that each vector is not in the closure of the span of the previous ones (and you need a complete space). That's why we're restricting to things like encodable types.</p>",
        "id": 278701465,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649774093
    },
    {
        "content": "<p>Here's the version I was thinking of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">locally_finite_order.to_has_well_founded</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_bot</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">locally_finite_order</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_well_founded</span> <span class=\"n\">Œπ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">),</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">convert</span> <span class=\"n\">measure_wf</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset.Iic</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">measure</span><span class=\"o\">,</span> <span class=\"n\">inv_image</span><span class=\"o\">],</span>\n    <span class=\"gr\">sorry</span> <span class=\"c1\">-- a &lt; b ‚Üî (finset.Iic a).card &lt; (finset.Iic b).card</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n\n<span class=\"sd\">/-- Gram-Schmidt process -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">gram_schmidt</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_bot</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">locally_finite_order</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"bp\">‚àë</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset.Iio</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"o\">,</span> <span class=\"n\">orthogonal_projection</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"bp\">‚àô</span> <span class=\"n\">gram_schmidt</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">finset.mem_Iio.mp</span> <span class=\"n\">i.prop</span><span class=\"o\">]}</span>\n</code></pre></div>",
        "id": 278701920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649774295
    },
    {
        "content": "<p>I guess this doesn't work for <code>fin 0</code> though</p>",
        "id": 278701994,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649774340
    },
    {
        "content": "<p>But I guess we don't care about <code>fin 0</code>.</p>",
        "id": 278702067,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649774378
    },
    {
        "content": "<p>I think we do care, after all 0-dimensional vector spaces are perfectly reasonable.</p>",
        "id": 278702250,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649774438
    },
    {
        "content": "<p>Do we have a propositional version of <code>order_bot</code> that is true on <code>empty</code>? \"does not have multiple bottom elements\"</p>",
        "id": 278702321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649774470
    },
    {
        "content": "<p>Reid, sure, but why would you ever apply Gram-Schmidt in such a situation? You don't even have linearly independent vectors?</p>",
        "id": 278702418,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649774517
    },
    {
        "content": "<p>Isn't <code>{}</code> a set of linearly independent vectors in 0D?</p>",
        "id": 278702514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649774544
    },
    {
        "content": "<p>Hmm... <code>is_empty (no_bot_order Œ±)</code> or something?</p>",
        "id": 278702527,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649774548
    },
    {
        "content": "<p>I just want to remark that one reason for this work is that G-S is on the undergraduate to-do list and a few people are realising that actually clearing this list, random though it is, is going to be a milestone. Jiale is a first year undergraduate at Imperial and I just want to make sure that this attempt to generalise the result out of the park doesn't end up with a result of 0 PRs and someone having to go back to the drawing board later.</p>",
        "id": 278702682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649774627
    },
    {
        "content": "<p>Kevin, understood. We'll definitely get it working soon, we really only want ‚Ñï and <code>fin n</code>.</p>",
        "id": 278702817,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649774677
    },
    {
        "content": "<p>I think being able to support <code>lex (prod (fin n) (fin m))</code> would also be nice, but certainly less important</p>",
        "id": 278703389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649774900
    },
    {
        "content": "<p>Maybe \"care\" is a bit of a strong word, but for uniformity it would be preferable to have statements like e.g. \"every fin-dim inner product space has an orthonormal basis\"</p>",
        "id": 278703587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649775001
    },
    {
        "content": "<p>We already have that statement elsewhere, <del>I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_orthogonal_basis\">docs#exists_orthogonal_basis</a></del> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/std_orthonormal_basis\">docs#std_orthonormal_basis</a></p>",
        "id": 278703653,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649775016
    },
    {
        "content": "<p>OK, pick some other use in that case</p>",
        "id": 278703685,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649775033
    },
    {
        "content": "<p>Maybe it would be best to keep only the nat version  for now, and focus our review efforts on simplifying the existing proofs. Generalizing will be easier later if the proofs are shorter</p>",
        "id": 278703709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649775049
    },
    {
        "content": "<p>To me, the biggest concern is that surely we must be duplicating most of the proof for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/std_orthonormal_basis\">docs#std_orthonormal_basis</a>, and that therefore we ought to be able to reuse some lemmas used to prove that (or vice versa)</p>",
        "id": 278704493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649775351
    },
    {
        "content": "<p>I don't think so. This proof goes by way of constructing maximal orthonormal sets containing a given orthonormal set.</p>",
        "id": 278705274,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649775624
    },
    {
        "content": "<p>The \"vice versa\" might apply though</p>",
        "id": 278705428,
        "sender_full_name": "Reid Barton",
        "timestamp": 1649775673
    },
    {
        "content": "<p>Even just the auxiliary steps in the proof which say \"And the new construction is still mutually orthogonal\" might be extractable to lemmas</p>",
        "id": 278705538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649775718
    },
    {
        "content": "<p>I'm just not yet convinced there's a close connection. The heart of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/std_orthonormal_basis\">docs#std_orthonormal_basis</a> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_maximal_orthonormal\">docs#exists_maximal_orthonormal</a>, which uses a Zorn argument. At no point is it doing anything like Gram-Schmidt. Of course, once we have Gram-Schmidt, yes, it would be possible to replace the proof of <code>std_orthonormal_basis</code>, but why would we?</p>\n<p>I'm not claiming that we shouldn't make the current PR as modular as possible. We should extract lemmas where appropriate. I'm just claiming that I don't think it's connected to <code>std_orthonormal_basis</code>.</p>",
        "id": 278707549,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649776454
    },
    {
        "content": "<p>Thanks all! I guess I could focus more on <code>N</code> and <code>fin n</code> and try to simplify the existing proofs now.  :)</p>",
        "id": 278744430,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649793030
    },
    {
        "content": "<p>Hello, may I ask someone to have a review on my code? I am trying to simplify the existing proof about span. But I couldn't get a good way to simplify my proof.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Gram-Schmidt process preserves span -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">span_gram_schmidt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">gram_schmidt</span> <span class=\"bp\">ùïú</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">Iic</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">Iic</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> suggested using a lemma like <code>Iic n.succ = insert n.succ (Iic n)</code> but I am not sure how to work with it. :(</p>",
        "id": 278883470,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649880610
    },
    {
        "content": "<p>Your proof worked by jnducting on <code>c</code>; my thinking was that that lemma combined with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.span_insert\">docs#submodule.span_insert</a> lets you easily apply your inductive hypothesis, and your left with only a bit of cleanup</p>",
        "id": 278883954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649880847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  sorry I am a bit confused since I saw <code>span_insert</code> working on forms like <code>span R (insert x s)</code>, but in my proof either it's like <code>span ùïú (f ''  insert c.succ (Iic c)) </code> or like <code>span ùïú (gram_schmidt ùïú f ''  insert c.succ (Iic c))</code>.</p>",
        "id": 278885918,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649881822
    },
    {
        "content": "<p><del>docs#set.image_insert</del></p>",
        "id": 278885952,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649881842
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.image_insert_eq\">docs#set.image_insert_eq</a></p>",
        "id": 278885960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649881848
    },
    {
        "content": "<p>Arf! Point for Eric</p>",
        "id": 278886001,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649881867
    },
    {
        "content": "<p>I only know that one because I started trying to prove it myself</p>",
        "id": 278886082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649881913
    },
    {
        "content": "<p>Probably that lemma should be renamed to match <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.image_insert\">docs#finset.image_insert</a></p>",
        "id": 278886241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649881971
    },
    {
        "content": "<p>Yeah, that's the one I know by heart.</p>",
        "id": 278886257,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649881983
    },
    {
        "content": "<p>But that rename is not in scope for Gram-schmidt obviously</p>",
        "id": 278886281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649882003
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  Thank you! I applied that lemma and it makes proof much clearer. May I ask how to deal with the lemma you given?  Do I wait it until being merged first or do I write something like that in my proof and wait for improvement later?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"bp\">....</span>\n<span class=\"kd\">begin</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Iic</span> <span class=\"n\">c.succ</span> <span class=\"bp\">=</span> <span class=\"n\">insert</span> <span class=\"n\">c.succ</span> <span class=\"o\">(</span><span class=\"n\">Iic</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 278896124,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649886891
    },
    {
        "content": "<p>That looks reasonable to me. <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>, is your PR adding that entire family of lemmas imminent, or should we just add that one for now?</p>",
        "id": 278925623,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649915435
    },
    {
        "content": "<p>May I ask for someone to have a review on my code?  (Waiting for 100th conversation :) )</p>",
        "id": 278994103,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1649956388
    },
    {
        "content": "<p>Could anyone look at this PR again? I have (or I think) tried my best to simplify the proof and it looks much better now :)</p>",
        "id": 279189299,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1650147857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"471791\">@Jiale Miao</span>, there you have it! <a href=\"https://github.com/leanprover-community/mathlib/pull/13486\">#13486</a></p>",
        "id": 279223889,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1650205417
    },
    {
        "content": "<p>Could anyone have a look on this PR? I have added Yael‚Äôs lemma into my codeüòÉ</p>",
        "id": 279436862,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1650387037
    },
    {
        "content": "<p>Thank you all! I have fixed them :)</p>",
        "id": 279515234,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1650444869
    },
    {
        "content": "<p>Cool! If CI is happy, let's kick this on the merge queue! I gave you the permission to do this yourself after the PR has a green checkmark.</p>",
        "id": 279515458,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650445009
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 279515751,
        "sender_full_name": "Jiale Miao",
        "timestamp": 1650445195
    }
]
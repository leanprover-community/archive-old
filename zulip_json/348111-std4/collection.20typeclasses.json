[
    {
        "content": "<p>Looking for feedback on adding a few collections typeclasses from LeanColls that I've found useful for writing code operating on collections.</p>\n<p>The first typeclasses are to do with fundamental basic operations on collections:</p>\n<ul>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L67\"><code>Foldable</code></a> (perhaps <code>Fold</code>?) for colls which have a folding function/internal iterator</li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L45\"><code>Iterable</code></a> for colls which can be externally iterated over (e.g. an iterator with a step function)</li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L107\"><code>Enumerable</code></a> for colls which can be constructed one element at a time</li>\n</ul>\n<p>Some more for common types of collections:</p>\n<ul>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L151\"><code>Indexed</code></a> for colls which have efficient indexed <code>get</code>/<code>nth</code> functions</li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L161\"><code>Initable</code></a> for colls efficiently constructable from a <code>Fin n -&gt; A</code> initialization function</li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L133\"><code>SetLike</code></a> for types isomorphic to <code>A -&gt; Bool</code></li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L141\"><code>MapLike</code></a> for types isomorphic to <code>A -&gt; Option B</code></li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Queue.lean#L13\"><code>Queue</code></a> for LIFO/FIFO queues (somewhat outdated)</li>\n</ul>\n<p>And then there's a few classes for implementations of common collection operations</p>\n<ul>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/FoldableOps.lean#L14\"><code>FoldableOps</code></a> for operations implementable on any <code>Foldable</code></li>\n<li><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/IndexedOps.lean\"><code>IndexedOps</code></a> for operations efficiently implementable on any <code>Iterable</code></li>\n</ul>",
        "id": 302347079,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664917530
    },
    {
        "content": "<p>I have a similar set of typeclasses for development of SciLean. My main interest is working with collections that are multidimensional arrays, it is interesting to see how it reflects in different design choices.</p>\n<p>The most prominent are:</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Mathlib/Data/Iterable.lean#L7\"><code>Iterable</code></a> - I think yours is better as it gives extra flexibility with iterator</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Mathlib/Data/Enumtype.lean#L5\"><code>Enumtype</code></a> - type with an explicit isomorphism with <code>Fin n</code>. This one I use all over the place.</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/FunType/Basic.lean#L7\"><code>SetElem</code></a> - accompanying buildin  <code>GetElem</code> class</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/FunType/Basic.lean#L91\"><code>HasIntro</code></a> - similar to yours <code>Initiable</code> but allows for arbitrary index type and carries lawfulness proof.</p>\n<hr>\n<p>Fee comments to yours:</p>\n<ol>\n<li>I like the use of iterator in <code>Iterable</code>. </li>\n<li>I'm a bit confused that by default <code>Foldable</code> implies <code>Iterable</code>, plus through construction intermediate <code>List</code> which can be performance footgun. Wouldn't you accidentally convert <code>Array</code>, or even worse <code>FloatArray</code>, to <code>List</code>?</li>\n<li><code>Indexed</code> and <code>Initiable</code> should use a generic type instead of <code>Fin n</code> for the index type</li>\n<li><code>MapLike</code> should align with buildin <code>a[i]?</code> notation</li>\n</ol>\n<hr>\n<p>In general, it would be great to converge to a certain set of these classes and add them to std4.</p>\n<p>Also how should we approach lawfulness? Should we define <code>Lawful***</code> version of all of these? Or define <code>***.Correct</code> class?</p>\n<p>I actually always want the lawful version of these. Is there a good example when you do not want lawful version? (That you do not want to provide proof does not count as you can always sorry it and at least document your intention that way)</p>",
        "id": 302389779,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664948673
    },
    {
        "content": "<p>Feedback very appreciated, I'm gonna clone scilean and play around with it!</p>",
        "id": 302391489,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664949803
    },
    {
        "content": "<p>Also another class of interest might be:</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/DataArray/PlainDataType.lean#L37\"><code>PlainDataType</code></a> - type that allows for conversion from/to byte(s). This allows to define <code>DataArray α</code> with appropriate bit compatification, thus <code>DataArray Bool</code> is bit array or <code>DataArray  (Fin 8 × Fin 4 × Fin 3)</code> consumes one byte per element.</p>",
        "id": 302391827,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664949966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302389779\">said</a>:</p>\n<blockquote>\n<p>I'm a bit confused that by default Foldable implies Iterable, plus through construction intermediate List which can be performance footgun. Wouldn't you accidentally convert Array, or even worse FloatArray, to List?</p>\n</blockquote>\n<p>Yeah, you definitely could end up with bad performance if you're not careful. All of the collections in LeanColls that have faster <code>Iterable</code> implementations do override it. I wasn't sure whether to explicitly extend it or not, since most users aren't going to be declaring their own <code>Iterable</code>.</p>\n<p>What I did with the <code>*Ops</code> typeclasses was to provide a default implementation given the minimum implementable subset, and then I explicitly said <code>instance : *Ops A := default</code> for collections where the default was what I wanted. Perhaps we do the same with Iterable.</p>",
        "id": 302393054,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664950757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302389779\">said</a>:</p>\n<blockquote>\n<p>Also how should we approach lawfulness? Should we define <code>Lawful***</code> version of all of these? Or define <code>***.Correct</code> class?</p>\n</blockquote>\n<p>I don't know much about Lean typeclass best practices, I'm not really sure what the difference is. for <code>Foldable</code>, the only \"law\" I have is that they abide parametricity, which is a relatively weak result but enough to let me write some theorems generic over folds :D</p>",
        "id": 302393396,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664951034
    },
    {
        "content": "<p>I think when it comes to \"lawfulness\" these classes usually interact in pairs. For example <code>Initiable</code> with <code>GetElem</code> or with <code>Size</code>. I'm not sure how to structure this. For example I have <a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/PowType/Basic.lean#L10\"><code>PowType</code></a> (for types <code>X^I</code> that are morally <code>I -&gt; X</code>) that bundles get/set/init and that they interact together, but I'm not sure if that is the best approach.</p>",
        "id": 302394239,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664951523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302393054\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302389779\">said</a>:</p>\n<blockquote>\n<p>I'm a bit confused that by default Foldable implies Iterable, plus through construction intermediate List which can be performance footgun. Wouldn't you accidentally convert Array, or even worse FloatArray, to List?</p>\n</blockquote>\n<p>Yeah, you definitely could end up with bad performance if you're not careful. All of the collections in LeanColls that have faster <code>Iterable</code> implementations do override it. I wasn't sure whether to explicitly extend it or not, since most users aren't going to be declaring their own <code>Iterable</code>.</p>\n<p>What I did with the <code>*Ops</code> typeclasses was to provide a default implementation given the minimum implementable subset, and then I explicitly said <code>instance : *Ops A := default</code> for collections where the default was what I wanted. Perhaps we do the same with Iterable.</p>\n</blockquote>\n<p>I'm actually a quite confused by your <code>Foldable</code> class. Every <code>Iterable</code> can be <code>Foldable</code>, no? Is there an instance for it? You have the reverse, which I find a bit questionable and dangerous.</p>",
        "id": 302394617,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664951723
    },
    {
        "content": "<p>Not every <code>Iterable</code> can be <code>Foldable</code>. Folding is guaranteed to be finite, whereas iteration can be infinite. The corresponding built-in classes are <code>ForIn</code> (for fold) and <code>Stream</code> (for Iterable)</p>",
        "id": 302394850,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664951839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302394239\">said</a>:</p>\n<blockquote>\n<p>I think when it comes to \"lawfulness\" these classes usually interact in pairs. For example <code>Initiable</code> with <code>GetElem</code> or with <code>Size</code>. I'm not sure how to structure this. For example I have <a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/PowType/Basic.lean#L10\"><code>PowType</code></a> (for types <code>X^I</code> that are morally <code>I -&gt; X</code>) that bundles get/set/init and that they interact together, but I'm not sure if that is the best approach.</p>\n</blockquote>\n<p>I see... hm. I'm not sure either. My suspicion is that nearly all lawfulness results in collection-world can be stated relative to <code>get</code> (most of my collections in LeanColls have loads of results of this form, but I haven't tried to make a typeclass for that yet...)</p>",
        "id": 302395069,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664951973
    },
    {
        "content": "<p>Relevant: I'm a bit surprised by <code>FunType</code> including an extensionality requirement. It seems a bit overly restrictive, since there's tons of collections that don't have canonical forms. We could quotient by the equivalence relation of being equal on all elements, but it seems better to just always state correctness relative to <code>get</code>?</p>",
        "id": 302395333,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664952132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302394850\">said</a>:</p>\n<blockquote>\n<p>Not every <code>Iterable</code> can be <code>Foldable</code>. Folding is guaranteed to be finite, whereas iteration can be infinite. The corresponding built-in classes are <code>ForIn</code> (for fold) and <code>Stream</code> (for Iterable)</p>\n</blockquote>\n<p>Ahh makes total sense. Well I would also suggest to maybe get ready to be aligned with mathlib. There is <code>finite</code> which should imply finite termination of iteration. Thus maybe <code>Foldable</code> should be <code>Iterable</code> + <code>finite</code> ?</p>",
        "id": 302395544,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664952262
    },
    {
        "content": "<p>I'm a bit hesitant to prefer Iterable over Foldable as the default iteration class; Rust had a big back and forth between internal/external iterators and ended up settling on internal iteration as preferred, because it tended to produce faster bytecode. I suspect (but have not measured this) that the same is true in Lean, but maybe I should test that hypothesis <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 302395801,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664952431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302395333\">said</a>:</p>\n<blockquote>\n<p>Relevant: I'm a bit surprised by <code>FunType</code> including an extensionality requirement. It seems a bit overly restrictive, since there's tons of collections that don't have canonical forms. We could quotient by the equivalence relation of being equal on all elements, but it seems better to just always state correctness relative to <code>get</code>?</p>\n</blockquote>\n<p>You are probably right that it is too restrictive in general. All I care about right now are multi-dimensional array like types and really want them to form algebraic structures. So for example there should be only one zero matrix, the one with zero elements.</p>",
        "id": 302396056,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664952590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302395801\">said</a>:</p>\n<blockquote>\n<p>I'm a bit hesitant to prefer Iterable over Foldable as the default iteration class; Rust had a big back and forth between internal/external iterators and ended up settling on internal iteration as preferred, because it tended to produce faster bytecode. I suspect (but have not measured this) that the same is true in Lean, but maybe I should test that hypothesis <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>\n</blockquote>\n<p>Ohh I see, then it is a definitely good idea to keep them separate if they have different performance behavior. I think testing performance right now, as the compiler is undergoing massive changes, is not going to be really indicative.</p>",
        "id": 302396353,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664952734
    },
    {
        "content": "<p>This makes complete sense -- then there's definitely a use case for a typeclass of <code>GetElem</code> with extensionality.</p>\n<p>Naming these typeclasses is going to be a nightmare <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> maybe something like <code>LawfulGetExt</code> for the extensionality law.</p>",
        "id": 302396473,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664952803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302396353\">said</a>:</p>\n<blockquote>\n<p>I think testing performance right now, as the compiler is undergoing massive changes, is not going to be really indicative.</p>\n</blockquote>\n<p>Yeah... I'm waiting until at least after the new code generator is done. It's the main reason I haven't been doing any performance testing yet. :/ but I think we can nail down a solid user interface before even thinking about (constant factor) performance</p>",
        "id": 302396729,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664952934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> do you have a built-in range class for iterating over the elements of <code>Fin n</code>? I've done a bit of work on making a <code>Range</code> iterator that works for common array stuff, and I'm assuming SciLean has something similar</p>",
        "id": 302397164,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664953117
    },
    {
        "content": "<p>To iterate over <code>Enumtype ι</code> (i.e.  <code>ι</code> isomoprhic to <code>Fin n</code>) I use <a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Mathlib/Data/Enumtype.lean#L176\"><code>forIn</code> notation</a></p>\n<p>Example of creating 3x3 identity matrix we will iterate over all <code>Fin 3 × Fin 3</code>  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"o\">((</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"n\">li</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">Enumtype.fullRange</span> <span class=\"n\">a.Index</span> <span class=\"k\">do</span>\n    <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">li</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n  <span class=\"n\">a</span>\n</code></pre></div>\n<p>The <code>forIn</code> notation gives you <code>(id, ld) : ι × (Fin (numOf ι))</code>, <code>id</code> is the structure index and <code>li</code> is linear index that actually corresponds how the matrix is stored in memory and you can use both indices to access matrix elements, <code>a[id]</code>, <code>a[li]</code> of if <code>id = (i,j)</code> you can write <code>a[i,j]</code>.</p>\n<p>(right now on github <code>li</code> is <code>Nat</code> but I have recently changed it to <code>Fin</code>)</p>",
        "id": 302398805,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664953946
    },
    {
        "content": "<p>Also have you considered using <a href=\"https://en.wikipedia.org/wiki/Zipper_(data_structure)#:~:text=A%20zipper%20is%20a%20technique,by%20G%C3%A9rard%20Huet%20in%201997.\">zipper</a> for modifying lists and trees? Or do you already have it?</p>",
        "id": 302403118,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664955975
    },
    {
        "content": "<p>I'd consider it a separate data structure. Didn't have a use case for it yet so I didn't implement anything on it. If we want generic, fast, persistent sequences, there's some radix-tree stuff I've been working on implementing in Lean that should cover those use cases!</p>",
        "id": 302406499,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664957249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302398805\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"o\">((</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"n\">li</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">Enumtype.fullRange</span> <span class=\"n\">a.Index</span> <span class=\"k\">do</span>\n    <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">li</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n  <span class=\"n\">a</span>\n</code></pre></div>\n<p>The <code>forIn</code> notation gives you <code>(id, ld) : ι × (Fin (numOf ι))</code>, <code>id</code> is the structure index and <code>li</code> is linear index that actually corresponds how the matrix is stored in memory and you can use both indices to access matrix elements, <code>a[id]</code>, <code>a[li]</code> of if <code>id = (i,j)</code> you can write <code>a[i,j]</code>.</p>\n</blockquote>\n<p>This is really interesting. Is there a huge cost to actually doing the indexing calculation at each iteration of the loop? I know most c compilers can optimize those kinds of calculations in loops, and it feels a bit not-ergonomic for the user to not write <code>[i,j]</code> everywhere</p>",
        "id": 302406910,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664957431
    },
    {
        "content": "<p>I agree that it is not the most ergonometric thing. In the future, my hope is to add some optimization pass that replaces <code>a[i,j]</code> with <code>a[li]</code>. </p>\n<p>I have no clue if the conversion adds some cost but it might and dealing with it looked like an interesting problem :) </p>\n<p>The conversion between structured and linear index can be somewhat complicated. For example, I deal with 3d regular grids and when I loop over all edges of the grid, the structured index holds info if the edge is X, Y or Z aligned and it's coordinates. Once I start doing finite element analysis over this grid it will get even more complicated.</p>",
        "id": 302411369,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664959137
    },
    {
        "content": "<p>Oh boy............</p>\n<p>Is there a good reason to linearize stuff like that? I'd naively have just stored the X, Y, and Z edges as 3 separate 3-dim arrays.</p>",
        "id": 302413219,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664959806
    },
    {
        "content": "<p>Of course, if you have some data stored on every edge and this data satisfies some linear system. Then you need to build the corresponding matrix, thus you need linear index.</p>\n<p>With finite element method this gets even more complicated, you have some data on points, some data on edges, faces and cells. They all interact through one big linear system. Thus you need linear index for the union of points, edges, faces and cells. This is actually the major pain in the ass in implementing finite element analysis and I'm soo happy to use Lean because it allows me to abstract all this annoyance away.</p>",
        "id": 302417374,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1664961460
    },
    {
        "content": "<p>I'm looking to add an API for fixed-length arrays, any gripes with the name <code>ArrayN</code>? Inspired from <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>'s <a href=\"https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/ArrayN.lean\"><code>ArrayN</code></a></p>",
        "id": 306041897,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1666708342
    },
    {
        "content": "<p>I think a good way to structure the laws is in terms of multiset operations, since collections are, well, collections.  I think the fundamental concept here is multiplicity (the number of a given item in a collection).  From this, you can define membership, set operations like  union, intersection, etc, correctness for iterators, etc.  I think this is more fundamental than iteration and especially folding.</p>",
        "id": 318996458,
        "sender_full_name": "Michael George",
        "timestamp": 1672667602
    },
    {
        "content": "<p>Regarding lawfulness, one example of a potentially non-lawful data structure would be something like a Bloom filter, although that's arguably not a collection.  AFAICT the choice of whether to provide \"non-lawful\" instances seems to vary for different parts of the library.  For example, if I understand correctly, the algebraic hierarchy largely bundles the laws with the structures so that you can't have a group that doesn't follow the group law, while there is a distinction between <code>Monad</code> and <code>LawfulMonad</code>.  I'm not sure if there's a good reason for this other than mathematicians are used to thinking more about the laws first and the implementations second while programmers are used to thinking more about the implementations first and the laws second.</p>",
        "id": 318997780,
        "sender_full_name": "Michael George",
        "timestamp": 1672668117
    },
    {
        "content": "<p>Regarding naming, I wonder if there is benefit in designing a <code>Lawful</code> class, with curried instances like <code>Lawful SortedSet</code>, <code>Lawful PriorityQueue</code>, <code>Lawful Dictionary</code> etc.  I haven't thought carefully enough about exactly how the dependent types would work out here; my gut says it would be possible but probably not trivial to figure out the right type for <code>Lawful</code>.  It's also not clear to me whether this provides benefit.  It is maybe better to just bundle lawfulness axioms, so that instances of the corresponding classes are all lawful.  I think using notation typeclasses allows for unlawful instances.</p>",
        "id": 318998330,
        "sender_full_name": "Michael George",
        "timestamp": 1672668353
    },
    {
        "content": "<p>You definitely could make a universe-polymorphic <code>Lawful</code> typeclass but I think the universe inference algorithm would quickly become unable to guess the right universes for everything <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> but that's orthogonal to the typeclass design</p>\n<p>I definitely should have split out lawful classes; it's quite nice to have the separation between implementation and laws when developing the library, so we don't feel like we need to prove the laws for each implementation when implementing it...</p>",
        "id": 319031156,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672680824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"568451\">@Michael George</span> was interested in meeting to discuss collection design stuff, would anyone else want to join a ~1hr meeting?</p>\n<p>I want to discuss</p>\n<ul>\n<li>Naming conventions</li>\n<li>Goal list for interfaces</li>\n<li>Goal list for implementations</li>\n<li>Top-level class hierarchy</li>\n</ul>\n<p>If interested, add your availability here: <a href=\"https://www.when2meet.com/?18110122-sgZI3\">https://www.when2meet.com/?18110122-sgZI3</a></p>",
        "id": 319032909,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672681679
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> pinging you because this might be of interest, and I'd appreciate your input!)</p>",
        "id": 319033558,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672681988
    },
    {
        "content": "<p>I'll put together a doc with agenda &amp; summary of what SciLean/LeanColls/Std4 have right now</p>",
        "id": 319033781,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672682100
    },
    {
        "content": "<p><strong>The mathematical model</strong>. I definitely agree that the mathematical model for collections should be something like lists up to permutation. One question which isn't entirely answered is whether to use lists up to permutation literally, or take the quotient and use multisets. So far I only attempted the former approach which worked out fine most of the time, except that proofs using permutations are really ugly because Lean doesn't (yet?) have <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations\">generalized rewriting</a> so we must construct them by hand, like <a href=\"https://github.com/leanprover/std4/pull/38/files#diff-0d3cf343ee463dee5554d064e98cad5a02e869266573118681bf6bba8ae687feR302\">here</a>. A quotient would turn this into normal rewriting by equality. It would be good to try it and see if things actually become easier or something else breaks; I haven't tried so far.</p>",
        "id": 319100962,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1672697947
    },
    {
        "content": "<p><strong>Laws vs implementations</strong>. I also agree that there should be a <code>Foldable</code> typeclass which just exposes the operations but doesn't contain any laws. This is convenient for programming - you don't <em>always</em> want to prove things correct. In mathematics you pretty much do - a group is lawful by definition; a (multiplicative) group without laws is not a group but rather something like <code>HasMul</code>+<code>HasOne</code>+<code>HasInv</code>. And then a <code>LawfulFoldable</code> which says that the <code>Foldable</code> instance is compatible with the (multiset or whatever) model. I am not seeing any benefit to having a generic <code>Lawful TypeClass</code> however. The laws are pretty specific to what <code>TypeClass</code> is, so there wouldn't be much you could do by parameterizing over <code>TypeClass</code>.</p>",
        "id": 319101369,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1672698227
    },
    {
        "content": "<p>It seems the same either way, we just call them <code>HasFold</code> and <code>Foldable</code> (mathlib convention) or <code>Foldable</code> and <code>LawfulFoldable</code> (std convention)</p>",
        "id": 319270474,
        "sender_full_name": "Michael George",
        "timestamp": 1672776111
    },
    {
        "content": "<p>Re modeling: Lists or quotients of lists feel very implementation focused, whereas multisets feel very interface / specification focused.  My gut says that the latter will lead to more natural definitions and proofs, but I don't have a lot of lean experience yet so there may be other conventions or considerations I'm not aware of.</p>",
        "id": 319271679,
        "sender_full_name": "Michael George",
        "timestamp": 1672776581
    },
    {
        "content": "<p>For example, the following seem very natural to me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The `HasMultiplicity` typeclass supports the `#(a ∈ S)` notation. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasMultiplicity</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `multiplicity a S` is the number of occurrences of `a` in `S`. -/</span>\n  <span class=\"n\">multiplicity</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">export</span> <span class=\"n\">HasMultiplicity</span> <span class=\"o\">(</span><span class=\"n\">multiplicity</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `#(a ∈ S)` gives the multiplicity of `a` in the multiset `S` -/</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\" #( \"</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">55</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"n\">S</span><span class=\"o\">:</span><span class=\"mi\">55</span> <span class=\"s2\">\" ) \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">multiplicity</span> <span class=\"n\">a</span> <span class=\"n\">S</span>\n\n\n<span class=\"sd\">/-- The standard definition of `⊆` in terms of multiplicity -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">LawfulMultiSubset</span> <span class=\"o\">[</span><span class=\"n\">HasMultiplicity</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSubset</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `S₁ ⊆ S₂` means every `a ∈ S₁` is also in `S₂` (counting multiplicity). -/</span>\n  <span class=\"n\">subset_defn</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">S₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S₁</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"o\">(</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The standard definition of `∪` in terms of multiplicity -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">LawfulMultiUnion</span> <span class=\"o\">[</span><span class=\"n\">HasMultiplicity</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Union</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `a ∈ S₁ ∪ S₂` means that `a ∈ S₁` or `a ∈ S₂` (counting multiplicity). -/</span>\n  <span class=\"n\">union_defn</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S₁</span> <span class=\"bp\">∪</span> <span class=\"n\">S₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S₁</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then operations like <code>insert</code> have natural laws:</p>\n<ul>\n<li><code>insert a S = S \\cup { a }</code></li>\n<li>for <code>poll</code>: <code>S = {fst (poll S)} ∪ snd (poll S)</code></li>\n</ul>",
        "id": 319272799,
        "sender_full_name": "Michael George",
        "timestamp": 1672777011
    },
    {
        "content": "<p>It does seem like multiplicity would be clean for describing a lot of collection operations. I haven't seen this used before in other formal languages, do you know if it has?</p>\n<p>Definitely worth trying out. I can't really visualize how this would shape the hierarchy, but we can talk about that when we meet!</p>\n<p>Speaking of which, it looks like Monday morning (EST) is when we are all the most free, so let's tentatively schedule for 11am EST</p>",
        "id": 319274327,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672777615
    },
    {
        "content": "<p>I don't know of other examples of this design.  This idea comes from trying to apply ideas that went into the design of the algebraic hierarchy to the problem of collections.</p>",
        "id": 319275117,
        "sender_full_name": "Michael George",
        "timestamp": 1672777911
    },
    {
        "content": "<p>one of the issues with using multiplicity-based characterizations of multisets, at least as far as the mathlib multiset formalization is concerned, is that it adds \"unnecessary\" <code>DecidableEq</code> assumptions to a lot of definitions and theorems, since you can't count the number of occurrences of <code>a</code> in a multiset unless the base type has decidable equality</p>",
        "id": 319286867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672783189
    },
    {
        "content": "<p>For a lot of data structures in std you don't really want to be using <code>DecidableEq</code> in the first place, because there is instead some equivalence relation implied by a <code>BEq</code> or <code>Ord</code> instance which the data structure is supposed to be using</p>",
        "id": 319287052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672783255
    },
    {
        "content": "<p>I see, you really want a sort of multisetoid.  I'm haven't yet learned how quotients work in lean so this is a little beyond my current understanding</p>",
        "id": 319290843,
        "sender_full_name": "Michael George",
        "timestamp": 1672784840
    },
    {
        "content": "<p>this is what <code>multiset</code> is in lean</p>",
        "id": 319291746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672785231
    },
    {
        "content": "<p>a multiset is a list-up-to-permutation, i.e. a quotient of <code>List A</code> by <code>List.Perm</code></p>",
        "id": 319291859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672785276
    },
    {
        "content": "<p>I was talking about the quotient of the set of elements by the equivalence defined by BEq.  That is, ‘multiplicity’ should satisfy ‘a == b’ implies ‘a’ and ‘b’ have the same multiplicity in ‘S’</p>",
        "id": 319296247,
        "sender_full_name": "Michael George",
        "timestamp": 1672787499
    },
    {
        "content": "<p>you can define that as a function on multisets, by having a function like <code>countP (f : A -&gt; Bool) (x : Multiset A)</code> which counts the number of elements of <code>x</code> satisfying <code>f</code></p>",
        "id": 319298883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672788901
    },
    {
        "content": "<p>where <code>f</code> is <code>(. == a)</code> for example</p>",
        "id": 319298930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672788923
    },
    {
        "content": "<p>I think there's some confusion because when I say \"multiset\" I'm talking about the concept of multiset, rather than a particular implementation.  The multiset I'm talking about should be a class, rather than a structure.  In the same way that a set is defined by the <code>\\in</code> relation, a multiset is defined by the <code>multiplicity</code> function.  I initially thought that <code>multiplicity</code> should have type <code>\\alpha \\to Nat</code>, but there's two problems with this.  The first, which you pointed out, is that the domain should really be the set of equivalence classes of <code>\\alpha</code> by some relation (which for our purposes should be decidable).  That's what I meant by \"multisetoid\".  The second is that the codomain should really be a (potentially infinite) cardinality, rather than a <code>Nat</code>.  This only matters for infinite data structures, but I guess those are useful.</p>\n<p>Probably the only requirement for the codomain is that it's a partial order, I haven't thought about it.  Probably something about decidability too.</p>",
        "id": 319416245,
        "sender_full_name": "Michael George",
        "timestamp": 1672847150
    },
    {
        "content": "<p>The reason I mention quotients is that I don't know how <code>(=)</code> is defined in lean; maybe it doesn't need to be baked into the interfaces for the data structures because you can already form quotients.  I think there's also some difference between how we're thinking of the equivalence relation; I'm thinking of both the equivalence relation on elements and the order as being part of the data structure definition, with a requirement that they are compatible, whereas it seems like you're suggesting that the order is not part of the data structure, but is rather extracted from the partial order (and the compatibility becomes a lemma rather than a field)</p>",
        "id": 319417322,
        "sender_full_name": "Michael George",
        "timestamp": 1672847494
    },
    {
        "content": "<p>(Needless to say I am a bit lost.......)</p>",
        "id": 319445805,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672856630
    },
    {
        "content": "<p>We can definitely flesh out both a model-based hierarchy and a property-based hierarchy and see what works out. Prove equivalences and such. Unless Mario et al are pretty confident it would be a pain to work with</p>",
        "id": 319446024,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672856692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> <span class=\"user-mention\" data-user-id=\"568451\">@Michael George</span> are you both still available for tomorrow at 11am? I think (?) this Jitsi link should work for then <a href=\"https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406\">https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406</a></p>",
        "id": 320129339,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673221131
    },
    {
        "content": "<p>Oh <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I see you on the when2meet too :) does that time work for you still?</p>",
        "id": 320129430,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673221194
    },
    {
        "content": "<p>I can't attend that time because it overlaps with the maintainer meeting. (Not sure if I was invited though. If you don't need me around feel free to ignore.)</p>",
        "id": 320130452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673222223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> did you see <a href=\"https://www.when2meet.com/?18110122-sgZI3\">https://www.when2meet.com/?18110122-sgZI3</a></p>",
        "id": 320133852,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1673225234
    },
    {
        "content": "<p>Oh, what time is that at? We can potentially schedule for another time...</p>",
        "id": 320135269,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673226451
    },
    {
        "content": "<p>11:30 EST</p>",
        "id": 320135345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673226494
    },
    {
        "content": "<p>I added my availability to that when2meet link</p>",
        "id": 320135559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673226698
    },
    {
        "content": "<p>We could do it during the std meeting on tuesday, although I'm thinking of cancelling regular meetings entirely because there isn't enough development / attendance to make it worthwhile</p>",
        "id": 320135679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673226814
    },
    {
        "content": "<p>Hrm, okay, let's shoot for 10:30 instead. I think an hour is plenty, but if we go over we go over</p>",
        "id": 320135773,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673226903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> <span class=\"user-mention\" data-user-id=\"568451\">@Michael George</span> <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> slightly revised meeting time -- 10:30am EST tomorrow!<br>\nJitsi link: <a href=\"https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406\">https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406</a></p>",
        "id": 320136124,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673227209
    },
    {
        "content": "<p>I'll have to move another meeting but I should be able to</p>",
        "id": 320136745,
        "sender_full_name": "Michael George",
        "timestamp": 1673227742
    },
    {
        "content": "<p>Sorry, I won't be able to join, I'm currently on a vacation.</p>",
        "id": 320239937,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1673274392
    },
    {
        "content": "<p>Sorry for missing the meeting. I didn't see the message before it was already to late. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 320454782,
        "sender_full_name": "Mac",
        "timestamp": 1673358611
    },
    {
        "content": "<p>No worries -- the main things we decided were (1) that ToList would be the model for all collections proofs (2) that implementations and users have very different expectations for the collections proof API (3) we can start experimenting with lawfulness classes, try to incorporate Wojciech's hashmap proofs and some of the LeanColls/SciLean stuff to see if a good lawfulness API emerges</p>",
        "id": 320506462,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673372379
    }
]
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/335062-homology/topic/Ideas.20for.20refactor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/335062-homology/index.html">homology</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html">Ideas for refactor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="296325171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296325171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296325171">(Aug 31 2022 at 13:31)</a>:</h4>
<p>Just a quick message to kick off the discussion concerning the impending refactor of chain complexes and homology.</p>
<p>What do people think about the following manuscript?<br>
<a href="https://arxiv.org/pdf/2208.13282.pdf">https://arxiv.org/pdf/2208.13282.pdf</a></p>



<a name="296326270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296326270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296326270">(Aug 31 2022 at 13:36)</a>:</h4>
<p>And the paper that this depends on: <a href="https://arxiv.org/abs/2101.06176">https://arxiv.org/abs/2101.06176</a></p>



<a name="296327250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296327250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296327250">(Aug 31 2022 at 13:41)</a>:</h4>
<p>Interesting. I couldn't find any discussion about "change of Q". Would this framework make it easy to "extend a complex by 0" or to restrict to a subcomplex (eg from <code>int</code>-indexed to <code>nat</code>-indexed)?</p>



<a name="296327792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296327792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296327792">(Aug 31 2022 at 13:44)</a>:</h4>
<p>presumably those would boil down to whiskering!</p>



<a name="296327841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296327841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296327841">(Aug 31 2022 at 13:44)</a>:</h4>
<p>for "restricting" I can believe that.</p>



<a name="296327868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296327868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296327868">(Aug 31 2022 at 13:44)</a>:</h4>
<p>But extending is less trivial, I think</p>



<a name="296328007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296328007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296328007">(Aug 31 2022 at 13:45)</a>:</h4>
<p>maybe extending is an adjoint of restricting?</p>



<a name="296329098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329098">(Aug 31 2022 at 13:51)</a>:</h4>
<p>not exactly</p>



<a name="296329267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329267">(Aug 31 2022 at 13:52)</a>:</h4>
<p>at least not with naive resticting/extending</p>



<a name="296329605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329605">(Aug 31 2022 at 13:54)</a>:</h4>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> be a nat-indexed cochain complex and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">X&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> its extension to a Z-cochain complex, and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Y&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> be any Z-cochain complex and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> its restriction to N. Is it not the case that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>Y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom(X,Y) = Hom(X&#x27;,Y&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>?</p>



<a name="296329659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329659">(Aug 31 2022 at 13:54)</a>:</h4>
<p>You need the square in indices <code>-1</code> and <code>0</code> to commute.</p>



<a name="296329711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329711">(Aug 31 2022 at 13:55)</a>:</h4>
<p>But the path via <code>X' _{-1}</code> is always <code>0</code>.</p>



<a name="296329736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329736">(Aug 31 2022 at 13:55)</a>:</h4>
<p>whereas the other one has no reason to be <code>0</code>.</p>



<a name="296329935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296329935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296329935">(Aug 31 2022 at 13:56)</a>:</h4>
<p>Other point: Those two papers are going full model category. They only ever talk about the homotopy category, but I didn't find a hands-on notion of homotopy between two complexes. I'm not sure what to make of that.</p>



<a name="296330075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330075">(Aug 31 2022 at 13:57)</a>:</h4>
<p>I'm confused. <code>X'_{-1}</code> is zero, so any map originating from it would be zero.</p>



<a name="296330276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330276">(Aug 31 2022 at 13:58)</a>:</h4>
<p>Ooh, maybe I want chain complexes</p>



<a name="296330339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330339">(Aug 31 2022 at 13:58)</a>:</h4>
<p>Or whatever. A little variation on this situation will cause a problem.</p>



<a name="296330629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330629">(Aug 31 2022 at 13:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">X_</span><span class="o">{</span><span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="c1">---&gt; X_0</span>
  <span class="bp">|</span>          <span class="bp">|</span>
  <span class="n">v</span>          <span class="n">v</span>
  <span class="mi">0</span> <span class="c1">------&gt; Y_0</span>
</code></pre></div>



<a name="296330752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330752">(Aug 31 2022 at 14:00)</a>:</h4>
<p>I'm extending X not Y</p>



<a name="296330858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330858">(Aug 31 2022 at 14:01)</a>:</h4>
<p>So</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="mi">0</span>  <span class="c1">---&gt; X_0</span>
   <span class="bp">|</span>           <span class="bp">|</span>
  <span class="n">v</span>          <span class="n">v</span>
<span class="n">Y_</span><span class="o">{</span><span class="bp">-</span><span class="mi">1</span><span class="o">}</span> <span class="c1">-----&gt; Y_0</span>
</code></pre></div>



<a name="296330936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330936">(Aug 31 2022 at 14:01)</a>:</h4>
<p>clearly I'm an expert at ASCII art</p>



<a name="296330965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296330965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296330965">(Aug 31 2022 at 14:01)</a>:</h4>
<p>Sure, but if you flip the direction of the differentials then you are in trouble.</p>



<a name="296331133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296331133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296331133">(Aug 31 2022 at 14:02)</a>:</h4>
<p>Which means that you need specific conditions on your <code>Q -&gt; Q'</code> before you can extend/restrict from one to the other with an adjunction.</p>



<a name="296331162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296331162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296331162">(Aug 31 2022 at 14:02)</a>:</h4>
<p>okay, yes, but if you flip for the extension, you also need to flip for the restriction</p>



<a name="296331303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296331303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296331303">(Aug 31 2022 at 14:03)</a>:</h4>
<p>Take the inclusion of <code>fin n</code> into <code>int</code>. You will either get problems close to <code>0</code> or close to <code>n</code>, depending on the direction of the differentials.</p>



<a name="296331611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296331611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296331611">(Aug 31 2022 at 14:05)</a>:</h4>
<p>right in this case there will be an issue at n for the cochain direction</p>



<a name="296331952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296331952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296331952">(Aug 31 2022 at 14:06)</a>:</h4>
<p>well, this is not much of an issue since we can define some extension functor in a similar way to what we do now, by saying that "everything which is not in the image should be set to zero"</p>



<a name="296332029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296332029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296332029">(Aug 31 2022 at 14:07)</a>:</h4>
<p>this is still something that can be checked on the quiver level</p>



<a name="296332598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296332598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296332598">(Aug 31 2022 at 14:10)</a>:</h4>
<p>So what about homotopies? Do they admit a clean definition?</p>



<a name="296337851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296337851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296337851">(Aug 31 2022 at 14:34)</a>:</h4>
<p>They need a theorem to describe the weak equivalences <span aria-label="grumpy" class="emoji emoji-1f621" role="img" title="grumpy">:grumpy:</span></p>



<a name="296338053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296338053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296338053">(Aug 31 2022 at 14:35)</a>:</h4>
<p>Right. That seems like a downside.</p>



<a name="296338400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296338400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296338400">(Aug 31 2022 at 14:37)</a>:</h4>
<p>The first idea that occurred to me when forming a derived category of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mo>=</mo><mi mathvariant="normal">Fun</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F := \operatorname{Fun}(Q,A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Fun</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> for some abelian category was something a'la <a href="https://preprints.ihes.fr/2009/M/M-09-20.pdf">Positselski</a></p>



<a name="296338775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296338775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296338775">(Aug 31 2022 at 14:39)</a>:</h4>
<p>You start with the pointwise abelian category structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></p>



<a name="296338983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296338983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296338983">(Aug 31 2022 at 14:40)</a>:</h4>
<p>Then you quotient by the subcategory of objects coming from totalizations of exact sequences.</p>



<a name="296339036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296339036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296339036">(Aug 31 2022 at 14:40)</a>:</h4>
<p>You call the result your derived category</p>



<a name="296339206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296339206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296339206">(Aug 31 2022 at 14:41)</a>:</h4>
<p>It relates to the usual derived category because totalizations of exact sequences of complexes are acyclic, hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> when inverting quasi-isomorphisms</p>



<a name="296339235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296339235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296339235">(Aug 31 2022 at 14:41)</a>:</h4>
<p>But in general it is not the same</p>



<a name="296339546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296339546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296339546">(Aug 31 2022 at 14:42)</a>:</h4>
<p>But generally in either of these approaches is there really a notion of 'homology'?</p>



<a name="296339708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296339708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296339708">(Aug 31 2022 at 14:43)</a>:</h4>
<p>At least of an object itself</p>



<a name="296400050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296400050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296400050">(Aug 31 2022 at 16:21)</a>:</h4>
<p>In both papers, the authors assume for most of the results that Q has a Serre functor (some abstract version of Q being selfinjective). This should not be satisfied for the N-indexed version of complexes. It lets the authors however deal with things like "circular" complexes, or even N-complexes, in the sense that d^N=0 in a uniform fashion.</p>



<a name="296698473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296698473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296698473">(Sep 01 2022 at 20:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/335062-homology/topic/Ideas.20for.20refactor/near/296329935">said</a>:</p>
<blockquote>
<p>Other point: Those two papers are going full model category. They only ever talk about the homotopy category, but I didn't find a hands-on notion of homotopy between two complexes. I'm not sure what to make of that.</p>
</blockquote>
<p>I did not go into the details of these two papers, but there are ways to do computations in derived categories by using model category structures as it seems they do. For example, the category of bounded above complexes in an abelian category with enough projectives has a model category structure whose weak equivalences are the quasi-isomorphisms, cofibrant objects are complexes that are degreewise projective and all objects are fibrant. Then, for this model category, the fundamental lemma of homotopical algebra (which I have implemented in Lean and [some previous version of...] mathlib) precisely says that in the derived category, morphisms from a degreewise projective complex can be computed as "homotopy classes" of actual morphisms of complexes. There, "homotopy classes" of morphisms is to be understood in the context of Quillen's homotopical algebra, using cylinders or path objects. In the case of complexes, there are natural constructions of cylinders which makes it so that the homotopy relation using such a cylinder is almost by definition equiv to the usual notion of homotopy of morphisms of complexes.</p>
<p>Then, using my work on homotopical algebra, we could do computations in the derived category (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">D^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span>) in Lean/Mathlib if we could also show the axioms of model categories in the case I have mentionned above. I have done a significant part of the work for this, and some of the missing lemmas are presumably in some form or another in the LTE.</p>
<p>However, if this would give a good first example of model category, I do not think that it would be the right way to do homological algebra with in Lean/Mathlib. I would think a better approach is to develop the notion of triangulated category, e.g. showing it is possible to localize a triangulated with respect to a triangulated subcategory, e.g. when we formally invert quasimorphisms in the homotopy category of an abelian category, the morphisms in the localized category can be described by a certain calculus of fractions. Then, the derived category of an abelian category (defined by localization) would be additive, triangulated, etc, and we could redefine <code>Ext</code> group using these, show we can compute them using projective or injective resolutions, etc.</p>
<p>If "homology" could certainly be refactored, I do not think we need to consider significant changes to the definitions of complexes or homotopies.<br>
Anyway, I would favour approaches which are based on standard "mainstream" mathematical works that have passed the test of time.</p>



<a name="296748244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296748244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296748244">(Sep 02 2022 at 04:06)</a>:</h4>
<p>Yes, I agree that we should make an effort to stay "mainstream".</p>



<a name="296748272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/335062-homology/topic/Ideas%20for%20refactor/near/296748272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/335062-homology/topic/Ideas.20for.20refactor.html#296748272">(Sep 02 2022 at 04:07)</a>:</h4>
<p>Also, thanks for explaining some of the abstract machinery. I'm not <em>that</em> familiar with it, so that's very helpful.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
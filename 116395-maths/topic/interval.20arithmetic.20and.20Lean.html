---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html">interval arithmetic and Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211251141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211251141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211251141">(Sep 25 2020 at 12:29)</a>:</h4>
<p>Over the last couple of years several staff members from across the university have asked me questions about doing formally verified computations in Lean and it's about time I learnt something about how this works. Today I was talking to Sheehan Olver, who does research into computational methods, and he was brandishing Julia code at me involving interval arithmetic and asking if it could be done in Lean. I mean yes, in theory -- but in practice? It seemed to me that he could do with an interval class which comprised of two rational endpoints and then things like square root functions on this class, and also the ability to do e.g. computations with sparse 1000x1000 matrices on this class (e.g. some variant of QR which was stable whose name I've forgotten, possibly multi-syllabic and begins with H). </p>
<p>Would I be better off telling him to use Coq? How much work is developing some computationally useful package in Lean 3 or Lean 4? Presumably these already exist in other systems?</p>



<a name="211252668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211252668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211252668">(Sep 25 2020 at 12:44)</a>:</h4>
<p>You should ask <span class="user-mention" data-user-id="243940">@Fabian Immler</span></p>



<a name="211277441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211277441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211277441">(Sep 25 2020 at 16:01)</a>:</h4>
<p>You don't want just to use rational endpoints in a naive way (you can do exact add/subtract/multiply/divide on intervals with rational endpoints, but the numerators and denominators will blow up in size very quickly), you need some kind of rounding. Floating-point endpoints (with an appropriate formal model of floating-point arithmetic) are better here than general rational ones.</p>



<a name="211277856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211277856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211277856">(Sep 25 2020 at 16:03)</a>:</h4>
<p>mathlib's <code>data.fp.basic</code> is all <code>meta</code> with no proofs that anything has the correct semantics, but I don't see any particular obstruction to having a formal model of floating-point suitable both for proofs, and, via some suitable variant of <code>norm_num</code>, computations. (The mathlib model would seem to be that you don't care about the arithmetic working sensibly via kernel reduction, as long as you have tactics that can do computations with it.)</p>



<a name="211278103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211278103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211278103">(Sep 25 2020 at 16:05)</a>:</h4>
<p>You could also ask Johannes: <a href="https://home.in.tum.de/~hoelzl/documents/hoelzl09diplomathesis.pdf">https://home.in.tum.de/~hoelzl/documents/hoelzl09diplomathesis.pdf</a></p>



<a name="211278303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211278303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211278303">(Sep 25 2020 at 16:07)</a>:</h4>
<p>(When I'm not doing olympiad stuff, much of the mathematically-related things I do is floating point as part of maintaining glibc libm. At some point I need to implement all the new special functions from IEEE 754-2008 that have been added to the next revision of the C standard.)</p>



<a name="211278324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211278324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211278324">(Sep 25 2020 at 16:07)</a>:</h4>
<p>Coq  has <a href="http://arxiv.org/abs/1106.3448">http://arxiv.org/abs/1106.3448</a> for one.</p>



<a name="211279302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211279302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211279302">(Sep 25 2020 at 16:15)</a>:</h4>
<p>The main questions here are what kind of performance you need and in what sense you want the result to be verified</p>



<a name="211279370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211279370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211279370">(Sep 25 2020 at 16:15)</a>:</h4>
<p>If you want a formal floating-point implementation that can be used to prove properties of floating-point algorithms, as well as as part of formally verified calculations for more mathematical results, that may impose further requirements on how the implementation is designed, but I think it should still be possible to cover both use cases in a single implementation. (For example, for proving properties of floating-point algorithms you might want exceptions and rounding modes and some IEEE implementation choices to be handled in the implementation, and for it to cover decimal floating point as well as binary; probably to represent things at IEEE level 3 "Representations of floating-point data" as the lowest level of IEEE floating-point semantics where almost all results are still fully specified by the IEEE standard.)</p>



<a name="211279799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211279799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211279799">(Sep 25 2020 at 16:19)</a>:</h4>
<p>A simple mathematical use case might be proving some inequality you need as a larger proof (cf. the bounds on pi that are already in mathlib). A use case for proving properties of floating-point algorithms might be to prove that a given algorithm calculates some function on floating-point inputs and with floating-point results, say tan(x), with a given bound on the errors. (No doubt the people Kevin's talking to want more complicated results, but proving bounds on a special function or error bounds on a floating-point algorithm for calculating a special function should be easier to achieve.)</p>



<a name="211281029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211281029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211281029">(Sep 25 2020 at 16:29)</a>:</h4>
<p>In my PhD I found I needed to prove a complicated two-variable function was positive, for one variable between 0 and 1 and the other variable between 0 and a number given as a root of a cubic equation, in order to prove a graph theory result. The very informal reason to believe the result was looking at graphs of that function for a few values of the second variable. The proof I came up with involved numerical bounds on the function and its first and second partial derivatives in 80 separate regions for the two variables (none of that formalised or even using interval arithmetic for computing the individual values of the functions and the derivatives that were used to deduce bounds on those intervals), effectively justifying that the graph of the function looked like it appeared to when plotted. I expect that kind of calculation that appears as part of a larger proof should be well within the scope of what can practically be formalised using a formal version of floating-point interval arithmetic.</p>



<a name="211294887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/interval%20arithmetic%20and%20Lean/near/211294887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sheehan Olver <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean.html#211294887">(Sep 25 2020 at 18:22)</a>:</h4>
<p>The idea was not to do the calculations in Lean but translate interval arithmetic as implemented in floating point by IntervalArithmetic.jl into lean statements. The easy way would be to translate each floating point number into a rational. So I’m not sure your worry about large numerator/denominator is valid: the rounding is taken care of already, so it’s only whatever the worst case of a floating point as a rational number.</p>
<p>Though I agree it’s probably better to have a floating point type.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html">Modular forms and related things</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="251898334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251898334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251898334">(Sep 03 2021 at 15:30)</a>:</h4>
<p>So I think its time I start trying to get some of the modular forms code and related things PR'd. The issue is that I have several files with lots of dependencies, so what is the best thing to do? Should each file be a separate PR? </p>
<p>I've made a draft PR here <a href="https://github.com/leanprover-community/mathlib/pull/8979">https://github.com/leanprover-community/mathlib/pull/8979</a>, so any advice on how to split things is welcome.</p>
<p>It basically contains the definitions of modular forms, a definition of holomorphic functions, and facts about <code>SL(2,Z)</code> , including that it is generated by two well-known matrices "S" and "T". (There are also things like the Weierstrass M-test and a definition of the Riemann zeta function (for real values), but these should be easier to split off).</p>



<a name="251898835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251898835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251898835">(Sep 03 2021 at 15:33)</a>:</h4>
<p>Is  <a href="https://github.com/leanprover-community/mathlib/issues/8611">#8611</a> related?</p>



<a name="251898854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251898854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251898854">(Sep 03 2021 at 15:33)</a>:</h4>
<p>A PR should be a couple of hundred lines at most, really, so even some of those single files are too long for one PR. It will be a lot of effort getting this stuff into mathlib (but this effort should be undertaken!).</p>



<a name="251899019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251899019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251899019">(Sep 03 2021 at 15:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251898835">said</a>:</p>
<blockquote>
<p>Is  <a href="https://github.com/leanprover-community/mathlib/issues/8611">#8611</a> related?</p>
</blockquote>
<p>Yes I used some of the definitions from here! But also extended some of the things in this PR.<br>
Edit: or at least I used things from a recent PR related to this</p>



<a name="251899033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251899033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251899033">(Sep 03 2021 at 15:34)</a>:</h4>
<p>Maybe you could start with a <code>general_linear_group.lean</code> PR and/or a Weierstrass M test PR?</p>



<a name="251899107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251899107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251899107">(Sep 03 2021 at 15:34)</a>:</h4>
<p>Note that making a PR is hard work and takes some time. Do you already have push access to non-master branches of mathlib?</p>



<a name="251899165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251899165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251899165">(Sep 03 2021 at 15:35)</a>:</h4>
<p>Yeah the <code>general_linear_group</code> is on the way.</p>



<a name="251899499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251899499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251899499">(Sep 03 2021 at 15:36)</a>:</h4>
<p>and yes the M-test should be fine on its own. The issue is where there are several things with dependencies. I guess if you're saying each PR should only be a couple of hundred lines then that tells me what to do.</p>



<a name="251899587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251899587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251899587">(Sep 03 2021 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251899107">said</a>:</p>
<blockquote>
<p>Note that making a PR is hard work and takes some time. Do you already have push access to non-master branches of mathlib?</p>
</blockquote>
<p>yes</p>



<a name="251900181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900181">(Sep 03 2021 at 15:41)</a>:</h4>
<p>Other relatively straightforward things to do could be to PR short lemmas which you needed and which weren't in the API already (i.e. a PR with just one lemma in), e.g. the lemmas at the start of <code>SL2Z_generators.lean</code> shouldn't be in that file (and could well be in mathlib already, but if they're not then they could be made into a PR to data.int.basic and other appropriate places)</p>



<a name="251900313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900313">(Sep 03 2021 at 15:42)</a>:</h4>
<p>What is the consensus about holomorphic functions? Holomorphic on open subset of <code>C</code> is general enough? I think we really need to have <code>complex_analysis.lean</code> in mathlib...</p>



<a name="251900368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900368">(Sep 03 2021 at 15:42)</a>:</h4>
<p>Well the upper half plane is now a type of its own!</p>



<a name="251900501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900501">(Sep 03 2021 at 15:43)</a>:</h4>
<p>We already have analytic functions.</p>



<a name="251900634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900634">(Sep 03 2021 at 15:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251900313">said</a>:</p>
<blockquote>
<p>What is the consensus about holomorphic functions? Holomorphic on open subset of <code>C</code> is general enough? I think we really need to have <code>complex_analysis.lean</code> in mathlib...</p>
</blockquote>
<p>Yeah I don't really feel qualified to make the holomorphic definition, but I needed it so just went with that for now. Not that I can prove anything is holomorphic, so can definitely change once someone with more authority makes the correct definition</p>



<a name="251900782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900782">(Sep 03 2021 at 15:45)</a>:</h4>
<p>I have to catch up what happened in mathlib in the last month, but I am pretty sure we don't want to develop complex analysis for holomorphic functions over <code>H</code>, or <code>C</code> or whatever, but at least over any open subset of <code>C</code></p>



<a name="251900958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251900958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251900958">(Sep 03 2021 at 15:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251900501">said</a>:</p>
<blockquote>
<p>We already have analytic functions.</p>
</blockquote>
<p>Yes I think this is what I should use instead. I did have some issues in that lots of things wanted my maps to be from <code>C</code> to <code>C</code> and not from an open subset to <code>C</code> so the extend_by_zero was a hack from Kevins birthday repo that I used.</p>



<a name="251923530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251923530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251923530">(Sep 03 2021 at 18:28)</a>:</h4>
<p>Looking at Chris' code, I begin to think mathlib is missing some theory on (local) uniform convergence.  We have the definitions <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on">docs#tendsto_uniformly_on</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_locally_uniformly_on">docs#tendsto_locally_uniformly_on</a>, but it would be nice to have <code>topological_space</code> instances on <code>α → β</code> such that these definitions are precisely <code>filter.tendsto</code> for those topologies.</p>



<a name="251925504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251925504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251925504">(Sep 03 2021 at 18:45)</a>:</h4>
<p>There also seems to be glue missing between <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on">docs#tendsto_uniformly_on</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function">docs#bounded_continuous_function</a></p>



<a name="251927043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251927043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251927043">(Sep 03 2021 at 18:58)</a>:</h4>
<p>With those in place, you have the Weierstrass M-test as <a href="https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded">docs#summable_of_norm_bounded</a>.</p>



<a name="251935593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251935593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251935593">(Sep 03 2021 at 20:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251923530">said</a>:</p>
<blockquote>
<p>Looking at Chris' code, I begin to think mathlib is missing some theory on (local) uniform convergence.  We have the definitions <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on">docs#tendsto_uniformly_on</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_locally_uniformly_on">docs#tendsto_locally_uniformly_on</a>, but it would be nice to have <code>topological_space</code> instances on <code>α → β</code> such that these definitions are precisely <code>filter.tendsto</code> for those topologies.</p>
</blockquote>
<p>Possibly related: <a href="#narrow/stream/116395-maths/topic/Metrisability.20of.20compact-open.20topology/near/251696483">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Metrisability.20of.20compact-open.20topology/near/251696483</a></p>



<a name="251991120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/251991120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#251991120">(Sep 04 2021 at 10:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251927043">said</a>:</p>
<blockquote>
<p>With those in place, you have the Weierstrass M-test as <a href="https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded">docs#summable_of_norm_bounded</a>.</p>
</blockquote>
<p>Yes I must admit, you mentioned proving it this way but I haven't had the chance to think about it this way.  I PR'd the version I have, but do you think proving it this way would be better?</p>



<a name="252100610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252100610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252100610">(Sep 05 2021 at 20:41)</a>:</h4>
<p><span class="user-mention" data-user-id="240862">@Oliver Nash</span> Indeed it seems quite closely related.  Will continue the discussion over there ...</p>



<a name="252156871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252156871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252156871">(Sep 06 2021 at 10:36)</a>:</h4>
<p>So I'm a bit lost as to what to do about the complex holomorphic definition. Originally I used this</p>
<p><code>def is_holomorphic_on {D : open_subs} (f : D.1 → ℂ) : Prop :=
  ∀ z : D.1, ∃ f', has_deriv_within_at (extend_by_zero f) (f') D.1 z</code></p>
<p>as my definition,  which I can prove forms ring. There is also enough in mathlib to prove </p>
<p><code>lemma is_holomorphic_on_iff_differentiable_on  (D : open_subs) (f : D.1 → ℂ):
  differentiable_on ℂ  (extend_by_zero f) D.1 ↔ is_holomorphic_on f:=</code></p>
<p>Now, as far as I can tell we don't have an <code>analytic_on</code> definition, but we do have <code>analytic_at</code>, so the extension wouldn't be an issue. The issue is as far as I can see, we don't have a result (or at least I can't find) that says the product of two analytic functions is analytic. So I guess these things would need to be added.</p>
<p>I guess all of these definitions also have the slight annoyance that if one wants functions only defined on some open subset, then we need to use an <code>extend_by_zero</code> or similar, since as far as I can see all of these definitions are for functions between normed  vector spaces. Is there a better way around this?</p>
<p>So  there seem to be three possibilities  for complex holomorphic functions, so my question is what should I use? are we close enough to having the necessary machinery for proving that they are all equivalent and therefore it makes no difference?</p>



<a name="252178574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252178574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252178574">(Sep 06 2021 at 13:52)</a>:</h4>
<p><span class="user-mention" data-user-id="389019">@Chris Birkbeck</span> Isn't this a bit of a moot point? We don't have the tools yet to prove the functions you're interested in are holomorphic, right?  (You're interested in the Eisenstein series for the modular group, and in the Riemann zeta function, and if I understand correctly both of these require the theorem that a uniform limit of holomorphic functions is holomorphic.)</p>



<a name="252178934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252178934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252178934">(Sep 06 2021 at 13:54)</a>:</h4>
<p>I think that <code>differentiable_on</code> or <code>mdifferentiable_on</code> are the definitions for which we are most likely, soon-ish, to be able to prove that a uniform limit of holomorphic functions is holomorphic.  (This is via Yury's WIP on Stokes.)</p>



<a name="252179225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252179225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252179225">(Sep 06 2021 at 13:56)</a>:</h4>
<p>So you could either work with functions <code>f : ℂ → ℂ</code> which are <code>differentiable_on D</code>, or with functions <code>f : ℍ → ℂ</code> which are <code>mdifferentiable</code>.</p>



<a name="252179259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252179259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252179259">(Sep 06 2021 at 13:57)</a>:</h4>
<p>Ah so you're saying I should just wait until we have have the uniform limit of holo is holo proven and then go with that definition of holomorphic? I guess that is very reasonable.</p>



<a name="252179429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252179429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252179429">(Sep 06 2021 at 13:58)</a>:</h4>
<p>Can on do <code>differentiable_on D</code>? I thought the D would have to be a normed vector space</p>



<a name="252179499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252179499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252179499">(Sep 06 2021 at 13:59)</a>:</h4>
<p>No, here <code>ℂ</code> is the normed vector space, so you consider functions on <code>ℂ</code> which are <code>differentiable_on D</code> (and just consider the values outside <code>D</code> as junk values).</p>



<a name="252179639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252179639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252179639">(Sep 06 2021 at 14:00)</a>:</h4>
<p>Aha I get you, this is what I was doing with the <code>extend_by_zero</code>.</p>



<a name="252179929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252179929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252179929">(Sep 06 2021 at 14:02)</a>:</h4>
<p>Right, but don't literally extend by zero, instead just start with a function on the whole of <code>ℂ</code>.</p>



<a name="252180245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252180245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252180245">(Sep 06 2021 at 14:04)</a>:</h4>
<p>Hmm but is that what we want? I only want to define modular forms on the upper half plane,  so maybe using  <code>mdifferentiable</code> is better (if it lets you work with <code>f : ℍ → ℂ</code>).</p>



<a name="252180537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252180537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252180537">(Sep 06 2021 at 14:06)</a>:</h4>
<p>tbh I didn't know about <code>mdifferentiable_on</code> until now, but looking at it quickly it might be the best choice.</p>



<a name="252180806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252180806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252180806">(Sep 06 2021 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/252180245">said</a>:</p>
<blockquote>
<p>Hmm but is that what we want? I only want to define modular forms on the upper half plane,  so maybe using  <code>mdifferentiable</code> is better (if it lets you work with <code>f : ℍ → ℂ</code>).</p>
</blockquote>
<p>btw this is just a personal preference, it would just feel weird having modular forms  defined on the complex plane who satisfy some tranformation property on <code>ℍ </code>, it seems this would get messy</p>



<a name="252194831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252194831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252194831">(Sep 06 2021 at 15:59)</a>:</h4>
<p>To use <code>mdifferentiable</code> you will need to establish that the upper half-plane is a manifold.  But this is not very difficult.  Use <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_space.opens.smooth_manifold_with_corners">docs#topological_space.opens.smooth_manifold_with_corners</a> probably.</p>



<a name="252246795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252246795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252246795">(Sep 07 2021 at 03:42)</a>:</h4>
<p><span class="user-mention" data-user-id="389019">@Chris Birkbeck</span> Here's how I would set up the Eisenstein series construction.  Following mathlib standard notation, denote by <code>C(ℍ, ℂ)</code> the space of continuous functions on the upper half-plane, equipped with the compact-open topology (i.e., the topology of locally uniform convergence).  For now you would just like to construct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{2k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as an element of <code>C(ℍ, ℂ)</code>, although eventually (when more complex analysis is available in mathlib) you will want to prove it is holomorphic.</p>
<p>Let's slightly modify what you wrote in your file and start by defining</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Eise</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span><span class="o">(</span><span class="n">ℍ</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="n">x.1</span><span class="bp">*</span><span class="n">z</span><span class="bp">+</span><span class="n">x.2</span><span class="o">)</span><span class="bp">^</span><span class="n">k</span><span class="o">,</span> <span class="bp">...</span> <span class="n">proof</span> <span class="n">of</span> <span class="n">continuity</span> <span class="bp">...</span><span class="o">⟩</span>
</code></pre></div>
<p>You want to prove <code>∀ k, summable (Eise k)</code>, i.e. that for each <code>k</code> the Eisenstein series is summable locally uniformly.</p>
<p>It will turn out that there is a family of seminorms on <code>C(ℍ, ℂ)</code>, parametrized by the compact subsets <code>s</code> of <code>ℍ</code>, which induce topologies <code>uniform_on ℂ s</code> on <code>C(ℍ, ℂ)</code> (the topologies of uniform convergence on the <code>s</code>), with the following property:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">summable_compact_open_iff_forall</span> <span class="o">[</span><span class="n">locally_compact_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">summable</span> <span class="n">F</span>
  <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">),</span> <span class="bp">@</span><span class="n">summable</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">uniform_on</span> <span class="n">β</span> <span class="n">s</span><span class="o">)</span> <span class="n">F</span> <span class="o">:=</span>
</code></pre></div>
<p>(This is what Oliver and I were discussing in the other stream.  See <a href="https://github.com/leanprover-community/mathlib/tree/compact-open-gluing">branch#compact-open-gluing</a> for a sketch, with some sorries.)</p>
<p>Then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded">docs#summable_of_norm_bounded</a> as I was suggesting, and your proof obligation becomes: prove that for any compact subset <code>s</code> of <code>ℍ</code>, there exists a summable nonnegative function <code>M : ℤ × ℤ → ℝ</code>, such that the sup-norm of <code>Eise k x</code> over the set <code>s</code> is at most <code>M x</code>.  (You can do this using the "strip" argument which you have written the beginnings of.)</p>
<p>Let me know if you think this approach will work.  I think it should be more efficient, in the sense of making the "end-user" (modular forms) files as short as possible.</p>



<a name="252260912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/252260912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#252260912">(Sep 07 2021 at 07:08)</a>:</h4>
<p>Yes I think working with <code>C(ℍ, ℂ)</code> is a good idea, thank you. I'm busy today, but I'll start translating things into this language tomorrow and see how it goes.</p>



<a name="255388156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/255388156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#255388156">(Sep 29 2021 at 12:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/252246795">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> Here's how I would set up the Eisenstein series construction.  Following mathlib standard notation, denote by <code>C(ℍ, ℂ)</code> the space of continuous functions on the upper half-plane, equipped with the compact-open topology (i.e., the topology of locally uniform convergence).  For now you would just like to construct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{2k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as an element of <code>C(ℍ, ℂ)</code>, although eventually (when more complex analysis is available in mathlib) you will want to prove it is holomorphic.</p>
<p>Let's slightly modify what you wrote in your file and start by defining</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Eise</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span><span class="o">(</span><span class="n">ℍ</span><span class="o">,</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="n">x.1</span><span class="bp">*</span><span class="n">z</span><span class="bp">+</span><span class="n">x.2</span><span class="o">)</span><span class="bp">^</span><span class="n">k</span><span class="o">,</span> <span class="bp">...</span> <span class="n">proof</span> <span class="n">of</span> <span class="n">continuity</span> <span class="bp">...</span><span class="o">⟩</span>
</code></pre></div>
<p>You want to prove <code>∀ k, summable (Eise k)</code>, i.e. that for each <code>k</code> the Eisenstein series is summable locally uniformly.</p>
<p>It will turn out that there is a family of seminorms on <code>C(ℍ, ℂ)</code>, parametrized by the compact subsets <code>s</code> of <code>ℍ</code>, which induce topologies <code>uniform_on ℂ s</code> on <code>C(ℍ, ℂ)</code> (the topologies of uniform convergence on the <code>s</code>), with the following property:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">summable_compact_open_iff_forall</span> <span class="o">[</span><span class="n">locally_compact_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">summable</span> <span class="n">F</span>
  <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">),</span> <span class="bp">@</span><span class="n">summable</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">uniform_on</span> <span class="n">β</span> <span class="n">s</span><span class="o">)</span> <span class="n">F</span> <span class="o">:=</span>
</code></pre></div>
<p>(This is what Oliver and I were discussing in the other stream.  See <a href="https://github.com/leanprover-community/mathlib/tree/compact-open-gluing">branch#compact-open-gluing</a> for a sketch, with some sorries.)</p>
<p>Then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded">docs#summable_of_norm_bounded</a> as I was suggesting, and your proof obligation becomes: prove that for any compact subset <code>s</code> of <code>ℍ</code>, there exists a summable nonnegative function <code>M : ℤ × ℤ → ℝ</code>, such that the sup-norm of <code>Eise k x</code> over the set <code>s</code> is at most <code>M x</code>.  (You can do this using the "strip" argument which you have written the beginnings of.)</p>
<p>Let me know if you think this approach will work.  I think it should be more efficient, in the sense of making the "end-user" (modular forms) files as short as possible.</p>
</blockquote>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span>  So I was just looking at some of the new additions relating to the compact-open topology. Has <code>summable_compact_open_iff_forall</code> also been PR'd? I couldn't find it.</p>



<a name="255415979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/255415979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#255415979">(Sep 29 2021 at 15:09)</a>:</h4>
<p><span class="user-mention" data-user-id="389019">@Chris Birkbeck</span> Sorry for not updating you.  Since <a href="https://github.com/leanprover-community/mathlib/issues/9240">#9240</a> you can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.continuous_function.algebra</span>
<span class="kn">import</span> <span class="n">topology.compact_open</span>
<span class="kn">import</span> <span class="n">topology.algebra.infinite_sum</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_continuous_add</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">restrict_sum</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">I</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">I</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">summable_compact_open_iff_forall</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">locally_compact_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">summable</span> <span class="n">F</span>
  <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">),</span> <span class="n">summable</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">continuous_map.exists_tendsto_compact_open_iff_forall</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">I</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">I</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>(in fact these should both be added as lemmas at some point).  What's left (<span class="user-mention" data-user-id="240862">@Oliver Nash</span> is working on it) is to show that on a compact space <code>α</code>, the compact-open topology is the same as the topology induced by the sup-norm.</p>



<a name="255416220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/255416220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#255416220">(Sep 29 2021 at 15:11)</a>:</h4>
<p>It's true that I promised Heather I'm working on it but I must confess it will be at least a week before I take this up again, and furthermore this has been the case for several weeks!</p>



<a name="255416284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/255416284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#255416284">(Sep 29 2021 at 15:11)</a>:</h4>
<p>(I do want to get to this though.)</p>



<a name="255416824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/255416824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#255416824">(Sep 29 2021 at 15:14)</a>:</h4>
<p>Oh no don't worry, I was just wondering if I'd missed it! I'm not in a huge rush as the other complex analysis parts are still being done. But I'm glad this is still moving forward :)</p>



<a name="266715152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266715152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266715152">(Jan 03 2022 at 17:45)</a>:</h4>
<p>Ok so <a href="https://github.com/leanprover-community/mathlib/pull/8979">#8979</a> now has a definition of modular forms , Eisenstein series and a sorry-free proof Eisenstein series are modular forms. Its still really just a  "test area", i.e. a huge mess, but at least I can see now what things are good and bad with my current definition of modular forms. The main missing result was the "uniform limit of holomorphic functions is holomorphic" but it is possible to get this using <a href="https://github.com/leanprover-community/mathlib/pull/10000">#10000</a> (but what is in <a href="https://github.com/leanprover-community/mathlib/pull/8979">#8979</a> is probably not really the neatest way of doing this). </p>
<p>What I want to start thinking about is breaking this up into PR-able chunks. One of the first things that I want to fix with the current definition of modular forms are "coe" issues. For example, I defined the action of <code>GL_pos (fin 2) ℝ</code> on the <code>upper_half_plane</code> but at some points one wants to take a matrix in  <code>SL(2,ℤ)</code> or some subgroup of this, and make them act on the <code>upper_half_plane</code>. But this ends up being a pain with how I've currently done it (at the moment there are lots of ugly coe lemmas to just get it done). Is there a particularly nice way to give an action of a group <code>G</code> on a set <code>X</code> which behaves nicely when restricting to subgroups of <code>G</code> or subgroups of subgroups of <code>G</code> and so on?</p>
<p>Similarly, I wonder if modular forms should be defined as  functions <code>ℂ → ℂ</code> which satisfy some properties on <code>ℍ</code>. Instead of functions <code>ℍ → ℂ</code>. I think the former probably is probably a better fit with other things (such as <code>differentiable_on</code>), but also one sometimes wants to say things like <code>f(1+z)=f(z)</code> for <code>z : ℍ</code>, but one then needs to give <code>ℍ</code> an <code>add_action ℤ ℍ</code>, which one would have already if one worked with <code>ℂ</code> instead. That said, it does still make me uneasy having modular forms defined on all the complex numbers...</p>
<p>In any case, any ideas on how to approach there issues are most welcome!</p>



<a name="266721866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266721866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266721866">(Jan 03 2022 at 18:44)</a>:</h4>
<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>



<a name="266722068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266722068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266722068">(Jan 03 2022 at 18:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266721866">said</a>:</p>
<blockquote>
<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>
</blockquote>
<p>OK you got me there! I guess I mean subgroups of <code>SL(2,Z)</code> coerced into <code>GL_pos</code></p>



<a name="266722077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266722077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266722077">(Jan 03 2022 at 18:46)</a>:</h4>
<p>If you define modular forms as functions on the complexes then you'd better have some extra axiom such as Im(z)&lt;=0 -&gt; f(z)=0, or else you'll run into problems with different functions agreeing on the upper half plane but not being equal modular forms. I don't see what's wrong with this approach though -- we use it in lots of other places. However GL_pos (fin 2) R and SL(2,Z) don't act on the complex numbers so then you get problems elsewhere.</p>



<a name="266722137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266722137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266722137">(Jan 03 2022 at 18:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266722068">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266721866">said</a>:</p>
<blockquote>
<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>
</blockquote>
<p>OK you got me there! I guess I mean subgroups of <code>SL(2,Z)</code> coerced into <code>GL_pos</code></p>
</blockquote>
<p>We should surely have that if G -&gt; H is a group hom and H acts on X then there's an induced action of G on X?</p>



<a name="266722271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266722271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266722271">(Jan 03 2022 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266722137">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266722068">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266721866">said</a>:</p>
<blockquote>
<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>
</blockquote>
<p>OK you got me there! I guess I mean subgroups of <code>SL(2,Z)</code> coerced into <code>GL_pos</code></p>
</blockquote>
<p>We should surely have that if G -&gt; H is a group hom and H acts on X then there's an induced action of G on X?</p>
</blockquote>
<p>ah yes good point. The issue might be that I didnt define them a group homs! just coes, I'll go back and check</p>



<a name="266724988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266724988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266724988">(Jan 03 2022 at 19:10)</a>:</h4>
<p>Can scalar towers be used, so that you don't have to coerce so much?</p>



<a name="266727649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266727649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266727649">(Jan 03 2022 at 19:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266724988">said</a>:</p>
<blockquote>
<p>Can scalar towers be used, so that you don't have to coerce so much?</p>
</blockquote>
<p>Maybe. I must admit I've yet to look at how they work and how much they help with coe issues!</p>



<a name="266728062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728062">(Jan 03 2022 at 19:36)</a>:</h4>
<p>Can you define modular forms as functions from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">H</mi></mrow><annotation encoding="application/x-tex">\mathbb{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">H</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span> with the right equivariance property, and which are complex-differentiable (when you see <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">H</mi></mrow><annotation encoding="application/x-tex">\mathbb{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">H</span></span></span></span> as a complex manifold)?</p>



<a name="266728162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728162">(Jan 03 2022 at 19:37)</a>:</h4>
<p>Long story short, instead of coercing you can make groups act on each other, like <code>A</code> on <code>B</code>, <code>C</code>, <code>D</code>, <code>B</code> on <code>C</code>, <code>D</code>, <code>C</code> on <code>D</code>... Then <code>is_scalar_tower</code>will state that the scalar multiplications associate with each other.</p>



<a name="266728177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728177">(Jan 03 2022 at 19:37)</a>:</h4>
<p>(Unless you want to define them as sections of some vector bundle, for which the differential geometry machinery will be even more useful).</p>



<a name="266728415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728415">(Jan 03 2022 at 19:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728062">said</a>:</p>
<blockquote>
<p>Can you define modular forms as functions from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">H</mi></mrow><annotation encoding="application/x-tex">\mathbb{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">H</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span> with the right equivariance property, and which are complex-differentiable (when you see <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">H</mi></mrow><annotation encoding="application/x-tex">\mathbb{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">H</span></span></span></span> as a complex manifold)?</p>
</blockquote>
<p>Yes this is something I was weighing up.  When I first started I didn't know about <code>mdifferentiable</code> which would be one way of doing this. This is probably the most pleasing definition, but I don't know how well it would end up playing with the other analysis things</p>



<a name="266728496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728496">(Jan 03 2022 at 19:40)</a>:</h4>
<p>By which you mean you don't know how easy it would be to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mi>m</mi><mi>z</mi><mo>+</mo><mi>n</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{m,n}(mz+n)^{-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span> is a modular form with this definition?</p>



<a name="266728566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728566">(Jan 03 2022 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728162">said</a>:</p>
<blockquote>
<p>Long story short, instead of coercing you can make groups act on each other, like <code>A</code> on <code>B</code>, <code>C</code>, <code>D</code>, <code>B</code> on <code>C</code>, <code>D</code>, <code>C</code> on <code>D</code>... Then <code>is_scalar_tower</code>will state that the scalar multiplications associate with each other.</p>
</blockquote>
<p>Aha I see, so I make all my groups act on each other via multiplication, but then also , each on the upper half plane? and then scalar_tower will say that the actions all work out?</p>



<a name="266728646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728646">(Jan 03 2022 at 19:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728496">said</a>:</p>
<blockquote>
<p>By which you mean you don't know how easy it would be to prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mi>m</mi><mi>z</mi><mo>+</mo><mi>n</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{m,n}(mz+n)^{-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span> is a modular form with this definition?</p>
</blockquote>
<p>Exactly!</p>



<a name="266728675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728675">(Jan 03 2022 at 19:42)</a>:</h4>
<p>But do you ever use this coercion from SL_2(Z) to SL_2(R) anyway? You'd be replacing it with an explicit function if you did this. Can you just make do with defining an action of SL_2(Z) on H?</p>



<a name="266728687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728687">(Jan 03 2022 at 19:42)</a>:</h4>
<p>It might be just as easy, I just haven't looked at <code>mdifferentiable</code> enough</p>



<a name="266728767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728767">(Jan 03 2022 at 19:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728675">said</a>:</p>
<blockquote>
<p>But do you ever use this coercion from SL_2(Z) to SL_2(R) anyway? You'd be replacing it with an explicit function if you did this. Can you just make do with defining an action of SL_2(Z) on H?</p>
</blockquote>
<p>Well eventually we'll want Hecke operators, so I wanted to use <code>GL_pos</code> for this reason.</p>



<a name="266728807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728807">(Jan 03 2022 at 19:43)</a>:</h4>
<p>But then you only need GL_2^+(Q)</p>



<a name="266728934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266728934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266728934">(Jan 03 2022 at 19:45)</a>:</h4>
<p>Oh yeah, sure the reals are just there because I thought being more general would appease the mathlib gods more.</p>



<a name="266740012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266740012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266740012">(Jan 03 2022 at 21:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728062">said</a>:</p>
<blockquote>
<p>Can you define modular forms as functions from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">H</mi></mrow><annotation encoding="application/x-tex">\mathbb{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">H</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span> with the right equivariance property, and which are complex-differentiable (when you see <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">H</mi></mrow><annotation encoding="application/x-tex">\mathbb{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">H</span></span></span></span> as a complex manifold)?</p>
</blockquote>
<p>I agree with this.</p>



<a name="266740192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266740192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266740192">(Jan 03 2022 at 21:44)</a>:</h4>
<p>And I still think that the Weierstrass M-test should be deduced as a simple consequence of the identification of the sup-norm topology with the compact-open topology -- did you encounter difficulties in doing it this way?</p>



<a name="266779097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266779097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266779097">(Jan 04 2022 at 08:02)</a>:</h4>
<p><span class="user-mention" data-user-id="389019">@Chris Birkbeck</span> See <a href="https://github.com/leanprover-community/mathlib/pull/11229">#11229</a>; this should be able to replace your Weierstrass M-test.</p>



<a name="266784266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266784266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266784266">(Jan 04 2022 at 09:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266740192">said</a>:</p>
<blockquote>
<p>And I still think that the Weierstrass M-test should be deduced as a simple consequence of the identification of the sup-norm topology with the compact-open topology -- did you encounter difficulties in doing it this way?</p>
</blockquote>
<p>Oh no I've just not gotten around to doing this way yet. Since I was just aiming for a sorry-free statement I just left the old version which I already had. My intention is to do it the way you suggested for the PR'ed version. Similarly, I think it was you who told me about <code>mdifferentiable</code>. I think this might be the way to go in the end, I just went with <code>differentiable_on</code> as a first attempt as that was what is in <a href="https://github.com/leanprover-community/mathlib/pull/10000">#10000</a></p>



<a name="266784317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Modular%20forms%20and%20related%20things/near/266784317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Modular.20forms.20and.20related.20things.html#266784317">(Jan 04 2022 at 09:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266779097">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="389019">Chris Birkbeck</span> See <a href="https://github.com/leanprover-community/mathlib/pull/11229">#11229</a>; this should be able to replace your Weierstrass M-test.</p>
</blockquote>
<p>This looks great! exactly what is needed, thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
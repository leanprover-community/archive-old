---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Ordered.20monoids.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html">Ordered monoids</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="295198846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295198846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295198846">(Aug 25 2022 at 10:22)</a>:</h4>
<p>These two lemmas on nat are definitely useful.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nat.add_lt_add_of_le_lt</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="o">:=</span>
    <span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">add_lt_add_left</span> <span class="n">hbd</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="n">hac</span> <span class="n">d</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">nat.add_lt_add_of_lt_le</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hbd</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="o">:=</span>
  <span class="n">lt_of_lt_of_le</span> <span class="o">(</span><span class="n">add_lt_add_right</span> <span class="n">hab</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">add_le_add_left</span> <span class="n">hbd</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>Although they are easy to reprove each time, shouldn't they belong to mathlib ?<br>
Probably in the framework of ordered monoids (if not magmas), rather than natural numbers, <br>
but I don't have the impression that general ordered monoids exist in mathlib, only commutative ones…</p>



<a name="295199098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295199098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295199098">(Aug 25 2022 at 10:24)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_lt_mul_of_le_of_lt">docs#mul_lt_mul_of_le_of_lt</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/add_lt_add_of_lt_of_le">docs#add_lt_add_of_lt_of_le</a> exist</p>



<a name="295200553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295200553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295200553">(Aug 25 2022 at 10:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130609">Antoine Chambert-Loir</span> has marked this topic as resolved.</p>



<a name="295200573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295200573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295200573">(Aug 25 2022 at 10:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130609">Antoine Chambert-Loir</span> has marked this topic as unresolved.</p>



<a name="295200657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295200657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295200657">(Aug 25 2022 at 10:35)</a>:</h4>
<p>(Not that I care too much about the answer , but the question about ordered monoids remains…)</p>



<a name="295201085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295201085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295201085">(Aug 25 2022 at 10:38)</a>:</h4>
<p>Ordered monoids basically got "removed" in favour of <code>co(ntra)variant_class</code>, because this approach allows more flexibility. cc <span class="user-mention" data-user-id="321459">@Damiano Testa</span> who started the refactor</p>



<a name="295206620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295206620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295206620">(Aug 25 2022 at 11:18)</a>:</h4>
<p>Yes, I think that the consensus was that for a type with a single operation and a single relation, it was more flexible to have a single class that would be expressive enough to say which monotonicity was assumed on which side.</p>
<p>For types with <em>two</em> operations and one relation, there is some consensus that the current <code>ordered_semiring</code> is too strong and <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> is fixing this.</p>



<a name="295207146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295207146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295207146">(Aug 25 2022 at 11:22)</a>:</h4>
<p>The general idea is that you should find the lemmas such as the one you mentioned by looking for a mixin of covariants and mul/add, but you may be able to unlock it from an <code>ordered_semiring</code>-like assumption as well, since these bigger typeclasses will have the relevant covariant instances on them.</p>



<a name="295207548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295207548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295207548">(Aug 25 2022 at 11:25)</a>:</h4>
<p>I see what you mean. <br>
But wouldn't some shortcuts be useful ? Such as a <code>ordered_magma</code> (instance, or type ?),<br>
which would automatically brings in <code>*</code>, <code>&lt;=</code>, <code>&lt;</code> and the correct <code>covariant_class</code> instance ?</p>



<a name="295208613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295208613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295208613">(Aug 25 2022 at 11:32)</a>:</h4>
<p>There is a fine balance between number of typeclasses, instance between them and potential combinations.  All choices lead to exponential blow ups.  In your situation, you may want <code>*</code> to possibly be <code>+</code>, <code>&lt;</code> is a stand-in for <code>has_lt, preorder, partial_order, linear_order</code>, plus, do you want to assume <code>co(ntra)variant</code> for strict inequality, weak inequality, both?</p>
<p>I think that it was decided that there weren't enough names to make everyone happy and separating</p>
<ul>
<li>what class of operation you want, from <code>has_mul/add</code> to <code>group/add_group</code>,</li>
<li>what kind of order relation you want,</li>
<li>which monotonicity and on which side of the operation you want,</li>
</ul>
<p>was a solution that would provide the right assumptions to most people.</p>



<a name="295209275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ordered%20monoids/near/295209275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ordered.20monoids.html#295209275">(Aug 25 2022 at 11:37)</a>:</h4>
<p>Right now, <code>covariant_class</code> has no typeclass assumptions: these are locked in once you start filling in the fields of the class and then the class converts into the appropriate covariance of the provided operation with respect to the provided relation.</p>
<p>It does not matter which typeclass assumptions are made on the operation/relation.  In fact, the operation is usually <code>+</code> or <code>*</code>, but it does not have to be and the relation is usually <code>&lt;/le</code>, but again they do not need to be.  Even more, the "operation" could be an action of one type on another, which is useful for when you want to have monotonicity only with respect to a subtype of the given type: you only want monotonicity of multiplication when the element is positive.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
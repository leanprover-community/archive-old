---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/composing.20a.20list.20of.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html">composing a list of functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205819136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205819136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205819136">(Aug 03 2020 at 16:59)</a>:</h4>
<p>Can we compose a list of functions? Would this have any use?</p>



<a name="205819188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205819188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205819188">(Aug 03 2020 at 16:59)</a>:</h4>
<p>Currently we can only compose two functions</p>



<a name="205819205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205819205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205819205">(Aug 03 2020 at 16:59)</a>:</h4>
<p>and n times if the domain and codomain happen to be the same</p>



<a name="205819261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205819261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205819261">(Aug 03 2020 at 16:59)</a>:</h4>
<p>Cant you just do a list.fold with \circ, or something like this?</p>



<a name="205819318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205819318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205819318">(Aug 03 2020 at 17:00)</a>:</h4>
<p>what's the type of the list?</p>



<a name="205820791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205820791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205820791">(Aug 03 2020 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/116395-maths/topic/composing.20a.20list.20of.20functions/near/205819318">said</a>:</p>
<blockquote>
<p>what's the type of the list?</p>
</blockquote>
<p>exactly</p>



<a name="205821960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205821960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205821960">(Aug 03 2020 at 17:21)</a>:</h4>
<p>There must be something like heterogeneous lists right?</p>



<a name="205821984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205821984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205821984">(Aug 03 2020 at 17:21)</a>:</h4>
<p>And it should be <code>traversable</code> so you should be able to fold over it.</p>



<a name="205822262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205822262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205822262">(Aug 03 2020 at 17:24)</a>:</h4>
<p>Maybe traversable isn't the right term here....</p>



<a name="205822284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205822284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205822284">(Aug 03 2020 at 17:24)</a>:</h4>
<p><a href="https://hackage.haskell.org/package/thrist-0.4/docs/Data-Thrist.html">https://hackage.haskell.org/package/thrist-0.4/docs/Data-Thrist.html</a><br>
<a href="https://ncatlab.org/nlab/show/free+category">https://ncatlab.org/nlab/show/free+category</a></p>



<a name="205826473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205826473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205826473">(Aug 03 2020 at 18:01)</a>:</h4>
<p>I tried writing a heterogeneous list type, and decided that it wouldn't actually serve the purposes people want for it very well</p>



<a name="205826616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205826616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205826616">(Aug 03 2020 at 18:02)</a>:</h4>
<p>It's better to just use iterated <code>prod</code> if you want a strongly typed heterogeneous list</p>



<a name="205826792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205826792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205826792">(Aug 03 2020 at 18:04)</a>:</h4>
<p>For composing lists of functions, the solution is to use <code>comp</code> several times</p>



<a name="205826948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205826948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205826948">(Aug 03 2020 at 18:05)</a>:</h4>
<p>If you want a type erased heterogeneous list you can use <code>list (Sigma A, A)</code> but I'm not really sure what this would be good for</p>



<a name="205837652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205837652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205837652">(Aug 03 2020 at 19:34)</a>:</h4>
<p>ok maybe I should talk about a potential use case to make this more clear</p>



<a name="205837719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205837719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205837719">(Aug 03 2020 at 19:35)</a>:</h4>
<p>I want to be able to state (and certainly prove) the statement that a functor from <code>[n] = {0 -&gt; 1 -&gt; ... -&gt; n}</code> to any category <code>C</code> is the same as <code>n</code> composable morphisms in <code>C</code></p>



<a name="205837787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205837787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205837787">(Aug 03 2020 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/composing.20a.20list.20of.20functions/near/205826792">said</a>:</p>
<blockquote>
<p>For composing lists of functions, the solution is to use <code>comp</code> several times</p>
</blockquote>
<p>do you mean that if we have 3 functions then we use <code>comp</code> twice? this sounds like it can't work for an arbitrary <code>n</code>, but I might be misunderstanding your suggestion</p>



<a name="205838060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838060">(Aug 03 2020 at 19:38)</a>:</h4>
<p>Are you defining the nerve?</p>



<a name="205838087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838087">(Aug 03 2020 at 19:38)</a>:</h4>
<p>indeed!</p>



<a name="205838095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838095">(Aug 03 2020 at 19:38)</a>:</h4>
<p>Cool!</p>



<a name="205838174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838174">(Aug 03 2020 at 19:39)</a>:</h4>
<p>Presumably you can define the simplicial set by induction on n, no?</p>



<a name="205838203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838203">(Aug 03 2020 at 19:39)</a>:</h4>
<p>you don't need induction right</p>



<a name="205838265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838265">(Aug 03 2020 at 19:40)</a>:</h4>
<p><code>def nerve (C) := \la n, [n] \func C</code></p>



<a name="205838289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838289">(Aug 03 2020 at 19:40)</a>:</h4>
<p>(pseudocode)</p>



<a name="205838314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838314">(Aug 03 2020 at 19:40)</a>:</h4>
<p>Yeah, sure, but I want to exploit the fact that this simplicial set has some horn filling properties :)</p>



<a name="205838408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838408">(Aug 03 2020 at 19:41)</a>:</h4>
<p>what's horn filling properties and how does defining <code>nerve</code> inductively exploits that?</p>



<a name="205838562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838562">(Aug 03 2020 at 19:43)</a>:</h4>
<p>It seems to me like you want to prove that <code>[n]</code> is the free category on the graph <code>0 -&gt; 1 -&gt; ... -&gt; n</code></p>



<a name="205838761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838761">(Aug 03 2020 at 19:45)</a>:</h4>
<p><del>defining</del> constructing the free category sounds like a cool project</p>



<a name="205838961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205838961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205838961">(Aug 03 2020 at 19:47)</a>:</h4>
<p><a href="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/graphs/category.lean">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/graphs/category.lean</a></p>



<a name="205839226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839226">(Aug 03 2020 at 19:49)</a>:</h4>
<p>aha, inductive</p>



<a name="205839286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839286">(Aug 03 2020 at 19:49)</a>:</h4>
<p>can one even state "a list of composable morphisms"? it might have to be a type with <code>nat.rec</code> again, like I made before</p>



<a name="205839359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839359">(Aug 03 2020 at 19:50)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/Canonical.20inductive.20types.20with.200.2C1.2C2.2C3.2C4.20terms/near/204653480">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Canonical.20inductive.20types.20with.200.2C1.2C2.2C3.2C4.20terms/near/204653480</a></p>



<a name="205839362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839362">(Aug 03 2020 at 19:50)</a>:</h4>
<p>Isn't that what <code>morphism_path</code> in the link above is?</p>



<a name="205839391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839391">(Aug 03 2020 at 19:50)</a>:</h4>
<p>I guess it is</p>



<a name="205839540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839540">(Aug 03 2020 at 19:51)</a>:</h4>
<p>Another option is trees of (formal) compositions modulo associativity</p>



<a name="205839552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839552">(Aug 03 2020 at 19:51)</a>:</h4>
<p>&amp; unitality</p>



<a name="205839615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839615">(Aug 03 2020 at 19:52)</a>:</h4>
<p>this is syntax vs semantics again: I don't know how to put it into words, but it's sort of the difference between saying that the inductive implementation is <code>list</code> vs a function from <code>fin n</code> is a list</p>



<a name="205839624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839624">(Aug 03 2020 at 19:52)</a>:</h4>
<p>if it quacks like a list, then it's a list</p>



<a name="205839701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839701">(Aug 03 2020 at 19:52)</a>:</h4>
<p>right, so there's a second presentation of categories which doesn't use dependent types but rather a type of objects and a type of (all) morphisms</p>



<a name="205839753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839753">(Aug 03 2020 at 19:53)</a>:</h4>
<p>then you could consider a list of morphisms together with a bunch of equations that say the intermediate objects line up</p>



<a name="205839794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839794">(Aug 03 2020 at 19:53)</a>:</h4>
<p>I suspect if you consider the nerve for long enough, you'll be sort of forced into this perspective anyways</p>



<a name="205839949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205839949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205839949">(Aug 03 2020 at 19:54)</a>:</h4>
<p>I keep having the illusion that objects have some "internal representation", that the <code>inductive</code> and the function from <code>fin n</code> have some sort of difference</p>



<a name="205841852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205841852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205841852">(Aug 03 2020 at 20:12)</a>:</h4>
<p>Mathlib should really have categories internal to other categories :)</p>



<a name="205841912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205841912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205841912">(Aug 03 2020 at 20:13)</a>:</h4>
<p><a href="https://github.com/b-mehta/topos/blob/master/src/internal_category%20copy.lean">https://github.com/b-mehta/topos/blob/master/src/internal_category%20copy.lean</a> Feel free to tidy this and PR it if you want :)</p>



<a name="205841937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205841937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205841937">(Aug 03 2020 at 20:13)</a>:</h4>
<p>i'm pretty sure it compiles on the latest mathlib</p>



<a name="205842134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205842134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205842134">(Aug 03 2020 at 20:15)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> what's an example of an internal category?</p>



<a name="205842196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205842196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205842196">(Aug 03 2020 at 20:16)</a>:</h4>
<p>A category is an internal category in types :)</p>



<a name="205842223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205842223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205842223">(Aug 03 2020 at 20:16)</a>:</h4>
<p>(At least in the way Reid mentioned above)</p>



<a name="205842242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205842242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205842242">(Aug 03 2020 at 20:16)</a>:</h4>
<p>apart from that, I guess</p>



<a name="205842346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205842346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205842346">(Aug 03 2020 at 20:17)</a>:</h4>
<p>a two-term chain complex is a category internal to abelian groups</p>



<a name="205843260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205843260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205843260">(Aug 03 2020 at 20:25)</a>:</h4>
<p>normally though you'd look at categories internal to say topological spaces</p>



<a name="205853030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205853030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205853030">(Aug 03 2020 at 22:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> In case you find this helpful:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">arrow</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span>

<span class="n">def</span> <span class="n">composable_things</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">g</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">-- wrong</span>
</code></pre></div>



<a name="205853089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205853089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205853089">(Aug 03 2020 at 22:09)</a>:</h4>
<p>Wait, I may have gotten the fin.succ's wrong.</p>



<a name="205853220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205853220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205853220">(Aug 03 2020 at 22:10)</a>:</h4>
<p>This is probably better:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">composable_things</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">arrow</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">fin</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">g</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="mi">0</span><span class="o">))</span>
</code></pre></div>



<a name="205874307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205874307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205874307">(Aug 04 2020 at 05:21)</a>:</h4>
<p>we will certainly run into <code>eq.rec</code> hell if we do this</p>



<a name="205874309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205874309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205874309">(Aug 04 2020 at 05:21)</a>:</h4>
<p>but there seems no other way</p>



<a name="205874534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205874534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205874534">(Aug 04 2020 at 05:28)</a>:</h4>
<p>I've used something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">composable_morphisms&#39;</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">[]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span><span class="o">,</span> <span class="n">composable_morphisms&#39;</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">composable_morphisms&#39;</span> <span class="n">Y</span><span class="o">),</span> <span class="n">composable_morphisms&#39;</span> <span class="n">X</span>

<span class="n">def</span> <span class="n">composable_morphisms</span> <span class="o">:=</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="o">(</span><span class="n">composable_morphisms&#39;</span> <span class="n">V</span> <span class="n">X</span><span class="o">)</span>
</code></pre></div>



<a name="205874620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205874620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205874620">(Aug 04 2020 at 05:31)</a>:</h4>
<p>yeah that sounds like a good idea</p>



<a name="205876507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876507">(Aug 04 2020 at 06:18)</a>:</h4>
<p>might be better to parameterise by both endpoints, for the sake of composition</p>



<a name="205876824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876824">(Aug 04 2020 at 06:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> this is what I have now, in my livestream:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>

<span class="c">/-</span><span class="cm">- A list of composable functions -/</span>
<span class="kn">inductive</span> <span class="n">list_fun</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">β</span> <span class="n">γ</span><span class="o">},</span> <span class="o">(</span><span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">γ</span>

<span class="kn">namespace</span> <span class="n">list_fun</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">nil</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">cons</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">$</span> <span class="n">cons</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span><span class="o">)</span> <span class="n">nil</span>

<span class="c">/-</span><span class="cm">- The composition of a list of composable functions.</span>
<span class="cm">Set up so that `comp (f :: g :: nil) = f ∘ g`. -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">β</span><span class="o">},</span> <span class="n">list_fun</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_nil</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">nil</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_cons</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">f</span> <span class="err">∘</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm">- Concatenation of two lists of composable functions. -/</span>
<span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">γ</span><span class="o">},</span> <span class="n">list_fun</span> <span class="n">β</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">α</span> <span class="n">γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>         <span class="n">L₂</span> <span class="o">:=</span> <span class="n">L₂</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">f</span> <span class="o">(</span><span class="n">append</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_append</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">L₁</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">L₂</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">α</span> <span class="n">β</span><span class="o">),</span>
  <span class="o">(</span><span class="n">L₁</span><span class="bp">.</span><span class="n">append</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">L₁</span><span class="bp">.</span><span class="n">comp</span> <span class="err">∘</span> <span class="n">L₂</span><span class="bp">.</span><span class="n">comp</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>         <span class="n">L₂</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="err">∘</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="err">$</span> <span class="n">comp_append</span> <span class="n">L₁</span> <span class="n">L₂</span>

<span class="kn">end</span> <span class="n">list_fun</span>
</code></pre></div>



<a name="205876901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876901">(Aug 04 2020 at 06:27)</a>:</h4>
<p>Looks great, except that you could make it category polymorphic trivially, and get the current behaviour substituting <code>Type</code> for <code>C</code>. :-)</p>



<a name="205876912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876912">(Aug 04 2020 at 06:27)</a>:</h4>
<p>right</p>



<a name="205876914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876914">(Aug 04 2020 at 06:27)</a>:</h4>
<p>where in the category library should this go?</p>



<a name="205876956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876956">(Aug 04 2020 at 06:28)</a>:</h4>
<p>I guess <code>comp_append</code> would be harder.</p>



<a name="205876962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876962">(Aug 04 2020 at 06:28)</a>:</h4>
<p>(deleted)</p>



<a name="205876971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876971">(Aug 04 2020 at 06:28)</a>:</h4>
<p>but I just proved <code>comp_append</code></p>



<a name="205876976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876976">(Aug 04 2020 at 06:28)</a>:</h4>
<p>oh, you mean for categories</p>



<a name="205876992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876992">(Aug 04 2020 at 06:29)</a>:</h4>
<p>Yes. Harder, but still easy. :-)</p>



<a name="205876999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205876999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205876999">(Aug 04 2020 at 06:29)</a>:</h4>
<p>Just make a new file in <code>category_theory/</code>?</p>



<a name="205877011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877011">(Aug 04 2020 at 06:29)</a>:</h4>
<p>with the same name as <code>lift_fun</code>, or whatever you call it?</p>



<a name="205877076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877076">(Aug 04 2020 at 06:30)</a>:</h4>
<p>I'll add <code>TODO: port every lemma about list ever (except the permutation part!)</code></p>



<a name="205877086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877086">(Aug 04 2020 at 06:30)</a>:</h4>
<p><code>comp list.repeat = nat.iterate</code>!</p>



<a name="205877100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877100">(Aug 04 2020 at 06:31)</a>:</h4>
<p>oh right, and prove that this is the same as a functor from fin n+1 to C</p>



<a name="205877556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877556">(Aug 04 2020 at 06:41)</a>:</h4>
<p>and the equivalence with the subtype of <code>list (arrow C)</code> satisfying some <code>pairwise</code> condition</p>



<a name="205877753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877753">(Aug 04 2020 at 06:46)</a>:</h4>
<p>if I define <code>cons f L</code> then I lose analogy with category; if I define <code>cons L f</code> then I lose analogy with functions...</p>



<a name="205877800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877800">(Aug 04 2020 at 06:46)</a>:</h4>
<p>the category theory composition is the opposite of functions iirc</p>



<a name="205877831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877831">(Aug 04 2020 at 06:47)</a>:</h4>
<p>Shall we switch the order in <code>category_theory/</code>? :-)</p>



<a name="205877881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877881">(Aug 04 2020 at 06:48)</a>:</h4>
<p>I'm not sure it matters particularly; just pick whichever order feels most ergonomic locally.</p>



<a name="205877995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205877995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205877995">(Aug 04 2020 at 06:50)</a>:</h4>
<p>I guess we want <code>(cons f L).comp = f &gt;&gt; L</code>?</p>



<a name="205878378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205878378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205878378">(Aug 04 2020 at 07:00)</a>:</h4>
<p>you know what, I'll just make it so that <code>(cons f L).comp = L.comp &gt;&gt; f</code>, who cares</p>



<a name="205878391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205878391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205878391">(Aug 04 2020 at 07:00)</a>:</h4>
<p>just to make the inductive require one argument less</p>



<a name="205878428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205878428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205878428">(Aug 04 2020 at 07:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> is this ok?</p>



<a name="205878439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205878439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205878439">(Aug 04 2020 at 07:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- A list of composable functions -/</span>
<span class="kn">inductive</span> <span class="n">list_fun</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span> <span class="n">Z</span><span class="o">},</span> <span class="o">(</span><span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">Z</span>

<span class="kn">namespace</span> <span class="n">list_fun</span>

<span class="c">/-</span><span class="cm">- The composition of a list of composable functions.</span>
<span class="cm">Set up so that `comp (f :: g :: nil) = (𝟙 ≫ g) ≫ f`. -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span><span class="o">},</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="n">X</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">f</span>

<span class="kn">end</span> <span class="n">list_fun</span>
</code></pre></div>



<a name="205878782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205878782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205878782">(Aug 04 2020 at 07:08)</a>:</h4>
<p>turns out <code>comp_append</code> wasn't hard:</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2020 Kenny Lau. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Kenny Lau</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm"># Lists of Composable Morphisms</span>

<span class="cm">In this file we define lists of composable morphisms, and their composition.</span>

<span class="cm">We also show that a list of composable morphism is the same as a functor from `[n]`</span>
<span class="cm">(the category `0 ⟶ 1 ⟶ ... ⟶ n`) to the category.</span>

<span class="cm">## Main Definitions</span>

<span class="cm">- `list_fun X Y` where `X, Y : C` for some category `C` is a list of composable morphisms starting</span>
<span class="cm">from `X` and ending at `Y`.</span>

<span class="cm">- `list_fun.comp L` where `L : list_fun X Y` returns the composition as a morphism `X ⟶ Y`.</span>

<span class="cm">-/</span>

<span class="c1">-- TODO: port every lemma about list ever</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- A list of composable functions -/</span>
<span class="kn">inductive</span> <span class="n">list_fun</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span> <span class="n">Z</span><span class="o">},</span> <span class="o">(</span><span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">Z</span>

<span class="kn">notation</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">list_fun</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">namespace</span> <span class="n">list_fun</span>

<span class="c">/-</span><span class="cm">- The composition of a list of composable functions.</span>
<span class="cm">Set up so that `comp (f :: g :: nil) = (𝟙 ≫ g) ≫ f`. -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span><span class="o">},</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="n">X</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">f</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_nil</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">nil</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_cons</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm">- Concatenation of two lists of composable functions. -/</span>
<span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Z</span><span class="o">},</span> <span class="n">list_fun</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Z</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>         <span class="n">L₂</span> <span class="o">:=</span> <span class="n">L₂</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">f</span> <span class="o">(</span><span class="n">append</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">nil_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">nil</span><span class="bp">.</span><span class="n">append</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">W</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Z</span> <span class="err">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">L₁</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L₂</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L₁</span><span class="o">)</span><span class="bp">.</span><span class="n">append</span> <span class="n">L₂</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">f</span> <span class="o">(</span><span class="n">L₁</span><span class="bp">.</span><span class="n">append</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">Z</span><span class="o">}</span> <span class="o">(</span><span class="n">L₁</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L₂</span> <span class="o">:</span> <span class="n">list_fun</span> <span class="n">X</span> <span class="n">Y</span><span class="o">),</span>
  <span class="o">(</span><span class="n">L₁</span><span class="bp">.</span><span class="n">append</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">L₁</span><span class="bp">.</span><span class="n">comp</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>         <span class="n">L₂</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">comp_nil</span><span class="o">,</span> <span class="n">nil_append</span><span class="o">,</span> <span class="n">category</span><span class="bp">.</span><span class="n">comp_id</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">f</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">comp_cons</span><span class="o">,</span> <span class="n">comp_cons</span><span class="o">,</span> <span class="n">comp_append</span><span class="o">,</span> <span class="n">category</span><span class="bp">.</span><span class="n">assoc</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">list_fun</span>

<span class="kn">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="205878865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205878865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205878865">(Aug 04 2020 at 07:10)</a>:</h4>
<p>presumably rename <code>list_fun</code> to <code>list_hom</code>?</p>



<a name="205879154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205879154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205879154">(Aug 04 2020 at 07:16)</a>:</h4>
<p>done</p>



<a name="205879163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205879163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205879163">(Aug 04 2020 at 07:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> what sort of structure does <code>list_hom</code> form, given <code>append</code> and <code>map</code>?</p>



<a name="205879169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205879169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205879169">(Aug 04 2020 at 07:17)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">},</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_hom</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">Y</span><span class="o">)</span>
</code></pre></div>



<a name="205879240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205879240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205879240">(Aug 04 2020 at 07:18)</a>:</h4>
<p>I think <code>list_hom</code> is just the free category on a <code>category_struct</code>.</p>



<a name="205879281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205879281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205879281">(Aug 04 2020 at 07:19)</a>:</h4>
<p>so maybe you could set it up as a functor from <code>Graph</code> to <code>Cat</code>, adjoint to the forgetful functor?</p>



<a name="205880039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880039">(Aug 04 2020 at 07:35)</a>:</h4>
<p>is graph in mathlib?</p>



<a name="205880047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880047">(Aug 04 2020 at 07:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>



<a name="205880158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880158">(Aug 04 2020 at 07:37)</a>:</h4>
<p>Even if someone had "put graphs in mathlib" the chances that they would be the kind of graph you wanted is i guess low</p>



<a name="205880246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880246">(Aug 04 2020 at 07:39)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">functor</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span> <span class="o">:</span>
  <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="n">u₁</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">obj</span> <span class="o">[]</span>    <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span>
<span class="o">(</span><span class="n">map</span>       <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">},</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="err">⟶</span> <span class="o">(</span><span class="n">obj</span> <span class="n">Y</span><span class="o">)))</span>
<span class="o">(</span><span class="n">map_id&#39;</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="n">map</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_comp&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">),</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="err">≫</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="err">≫</span> <span class="o">(</span><span class="n">map</span> <span class="n">g</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>



<a name="205880254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880254">(Aug 04 2020 at 07:40)</a>:</h4>
<p>you don't need C and D to be a category! ;)</p>



<a name="205880422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880422">(Aug 04 2020 at 07:42)</a>:</h4>
<p>oh what am I doing, generalizing category theory itself</p>



<a name="205880590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880590">(Aug 04 2020 at 07:45)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2020 Kenny Lau. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Kenny Lau</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor_category</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm"># Lists of Composable Morphisms</span>

<span class="cm">In this file we define lists of composable morphisms, and their composition.</span>

<span class="cm">We also show that a list of composable morphism is the same as a functor from `[n]`</span>
<span class="cm">(the category `0 ⟶ 1 ⟶ ... ⟶ n`) to the category.</span>

<span class="cm">## Main Definitions</span>

<span class="cm">- `list_hom X Y` where `X, Y : C` for some category `C` is a list of composable morphisms starting</span>
<span class="cm">from `X` and ending at `Y`.</span>

<span class="cm">- `list_hom.comp L` where `L : list_hom X Y` returns the composition as a morphism `X ⟶ Y`.</span>

<span class="cm">-/</span>

<span class="c1">-- TODO: port every lemma about list ever</span>

<span class="n">universes</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="n">u₁</span> <span class="n">u₂</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">{</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">- A list of composable functions -/</span>
<span class="kn">inductive</span> <span class="n">list_hom</span> <span class="o">[</span><span class="n">has_hom</span><span class="bp">.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u₁</span> <span class="n">v₁</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span> <span class="n">Z</span><span class="o">},</span> <span class="o">(</span><span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list_hom</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_hom</span> <span class="n">Z</span>

<span class="kn">namespace</span> <span class="n">list_hom</span>

<span class="kn">notation</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">section</span> <span class="n">has_hom</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">has_hom</span><span class="bp">.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">has_hom</span><span class="bp">.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- Concatenation of two lists of composable functions. -/</span>
<span class="n">def</span> <span class="n">append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Z</span><span class="o">},</span> <span class="n">list_hom</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Z</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>       <span class="n">L₂</span> <span class="o">:=</span> <span class="n">L₂</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="n">f</span> <span class="bp">::</span> <span class="o">(</span><span class="n">append</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">)</span>

<span class="kn">notation</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">append</span> <span class="n">a</span> <span class="n">b</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">nil_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">nil</span> <span class="bp">++</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">cons_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">W</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Z</span> <span class="err">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">L₁</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L₂</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L₁</span><span class="o">)</span> <span class="bp">++</span> <span class="n">L₂</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">::</span> <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">end</span> <span class="n">has_hom</span>

<span class="kn">section</span> <span class="n">category_struct</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">category_struct</span><span class="bp">.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category_struct</span><span class="bp">.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- The composition of a list of composable functions.</span>
<span class="cm">Set up so that `comp (f :: g :: nil) = (𝟙 ≫ g) ≫ f`. -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span><span class="o">},</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>      <span class="o">:=</span> <span class="mi">𝟙</span> <span class="n">X</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">f</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_nil</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">nil</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_cons</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">L</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">end</span> <span class="n">category_struct</span>

<span class="kn">section</span> <span class="n">category</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">Z</span><span class="o">}</span> <span class="o">(</span><span class="n">L₁</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L₂</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">),</span>
  <span class="o">(</span><span class="n">L₁</span><span class="bp">.</span><span class="n">append</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">.</span><span class="n">comp</span> <span class="err">≫</span> <span class="n">L₁</span><span class="bp">.</span><span class="n">comp</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>       <span class="n">L₂</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">comp_nil</span><span class="o">,</span> <span class="n">nil_append</span><span class="o">,</span> <span class="n">category</span><span class="bp">.</span><span class="n">comp_id</span><span class="o">]</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">comp_cons</span><span class="o">,</span> <span class="n">comp_cons</span><span class="o">,</span> <span class="n">comp_append</span><span class="o">,</span> <span class="n">category</span><span class="bp">.</span><span class="n">assoc</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="err">⥤</span> <span class="n">D</span><span class="o">)</span>

<span class="n">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">},</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">list_hom</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">Y</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>      <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="bp">.</span><span class="n">map</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_nil</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">nil</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_cons</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⟶</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">::</span> <span class="n">L</span><span class="bp">.</span><span class="n">map</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_append</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">Z</span><span class="o">}</span> <span class="o">(</span><span class="n">L₁</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">L₂</span> <span class="o">:</span> <span class="n">list_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">),</span>
  <span class="o">(</span><span class="n">L₁</span> <span class="bp">++</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">F</span> <span class="bp">=</span> <span class="n">L₁</span><span class="bp">.</span><span class="n">map</span> <span class="n">F</span> <span class="bp">++</span> <span class="n">L₂</span><span class="bp">.</span><span class="n">map</span> <span class="n">F</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">nil</span>       <span class="n">L₂</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">f</span> <span class="bp">::</span> <span class="n">L₁</span><span class="o">)</span> <span class="n">L₂</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">cons</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">))</span> <span class="err">$</span> <span class="n">map_append</span> <span class="n">L₁</span> <span class="n">L₂</span>

<span class="kn">end</span> <span class="n">category</span>

<span class="kn">end</span> <span class="n">list_hom</span>

<span class="kn">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="205880595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880595">(Aug 04 2020 at 07:45)</a>:</h4>
<p>"maximal generality"</p>



<a name="205880678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880678">(Aug 04 2020 at 07:47)</a>:</h4>
<p>so <code>Func([n], -)</code> is a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">t</mi></mrow><mo>→</mo><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi><mi mathvariant="sans-serif">p</mi><mi mathvariant="sans-serif">e</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{Cat} \to \mathsf{Type}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">C</span><span class="mord mathsf">a</span><span class="mord mathsf">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span><span class="mord mathsf">p</span><span class="mord mathsf">e</span></span></span></span></span>?</p>



<a name="205880683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880683">(Aug 04 2020 at 07:47)</a>:</h4>
<p>aha</p>



<a name="205880695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205880695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205880695">(Aug 04 2020 at 07:47)</a>:</h4>
<p>then list_hom would also have to be one...?</p>



<a name="205915653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205915653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205915653">(Aug 04 2020 at 14:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/composing.20a.20list.20of.20functions/near/205880158">said</a>:</p>
<blockquote>
<p>Even if someone had "put graphs in mathlib" the chances that they would be the kind of graph you wanted is i guess low</p>
</blockquote>
<p>indeed, the most recent PR attempting to put graphs in mathlib implements loopless graphs, but for the category Graph you really ought to allow loops.</p>



<a name="205916390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205916390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205916390">(Aug 04 2020 at 14:50)</a>:</h4>
<p>this makes it, uh, "cartesian closed" might be the right word? The graph 1 with one vertex and one edge is a terminal object, and this terminal object gives rise to a sensible notion of point. e.g. there is a good bijection between Hom(1, G^H) and Hom(H, G)</p>



<a name="205917078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205917078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205917078">(Aug 04 2020 at 14:55)</a>:</h4>
<p>Mathlib already has something like a (pre-)graph (whatever that means):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_hom</span> <span class="n">G</span><span class="o">]</span>
</code></pre></div>



<a name="205917376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/composing%20a%20list%20of%20functions/near/205917376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/composing.20a.20list.20of.20functions.html#205917376">(Aug 04 2020 at 14:57)</a>:</h4>
<p>It's certainly possible to take such a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> and construct the free category associated to it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
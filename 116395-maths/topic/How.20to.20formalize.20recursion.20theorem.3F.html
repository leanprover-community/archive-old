---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html">How to formalize recursion theorem?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="216548611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216548611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216548611">(Nov 13 2020 at 00:15)</a>:</h4>
<p>I have defined natural numbers with Peano axioms, rather than inductive types. Any hint on how to formalize natural number recursion theorem from this framework?</p>
<p>The reference book I got is <code>Elements of Set Theory</code>, in which the recursion theorem is proved by taking union of functions. This operation doesn't seem to be very native in type theory language. Is there any other way to formalize it?</p>



<a name="216573198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216573198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216573198">(Nov 13 2020 at 06:49)</a>:</h4>
<p><span class="user-mention" data-user-id="352122">@Rui Liu</span> Could you share some code? That will make it easier to help you.</p>



<a name="216603537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216603537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216603537">(Nov 13 2020 at 12:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216573198">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="352122">Rui Liu</span> Could you share some code? That will make it easier to help you.</p>
</blockquote>
<p>I have defined the following code for Peano axioms:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">Nat</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">Zero</span><span class="o">:</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">Successor</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">AxiomNat1</span><span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Successor</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">Zero</span>
<span class="kd">constant</span> <span class="n">AxiomNat2</span><span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="bp">∀</span><span class="n">m</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Successor</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Successor</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span>
<span class="kd">constant</span> <span class="n">AxiomNat3</span><span class="o">:</span> <span class="bp">∀</span><span class="n">P</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="n">Zero</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">Successor</span> <span class="n">n</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>
</code></pre></div>
<p>Now I would like to prove the recursion theorem, which takes <code>a:A</code> and <code>f: A → A</code>, to get a <em>unique</em> recursion function <code>g</code> on <code>Nat</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">recursion</span><span class="o">:</span> <span class="bp">∀</span><span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">,</span> <span class="bp">Π</span><span class="n">a</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="bp">Π</span><span class="n">f</span><span class="o">:(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">),</span> <span class="bp">∃</span><span class="n">g</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">g</span> <span class="n">Zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">Successor</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>I know a proof in documented in "Elements of Set Theory" but that's too heavily based on sets and feel unnatural to do in type theory (not even sure if it will work). Is there a more natural way to prove it in type theory that only uses the axioms above without resorting to inductive types?</p>



<a name="216611777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216611777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216611777">(Nov 13 2020 at 13:44)</a>:</h4>
<p>I think you can approach the problem like this:</p>
<ul>
<li>there's no way we can produce the required function <code>g</code> directly, so we have to use (unique) choice to obtain it from its graph</li>
<li>so let's try to produce the relation <code>r : Nat -&gt; A -&gt; Prop</code> which is supposed to be the graph of <code>g</code></li>
<li>now if we used the inductive type <code>nat</code>, we could define <code>r</code> as an inductive predicate with two constructors <code>r 0 a</code> and <code>r n x -&gt; r (n+1) (f x)</code></li>
<li>by a general procedure, we can replace the inductive description of this predicate by the following "impredicative" one: take the intersection of all relations <code>s</code> satisfying <code>s 0 a</code> and <code>forall n x, s n x -&gt; s (n + 1) (f x)</code>, and call it <code>r</code></li>
<li>now try to prove by induction on <code>n</code> that this <code>r</code> is the graph of a function <code>g</code></li>
<li>since it satisfies the conditions <code>r 0 a</code> and <code>r n x -&gt; r (n+1) (f x)</code> (basically by definition) we conclude the function <code>g</code> will satisfy the desired recurrence relation.</li>
</ul>



<a name="216612130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216612130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216612130">(Nov 13 2020 at 13:46)</a>:</h4>
<p>in the next to last point by "is the graph of a function" I just mean that for each <code>n</code>, there is a unique <code>y</code> such that <code>r n y</code></p>



<a name="216613139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216613139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216613139">(Nov 13 2020 at 13:54)</a>:</h4>
<p>Probably you could approximate the relation <code>r</code> "from below" rather than "from above", as well</p>



<a name="216627096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216627096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216627096">(Nov 13 2020 at 15:33)</a>:</h4>
<p>If you want a minimal addition to your setup that allows you to construct such functions, I suggest adding a <code>constant the : unique A -&gt; A</code></p>



<a name="216627203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216627203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216627203">(Nov 13 2020 at 15:34)</a>:</h4>
<p>or possibly even a first order version of that to avoid needing subtypes</p>



<a name="216671131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216671131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216671131">(Nov 13 2020 at 20:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216611777">said</a>:</p>
<blockquote>
<p>I think you can approach the problem like this:</p>
<ul>
<li>there's no way we can produce the required function <code>g</code> directly, so we have to use (unique) choice to obtain it from its graph</li>
<li>so let's try to produce the relation <code>r : Nat -&gt; A -&gt; Prop</code> which is supposed to be the graph of <code>g</code></li>
<li>now if we used the inductive type <code>nat</code>, we could define <code>r</code> as an inductive predicate with two constructors <code>r 0 a</code> and <code>r n x -&gt; r (n+1) (f x)</code></li>
<li>by a general procedure, we can replace the inductive description of this predicate by the following "impredicative" one: take the intersection of all relations <code>s</code> satisfying <code>s 0 a</code> and <code>forall n x, s n x -&gt; s (n + 1) (f x)</code>, and call it <code>r</code></li>
<li>now try to prove by induction on <code>n</code> that this <code>r</code> is the graph of a function <code>g</code></li>
<li>since it satisfies the conditions <code>r 0 a</code> and <code>r n x -&gt; r (n+1) (f x)</code> (basically by definition) we conclude the function <code>g</code> will satisfy the desired recurrence relation.</li>
</ul>
</blockquote>
<p>How do you define "intersection of all relations", when we're working in a synthetic theory rather than reducing everything to sets?</p>



<a name="216671358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216671358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216671358">(Nov 13 2020 at 20:52)</a>:</h4>
<p>Intersection meaning "and", if you will. The relations are all effectively subsets of <code>Nat \x A</code>.</p>



<a name="216671527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216671527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216671527">(Nov 13 2020 at 20:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">\</span><span class="n">lam</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
<span class="bp">\</span><span class="n">all</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="n">s</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">/\</span> <span class="bp">\</span><span class="n">all</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">s</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">-&gt;</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span>
</code></pre></div>



<a name="216750436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216750436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216750436">(Nov 14 2020 at 21:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216671527">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">\</span><span class="n">lam</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
<span class="bp">\</span><span class="n">all</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="n">s</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">/\</span> <span class="bp">\</span><span class="n">all</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">s</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">-&gt;</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span>
</code></pre></div>
</blockquote>
<p>Thanks and I'm trying out this approach. Intuitively with this definition I should be able to prove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h0</span><span class="o">:</span> <span class="n">r</span> <span class="mi">0</span> <span class="n">a</span>
<span class="n">h1</span><span class="o">:</span> <span class="k">forall</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">r</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>These properties are directly provable when we define <code>r</code> as intersection in set theory. However in type theory, I managed to prove <code>h0</code>, but I don't see how to prove <code>h1</code> yet. Any ideas?</p>



<a name="216750530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216750530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216750530">(Nov 14 2020 at 21:15)</a>:</h4>
<p>I think just expanding everything and apply hypotheses will do it</p>



<a name="216750676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216750676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216750676">(Nov 14 2020 at 21:19)</a>:</h4>
<p>we know every "good" <code>s</code> (satisfying the inner condition) satisfies <code>s n x</code>, and we need to show every good <code>s</code> satisfies <code>s (n+1) (f x)</code>, but by definition, for a good <code>s</code>, <code>s n x</code> implies <code>s (n+1) (f x)</code></p>



<a name="216750873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216750873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216750873">(Nov 14 2020 at 21:24)</a>:</h4>
<p>in general, any set theory that doesn't rely on a global membership relation (like ordinals) should translate directly to type theory</p>



<a name="216750995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216750995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216750995">(Nov 14 2020 at 21:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216750873">said</a>:</p>
<blockquote>
<p>in general, any set theory that doesn't rely on a global membership relation (like ordinals) should translate directly to type theory</p>
</blockquote>
<p>I might missed something ... but the following code doesn't type check:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">Nat</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">Zero</span><span class="o">:</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">Succ</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">AxiomNat1</span><span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">Zero</span>
<span class="kd">constant</span> <span class="n">AxiomNat2</span><span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="bp">∀</span><span class="n">m</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Succ</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span>
<span class="kd">constant</span> <span class="n">AxiomNat3</span><span class="o">:</span> <span class="bp">∀</span><span class="n">P</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="n">Zero</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>

<span class="kd">constant</span> <span class="n">A</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span>
<span class="kd">constant</span> <span class="n">f</span><span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">r</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">),</span>
    <span class="bp">∀</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span>

<span class="kd">theorem</span> <span class="n">h0</span><span class="o">:</span> <span class="n">r</span> <span class="n">Zero</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">and.elim_left</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">h1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h'</span><span class="o">:</span> <span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">and.elim_right</span> <span class="n">h'</span> <span class="n">n</span> <span class="n">x</span> <span class="n">h</span>
</code></pre></div>



<a name="216751078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216751078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216751078">(Nov 14 2020 at 21:31)</a>:</h4>
<p>You're using term mode = challenge mode.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">h1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h'</span><span class="o">:</span> <span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="kd">begin</span>
      <span class="n">apply</span> <span class="n">h'.2</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h'</span><span class="o">,</span>
    <span class="kd">end</span>
</code></pre></div>



<a name="216751269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216751269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216751269">(Nov 14 2020 at 21:34)</a>:</h4>
<p>Or in term mode, it's easier if you keep the proof type checking aside from holes (<code>_</code>).</p>



<a name="216751886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216751886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216751886">(Nov 14 2020 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> </p>
<p>Thank you! I just spent like an hour staring at screen...</p>
<blockquote>
<p>Or in term mode, it's easier if you keep the proof type checking aside from holes (_).</p>
</blockquote>
<p>How do you do this?</p>
<p>Also you mentioned that it's also possible to approximate from below, can you elaborate how would you do with that strategy?</p>



<a name="216752020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216752020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216752020">(Nov 14 2020 at 21:47)</a>:</h4>
<p>e.g. after all the <code>assume</code>s, put <code>_</code></p>



<a name="216752072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216752072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216752072">(Nov 14 2020 at 21:48)</a>:</h4>
<p>then only replace the <code>_</code> by some other term with a hole that still type checks, like <code>h'.2 _</code></p>



<a name="216752451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216752451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216752451">(Nov 14 2020 at 21:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="352122">Rui Liu</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216751886">said</a>:</p>
<blockquote>
<p>Also you mentioned that it's also possible to approximate from below, can you elaborate how would you do with that strategy?</p>
</blockquote>
<p>Something like: take the union of all relations <code>s</code> such that</p>
<ul>
<li>if <code>s 0 x</code>, then <code>x = a</code></li>
<li>if <code>s (n+1) y</code>, then there exists <code>x</code> with <code>s n x</code> and <code>y = f x</code></li>
</ul>



<a name="216752789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216752789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216752789">(Nov 14 2020 at 22:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216752451">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="352122">Rui Liu</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216751886">said</a>:</p>
<blockquote>
<p>Also you mentioned that it's also possible to approximate from below, can you elaborate how would you do with that strategy?</p>
</blockquote>
<p>Something like: take the union of all relations <code>s</code> such that</p>
<ul>
<li>if <code>s 0 x</code>, then <code>x = a</code></li>
<li>if <code>s (n+1) y</code>, then there exists <code>x</code> with <code>s n x</code> and <code>y = f x</code></li>
</ul>
</blockquote>
<p>Sorry but how do you do union of relations in type theory?</p>



<a name="216752888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216752888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216752888">(Nov 14 2020 at 22:06)</a>:</h4>
<p><code>\exists</code></p>



<a name="216753241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216753241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216753241">(Nov 14 2020 at 22:16)</a>:</h4>
<p>I don't think this proof works, because to show the relation is not trivial you have to first prove the theorem</p>



<a name="216798695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216798695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216798695">(Nov 15 2020 at 15:42)</a>:</h4>
<p>Thanks for the help from everyone! I finally got this theorem formalized using <span class="user-mention" data-user-id="110032">@Reid Barton</span> 's idea! This is so much more involved than informal proof, since I need to find out all the details to derive a simple property and find the correct way to invoke them in type theory. This makes me realize how much implicit formula manipulation that's happening in mind without realizing them.... Also, after several levels deep inside the proof, I don't see a good way to name the proof terms and bookkeeping them any more... All the important steps and non-important steps are all listed together, which doesn't give a good high level overview. I'd like to try tactics mode at some point and I don't know if they will solve some of the problems above. </p>
<p>Here's the proof (also here a reference on the proof <a href="http://math.iisc.ernet.in/~gadgil/BasicAnalysis/blog/2016/01/08/natural-numbers-axioms/">http://math.iisc.ernet.in/~gadgil/BasicAnalysis/blog/2016/01/08/natural-numbers-axioms/</a>) for anyone interested:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">constant</span> <span class="n">Nat</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">Zero</span><span class="o">:</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">Succ</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">AxiomNat1</span><span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">Zero</span>
<span class="kd">constant</span> <span class="n">AxiomNat2</span><span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="bp">∀</span><span class="n">m</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Succ</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span>
<span class="kd">constant</span> <span class="n">AxiomNat3</span><span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">P</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="o">(</span><span class="n">P</span> <span class="n">Zero</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">Unique</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="bp">Π</span> <span class="n">P</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)(</span><span class="n">P</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="bp">∃</span><span class="n">x</span><span class="o">:</span><span class="n">S</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">y</span><span class="o">:</span><span class="n">S</span><span class="o">,</span> <span class="n">P</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">UniqueIntro</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">P</span><span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">h0</span><span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">),</span> <span class="n">Unique</span> <span class="n">P</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span><span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span><span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">),</span> <span class="n">exists.intro</span> <span class="n">a</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">h0</span> <span class="n">h1</span><span class="o">)</span>
<span class="kd">constant</span> <span class="n">UniqueObj</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">P</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">Unique</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">S</span>
<span class="kd">constant</span> <span class="n">UniqueProp</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">P</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">Unique</span> <span class="n">P</span><span class="o">),</span> <span class="n">P</span> <span class="o">(</span><span class="n">UniqueObj</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">UniqueEq</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">P</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">S</span><span class="o">},</span> <span class="n">Unique</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">P</span><span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">S</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">Unique</span> <span class="n">P</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ha</span><span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hb</span><span class="o">:</span> <span class="n">P</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">exists.elim</span> <span class="n">h</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">x</span><span class="o">:</span> <span class="n">S</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">P</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
        <span class="k">let</span> <span class="n">ea</span><span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.elim_right</span> <span class="n">h</span> <span class="n">a</span> <span class="n">ha</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">eb</span><span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.elim_right</span> <span class="n">h</span> <span class="n">b</span> <span class="n">hb</span> <span class="k">in</span>
        <span class="o">(</span><span class="n">eq.trans</span> <span class="n">ea</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">eb</span><span class="o">))</span>
    <span class="o">)</span>

<span class="kd">theorem</span> <span class="n">NotAnd</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">),</span>
    <span class="n">by_cases</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">p</span><span class="o">:</span> <span class="n">P</span><span class="o">,</span>
        <span class="n">by_cases</span> <span class="o">(</span>
            <span class="k">assume</span> <span class="n">q</span><span class="o">:</span> <span class="n">Q</span><span class="o">,</span>
            <span class="n">absurd</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="n">h</span>
        <span class="o">)</span> <span class="o">(</span>
            <span class="k">assume</span> <span class="n">q</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">,</span>
            <span class="n">or.intro_right</span> <span class="n">_</span> <span class="n">q</span>
        <span class="o">)</span>
    <span class="o">)</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">p</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span><span class="o">,</span>
        <span class="n">or.intro_left</span> <span class="n">_</span> <span class="n">p</span>
    <span class="o">)</span>

<span class="kd">theorem</span> <span class="n">NotOr</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">np</span><span class="o">:</span> <span class="bp">¬</span><span class="n">P</span> <span class="o">:=</span> <span class="o">(</span><span class="k">assume</span> <span class="n">p</span><span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">or.intro_left</span> <span class="n">_</span> <span class="n">p</span><span class="o">))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">nq</span><span class="o">:</span> <span class="bp">¬</span><span class="n">Q</span> <span class="o">:=</span> <span class="o">(</span><span class="k">assume</span> <span class="n">q</span><span class="o">:</span> <span class="n">Q</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">or.intro_right</span> <span class="n">_</span> <span class="n">q</span><span class="o">))</span> <span class="k">in</span>
    <span class="n">and.intro</span> <span class="n">np</span> <span class="n">nq</span>

<span class="kd">theorem</span> <span class="n">NotPOrQ</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="bp">¬</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">p</span><span class="o">:</span> <span class="n">P</span><span class="o">,</span>
    <span class="n">or.elim</span> <span class="n">h</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">notP</span><span class="o">:</span> <span class="bp">¬</span><span class="n">P</span><span class="o">,</span>
        <span class="n">absurd</span> <span class="n">p</span> <span class="n">notP</span>
    <span class="o">)</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">q</span><span class="o">:</span> <span class="n">Q</span><span class="o">,</span>
        <span class="n">q</span>
    <span class="o">)</span>

<span class="kd">theorem</span> <span class="n">NeSymm</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hh</span><span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">h</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">hh</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">NeNot</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">},</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">A</span><span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">by_contradiction</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">nh</span><span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">,</span>
        <span class="n">h</span> <span class="n">nh</span>
    <span class="o">)</span>

<span class="kd">theorem</span> <span class="n">Recursion</span><span class="o">:</span> <span class="bp">∀</span><span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">,</span> <span class="bp">Π</span><span class="n">a</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="bp">Π</span><span class="n">f</span><span class="o">:(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">),</span> <span class="bp">∃</span><span class="n">g</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">g</span> <span class="n">Zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">A</span><span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">f</span><span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">,</span>
<span class="k">let</span> <span class="n">r</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">),</span>
    <span class="bp">∀</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">r0</span><span class="o">:</span> <span class="n">r</span> <span class="n">Zero</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">and.elim_left</span> <span class="n">h</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">r1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">s</span><span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h'</span><span class="o">:</span> <span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">and.elim_right</span> <span class="n">h'</span> <span class="n">n</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span> <span class="n">s</span> <span class="n">h'</span><span class="o">)</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">unique_zero</span><span class="o">:</span> <span class="n">Unique</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="n">Zero</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">unique</span><span class="o">:</span> <span class="bp">∀</span><span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="n">Zero</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
        <span class="k">assume</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">r</span> <span class="n">Zero</span> <span class="n">b</span><span class="o">,</span>
        <span class="n">by_contradiction</span><span class="o">(</span>
            <span class="k">assume</span> <span class="n">b_ne_a</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span><span class="o">,</span>
            <span class="k">let</span> <span class="n">r'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
                <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span>
                <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">Zero</span> <span class="bp">≠</span> <span class="n">n</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">)</span>
            <span class="k">in</span>
            <span class="k">let</span> <span class="n">r'0</span> <span class="o">:</span> <span class="n">r'</span> <span class="n">Zero</span> <span class="n">a</span> <span class="o">:=</span>
                <span class="n">and.intro</span> <span class="n">r0</span> <span class="o">(</span><span class="n">or.intro_right</span> <span class="n">_</span> <span class="n">b_ne_a</span><span class="o">)</span>
            <span class="k">in</span>
            <span class="k">let</span> <span class="n">r'1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">)(</span><span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">),</span> <span class="n">r'</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r'</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
                <span class="k">assume</span> <span class="n">n</span><span class="o">:</span> <span class="n">Nat</span><span class="o">,</span>
                <span class="k">assume</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
                <span class="k">assume</span> <span class="n">r'_n_x</span><span class="o">:</span> <span class="n">r'</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
                <span class="k">let</span> <span class="n">r_n_x</span><span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.elim_left</span> <span class="n">r'_n_x</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">r_succ_n_f_x</span><span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r1</span> <span class="n">n</span> <span class="n">x</span> <span class="n">r_n_x</span> <span class="k">in</span>
                <span class="n">and.intro</span> <span class="n">r_succ_n_f_x</span> <span class="o">(</span><span class="n">or.intro_left</span> <span class="o">(</span><span class="n">b</span> <span class="bp">≠</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">NeSymm</span> <span class="o">(</span><span class="n">AxiomNat1</span> <span class="n">n</span><span class="o">)))</span>
            <span class="k">in</span>
            <span class="k">let</span> <span class="n">r'_zero_b</span> <span class="o">:</span> <span class="n">r'</span> <span class="n">Zero</span> <span class="n">b</span> <span class="o">:=</span>
                <span class="n">h</span> <span class="n">r'</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">r'0</span> <span class="n">r'1</span><span class="o">)</span>
            <span class="k">in</span>
            <span class="n">or.elim</span> <span class="o">(</span><span class="n">and.elim_right</span> <span class="n">r'_zero_b</span><span class="o">)</span>
                <span class="o">(</span><span class="k">assume</span> <span class="n">f</span><span class="o">:</span> <span class="n">Zero</span> <span class="bp">≠</span> <span class="n">Zero</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">Zero</span><span class="o">))</span>
                <span class="o">(</span><span class="k">assume</span> <span class="n">f</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">b</span><span class="o">))</span>
        <span class="o">)</span>
    <span class="k">in</span>
    <span class="n">UniqueIntro</span> <span class="n">a</span> <span class="n">r0</span> <span class="n">unique</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">unique_succ</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Unique</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Unique</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">Unique</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">UniqueObj</span> <span class="n">h</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">r_n_x</span><span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">UniqueProp</span> <span class="n">h</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">r_succ_n_f_x</span><span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r1</span> <span class="n">n</span> <span class="n">x</span> <span class="n">r_n_x</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">unique</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
        <span class="k">assume</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">r_succ_n_b</span><span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span>
        <span class="n">by_contradiction</span><span class="o">(</span>
            <span class="k">assume</span> <span class="n">b_ne_x</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
            <span class="k">let</span> <span class="n">r'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
                <span class="bp">λ</span> <span class="o">(</span><span class="n">n'</span><span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x'</span><span class="o">:</span> <span class="n">A</span><span class="o">),</span>
                <span class="n">r</span> <span class="n">n'</span> <span class="n">x'</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">n'</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">x'</span><span class="o">)</span>
            <span class="k">in</span>
            <span class="k">let</span> <span class="n">r'0</span> <span class="o">:</span> <span class="n">r'</span> <span class="n">Zero</span> <span class="n">a</span> <span class="o">:=</span>
                <span class="n">and.intro</span> <span class="n">r0</span> <span class="o">(</span><span class="n">or.intro_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">AxiomNat1</span> <span class="n">n</span><span class="o">))</span>
            <span class="k">in</span>
            <span class="k">let</span> <span class="n">r'1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n'</span><span class="o">:</span><span class="n">Nat</span><span class="o">)(</span><span class="n">x'</span><span class="o">:</span><span class="n">A</span><span class="o">),</span> <span class="n">r'</span> <span class="n">n'</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">r'</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x'</span><span class="o">)</span> <span class="o">:=</span>
                <span class="k">assume</span> <span class="n">n'</span><span class="o">:</span> <span class="n">Nat</span><span class="o">,</span>
                <span class="k">assume</span> <span class="n">x'</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
                <span class="k">assume</span> <span class="n">r'_n'_x'</span><span class="o">:</span> <span class="n">r'</span> <span class="n">n'</span> <span class="n">x'</span><span class="o">,</span>
                <span class="k">let</span> <span class="n">r_n'_x'</span><span class="o">:</span> <span class="n">r</span> <span class="n">n'</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">and.elim_left</span> <span class="n">r'_n'_x'</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">r_succ_n'_f_x'</span><span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r1</span> <span class="n">n'</span> <span class="n">x'</span> <span class="n">r_n'_x'</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">r'_succ_n'_f_x'</span><span class="o">:</span> <span class="n">r'</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">by_contradiction</span><span class="o">(</span>
                    <span class="k">assume</span> <span class="n">hh</span><span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">r'</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x'</span><span class="o">)),</span>
                    <span class="k">let</span> <span class="n">hh'</span><span class="o">:</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">((</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n'</span><span class="o">))</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">b</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">f</span> <span class="n">x'</span><span class="o">)))</span> <span class="o">:=</span> <span class="n">NotOr</span> <span class="o">(</span><span class="n">NotPOrQ</span> <span class="o">(</span><span class="n">NotAnd</span> <span class="n">hh</span><span class="o">)</span> <span class="n">r_succ_n'_f_x'</span><span class="o">)</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="n">eq1</span><span class="o">:</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Succ</span> <span class="n">n'</span> <span class="o">:=</span> <span class="n">NeNot</span> <span class="o">(</span><span class="n">and.elim_left</span> <span class="n">hh'</span><span class="o">)</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="n">eq2</span><span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">NeNot</span> <span class="o">(</span><span class="n">and.elim_right</span> <span class="n">hh'</span><span class="o">)</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="n">eq3</span><span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n'</span> <span class="o">:=</span> <span class="n">AxiomNat2</span> <span class="n">n</span> <span class="n">n'</span> <span class="o">(</span><span class="n">eq1</span><span class="o">)</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="n">r_n_x'</span><span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">eq3</span><span class="o">)</span> <span class="n">r_n'_x'</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="n">eq4</span><span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">UniqueEq</span> <span class="n">h</span> <span class="n">r_n_x</span> <span class="n">r_n_x'</span> <span class="k">in</span>
                    <span class="k">let</span> <span class="n">eq5</span><span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">f</span> <span class="n">eq4</span> <span class="k">in</span>
                    <span class="n">b_ne_x</span> <span class="o">(</span><span class="n">eq.trans</span> <span class="n">eq2</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">eq5</span><span class="o">))</span>
                <span class="o">)</span> <span class="k">in</span>
                <span class="n">r'_succ_n'_f_x'</span>
            <span class="k">in</span>
            <span class="k">let</span> <span class="n">r'_false</span> <span class="o">:</span> <span class="n">r'</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span>
                <span class="n">r_succ_n_b</span> <span class="n">r'</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">r'0</span> <span class="n">r'1</span><span class="o">)</span>
            <span class="k">in</span>
            <span class="n">or.elim</span> <span class="o">(</span><span class="n">and.elim_right</span> <span class="n">r'_false</span><span class="o">)</span>
                <span class="o">(</span><span class="k">assume</span> <span class="n">f</span><span class="o">:</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">Succ</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)))</span>
                <span class="o">(</span><span class="k">assume</span> <span class="n">f</span><span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">b</span><span class="o">))</span>
        <span class="o">)</span>
    <span class="k">in</span>
    <span class="n">UniqueIntro</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="n">r_succ_n_f_x</span> <span class="n">unique</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">unique_all</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">Unique</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">:</span><span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">AxiomNat3</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">unique_zero</span> <span class="n">unique_succ</span><span class="o">)</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">g</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span> <span class="n">UniqueObj</span> <span class="o">(</span><span class="n">unique_all</span> <span class="n">n</span><span class="o">)</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">h0</span><span class="o">:</span> <span class="n">g</span> <span class="n">Zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">h</span><span class="o">:</span> <span class="n">r</span> <span class="n">Zero</span> <span class="o">(</span><span class="n">g</span> <span class="n">Zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">UniqueProp</span> <span class="n">unique_zero</span> <span class="k">in</span>
    <span class="n">UniqueEq</span> <span class="n">unique_zero</span> <span class="n">h</span> <span class="n">r0</span>
<span class="k">in</span>
<span class="k">let</span> <span class="n">h1</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">),</span> <span class="n">g</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">assume</span> <span class="n">n</span><span class="o">:</span><span class="n">Nat</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">h0</span><span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">UniqueProp</span> <span class="o">(</span><span class="n">unique_all</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">h1</span><span class="o">:</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">r1</span> <span class="n">n</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">UniqueProp</span> <span class="o">(</span><span class="n">unique_all</span> <span class="n">n</span><span class="o">))</span> <span class="k">in</span>
    <span class="n">UniqueEq</span> <span class="o">(</span><span class="n">unique_all</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="n">h0</span> <span class="n">h1</span>
<span class="k">in</span>
<span class="n">exists.intro</span> <span class="n">g</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">h0</span> <span class="n">h1</span><span class="o">)</span>
</code></pre></div>



<a name="216803764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216803764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216803764">(Nov 15 2020 at 17:34)</a>:</h4>
<p>You <em>definitely</em> want to try either proper term mode or tactic mode!</p>



<a name="216805696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216805696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216805696">(Nov 15 2020 at 18:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> What's <strong>proper</strong> term mode?</p>



<a name="216806147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806147">(Nov 15 2020 at 18:21)</a>:</h4>
<p>I guess Kevin means a far more concise version of term mode. Using things like <code>⟨a, b⟩</code> instead of <code>and.intro a b</code>, <code>h.2</code> instead of <code>and.elim_right h</code>, <code>λ n x h s h',</code> instead of five lines of <code>assume</code>.</p>



<a name="216806167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806167">(Nov 15 2020 at 18:22)</a>:</h4>
<p>This proof looks like some kind of compiler intermediate language where there are only three constructs left--<code>assume</code>, <code>let</code> and function application.</p>



<a name="216806229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806229">(Nov 15 2020 at 18:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">h1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="n">_</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h'.2</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">h</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">h'</span>
</code></pre></div>



<a name="216806347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806347">(Nov 15 2020 at 18:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">NeNot</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">},</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">finish</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216806356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806356">(Nov 15 2020 at 18:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">NeSymm</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span><span class="kt">Type</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span><span class="n">A</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216806368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806368">(Nov 15 2020 at 18:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">NotPOrQ</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">tauto</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216806379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806379">(Nov 15 2020 at 18:28)</a>:</h4>
<p>(the latter three only work with <code>import tactic</code> at the top of your file, and working in a project with mathlib as a dependency)</p>



<a name="216806418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806418">(Nov 15 2020 at 18:28)</a>:</h4>
<p>I guess maybe part of the exercise was to use almost nothing even from the core library.</p>



<a name="216806494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806494">(Nov 15 2020 at 18:30)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">NotPOrQ</span>  <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contradiction</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216806496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806496">(Nov 15 2020 at 18:30)</a>:</h4>
<p>Actually I think starting out with this style can be good if you have the stomach for it, because then as you learn more (syntax, library functions, tactics) you can understand how they work at this level.</p>



<a name="216806502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216806502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216806502">(Nov 15 2020 at 18:31)</a>:</h4>
<p>Clearly Jeremy thinks the same way, or he wouldn't have written TPIL like that.</p>



<a name="216807656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216807656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216807656">(Nov 15 2020 at 18:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="352122">Rui Liu</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216805696">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> What's <strong>proper</strong> term mode?</p>
</blockquote>
<p>Just like in math, "proper" = "compact" :)</p>



<a name="216808229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216808229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216808229">(Nov 15 2020 at 19:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> That's short <span aria-label="sweat" class="emoji emoji-1f613" role="img" title="sweat">:sweat:</span> , what's good resource to learn more about tactics and more utilities? I know this <a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html">https://leanprover.github.io/theorem_proving_in_lean/tactics.html</a> , any more?</p>
<blockquote>
<p>I guess maybe part of the exercise was to use almost nothing even from the core library.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> That was indeed the intention. I started to learn about type theory, then got interested in how to formalize maths in type theory. So I was deliberately not using any tools.</p>
<p>Btw, how do you manage proof term variables? I was struggling to give sensible names to it. Or is it when you're using more advanced tactic modes, you usually don't need to write proof variables?</p>



<a name="216809983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216809983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216809983">(Nov 15 2020 at 19:42)</a>:</h4>
<p>More tactics here: <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html">https://leanprover-community.github.io/mathlib_docs/tactics.html</a> . But many of these tactics need the maths library <code>mathlib</code>.</p>



<a name="216818788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216818788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216818788">(Nov 15 2020 at 22:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="352122">Rui Liu</span> <a href="#narrow/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F/near/216808229">said</a>:</p>
<blockquote>
<p>Btw, how do you manage proof term variables? I was struggling to give sensible names to it. Or is it when you're using more advanced tactic modes, you usually don't need to write proof variables?</p>
</blockquote>
<p>You can inline the use of a variable if it appears only once. That way you only have to focus on the "interesting" subgoals. In tactic mode, if you use <code>have</code> without a name it gets the default name <code>this</code>, which is also useful if your proof is somewhat linear and you just keep shadowing the name</p>



<a name="216820894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216820894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216820894">(Nov 15 2020 at 23:35)</a>:</h4>
<p><span class="user-mention" data-user-id="352122">@Rui Liu</span> Here's a conversion of your proof to tactic style (keeping the original proof structure, i.e. no fancy tactics like <code>finish</code> or even <code>rw</code>). I have also tried to use mathlib style elsewhere.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">constant</span> <span class="n">Nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">Zero</span> <span class="o">:</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">Succ</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kd">constant</span> <span class="n">AxiomNat1</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">n</span><span class="o">,</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">Zero</span>
<span class="kd">constant</span> <span class="n">AxiomNat2</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">}</span> <span class="o">:</span> <span class="n">Succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">Succ</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span>
<span class="kd">constant</span> <span class="n">AxiomNat3</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">P</span> <span class="n">Zero</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">Unique</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">P</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>
<span class="kd">theorem</span> <span class="n">UniqueIntro</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">Unique</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h0</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩</span>
<span class="kd">constant</span> <span class="n">UniqueObj</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">Unique</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">S</span>
<span class="kd">constant</span> <span class="n">UniqueProp</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Unique</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="n">UniqueObj</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">theorem</span> <span class="n">UniqueEq</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">S</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Unique</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">P</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="k">in</span> <span class="o">(</span><span class="n">h2</span> <span class="n">_</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">h2</span> <span class="n">_</span> <span class="n">hb</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">theorem</span> <span class="n">NotAnd</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_and_distrib.1</span>

<span class="kd">theorem</span> <span class="n">NotOr</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_or_distrib.1</span>

<span class="kd">theorem</span> <span class="n">NotPOrQ</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">or.neg_resolve_left</span>

<span class="kd">theorem</span> <span class="n">NeSymm</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">ne.symm</span>

<span class="kd">theorem</span> <span class="n">NeNot</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">not_not.1</span>

<span class="kd">theorem</span> <span class="n">Recursion</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span><span class="o">,</span> <span class="n">g</span> <span class="n">Zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
      <span class="n">s</span> <span class="n">Zero</span> <span class="n">a</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">s</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">r0</span> <span class="o">:</span> <span class="n">r</span> <span class="n">Zero</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">r1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="n">x</span><span class="o">},</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">x</span> <span class="n">h</span> <span class="n">s</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h'.2</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">h</span> <span class="n">s</span> <span class="n">h'</span><span class="o">),</span>
  <span class="k">suffices</span> <span class="n">hu</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">Unique</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">let</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">UniqueObj</span> <span class="o">(</span><span class="n">hu</span> <span class="n">n</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">pg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">UniqueProp</span> <span class="o">(</span><span class="n">hu</span> <span class="n">n</span><span class="o">),</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">UniqueEq</span> <span class="o">(</span><span class="n">hu</span> <span class="n">Zero</span><span class="o">)</span> <span class="o">(</span><span class="n">pg</span> <span class="n">Zero</span><span class="o">)</span> <span class="n">r0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">UniqueEq</span> <span class="o">(</span><span class="n">hu</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">pg</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">r1</span> <span class="o">(</span><span class="n">pg</span> <span class="n">n</span><span class="o">))</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">AxiomNat3</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">r0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b_ne_a</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">r'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">Zero</span> <span class="bp">≠</span> <span class="n">n</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">),</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">r'</span> <span class="n">Zero</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">this.2</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">f</span> <span class="n">rfl</span> <span class="o">},</span>
    <span class="n">refine</span> <span class="n">h</span> <span class="n">r'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">r0</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">b_ne_a</span><span class="o">⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">n</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">r1</span> <span class="n">h1</span><span class="o">,</span> <span class="n">or.inl</span> <span class="o">(</span><span class="n">AxiomNat1</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">UniqueObj</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">px</span> <span class="o">:</span> <span class="n">r</span> <span class="n">n</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">UniqueProp</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">UniqueIntro</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">r1</span> <span class="n">px</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">pb</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b_ne_x</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">r'</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n'</span> <span class="n">x'</span><span class="o">,</span> <span class="n">r</span> <span class="n">n'</span> <span class="n">x'</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span> <span class="bp">≠</span> <span class="n">n'</span> <span class="bp">∨</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">x'</span><span class="o">),</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">r'</span> <span class="o">(</span><span class="n">Succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">this.2</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">f</span> <span class="n">rfl</span> <span class="o">},</span>
    <span class="n">refine</span> <span class="n">pb</span> <span class="n">r'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">r0</span><span class="o">,</span> <span class="n">or.inl</span> <span class="o">(</span><span class="n">AxiomNat1</span> <span class="n">n</span><span class="o">)⟩</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">n'</span> <span class="n">x'</span> <span class="o">⟨</span><span class="n">px'</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span>
      <span class="n">apply</span> <span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hh</span><span class="o">,</span> <span class="n">b_ne_x</span> <span class="n">_</span><span class="o">),</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">not_and_distrib.1</span> <span class="n">hh</span><span class="o">)</span><span class="bp">.</span><span class="n">neg_resolve_left</span> <span class="o">(</span><span class="n">r1</span> <span class="n">px'</span><span class="o">),</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h3</span><span class="o">,</span> <span class="n">h4</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">not_or_distrib.1</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">AxiomNat2</span> <span class="o">(</span><span class="n">not_not.1</span> <span class="n">h3</span><span class="o">),</span>
      <span class="n">cases</span> <span class="n">not_not.1</span> <span class="n">h4</span><span class="o">,</span>
      <span class="n">congr</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">UniqueEq</span> <span class="n">h</span> <span class="n">px</span> <span class="n">px'</span><span class="o">,</span>
      <span class="n">refl</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216820979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216820979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216820979">(Nov 15 2020 at 23:37)</a>:</h4>
<p>(Isn't <code>obtain rfl := ...</code> a fancy tactic?)</p>



<a name="216820983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216820983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216820983">(Nov 15 2020 at 23:37)</a>:</h4>
<p>as in it keeps to axiomatically basic tactics</p>



<a name="216821026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216821026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216821026">(Nov 15 2020 at 23:38)</a>:</h4>
<p><code>obtain rfl</code> is a way to write <code>subst h</code>, a.k.a <code>eq.rec</code></p>



<a name="216821041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216821041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216821041">(Nov 15 2020 at 23:39)</a>:</h4>
<p>but I think proper use of <code>obtain</code> or <code>cases</code> is important for writing tactic proofs</p>



<a name="216838060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216838060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216838060">(Nov 16 2020 at 07:03)</a>:</h4>
<p>I think <code>obtain</code> is relatively new (compared to <code>intro</code>), but I wouldn't say it's "fancy".</p>



<a name="216867575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216867575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216867575">(Nov 16 2020 at 13:04)</a>:</h4>
<p>If <code>rw</code> is being considered fancy I'd probably consider <code>obtain</code> fancy too</p>



<a name="216872028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216872028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216872028">(Nov 16 2020 at 13:45)</a>:</h4>
<p><code>obtain</code> is just syntax sugar for <code>cases</code>, right? <code>rw</code> is a non-trivial extension of <code>eq.rec</code>.</p>



<a name="216873163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216873163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216873163">(Nov 16 2020 at 13:54)</a>:</h4>
<p>I think <code>obtain</code>+<code>rfl</code> is actually <code>subst</code> which is somehow different from <code>cases</code>, but I still wouldn't count it as fancy</p>



<a name="216919717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/216919717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#216919717">(Nov 16 2020 at 19:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Thank you for the proof! Will try using this style some time!</p>



<a name="217080610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217080610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217080610">(Nov 18 2020 at 00:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is there a reason to prefer <code>have</code> over <code>let</code>? I saw in your proof you got several places using <code>have</code> instead of <code>let</code></p>



<a name="217080643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217080643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217080643">(Nov 18 2020 at 00:08)</a>:</h4>
<p>Use <code>have</code> for proofs and <code>let</code> only if you want to unfold the definition in subsequent reasoning</p>



<a name="217080661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217080661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217080661">(Nov 18 2020 at 00:09)</a>:</h4>
<p>it is similar to the difference between <code>def</code> and <code>theorem</code></p>



<a name="217080772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217080772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217080772">(Nov 18 2020 at 00:10)</a>:</h4>
<p>Really you don't need <code>let</code> at all in the proof, you could just construct and then destruct an existential statement</p>



<a name="217080940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217080940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217080940">(Nov 18 2020 at 00:12)</a>:</h4>
<p>as far as I understand, <code>let</code> is a more general version of <code>have</code>, since in the places we want to unfold body only <code>let</code> works? Any reason for not always using <code>let</code>? </p>
<p>what's the difference between <code>def</code> and <code>theorem</code>?</p>
<blockquote>
<p>Really you don't need let at all in the proof, you could just construct and then destruct an existential statement</p>
</blockquote>
<p>Are you talking about this particular proof? or something in general?</p>



<a name="217081088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217081088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217081088">(Nov 18 2020 at 00:14)</a>:</h4>
<p>in this particular proof</p>



<a name="217081194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217081194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217081194">(Nov 18 2020 at 00:16)</a>:</h4>
<p>Using <code>let</code> clutters up the context with <code>:= ...</code> because it has to retain the definition, and ultimately it boils down to a substitution anyway so it's not really using the cut rule in the way <code>have</code> does</p>



<a name="217081289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217081289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217081289">(Nov 18 2020 at 00:16)</a>:</h4>
<p><code>let x := e in a</code> becomes <code>a [e / x]</code> while <code>have x := e, a</code> becomes <code>(\lam x, a) e</code></p>



<a name="217081931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217081931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217081931">(Nov 18 2020 at 00:24)</a>:</h4>
<p>so the reason for preferring <code>have</code> is <code>let</code> is not needed?</p>



<a name="217082051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217082051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rui Liu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217082051">(Nov 18 2020 at 00:26)</a>:</h4>
<p>oh I see, so by "clutters up the context", you mean it will create a lot more entries in the context which makes it harder to look at the hypothesis</p>



<a name="217083086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217083086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217083086">(Nov 18 2020 at 00:41)</a>:</h4>
<p>This is less true of the widget view because it hides <code>:= ...</code> in the context, unlike the plain text view, but I'm worried about an explosion of type checking cost in some cases</p>



<a name="217083108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/How%20to%20formalize%20recursion%20theorem%3F/near/217083108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/How.20to.20formalize.20recursion.20theorem.3F.html#217083108">(Nov 18 2020 at 00:41)</a>:</h4>
<p>generally, it is useful information for lean to know that a definition will not be used later except via its type</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
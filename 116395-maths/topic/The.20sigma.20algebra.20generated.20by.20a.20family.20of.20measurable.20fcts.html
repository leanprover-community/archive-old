---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html">The sigma algebra generated by a family of measurable fcts</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213812682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213812682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Golol <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213812682">(Oct 19 2020 at 16:39)</a>:</h4>
<p>Alright, so today I managed to formalize this and proof some lemmas about it, with the idea of trying to do something which could theoretically, possibly, actually be used in the mathlib.<br>
What I am looking for is feedback on what would keep this from getting added to the mathlib.<br>
Some points:<br>
1) The proofs are surely way longer than they need to be - Theoretically only an aesthetic issue but it would probably not be nice to have walls of tactics when a short, elegant proof does the job. In particular I suspect that the correct usage of some lemmas already in the mathlib would have made things smoother.<br>
2) Some of the arguments should probably be implicit but for now I just kept it simple.<br>
3) Are these kinds of lemmas worthwhile? Do they actually exist alreadyß</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">measure_theory.measurable_space</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>


<span class="sd">/--- the induced σ-algebra of a family of functions --/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">comap_family</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">measurable_space</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="n">is_measurable'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">,</span> <span class="k">from</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">measurable_space.generate_from</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">is_measurable'</span> <span class="n">a</span><span class="o">}</span>

<span class="sd">/-- the induced σ-algebra makes all functions of the family measurable --/</span>
<span class="kd">lemma</span> <span class="n">comap_family_all_measurable</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">(</span><span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="n">m</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">iff.mpr</span> <span class="o">(</span><span class="bp">@</span><span class="n">measurable_iff_comap_le</span> <span class="n">α</span> <span class="n">β</span> <span class="o">(</span><span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="n">m</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">comap_family</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">measurable_space.generate_from</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">p</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">},</span>
      <span class="n">exact</span> <span class="o">⟨</span> <span class="n">i</span><span class="o">,</span> <span class="n">h</span> <span class="o">⟩,</span>
    <span class="n">generalize</span> <span class="n">q</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">}</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">eq.symm</span> <span class="n">q</span><span class="o">,</span> <span class="n">exact</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">measurable_space.generate_measurable.basic</span> <span class="n">α</span> <span class="n">x</span> <span class="n">a</span> <span class="n">hp</span><span class="o">,</span>
  <span class="kd">end</span>

<span class="sd">/-- The function is monotone w.r. to inclusion on the index set and measurable spaces --/</span>
<span class="kd">lemma</span> <span class="n">comap_le_if_family_le</span> <span class="o">(</span><span class="n">I</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">-&gt;</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">hinj</span><span class="o">:</span> <span class="n">function.injective</span> <span class="n">inj</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap_family</span> <span class="n">J</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">inj</span> <span class="n">j</span><span class="o">))</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">comap_family</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">measurable_space.generate_from_le_generate_from</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span> <span class="n">inj</span> <span class="n">j</span><span class="o">,</span> <span class="n">h</span> <span class="o">⟩,</span>
  <span class="kd">end</span>

<span class="sd">/-- The σ-algebra generated by a measurable space is the space itself --/</span>
<span class="kd">lemma</span> <span class="n">generate_from_measurable_space_id</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">measurable_space.generate_from</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">m.is_measurable'</span><span class="o">)</span>
  <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">unfold</span> <span class="n">set_of</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">measurable_space.generate_from</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h_H</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">m.is_measurable_empty</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">m.is_measurable_compl</span> <span class="n">h_s</span> <span class="n">h_ih</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">m.is_measurable_Union</span> <span class="n">h_f</span> <span class="n">h_ih</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">measurable_space.generate_measurable.basic</span> <span class="n">β</span> <span class="n">m.is_measurable'</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
    <span class="kd">end</span>

<span class="sd">/-- THe function comap_family is a generalization - in the case that the Index type has one element,</span>
<span class="sd">it reduces to comap --/</span>
<span class="kd">lemma</span> <span class="n">comap_family_is_comap_for_singleton</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">comap_family</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span>
        <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">)</span>
        <span class="bp">↔</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">),</span>
      <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">iff.intro</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h</span> <span class="n">i</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="o">⟨</span> <span class="n">i</span><span class="o">,</span> <span class="n">h</span> <span class="o">⟩,</span>
    <span class="k">have</span> <span class="n">hq</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">}</span>
        <span class="bp">=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">|</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">is_measurable'</span> <span class="n">a</span><span class="o">},</span>
      <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hp</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hq</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">generate_from_measurable_space_id</span> <span class="o">(</span><span class="n">measurable_space.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">m</span><span class="o">),</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="213813122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213813122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213813122">(Oct 19 2020 at 16:43)</a>:</h4>
<p>Looking at <code>comap_family</code>, my first thought is to try to factor it into two parts: constructing a measurable space from a family of measurable spaces, and pulling back a measurable space along a function</p>



<a name="213813218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213813218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213813218">(Oct 19 2020 at 16:44)</a>:</h4>
<p>the latter we already have, that's <code>comap</code>, and the former is the lattice operation on <code>measurable_space</code> (which is a complete lattice IIRC)</p>



<a name="213815192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213815192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Golol <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213815192">(Oct 19 2020 at 16:59)</a>:</h4>
<p>Would the product be the sigma algebra generated by the finite dimensional cylinder sets?</p>



<a name="213815298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213815298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213815298">(Oct 19 2020 at 17:00)</a>:</h4>
<p>It's just <code>\bigcap i, m i</code></p>



<a name="213815392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213815392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213815392">(Oct 19 2020 at 17:01)</a>:</h4>
<p>it's the supremum (or infimum, I always get them mixed up) of the family of measurable spaces</p>



<a name="213815524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213815524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213815524">(Oct 19 2020 at 17:01)</a>:</h4>
<p>you certainly don't need any <code>generate_from</code> stuff, and that will hugely simplify the proofs</p>



<a name="213817248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817248">(Oct 19 2020 at 17:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--- the induced σ-algebra of a family of functions --/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">comap_family</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">measurable_space</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">⨆</span> <span class="n">i</span><span class="o">,</span> <span class="n">m.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">comap_family_all_measurable</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">measurable</span> <span class="n">α</span> <span class="n">β</span> <span class="o">(</span><span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="n">m</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">measurable_iff_comap_le.2</span> <span class="o">(</span><span class="n">le_supr</span> <span class="n">_</span> <span class="n">i</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">comap_le_if_family_le</span> <span class="o">(</span><span class="n">I</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">-&gt;</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">hinj</span><span class="o">:</span> <span class="n">function.injective</span> <span class="n">inj</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap_family</span> <span class="n">J</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">inj</span> <span class="n">j</span><span class="o">))</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">supr_le</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">measurable_iff_comap_le.1</span> <span class="bp">$</span> <span class="n">comap_family_all_measurable</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span> <span class="o">(</span><span class="n">inj</span> <span class="n">j</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">comap_family_is_comap_for_singleton</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">subsingleton</span> <span class="n">I</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">I</span> <span class="bp">-&gt;</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">measurable_space</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comap_family</span> <span class="n">I</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m.comap</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">supr_le</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">subsingleton.elim</span> <span class="n">i</span> <span class="n">j</span><span class="bp">;</span> <span class="n">refl'</span><span class="o">)</span> <span class="o">(</span><span class="n">le_supr</span> <span class="n">_</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>



<a name="213817353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817353">(Oct 19 2020 at 17:17)</a>:</h4>
<p>I think there are some missing theorems about measurable functions wrt the <code>supr</code> measurable space though</p>



<a name="213817503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817503">(Oct 19 2020 at 17:18)</a>:</h4>
<p>If this is true then the proofs of these missing theorems should be verbatim copy of the corresponding topological theorems.</p>



<a name="213817530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817530">(Oct 19 2020 at 17:19)</a>:</h4>
<p>I think they are, more or less</p>



<a name="213817531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Golol <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817531">(Oct 19 2020 at 17:19)</a>:</h4>
<p>Oh that makes me realize, I actually wanted to do this for a family f_i -&gt; \b_i, the target spaces should change. I should generalize it.<br>
My plan is to follow a script I have on stochastic processes. There is this basic theorem which tells you that the obvious choices for sigma algebras for your stochastic process are the same and you dont have to worry, would be nice to have that.</p>



<a name="213817650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817650">(Oct 19 2020 at 17:20)</a>:</h4>
<p>The point I'm making is that you don't really need this definition because it factors cleanly into two more reusable parts (about which we already have a bunch of theorems)</p>



<a name="213817802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213817802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213817802">(Oct 19 2020 at 17:21)</a>:</h4>
<p>if you wanted the measurable spaces to change, it would just become <code>⨆ i, (m i).comap (f i)</code> instead</p>



<a name="213818296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213818296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Golol <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213818296">(Oct 19 2020 at 17:25)</a>:</h4>
<p>Ah yes yes, I realized that. I just want to practice doing some "theorybuilding" in lean. And if an earlier definition in the theory is inefficient, then that  can be generalized later I suppose.</p>



<a name="213818620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213818620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213818620">(Oct 19 2020 at 17:27)</a>:</h4>
<p>Yes, as always it is getting the definitions right that is the hard part</p>



<a name="213818850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213818850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213818850">(Oct 19 2020 at 17:29)</a>:</h4>
<p>One way to do theory building would be to pick a target theorem and figure out what the library would need to state and prove the theorem, like the planning phase of an expedition</p>



<a name="213819023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/The%20sigma%20algebra%20generated%20by%20a%20family%20of%20measurable%20fcts/near/213819023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/The.20sigma.20algebra.20generated.20by.20a.20family.20of.20measurable.20fcts.html#213819023">(Oct 19 2020 at 17:30)</a>:</h4>
<p>make sure that all the theorems are easy to state and all the notions involved have enough API theorems to be usable together</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
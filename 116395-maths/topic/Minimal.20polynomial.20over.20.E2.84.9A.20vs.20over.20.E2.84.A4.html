---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html">Minimal polynomial over ℚ vs over ℤ</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="217004166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217004166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217004166">(Nov 17 2020 at 13:50)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib/issues/5006">#5006</a> I proved that the minimal polynomial over any GCD domain is the same  as the minimal polynomial over its field of fractions. Now I want to use it to say that the minimal polynomial of an algebraic integer, over <code>ℤ</code>, is the same as the minimal polynomial over <code>ℚ</code>. Something like in the following code (there is a <code>sorry</code> in <code>gcd_domain_eq_field_fractions</code> because it needs other results, but in <a href="https://github.com/leanprover-community/mathlib/issues/5006">#5006</a> it is proved. If you are wondering why the <code>@is_integral...</code> is because without that it doesn't work)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.minimal_polynomial</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">analysis.complex.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">hint</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℤ</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">halg</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℚ</span> <span class="n">z</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">gcd_domain_eq_field_fractions</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">gcd_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">f.codomain</span> <span class="n">γ</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">α</span> <span class="n">f.codomain</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">α</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">minimal_polynomial</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">is_integral_of_is_scalar_tower</span> <span class="n">α</span> <span class="n">f.codomain</span> <span class="n">γ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">minimal_polynomial</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span>
  <span class="o">(</span><span class="n">localization_map.to_ring_hom</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">test</span> <span class="o">:</span> <span class="n">polynomial.map</span> <span class="o">(</span><span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">hint</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">minimal_polynomial</span> <span class="n">halg</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">gcd_domain_eq_field_fractions</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="n">ℂ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
  <span class="n">fraction_map.int.fraction_map</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">z</span> <span class="n">hint</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>It seems that the second lemma should be an immediate consequence of the first one, but I am not able to prove it. I want to prove it using <code>fraction_map.int.fraction_map</code>, but Leans complains with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span>
<span class="n">hint</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℤ</span> <span class="n">z</span><span class="o">,</span>
<span class="n">halg</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℚ</span> <span class="n">z</span>
<span class="bp">⊢</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span>
</code></pre></div>
<p>I see that at some point I have to prove some compatibility between <code>polynomial.map (int.cast_ring_hom ℚ)</code> and <code>polynomial.map
  (localization_map.to_ring_hom fraction_map.int.fraction_map)</code> but I am stuck before getting to it: I do not know how to say that <code>localization_map.codomain fraction_map.int.fraction_map</code> is<code>ℚ</code>, so we have the required algebra structure on <code>ℂ</code>.</p>
<p>Any help is appreciated, thank you!</p>



<a name="217006063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217006063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217006063">(Nov 17 2020 at 14:07)</a>:</h4>
<p>Does something like this work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test</span> <span class="o">:</span> <span class="n">polynomial.map</span> <span class="o">(</span><span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">hint</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">minimal_polynomial</span> <span class="n">halg</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">:=</span>
    <span class="k">show</span> <span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">ℂ</span><span class="o">,</span> <span class="k">from</span> <span class="n">infer_instance</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">gcd_domain_eq_field_fractions</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="n">ℂ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
  <span class="n">fraction_map.int.fraction_map</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">z</span> <span class="n">hint</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="217006608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217006608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217006608">(Nov 17 2020 at 14:12)</a>:</h4>
<p>I think this might show that we've been using too much bundling for localization maps?</p>



<a name="217006693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217006693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217006693">(Nov 17 2020 at 14:13)</a>:</h4>
<p>If <code>is_localization</code> were a predicate assuming <code>[algebra R A]</code>, then we wouldn't have those <code>g.codomain</code>s that throw sand in the type class inference machine.</p>



<a name="217007228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217007228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217007228">(Nov 17 2020 at 14:17)</a>:</h4>
<p>Yeah, now that <code>is_scalar_tower</code> exists, we should be able to get rid of the <code>codomain</code> trick.</p>



<a name="217008818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217008818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217008818">(Nov 17 2020 at 14:28)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span>  Now it asks to prove <code>scalar_tower</code>, that should follow from <code>is_scalar_tower.int</code>. I am trying to understand what you wrote to prove this.</p>



<a name="217010444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217010444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217010444">(Nov 17 2020 at 14:40)</a>:</h4>
<p>I tried with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test</span> <span class="o">:</span> <span class="n">polynomial.map</span> <span class="o">(</span><span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">hint</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">minimal_polynomial</span> <span class="n">halg</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="k">show</span> <span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">ℂ</span><span class="o">,</span> <span class="k">from</span> <span class="n">infer_instance</span><span class="o">,</span>

  <span class="n">letI</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">is_scalar_tower.int</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">},</span>

  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">gcd_domain_eq_field_fractions</span> <span class="n">fraction_map.int.fraction_map</span> <span class="n">hint</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>But it says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span>
<span class="n">hint</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℤ</span> <span class="n">z</span><span class="o">,</span>
<span class="n">halg</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℚ</span> <span class="n">z</span><span class="o">,</span>
<span class="n">_inst</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="k">show</span> <span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">ℂ</span><span class="o">,</span> <span class="k">from</span> <span class="n">infer_instance</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="n">is_scalar_tower.int</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span>
<span class="bp">⊢</span> <span class="n">is_scalar_tower</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span>
<span class="n">hint</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℤ</span> <span class="n">z</span><span class="o">,</span>
<span class="n">halg</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℚ</span> <span class="n">z</span><span class="o">,</span>
<span class="n">_inst</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="k">show</span> <span class="n">algebra</span> <span class="n">ℚ</span> <span class="n">ℂ</span><span class="o">,</span> <span class="k">from</span> <span class="n">infer_instance</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℤ</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="n">is_scalar_tower.int</span> <span class="o">(</span><span class="n">localization_map.codomain</span> <span class="n">fraction_map.int.fraction_map</span><span class="o">)</span> <span class="n">ℂ</span>
<span class="bp">⊢</span> <span class="n">polynomial.map</span> <span class="o">(</span><span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">hint</span><span class="o">)</span> <span class="bp">=</span> <span class="n">minimal_polynomial</span> <span class="n">halg</span>
</code></pre></div>
<p>I guess I will just prove it by hand, without using the general result :D</p>



<a name="217013210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217013210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217013210">(Nov 17 2020 at 14:58)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> Really, we should try to fix the library so that you can apply the general result in a 1-liner.</p>



<a name="217015552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217015552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217015552">(Nov 17 2020 at 15:15)</a>:</h4>
<p>I agree that  having a proposition <code>is_localization</code> for an algebra is much more close to what I have in mind, but I don't know  how much work it requires.</p>



<a name="217036107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217036107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217036107">(Nov 17 2020 at 17:37)</a>:</h4>
<p>By the way, I would be very happy to help in doing this!</p>



<a name="217914580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/217914580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#217914580">(Nov 25 2020 at 17:23)</a>:</h4>
<p>If someone is still interested in this I managed to make it working. This  should be useful to at least understand what can be improved in <code>ring_theory/localization</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.minimal_polynomial</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">char_zero</span> <span class="n">K</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">hint</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℤ</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">halg</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">ℚ</span> <span class="n">z</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">gcd_domain_eq_field_fractions</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">gcd_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">f.codomain</span> <span class="n">γ</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">α</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">hto</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">α</span> <span class="n">f.codomain</span> <span class="n">γ</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">α</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">minimal_polynomial</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_integral_of_is_scalar_tower</span> <span class="n">α</span> <span class="n">f.codomain</span> <span class="n">γ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">((</span><span class="n">minimal_polynomial</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">localization_map.to_ring_hom</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">test</span> <span class="o">:</span> <span class="n">map</span> <span class="o">(</span><span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">hint</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">minimal_polynomial</span> <span class="n">halg</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">localization_map.to_ring_hom</span> <span class="n">fraction_map.int.fraction_map</span> <span class="bp">=</span> <span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">h₁</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">gcd_domain_eq_field_fractions</span> <span class="n">fraction_map.int.fraction_map</span> <span class="n">_</span> <span class="n">hint</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">algebra.smul_def</span> <span class="n">_</span> <span class="n">_</span><span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.eq_int_cast</span><span class="o">,</span> <span class="n">ring_hom.map_int_cast</span><span class="o">,</span> <span class="n">ring_hom.map_mul</span><span class="o">],</span>
  <span class="n">ring</span>
<span class="kd">end</span>
</code></pre></div>
<p>Note that <code>is_scalar_tower</code> in the first lemma is now an assumption rather than an instance, so I can use <code>refine</code> (I tried all the various <code>letI</code> <code>haveI</code>, but they don't work).</p>
<p>I think that the main problem using the codomain trick is that lean uses <code>fraction_map.int.fraction_map</code> to consider <code>ℚ</code> a <code>ℤ</code>-algebra in the lemma, but use the obvious structure otherwise. This leads to very confusing things to prove, for example at some point I had to prove <code>(x • y) • z = x • y • z</code> and I managed to prove <code>(x • y) • z = x • y • z</code>... except that the <code>•</code> where not the same...  and <code>set_option pp.implicit true</code> produced a gigantic practically unreadable output.</p>
<p>Note that the result <code>localization_map.to_ring_hom fraction_map.int.fraction_map = int.cast_ring_hom ℚ</code> and should probably be added,  the problem with the algebra structure would not be solved simply by this.</p>



<a name="218166533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166533">(Nov 28 2020 at 14:31)</a>:</h4>
<p>So what exactly is the suggestion here? Rather than <code>localization_map</code>, we want to say that an <code>algebra</code> instance is a localization? How do we relate it to the set <code>S</code>?</p>



<a name="218166592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166592">(Nov 28 2020 at 14:33)</a>:</h4>
<p>I guess <code>is_localization</code> would still be an ordinary proposition and not an instance?</p>



<a name="218166733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166733">(Nov 28 2020 at 14:36)</a>:</h4>
<p>In the non-additive setting, we still have <code>is_scalar_tower</code> but nothing like <code>algebra</code> I guess. Also, <code>localization_map</code> makes sense even for <code>R</code> (and <code>S</code>) noncommutative but we don't have <code>algebra</code> in that situation either.</p>



<a name="218166753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166753">(Nov 28 2020 at 14:37)</a>:</h4>
<p>I think we should refactor <code>localization</code> in such a way that <code>is_localization</code> is a proposition for an <code>algebra</code>. If you look in the source code there is this trick with <code>codomain</code> that I don't understand completely. I am thinking about it, but it is the first time I try to do something like that (instead of proving a "normal" theorem), so I am (very) slow and I would appreciate any suggestion :)</p>



<a name="218166806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166806">(Nov 28 2020 at 14:38)</a>:</h4>
<p>I've been (also very slowly) working on generalizing localization to Ore localization and handling localization of modules, so this will intersect what I'm doing at some point.</p>



<a name="218166920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166920">(Nov 28 2020 at 14:40)</a>:</h4>
<p>It seems like we can write something like <code>is_localization R A S : Prop</code> to mean that <code>algebra_map</code> from <code>R</code> to <code>A</code> can be made into a <code>localization_map</code> at <code>S</code>, right?</p>



<a name="218166933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218166933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218166933">(Nov 28 2020 at 14:41)</a>:</h4>
<p>I guess <code>R</code> is redundant, since it's determined by <code>S</code>, but maybe it's nice to include it anyways</p>



<a name="218167013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167013">(Nov 28 2020 at 14:43)</a>:</h4>
<p>I am still in the process of reading the source code (that also use localization for monoids) to decide what to do.</p>



<a name="218167015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167015">(Nov 28 2020 at 14:43)</a>:</h4>
<p>Currently <code>localization_map</code> extends <code>ring_hom</code> by some propositional fields, so we could split those propositional fields into a new <code>is_localization_map</code> and define <code>is_localization</code> for algebras by applying that to <code>algebra_map</code></p>



<a name="218167068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167068">(Nov 28 2020 at 14:44)</a>:</h4>
<p>I think at the end what we need is something like a proposition<code>is_localization (R A  M: Type*) [comm_ring R] [comm_ring A] [algebra R A] (M : submonoid R)</code></p>



<a name="218167080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167080">(Nov 28 2020 at 14:45)</a>:</h4>
<p>And just an ordinary proposition, not a class, right?</p>



<a name="218167091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167091">(Nov 28 2020 at 14:45)</a>:</h4>
<p>at least, we can start with an ordinary proposition</p>



<a name="218167092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167092">(Nov 28 2020 at 14:45)</a>:</h4>
<p>To be honest I have no idea about this kind of details, my plan was to ask here :D</p>



<a name="218167149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167149">(Nov 28 2020 at 14:46)</a>:</h4>
<p>For special cases like "is the fraction field of", maybe it makes sense to have a class</p>



<a name="218167697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218167697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218167697">(Nov 28 2020 at 15:00)</a>:</h4>
<p>Defining the proposition is really easy, as you said it suffices to use <code>algebra_map</code>.  It is the part of working with classes/structures/instances that scares me a little bit.</p>



<a name="218169880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218169880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218169880">(Nov 28 2020 at 16:00)</a>:</h4>
<p>It might make sense to do this for <code>ring_hom</code> instead of <code>algebra_map</code>. (I'm maybe still too biased towards comm. algebra)</p>



<a name="218171656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Minimal%20polynomial%20over%20%E2%84%9A%20vs%20over%20%E2%84%A4/near/218171656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Minimal.20polynomial.20over.20.E2.84.9A.20vs.20over.20.E2.84.A4.html#218171656">(Nov 28 2020 at 16:52)</a>:</h4>
<p>You mean defining <code>is_localization (R A  M: Type*) [comm_ring R] [comm_ring A] (M : submonoid R) (f : R →+* S)</code>?  This is exactly the kind of questions I have no idea how to answer, in my head this and <code>is_localization (R A  M: Type*) [comm_ring R] [comm_ring A] [algebra R A] (M : submonoid R)</code> are exactly the same thing.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Name.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html">Name?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="193345603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193345603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193345603">(Apr 08 2020 at 16:34)</a>:</h4>
<p>What are the proper names of the following two construction?</p>
<ol>
<li>Given a map <code>f : α → α</code>, consider the space of sequences <code>x : ℕ → α</code> such that <code>x n = f (x (n + 1))</code>; the left shift is an injective map on this space, and it is bijective if <code>f</code> was surjective.</li>
<li>Given a map <code>f : α → α</code>, consider the quotient of <code>ℕ × α</code> by <code>(n, x) ~ (n + 1, f x)</code>; if <code>f</code> was injective, then we have an embedding of <code>α</code> into this quotient and <code>f</code> lifts to a bijective map.</li>
</ol>
<p>Of course, both constructions can be generalized to an action of a monoid different from <code>multiplicative ℕ</code>.</p>



<a name="193345743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193345743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193345743">(Apr 08 2020 at 16:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> <span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span></p>



<a name="193351015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193351015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193351015">(Apr 08 2020 at 17:15)</a>:</h4>
<p>The sequences in 1 are the usual model for the (projective) limit of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo><mo>→</mo><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\cdots\to\alpha\to\alpha\to\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>, with all the maps being <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>.</p>



<a name="193351184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193351184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193351184">(Apr 08 2020 at 17:17)</a>:</h4>
<p>and the type in 2 is the usual model for the colimit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\alpha\to\alpha\to\alpha\to\cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>.</p>



<a name="193351659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193351659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193351659">(Apr 08 2020 at 17:20)</a>:</h4>
<p>Do we have some of these in <code>mathlib</code>?</p>



<a name="193352026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193352026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193352026">(Apr 08 2020 at 17:23)</a>:</h4>
<p>I guess we might well have general limits and colimits now, so perhaps the question reduces to (a) do we have the small category with objects indexed by nat and Hom(a,b)=(a&lt;=b) (or more generally do we have the small category associated to a preorder) and (b) do we have the machinery to define a functor from this nat category to an arbitrary category (e.g. Type) by just saying where the maps associated to a proof of a&lt;=succ(a) go.</p>



<a name="193352456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193352456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193352456">(Apr 08 2020 at 17:27)</a>:</h4>
<p>We have an instance <code>preorder.small_category</code>.</p>



<a name="193352690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193352690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193352690">(Apr 08 2020 at 17:28)</a>:</h4>
<p>So it would be an amusing exercise to define a functor from nat to Type sending all objects to alpha, and sending h:a&lt;=b to f^{b-a}, but whether this is in already I don't know.</p>



<a name="193352897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193352897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193352897">(Apr 08 2020 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/116395-maths/topic/Name.3F/near/193345603" title="#narrow/stream/116395-maths/topic/Name.3F/near/193345603">said</a>:</p>
<blockquote>
<p>What are the proper names of the following two construction?</p>
<ol>
<li>Given a map <code>f : α → α</code>, consider the space of sequences <code>x : ℕ → α</code> such that <code>x n = f (x (n + 1))</code>; the left shift is an injective map on this space, and it is bijective if <code>f</code> was surjective.</li>
</ol>
</blockquote>
<p>In general, one considers instead the space of sequences <code>y : \Z → α</code>such that <code>y (n + 1) = f (y n)</code> for all <code>n</code>. Noting that the values of such a sequence for <code>n &gt; 0</code> are completely determined by <code>y 0</code>, it suffices to fix the values <code>y n</code>for <code>n \le 0</code>, so this is clearly equivalent to you definition. This is called the natural extension of the original system.</p>
<blockquote>
<ol start="2">
<li>Given a map <code>f : α → α</code>, consider the quotient of <code>ℕ × α</code> by <code>(n, x) ~ (n + 1, f x)</code>; if <code>f</code> was injective, then we have an embedding of <code>α</code> into this quotient and <code>f</code> lifts to a bijective map.</li>
</ol>
</blockquote>
<p>I don't know a name for this one. It is a cousin of the suspension of <code>f</code> with roof function <code>r</code>, i.e., taking the quotient of <code>ℕ × α</code> by <code>(x, n + r(x)) ~ (f x, n)</code>.</p>



<a name="193353063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193353063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193353063">(Apr 08 2020 at 17:31)</a>:</h4>
<p>(deleted)</p>



<a name="193353243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193353243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193353243">(Apr 08 2020 at 17:33)</a>:</h4>
<ol start="2">
<li>is not really well behaved as it does not respect compatness. For instance, if <code>α</code> has two points and <code>f</code> is constant.</li>
</ol>



<a name="193353421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193353421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193353421">(Apr 08 2020 at 17:34)</a>:</h4>
<p>Sorry, you are assuming <code>f</code> is injective, so forget my comment.</p>



<a name="193353849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193353849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193353849">(Apr 08 2020 at 17:38)</a>:</h4>
<p>What does it look like if <code>α = [0, 1]</code> and <code>f (x) = x / 2</code>?</p>



<a name="193354992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193354992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193354992">(Apr 08 2020 at 17:48)</a>:</h4>
<ol start="2">
<li>looks like the inductive limit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>⊂</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo><mo>⊂</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo><mo>⊂</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">[0,1]\subset[0,2]\subset[0,4]\subset\cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> so it's <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbb{R}_{\geq0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.934069em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span>.</li>
</ol>



<a name="193355100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193355100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193355100">(Apr 08 2020 at 17:50)</a>:</h4>
<p>I'm assuming alpha isn't a list here ;-)</p>



<a name="193355230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/193355230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#193355230">(Apr 08 2020 at 17:51)</a>:</h4>
<p>I'm also assuming that things which are the same, are equal.</p>



<a name="229954976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229954976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229954976">(Mar 12 2021 at 00:41)</a>:</h4>
<p>How would you call the following object?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">i_need_a_name</span> <span class="o">(</span><span class="n">k</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bilin</span> <span class="o">:</span> <span class="n">bilin_form</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">lin</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">i_need_a_name</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f.bilin</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f.lin</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f.c</span><span class="o">⟩</span>
</code></pre></div>



<a name="229955393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229955393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229955393">(Mar 12 2021 at 00:45)</a>:</h4>
<p>Do you mean <code>.bilin x x</code>?</p>



<a name="229955681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229955681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229955681">(Mar 12 2021 at 00:48)</a>:</h4>
<p>Perhaps <code>affine_bilin_form</code>?</p>



<a name="229956719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229956719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229956719">(Mar 12 2021 at 00:58)</a>:</h4>
<p>You wouldn't call this anything, because it should be more generally defined using the tensor algebra.</p>



<a name="229956794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229956794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229956794">(Mar 12 2021 at 00:59)</a>:</h4>
<p>But if I had to choose a name, I think Heather's suggestion is good!</p>



<a name="229958211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958211">(Mar 12 2021 at 01:14)</a>:</h4>
<p>I guess the tensor version would look something like<code>(⨁ n : fin 3, ⨂[k] _ : fin n, E) →ₗ[k] E</code>, composed with a function mapping <code>x</code> to <code>1 + x + x ⊗ x</code></p>



<a name="229958275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958275">(Mar 12 2021 at 01:14)</a>:</h4>
<p>I mean, this is a special case of a linear map from the tensor algebra of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></p>



<a name="229958514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958514">(Mar 12 2021 at 01:17)</a>:</h4>
<p>how would you define <code>i_need_a_name.as_tensor_algebra_linear_map</code>?</p>



<a name="229958528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958528">(Mar 12 2021 at 01:17)</a>:</h4>
<p>Wait, not it's not. And I'm confused anyway. A bilinear form on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> takes values in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>. How do you add that to an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>?</p>



<a name="229958640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958640">(Mar 12 2021 at 01:18)</a>:</h4>
<p>I think there are problems with the above code.</p>



<a name="229958661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958661">(Mar 12 2021 at 01:18)</a>:</h4>
<p>I assume Yuri wanted a bilinear map, not a bilinear form.</p>



<a name="229958667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229958667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229958667">(Mar 12 2021 at 01:18)</a>:</h4>
<p>I guess I'd call it "rejected by the typechecker"</p>



<a name="229959392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229959392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229959392">(Mar 12 2021 at 01:26)</a>:</h4>
<p>The tensor algebra up to degree 2 looks like this:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>⊕</mo><mi>E</mi><mo>⊕</mo><mi>E</mi><msub><mo>⊗</mo><mi>k</mi></msub><mi>E</mi></mrow><annotation encoding="application/x-tex">k \oplus E \oplus E \otimes_k E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span><br>
So a linear map from this to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> consists of the following data:</p>
<ol>
<li>a bilinear map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>×</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">E \times E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>.</li>
<li>a linear map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">E \to E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>.</li>
<li>a constant in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>.</li>
</ol>



<a name="229959431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229959431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229959431">(Mar 12 2021 at 01:26)</a>:</h4>
<p>That's exactly what <code>i_need_a_name</code> is (or at least I assume it should be, if one replaces <code>bilin_form</code> with <code>bilin_map</code> or something like that)</p>



<a name="229983790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229983790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229983790">(Mar 12 2021 at 06:34)</a>:</h4>
<p>Note that the identification between bilinear forms and the tensor product only works in finite dimension. For instance, on a Hilbert space the scalar product is <em>not</em> an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mo>∗</mo></msup><mo>⊗</mo><msup><mi>E</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">E^* \otimes E^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.772026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> (because the elements of the tensor product have finite rank). So, if you want to do this in more general situations, the tensor product approach is not a good choice.</p>



<a name="229984576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%3F/near/229984576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.3F.html#229984576">(Mar 12 2021 at 06:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Name.3F/near/229958667">said</a>:</p>
<blockquote>
<p>I guess I'd call it "rejected by the typechecker"</p>
</blockquote>
<p>I'm sorry for the typos. Fixed now. <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>: I'm going to rewrite some of theorems about inner product in a Hilbert space in terms of this object. This is useful, e.g., to show (some day in the future) that the Dirichlet problem in the disc has a solution in the appropriate Sobolev space. In this case you have <code>f x = q x + l x + c</code> where <code>q</code> is a quadratic form (not necessarily the one coming from the inner product) and you need to minimize it. Another goal is to use theorems like <code>is_local_min_on.has_fderiv_within_at_eq_zero</code> instead of manually choosing <code>ε</code>s.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
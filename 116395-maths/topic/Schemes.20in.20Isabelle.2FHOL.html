---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html">Schemes in Isabelle/HOL</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235320332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235320332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235320332">(Apr 20 2021 at 10:25)</a>:</h4>
<p>I haven't finished reading this yet but this is good food for thought: <a href="https://arxiv.org/abs/2104.09366">https://arxiv.org/abs/2104.09366</a></p>



<a name="235320930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235320930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235320930">(Apr 20 2021 at 10:30)</a>:</h4>
<p>It's great to see this stuff happening in the other theorem provers -- especially Isabelle/HOL with its weaker logic (I was not at all convinced that this was even possible, and in some sense they'll still have to do more to convince me that it's usable, but this is a fabulous start). I would be in some sense less interested in seeing a Coq formalisation, because Coq's type theory is very close to Lean's so I am very confident that defining schemes in Coq would be possible. But I would also be very interested to see a formalisation in a HoTT prover, because for a while the HoTT people had convinced me that the problems we ran into with our initial approach would all be solved by HoTT, and it is only more recently that I decided that I'd had the wool pulled over my eyes (details: in HoTT R[1/fg]=R[1/f][1/g] so the issues we had with our original 2018 approach in Lean (we only had an isomorphism) look like they might not be there -- however after rewriting along this equality I realised that one still has to do the diagram chase! You now have two maps from some localisation to another and HoTT doesn't say that they're equal, so one still has to do the work which Kenny, Chris and I did)</p>



<a name="235322104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235322104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235322104">(Apr 20 2021 at 10:42)</a>:</h4>
<p>I too would be most interested to see this done in HoTT. The fact that <code>R[1/fg] = R[1/f][1/g] </code> (or <code>≃</code> depending on foundations) is, I guess, a minor mathematical result so I don't blame HoTT if I still have a diagram to chase. Maybe HoTT sets me up more conveniently to discharge this proof obligation, or maybe the opposite? I don't know!</p>



<a name="235322325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235322325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235322325">(Apr 20 2021 at 10:44)</a>:</h4>
<p>Despite remaining convinced that Lean is the way forward, I salute this work in Isabelle. It will be very interesting to see how we both scale. I think we're lucky to have something against which we can compare.</p>



<a name="235322657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235322657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Hauge <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235322657">(Apr 20 2021 at 10:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235320930">said</a>:</p>
<blockquote>
<p>It's great to see this stuff happening in the other theorem provers -- especially Isabelle/HOL with its weaker logic (I was not at all convinced that this was even possible, and in some sense they'll still have to do more to convince me that it's usable, but this is a fabulous start). I would be in some sense less interested in seeing a Coq formalisation, because Coq's type theory is very close to Lean's so I am very confident that defining schemes in Coq would be possible. But I would also be very interested to see a formalisation in a HoTT prover, because for a while the HoTT people had convinced me that the problems we ran into with our initial approach would all be solved by HoTT, and it is only more recently that I decided that I'd had the wool pulled over my eyes (details: in HoTT R[1/fg]=R[1/f][1/g] so the issues we had with our original 2018 approach in Lean (we only had an isomorphism) look like they might not be there -- however after rewriting along this equality I realised that one still has to do the diagram chase! You now have two maps from some localisation to another and HoTT doesn't say that they're equal, so one still has to do the work which Kenny, Chris and I did)</p>
</blockquote>
<p>That HoTT pitch kind of sounded suspicious because how could they have non-isomorphic line bundles for example if everything is equal?</p>



<a name="235322718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235322718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235322718">(Apr 20 2021 at 10:48)</a>:</h4>
<p>Great to see that we provoked them into doing this in Isabelle/HOL! :-)</p>



<a name="235323306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235323306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235323306">(Apr 20 2021 at 10:55)</a>:</h4>
<p>I'd love to hear any of our local experts who also know Isabelle/HOL give any comments they have on this paper.</p>



<a name="235323483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235323483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235323483">(Apr 20 2021 at 10:57)</a>:</h4>
<p>One thing that struck me was </p>
<blockquote>
<p>We seized the opportunity of formalizing schemes to build a new topology library<br>
despite the two existing formalizations of topology in Isabelle/HOL</p>
</blockquote>



<a name="235323765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235323765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235323765">(Apr 20 2021 at 11:00)</a>:</h4>
<p>Similarly they built off an experimental algebra library. In both cases this was driven by their desire to use "locales".</p>



<a name="235324583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235324583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235324583">(Apr 20 2021 at 11:06)</a>:</h4>
<p>AFAICT <code>locale</code> is as mundane in Isabelle/HOL as <code>structure</code> is in Lean.</p>



<a name="235327399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235327399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235327399">(Apr 20 2021 at 11:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> I'm confused by that comment. I guess here "locale" is being used in the mathematical sense of the word, as some sort of variation on topological space. Not in the sense of <code>open_locale</code> and other keywords, etc...</p>



<a name="235327497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235327497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235327497">(Apr 20 2021 at 11:33)</a>:</h4>
<p><span class="user-mention" data-user-id="403138">@Joachim Hauge</span> Who said everything is equal in HoTT? Only isomorphic things are equal.</p>



<a name="235327862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235327862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235327862">(Apr 20 2021 at 11:36)</a>:</h4>
<p>Yes, a <code>locale</code> in Isabelle is a mechanism to put together a bunch of different assumptions/results in one framework. You can instantiate a locale in a proof, by showing that some objects satisfy the assumptions in this locale, and then all the results of the locale become available.</p>



<a name="235327925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235327925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235327925">(Apr 20 2021 at 11:37)</a>:</h4>
<p>Aha, so I misunderstood what they are doing with locales. It's not the intuitionistic variant on topological spaces that they are talking about.</p>



<a name="235328078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235328078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235328078">(Apr 20 2021 at 11:38)</a>:</h4>
<p>Their desire to build a new topological space theory in Isabelle is certainly due to the fact that they can not use typeclasses. For instance, fibers of a topological vector bundle would not be types in Isabelle (as there are no dependent types), so instead you would see them as subsets of the total space of the fiber bundle, and then you want to talk about the topology on this subset. You can not use a typeclass here, so you have to rebuild everything from scratch in a different language. And locales probably give the right abstraction to be able to do this in a mildly convenient way.</p>



<a name="235328233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235328233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235328233">(Apr 20 2021 at 11:40)</a>:</h4>
<p>(I say mildly because, if you open the formalization, you will see that everything is very verbose since you can not rely on the system to infer the topology for you, so you have to provide it by hand in all statements).</p>



<a name="235331481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235331481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235331481">(Apr 20 2021 at 12:06)</a>:</h4>
<p>Now we need to raise the bar. In some sense we have less about schemes now than in 2019 because after Ramon's thesis Kenny did a bunch of stuff like gluing sheaves and Gamma Spec adjointness all of which needs to be redone because we changed the definition again (to something different -- we changed our definition of the structure sheaf from Stacks to Hartshorne which makes some things easier and some more difficult). There are plenty of interesting mini projects here but in some sense you can argue that Isabelle/HOL caught up with us right now. </p>
<p>Accessible future Lean projects:</p>
<p>1) isomorphism between R and global sections of Spec(R)<br>
2) global sections (ideally on category of locally ringed spaces) are adjoint to Spec<br>
3) Hartshorne exercise which glues sheaves on a top space<br>
4) existence of pullback squares in the category of schemes<br>
5) definition of affine morphisms, finite presentation morphisms, smooth morphisms, flat morphisms, étale morphisms... (all relatively easy in some sense because you just mindlessly copy the definition from a book), but...<br>
6) basic API for these notions. Specific example: prove that if X-&gt;Y is affine in the weak sense that there's an open cover of Y by affines whose preimage is affine, then it's affine in the strong sense that the preimage of every open affine is affine.</p>



<a name="235331581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235331581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235331581">(Apr 20 2021 at 12:06)</a>:</h4>
<p>Then we challenge mathematicians to do the same in Isabelle/HOL and see if we can get any more algebraic geometers involved</p>



<a name="235336479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235336479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Hauge <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235336479">(Apr 20 2021 at 12:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235327497">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="403138">Joachim Hauge</span> Who said everything is equal in HoTT? Only isomorphic things are equal.</p>
</blockquote>
<p>Sure but then the fibers of the line bundles are all equal but since it's possible to be equal in homotopically different ways this is not much better than any other type theory with decidable type checking. Thus bringing in question how it could help with Buzzard's complaint.</p>



<a name="235337552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235337552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235337552">(Apr 20 2021 at 12:49)</a>:</h4>
<p>HoTT's concept of equality is very different to Lean's, and in my experience very different to that of the generic mathematician. I'm not saying that's a bad thing, but it's just something to remember. Nowadays my mental model of HoTT is that it's Lean but with a more powerful rewrite command that rewrites along isomorphisms, and they happen to use the notation <code>=</code> for what we call <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span>.</p>



<a name="235337855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235337855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235337855">(Apr 20 2021 at 12:51)</a>:</h4>
<p>So we know <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>≅</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}\cong\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> and they write this as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> but big deal, they're not really equal in any useful sense, they just biject with each other. If you have a Diophantine equation about naturals then you can use their <code>rw</code> to turn it into what <em>looks</em> like a Diophantine equation over integers, but it's integers with a completely wacky <code>+</code> and <code>*</code> inherited from the naturals via the bijection you chose to rewrite along (different bijections give you different goals, of course, even though they all look identical)</p>



<a name="235337882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235337882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235337882">(Apr 20 2021 at 12:51)</a>:</h4>
<p>why does that not cause problems with things that are unique up to isomorphism, but not up to unique isomorphism?</p>



<a name="235337909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235337909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235337909">(Apr 20 2021 at 12:51)</a>:</h4>
<p>Because <code>=</code> doesn't mean <code>=</code></p>



<a name="235337984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235337984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235337984">(Apr 20 2021 at 12:52)</a>:</h4>
<p>that's some insanity, the ℕ ℤ stuff</p>



<a name="235338063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338063">(Apr 20 2021 at 12:52)</a>:</h4>
<p>We have things which are unique up to non-unique isomorphism and we're not bothered by this because for us <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> is data, it involves the choice of an isomorphism. In HoTT <code>=</code> is also data, things can be equal in more than one way, so it's just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mrel">≅</span></span></span></span> in disguise.</p>



<a name="235338224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338224">(Apr 20 2021 at 12:53)</a>:</h4>
<p>It's a theorem in Lean that if <code>h1 : a = b</code> and <code>h2 : a = b</code> then <code>h1 = h2</code> because "all proofs are equal". In HoTT this can fail. But in Lean we can have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>X</mi><mo>≅</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">i:X\cong Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>:</mo><mi>X</mi><mo>≅</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">j:X\cong Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\not=j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> as well.</p>



<a name="235338293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338293">(Apr 20 2021 at 12:54)</a>:</h4>
<p>We just have a cool extra thing which they don't have, called proof-irrelevant equality.</p>



<a name="235338336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338336">(Apr 20 2021 at 12:54)</a>:</h4>
<p>And they have a cool extra thing which we don't have, called rewriting along isomorphisms.</p>



<a name="235338386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338386">(Apr 20 2021 at 12:54)</a>:</h4>
<p>And they can probably make our thing in some way, and we can make their thing in some way using tactics</p>



<a name="235338437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338437">(Apr 20 2021 at 12:55)</a>:</h4>
<p>Is rewriting along isomorphisms any better than <code>equiv_rw</code> + suitable simp lemmas for the equivs?</p>



<a name="235338527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338527">(Apr 20 2021 at 12:56)</a>:</h4>
<p>Well yes, because to make <code>equiv_rw</code> work, you need to do quite a lot of things. In HoTT it's "for free".</p>



<a name="235338596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338596">(Apr 20 2021 at 12:56)</a>:</h4>
<p>I would be interested to hear from people who actually know what they're talking about (oh there's someone now) if they could say anything which my "model" of HoTT is missing, i.e. some extra useful functionality they have which my model doesn't make clear.</p>



<a name="235338890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338890">(Apr 20 2021 at 12:58)</a>:</h4>
<p>My feeling right now is that it's a bit like these "axiom schemes" they have in ZFC. You get something which isn't an axiom, but in fact a family of axioms, one for e.g. each mathematical statement which has some property. In another system you could imagine that this would be one axiom, but in ZFC it's an infinite family of axioms. It feels like the same here -- we have to prove infinitely many theorems, but they're of a similar form so ultimately if we need them we'll write a tactic to do it (and right now we've not really needed them, and have proved special cases by hand ourselves like "if X and Y are isomorphic topological spaces and X is compact then Y is compact", an example which is subject to the Mario counter anyway).</p>



<a name="235338993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235338993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235338993">(Apr 20 2021 at 12:59)</a>:</h4>
<p>[Mario observes that in an API for compact top spaces you want the result that if X surjects onto Y and X is compact then Y is compact, and the fact that compactness travels along isomorphisms is an easy consequence]</p>



<a name="235339409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235339409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235339409">(Apr 20 2021 at 13:01)</a>:</h4>
<p>My counter to the Mario counter was local rings. If A and B are isomorphic commutative rings and A is local, then B is local, and we will have to prove that as a lemma because it is not true that if A surjects onto B and A is local then B is local; indeed being local means "has a unique maximal ideal" so if B is the zero ring then it has too few maximal ideals so it's not local. However recently I discovered a fix for this! Say a ring is <em>prelocal</em> if it has at most 1 maximal ideal. Then a homomorphic image of a prelocal ring is prelocal, so you can get the result that locality travels along isomorphisms from the fact that nonzeroness travels along isomorphisms, which is easy.</p>



<a name="235341311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235341311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235341311">(Apr 20 2021 at 13:15)</a>:</h4>
<p>The above arguments are perhaps an indication that for the kind of maths we're doing, you can see that we can get away with not rewriting along isomorphisms and still go a long way. Anyway, back to Isabelle:</p>



<a name="235342052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235342052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235342052">(Apr 20 2021 at 13:20)</a>:</h4>
<p>The reason that my mental model of Isabelle said "schemes is impossible" is the following, and perhaps an Isabelle whizz can explain to me my mistake. The sheaf of rings on X, X a scheme, is the data of, for each U, a ring O(U). So it's a function from the open subsets of X to...something which Isabelle doesn't have (the category of rings). I can believe that one can use trickery to make some kind of object in HOL which in some way corresponds to this gadget, in the sense that it contains the same data as the gadget, perhaps packaged up in a clever way. However what was not at all clear to me was that one could now use Isabelle's type class system to say "O(U) is a ring for every U". </p>
<p>Oh -- a really important thing to add to my list of future work is sheaves of O-modules. This is again a fundamental construction in algebraic geometry -- a "continuously varying" family of modules M(U), with M(U) a module for O(U). We don't have these so I can't crow about it on Twitter, and the last time we talked about it we ended up in some category theory rabbithole from which I never emerged. Here is the definition of Picard group of a scheme which I want to give: take the monoid whose objects are isomorphism classes of sheaves of O-modules, with monoid law tensor product; the Picard group is the units of this monoid. In Lean if we define it like this we'll have universe issues. What issues will they have in Isabelle/HOL?</p>



<a name="235342100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235342100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235342100">(Apr 20 2021 at 13:20)</a>:</h4>
<p>If <code>X : Type u</code> then we'll get <code>Pic X : Type (u+1)</code> :-)</p>



<a name="235351596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235351596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235351596">(Apr 20 2021 at 14:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235342052">said</a>:</p>
<blockquote>
<p>However what was not at all clear to me was that one could now use Isabelle's type class system to say "O(U) is a ring for every U". </p>
</blockquote>
<p>You can't. So the scheme formalization does not use Isabelle's type class system. There are two coexisting algebraic hierarchies in Isabelle, one in terms of type classes, and the other one in terms of locale. The second one is: we have a subset of some big type, and a ring structure on this subset (with its own 1, its own 0, its own multiplication, and so on). This subset can not be interpreted as a type (for lack of dependent type), so you can not use a typeclass to express this ring structure. Indeed, in your big types, you have a lot of rings (one above each open set in the basis), while a typeclass should talk about a unique ring structure. So, to formalize schemes, you give up on type classes, and provide all the data about the ring every time you speak about the ring, because Isabelle can not infer it from you. Maybe I am oversimplifying, but if I understand correctly this is how they are doing things.</p>



<a name="235353485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235353485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235353485">(Apr 20 2021 at 14:34)</a>:</h4>
<p>But it seems that this <code>locale</code> thing allows you to bundle it together in some sense? I see some long-winded explicit passing-arounds of ringstructures, but other parts are quite concise.</p>



<a name="235359964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235359964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235359964">(Apr 20 2021 at 15:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235331481">said</a>:</p>
<blockquote>
<p>Now we need to raise the bar. In some sense we have less about schemes now than in 2019 because after Ramon's thesis Kenny did a bunch of stuff like gluing sheaves and Gamma Spec adjointness all of which needs to be redone because we changed the definition again (to something different -- we changed our definition of the structure sheaf from Stacks to Hartshorne which makes some things easier and some more difficult). There are plenty of interesting mini projects here but in some sense you can argue that Isabelle/HOL caught up with us right now. </p>
<p>Accessible future Lean projects:</p>
<p>1) isomorphism between R and global sections of Spec(R)<br>
2) global sections (ideally on category of locally ringed spaces) are adjoint to Spec<br>
3) Hartshorne exercise which glues sheaves on a top space<br>
4) existence of pullback squares in the category of schemes<br>
5) definition of affine morphisms, finite presentation morphisms, smooth morphisms, flat morphisms, étale morphisms... (all relatively easy in some sense because you just mindlessly copy the definition from a book), but...<br>
6) basic API for these notions. Specific example: prove that if X-&gt;Y is affine in the weak sense that there's an open cover of Y by affines whose preimage is affine, then it's affine in the strong sense that the preimage of every open affine is affine.</p>
</blockquote>
<p>In my eyes 3 and 4 could be pretty doable - what's the maths proof of 4?</p>



<a name="235360988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235360988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235360988">(Apr 20 2021 at 15:14)</a>:</h4>
<p>I think that the usual argument is to perform a series of reductions to reduce to the affine case. See for example <a href="https://rohilprasad.wordpress.com/2015/12/21/29/">https://rohilprasad.wordpress.com/2015/12/21/29/</a></p>



<a name="235361970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235361970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235361970">(Apr 20 2021 at 15:18)</a>:</h4>
<p>That's right -- do it in the affine case and glue (same with every proof from EGA)</p>



<a name="235363151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235363151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235363151">(Apr 20 2021 at 15:25)</a>:</h4>
<p>IMO the most pressing thing for schemes in mathlib is some sort of gluing construction</p>



<a name="235363476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235363476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235363476">(Apr 20 2021 at 15:26)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> do you have something resembling "descent data" in your topos project?</p>



<a name="235363697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235363697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235363697">(Apr 20 2021 at 15:28)</a>:</h4>
<p>I don't really understand what descent data means, so the answer is either no, or yes but indirectly</p>



<a name="235364298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235364298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235364298">(Apr 20 2021 at 15:31)</a>:</h4>
<p>Looking through the nlab page, I have that the sheaves are a reflective subcategory, and iirc I almost have that any reflective subcategory of the presheaves is equivalent to the sheaves on some topology</p>



<a name="235364434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235364434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235364434">(Apr 20 2021 at 15:32)</a>:</h4>
<p>Bhavik: schemes are some weird way of gluing rings together to make a geometric rather than an algebraic object. This "Spec" construction starts with a ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, like the polynomial ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo stretchy="false">[</mo><mi>T</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}[T]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">]</span></span></span></span>, and spits out a topological space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Spec(R)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> which is basically <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> with a weird topology (the cofinite one) and for each open subset the data of what a "polynomial function" is on that open set (so for example on the open set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>−</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>37</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}-\{0,37\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.77222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mclose">}</span></span></span></span> the function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>T</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>T</mi><mo stretchy="false">(</mo><mi>T</mi><mo>−</mo><mn>37</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(T^2+3)/T(T-37)^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> is a "polynomial function". You can glue schemes together on open subsets: for example if you glue one <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> with another one along their common <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>−</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}-\{0\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.77222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span></span></span></span> via the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>↦</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">z\mapsto 1/z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> then you've just made the Riemann sphere <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>∪</mo><mo stretchy="false">{</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}\cup\{\infty\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∞</span><span class="mclose">}</span></span></span></span>.</p>



<a name="235364574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235364574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235364574">(Apr 20 2021 at 15:33)</a>:</h4>
<p>If descent has anything to do with <a href="https://ncatlab.org/nlab/show/monadic+descent#properties">this</a> then Beck's monadicity theorem was in the topos project and is now in mathlib; though you might need to dualise to get cases which are useful for geometry?</p>



<a name="235364594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235364594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235364594">(Apr 20 2021 at 15:33)</a>:</h4>
<p>There is a general notion of descent, but the concrete version for schemes is described nicely here <br>
<a href="https://en.m.wikipedia.org/wiki/Gluing_schemes">https://en.m.wikipedia.org/wiki/Gluing_schemes</a></p>



<a name="235364671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235364671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235364671">(Apr 20 2021 at 15:33)</a>:</h4>
<p>The way products work is that in the affine case you show that the tensor product works, and this is not purely ring-theoretic because you need to understand what a map from a random scheme to an affine scheme looks like. Once you've done this, then you can start gluing general schemes together by doing tensor producting on an affine cover and then checking it all glues together. It's quite an ordeal! In Hartshorne's alg geom book it's presented as an 8 step process.</p>



<a name="235364897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235364897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235364897">(Apr 20 2021 at 15:35)</a>:</h4>
<p>For that gluing schemes Wikipedia page, if you want to understand it, just pretend "scheme" = "topological space", because already you see the key idea.</p>



<a name="235365193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365193">(Apr 20 2021 at 15:36)</a>:</h4>
<p>I suspect that doing that "simple" construction for topological spaces would be a challenge in dependent type theory. I say "simple" because if you were to explain that in class for top spaces you'd just say the proof was obvious, you just let X be the quotient of the disjoint union via the gluing phi_{ij} and you'd then claim that everything was obvious.</p>



<a name="235365195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365195">(Apr 20 2021 at 15:36)</a>:</h4>
<p>Is it reasonable to view this as like a <a href="https://en.wikipedia.org/wiki/Pasting_lemma">pasting lemma</a> but for schemes rather than spaces?</p>



<a name="235365257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365257">(Apr 20 2021 at 15:37)</a>:</h4>
<p>The pasting lemma is gluing sheaves</p>



<a name="235365326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365326">(Apr 20 2021 at 15:37)</a>:</h4>
<p>the difference between the descent and the pasting lemma is that with the pasting lemma you already have the top space -- it's just the union of X and Y.</p>



<a name="235365400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365400">(Apr 20 2021 at 15:38)</a>:</h4>
<p>With gluing schemes the X_i are arbitrary independent things so you have to make the type, not just the function on the type.</p>



<a name="235365564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365564">(Apr 20 2021 at 15:39)</a>:</h4>
<p>I see - so the summary is that I was very wrong to think 4 is more doable than the others!</p>



<a name="235365569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365569">(Apr 20 2021 at 15:39)</a>:</h4>
<p>Once you've done the gluing to make the space, you can then prove the universal property, which is that to give a function on X it suffices to give functions on the X_i which agree on the U_{ij} in the obvious sense (via the phi_{ij})</p>



<a name="235365946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235365946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235365946">(Apr 20 2021 at 15:41)</a>:</h4>
<p>and one direction of the universal property is the pasting lemma</p>



<a name="235366759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235366759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235366759">(Apr 20 2021 at 15:46)</a>:</h4>
<p>I got a bit lost in the discussion: I thought that 4 was pull-backs in the category of schemes.  Aren't those fibered products?  The discussion seems to be talking about gluing schemes along something, which seems more closely related to push-<em>out</em> diagrams, which are indeed harder.</p>



<a name="235366830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235366830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235366830">(Apr 20 2021 at 15:46)</a>:</h4>
<p>Pullbacks are constructed by gluing pullbacks of affine schemes</p>



<a name="235366960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235366960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235366960">(Apr 20 2021 at 15:47)</a>:</h4>
<p>Oh, I see: you are talking about how to define pull-backs, once you have pull-backs for affines!</p>



<a name="235366996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235366996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235366996">(Apr 20 2021 at 15:47)</a>:</h4>
<p>Ok, I agree: then you do have to glue affine schemes together and you have push-outs!</p>



<a name="235367020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367020">(Apr 20 2021 at 15:48)</a>:</h4>
<p>pushouts don't exist in general though :-(</p>



<a name="235367130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367130">(Apr 20 2021 at 15:48)</a>:</h4>
<p>No, but <em>these</em> kinds of push-outs are <code>[several thousands of lines of code]</code> obvious.</p>



<a name="235367185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367185">(Apr 20 2021 at 15:48)</a>:</h4>
<p>which is exactly why I had missed the point of talking about them!  <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="235367255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367255">(Apr 20 2021 at 15:49)</a>:</h4>
<p>Can you see the problem? To actually make the underlying type you take the disjoint union of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and then quotient out by the relation coming from the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, but then the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are not actually subsets, they're just injective maps into the quotient</p>



<a name="235367272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367272">(Apr 20 2021 at 15:49)</a>:</h4>
<p>It is quite amazing how much "functoriality" buys you for free.</p>



<a name="235367391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367391">(Apr 20 2021 at 15:50)</a>:</h4>
<p>and when I tried this once (admittedly when I was a lot more Lean-naive) I got in a real mess with things, because you constantly have an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">U_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> which you want to consider as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">U_{ji}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> and then of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">X_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and then of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and then of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>...</p>



<a name="235367441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367441">(Apr 20 2021 at 15:50)</a>:</h4>
<p>Yes, and I was horrified when I realized that constructing the integers as equivalence classes of naturals did not "simply contain" the naturals.  This is a whole different level!</p>



<a name="235367603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235367603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235367603">(Apr 20 2021 at 15:51)</a>:</h4>
<p>I am slowly starting to appreciate how much more detailed proof have to be, in order to be formalized.</p>



<a name="235368035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235368035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235368035">(Apr 20 2021 at 15:54)</a>:</h4>
<p>Do schemes even have elements!? <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="235368178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235368178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235368178">(Apr 20 2021 at 15:55)</a>:</h4>
<p>In fact <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> this reminds me of the conversation we were having the other day about those pentagon/hexagon axioms. This is another situation where you constantly want to move between a bunch of things which are "all the same thing" but actually doing the moving just piles up maps on top of maps. It would be interesting to prove the gluing lemma statement for topological spaces (you just literally replace "scheme" by "topological space" in the statement on the Wikipedia page, and "isomorphism" by "homeomorphism" if you like). In fact the Wikipedia page is already a bit unclear -- am I allowed i=j? If so, does U_{ii} have to be X_i? Does phi_{ii} have to be the identity map? [YES! But it doesn't say this?]</p>



<a name="235368712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235368712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235368712">(Apr 20 2021 at 15:58)</a>:</h4>
<p>There are funny examples in schemes, where you glue a projective scheme to itself along isomorphic proper closed subsets and the result is not projective anymore.  Producing such examples would be a great addition to the <code>counterexample</code> branch!</p>



<a name="235369058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235369058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235369058">(Apr 20 2021 at 16:00)</a>:</h4>
<p>I'm not sure that topological spaces is a good test, because <code>Top</code> has all colimits</p>



<a name="235369179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235369179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235369179">(Apr 20 2021 at 16:01)</a>:</h4>
<p>The hard part is proving that for these diagrams, the colimit on the level of topological spaces is again a scheme</p>



<a name="235370522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235370522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235370522">(Apr 20 2021 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235364671">said</a>:</p>
<blockquote>
<p>The way products work is that in the affine case you show that the tensor product works, and this is not purely ring-theoretic because you need to understand what a map from a random scheme to an affine scheme looks like. Once you've done this, then you can start gluing general schemes together by doing tensor producting on an affine cover and then checking it all glues together. It's quite an ordeal! In Hartshorne's alg geom book it's presented as an 8 step process.</p>
</blockquote>
<p>This is basically <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.right_adjoint_preserves_limits">docs#category_theory.adjunction.right_adjoint_preserves_limits</a> for the gamma-spec adjunction, right? (spec turns colimits into limits, hence tensor product into pullback)</p>



<a name="235371258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235371258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235371258">(Apr 20 2021 at 16:13)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> I think that's step 1 of the 8 :)</p>



<a name="235372703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235372703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235372703">(Apr 20 2021 at 16:22)</a>:</h4>
<p>Yeah, I cunningly mentioned Gamma-Spec adjunction before pullback squares :-)</p>



<a name="235376974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235376974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wenda Li <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235376974">(Apr 20 2021 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235351596">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235342052">said</a>:</p>
<blockquote>
<p>However what was not at all clear to me was that one could now use Isabelle's type class system to say "O(U) is a ring for every U". </p>
</blockquote>
<p>You can't. So the scheme formalization does not use Isabelle's type class system. There are two coexisting algebraic hierarchies in Isabelle, one in terms of type classes, and the other one in terms of locale. The second one is: we have a subset of some big type, and a ring structure on this subset (with its own 1, its own 0, its own multiplication, and so on). This subset can not be interpreted as a type (for lack of dependent type), so you can not use a typeclass to express this ring structure. Indeed, in your big types, you have a lot of rings (one above each open set in the basis), while a typeclass should talk about a unique ring structure. So, to formalize schemes, you give up on type classes, and provide all the data about the ring every time you speak about the ring, because Isabelle can not infer it from you. Maybe I am oversimplifying, but if I understand correctly this is how they are doing things.</p>
</blockquote>
<p>Thanks a lot for your detailed explanation of the difference between type classes and locales, Sebastien :-) To me, locales are more flexible/general than type classes, and we can freely switch from locales to type classes by instantiating some carrier sets. In this project, we avoided  type classes  to gain the flexibility from locales. It is true that with locales we need to do some instance proofs manually, but Sledgehammer turns out fairly capable with such obligations. One issue with locale is that we cannot introduce a type within a locale structure, but I guess in the future there could be some resolutions from Andrei Popescu's Types-to-Sets framework.</p>



<a name="235378970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235378970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235378970">(Apr 20 2021 at 17:02)</a>:</h4>
<p>Hi Wenda! I was just plotting about how to pull ahead of you guys again :-) Do you think you could do "sheaves of modules" in Isabelle? As you will know, a sheaf of rings on a topological space is a ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> attached to each open set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> (and satisfying some axioms). A sheaf of modules for this sheaf of rings is an abelian group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> attached to each open set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, plus an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, satisfying some axioms (the axioms for a sheaf of abelian groups, the axioms for modules over a ring, and an axiom saying that the actions are compatible with restriction maps).</p>



<a name="235390705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235390705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235390705">(Apr 20 2021 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> is working on turning <code>Spec</code> into a functor. So that would be (1.a) <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="235395589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235395589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235395589">(Apr 20 2021 at 18:52)</a>:</h4>
<p>Currently I'm proving the isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>R</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X(D(f))=R_f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, of which (1) is a special case. This is not strictly necessary to define <code>Spec</code> as a functor but it will be needed when proving adjointness of <code>Spec</code>. I think this exactly the part that's difficult in Hartshorns approach, because in Stacks, this is basically the definition of the structure sheaf. The proof is about one page in Hartshorne, which I've come to realize, is quite a lot when formlizing <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> <br>
I'm more than halfway through though</p>



<a name="235395727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235395727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235395727">(Apr 20 2021 at 18:53)</a>:</h4>
<p>(Ooh, I mean (2.a) instead of (1.a)...)</p>



<a name="235395991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235395991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235395991">(Apr 20 2021 at 18:54)</a>:</h4>
<p>Note that for the Stacks definition it is also not "by definition". You need to show that extending a sheaf from a basis doesn't "change" the values of the sheaf on the basis. Still seems to be a gory computation if you actually need to formalize it.</p>



<a name="235397314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235397314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235397314">(Apr 20 2021 at 19:03)</a>:</h4>
<p>Okay, but as soon as the sheaf theory has been set up, you essentially define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><msub><mi>R</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{O}_X(D(f)):=R_f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> and extend, don't you?<br>
I didn't mean to imply that the other approach would be easier of course. Since I wasn't around for the earlier iterations of Schemes in Lean, I'm happy to take your word that you had good reasons to switch :)</p>



<a name="235397364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235397364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235397364">(Apr 20 2021 at 19:03)</a>:</h4>
<p>Personally I find Hartshorne's definition more comprehensible</p>



<a name="235397896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235397896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235397896">(Apr 20 2021 at 19:06)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> No, I mean that "and extend" doesn't preserve the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O_X(D(f))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. So you will have to do a computation showing that some colimit preserves the thing up to isom. I'm sure it will be quite a bit shorter in Lean (at the expense of setting up sheaves over a basis). But you still need to do it. It's not defeq.</p>



<a name="235398333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235398333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235398333">(Apr 20 2021 at 19:09)</a>:</h4>
<p>Ah I think I see what you mean. I was using "by definition" more loosely in an informal way, not as defeq in Lean :)</p>



<a name="235398752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235398752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235398752">(Apr 20 2021 at 19:12)</a>:</h4>
<p>There will be some colimit thrown in the mix</p>



<a name="235402815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235402815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wenda Li <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235402815">(Apr 20 2021 at 19:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235378970">said</a>:</p>
<blockquote>
<p>Hi Wenda! I was just plotting about how to pull ahead of you guys again :-) Do you think you could do "sheaves of modules" in Isabelle? As you will know, a sheaf of rings on a topological space is a ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> attached to each open set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> (and satisfying some axioms). A sheaf of modules for this sheaf of rings is an abelian group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> attached to each open set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, plus an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, satisfying some axioms (the axioms for a sheaf of abelian groups, the axioms for modules over a ring, and an axiom saying that the actions are compatible with restriction maps).</p>
</blockquote>
<p>I cannot give an affirmative answer yet, as subtleties often arise when going through the actual formalisation. But, in general, I don't think there is any major obstacle here: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> is essentially a bunch of extra functions (i.e., from an open set to the carrier set of M, from an open set to the group operation). I am not quite sure what <code>an action of $$R(U)$$ on $$M(U)$$ </code> looks like, but as long as it can be encoded into some sorts of functions we should be good. After that, axioms are just some predicates on those operations/functions. I will check this with our math expert Anthony, and see if we can have the exact definition in Isabelle :-)</p>



<a name="235403009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235403009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235403009">(Apr 20 2021 at 19:41)</a>:</h4>
<p><code>an action of $$R(U)$$ on $$M(U)$$</code>: just the "vector space axioms" but without assuming that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> is a field.</p>



<a name="235409514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Schemes%20in%20Isabelle/HOL/near/235409514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL.html#235409514">(Apr 20 2021 at 20:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235339409">said</a>:</p>
<blockquote>
<p>My counter to the Mario counter was local rings. If A and B are isomorphic commutative rings and A is local, then B is local, and we will have to prove that as a lemma because it is not true that if A surjects onto B and A is local then B is local; indeed being local means "has a unique maximal ideal" so if B is the zero ring then it has too few maximal ideals so it's not local. However recently I discovered a fix for this! Say a ring is <em>prelocal</em> if it has at most 1 maximal ideal. Then a homomorphic image of a prelocal ring is prelocal, so you can get the result that locality travels along isomorphisms from the fact that nonzeroness travels along isomorphisms, which is easy.</p>
</blockquote>
<p>By the way, another way to think of this is that most mathematical notations have some kind of variance, and you only get an invariant notion if you combine operators with different variance. Being prelocal is covariant, and being nonzero is contravariant (because being zero is covariant), so being local is invariant.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
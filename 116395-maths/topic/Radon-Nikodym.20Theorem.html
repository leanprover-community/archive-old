---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Radon-Nikodym.20Theorem.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html">Radon-Nikodym Theorem</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210543843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210543843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Zinkevich <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210543843">(Sep 18 2020 at 16:28)</a>:</h4>
<p>Hello all,<br>
I am Martin Zinkevich, a research scientist at Google in machine learning. I was pointed to LEAN by a colleague last fall and I fell in love with it,<br>
in a big part because of the mathlib library.<br>
I am interested in formalizing the foundations of machine learning theory, and along those lines,<br>
I wrote a proof of the Lebesgue-Radon-Nikodym theorem for finite, unsigned measures:</p>
<p><a href="https://github.com/google/formal-ml/blob/master/src/formal_ml/radon_nikodym.lean">https://github.com/google/formal-ml/blob/master/src/formal_ml/radon_nikodym.lean</a></p>
<p>I would love to make this theorem part of mathlib, although I realize there is a lot of work on my part to be done to make that happen.<br>
I would also like to better understand the direction of the measure_theory portion of the library.</p>
<ol>
<li>I notice that there are very few uses of with_density. Is there an alternative elsewhere in the library?</li>
<li>The measure_theory.measure.integral was removed. What should I use to represent integration over measures?</li>
<li>Are signed measures going to appear soon, or are the non-finite signed measures too cumbersome?</li>
<li>
<p>Z3 is available for the vanilla version of LEAN. Are there plans to make it available for the community one? In particular, the ability to solve real<br>
   inequalities with Z3 would be awesome!</p>
</li>
<li>
<p>Having read over many of the files in mathlib, I still don't feel I understand where it is currently headed. Are there any RFCs that capture how the design is evolving, especially in the direction of probability and statistics?</p>
</li>
</ol>
<p>In the github package above, I also explored ideas like using a subtype of set to represent a measurable set or event, and using Pr[A] to represent the probability of an event A as a non-negative real. I am new to LEAN: what is the philosophy around when a subtype is appropriate and when a propositional function such as is_measurable should be used in its raw form?</p>
<p>Again, big fan,</p>
<p>-Marty</p>



<a name="210543964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210543964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210543964">(Sep 18 2020 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span></p>



<a name="210544008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210544008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210544008">(Sep 18 2020 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="247798">@Martin Zinkevich</span> Welcome! We are always happy to hear such stories!</p>



<a name="210544361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210544361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210544361">(Sep 18 2020 at 16:32)</a>:</h4>
<p>i'm not an expert on measure theory (in or outside of lean).</p>
<p>Re 5: we don't have many plans. people just work on whatever they like. maybe one of the only plans that is really sort of crystallized is that we want to formalize an entire undergraduate curriculum. progress is measured at <a href="https://leanprover-community.github.io/overview.html">https://leanprover-community.github.io/overview.html</a></p>



<a name="210544414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210544414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210544414">(Sep 18 2020 at 16:32)</a>:</h4>
<p>Unfortunately we don't have anything on probability/stochastics/statistics at the moment. This is mostly due to the fact that we don't have contributors interested in it.</p>



<a name="210544490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210544490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210544490">(Sep 18 2020 at 16:33)</a>:</h4>
<p>A little while ago, Yury did a massive refactor of integration theory. If anything was removed, it must have been replaced by something more general and or more powerful.</p>



<a name="210544930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210544930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210544930">(Sep 18 2020 at 16:37)</a>:</h4>
<p>This is an impressive amount of work! It's always exciting to see signs that Lean has a life outside of mathlib. Although, in this case, that life should definitely be absorbed at some point ;)</p>



<a name="210544980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210544980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210544980">(Sep 18 2020 at 16:37)</a>:</h4>
<p><a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/probability">Here's</a> a thread from a few months ago on probability theory (mostly the lack thereof) in Lean. Note the links to <span class="user-mention" data-user-id="116448">@Koundinya Vajjha</span>'s  repo (and <span class="user-mention" data-user-id="127136">@Alex J. Best</span>'s fork which updates it to a newer version of mathlib).</p>



<a name="210545132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210545132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210545132">(Sep 18 2020 at 16:38)</a>:</h4>
<blockquote>
<p>Z3 is available for the vanilla version of LEAN. Are there plans to make it available for the community one? In particular, the ability to solve real<br>
inequalities with Z3 would be awesome!</p>
</blockquote>
<p>As far as I know there was never a real connection to Z3. There was some very old work on an interface without proof reconstruction but I don't think it was ever used in production.</p>



<a name="210545212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210545212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210545212">(Sep 18 2020 at 16:39)</a>:</h4>
<p>We do have some other tactics for proving inequalities. But I have no idea how they compare to Z3.</p>



<a name="210545276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210545276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210545276">(Sep 18 2020 at 16:40)</a>:</h4>
<p>I don't think mathlib will ever accept Z3 proofs axiomatically.</p>



<a name="210562656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210562656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210562656">(Sep 18 2020 at 19:07)</a>:</h4>
<p>This is great! We definitely want the Radon-Nikodym Theorem in mathlib. I actually talked recently with <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> that we should include it at some point. PR's are very welcome (generally we encourage to start with some small PRs, so you can start my just making a PR with some supporting lemmas)!</p>
<p>To answer the questions that were not answered before:</p>
<ol>
<li><code>with_density</code> is just not used very much, I'm quite sure there is no alternative (because in that case, there should at the very least be lemmas and docstrings conneting these concepts). More properties about <code>with_density</code> are very welcome. More generally, you will notice that in all "leaves" of mathlib, important lemmas will be missing. Integration is definitely such a leaf.</li>
<li>I don't know what <code>measure_theory.measure.integral</code> was. Is it either <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral">docs#measure_theory.integral</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.lintegral">docs#measure_theory.lintegral</a>? If not, what was its type?</li>
<li>AFAIK there is no-one currently working on signed measures. However, if someone makes a PR with signed measures, that is definitely welcome to mathlib.</li>
</ol>



<a name="210563298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210563298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210563298">(Sep 18 2020 at 19:12)</a>:</h4>
<p>About the last question: when to use subtypes and when to use predicates: it really depends on which one is more convenient. We regularly refactor definitions going from one to the other. But generally I think it's more convenient to work with predicates on objects than to work with a subtype of these objects.<br>
However, this changes once you want to do operations on the subtype as a whole. For example, in most of the measure theory library we talk about functions <code>f : \a \to \b</code> with a predicate <code>measurable f</code>: most theorems are formulated with these extra conditions. However, in some cases (like <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.ae_eq_fun">docs#measure_theory.ae_eq_fun</a>) we want to take a quotient on all measurable functions. So then we talk about the subtype of measurable functions and take a quotient of that.</p>



<a name="210573383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210573383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210573383">(Sep 18 2020 at 20:46)</a>:</h4>
<p>I agree, it will be incredibly useful to have Radon-Nikodym in mathlib, in particular for defining conditional expectation. I am very impressed.</p>



<a name="210574981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210574981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210574981">(Sep 18 2020 at 21:02)</a>:</h4>
<p>Indeed it would be really nice to have this in mathlib! The good news is you won't have to PR 10000 lines, I can see thousands of lines that prove lemmas we already have in mathlib or in the core library. Your layout style is also pretty far from mathlib and adds a lot of lines, in particular lines containing only curly braces. See our <a href="https://leanprover-community.github.io/contribute/index.html">contribution guide</a>. I'm sure you'll enjoy what you'll learn while turning this work into something suitable for mathlib, even if this will be a lot of work.</p>



<a name="210595947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210595947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Zinkevich <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210595947">(Sep 19 2020 at 03:59)</a>:</h4>
<p>Don't worry, I won't dump a PR with 10,000 lines. :-)</p>
<p>The integral I was referring to was:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/87f8ab22d97dfa5f76be928ba3aefe7bc8da5e4e/src/measure_theory/integration.lean#L1247">https://github.com/leanprover-community/mathlib/blob/87f8ab22d97dfa5f76be928ba3aefe7bc8da5e4e/src/measure_theory/integration.lean#L1247</a><br>
It was basically a lower integral, but defined as a method of a measure. I liked it, but no big deal, there is a lot to do before I worry about what<br>
to replace it with.</p>
<p>I have already started cleaning up set.lean, identifying used and unused lemmas, and trying to find similar lemmas inside of mathlib and lean. I am pretty sure I can drop a few files wholesale, as mathlib has made progress since I started this project. </p>
<p>I created a short PR <a href="https://github.com/leanprover-community/mathlib/pull/4184">https://github.com/leanprover-community/mathlib/pull/4184</a> with a few theorems about sets. I'll take it slow until I learn more about the group's style and expectations.</p>
<p>Re: learning: I had never heard of lattice theory before working in Lean, and now it seems like the solution to everything. Hopefully, I will learn more about how mathematical fields connect, as well as metaprogramming and tactics, and just formal systems in general.</p>
<p>Stylistically (and I know this is a can of worms I am opening), I would love a tactic that handles any system of linear inequalities over the reals, nonnegative reals, and extended non-negative reals, rather than proving a bunch of individual theorems by hand. I don't know how to do that in Lean, but it definitely would be cool.</p>
<p>-Marty</p>



<a name="210596056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210596056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210596056">(Sep 19 2020 at 04:01)</a>:</h4>
<p>Do you know about <code>linarith</code> and <code>nlinarith</code>?</p>



<a name="210596651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210596651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210596651">(Sep 19 2020 at 04:18)</a>:</h4>
<p>See <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#linarith">tactic#linarith</a> and <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#nlinarith">tactic#nlinarith</a> .</p>



<a name="210708534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210708534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210708534">(Sep 21 2020 at 07:27)</a>:</h4>
<p>I've recently rewrote integrals API in mathlib. Now the main integral takes measure as an argument.</p>



<a name="210708605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210708605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210708605">(Sep 21 2020 at 07:28)</a>:</h4>
<p>So, just use <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.lintegral/src">src#measure_theory.lintegral</a></p>



<a name="210708664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210708664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210708664">(Sep 21 2020 at 07:29)</a>:</h4>
<p>Statements should use notation introduced right after the definition.</p>



<a name="210708755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210708755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210708755">(Sep 21 2020 at 07:30)</a>:</h4>
<p>As for signed measures, as far as I understand, the main difficulty is that you can't use the trick "any measure is an outer measure" anymore.</p>



<a name="210709165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/210709165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#210709165">(Sep 21 2020 at 07:35)</a>:</h4>
<p>So, you have three options: (a) make <code>μ</code> take <code>(h : is_measurable s)</code> as an argument; (b) define measure as a total function and introduce the equivalent relation "equivalent on measurable subsets"; (c) do (b), them take the quotient, and coerce to a function using <code>quotient.out</code></p>



<a name="211588036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/211588036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Zinkevich <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#211588036">(Sep 29 2020 at 07:23)</a>:</h4>
<p>Thank you! I started using nlinarith and linarith. I will looking into the tactic tutorials to see if I can build on those for nnreal and ennreal.</p>
<p>I refactored the measure theory part to use the definitions and notation suggested. I used measure_theory.simple_func.lintegral where possible.</p>
<p>I feel that it might be simplest to start with a related result about Radon-Nikodym, as it has fewer dependencies and a more obvious path.<br>
My worry is that the digression into topology may get bogged down.</p>
<p>I am not sure the name of this, but it is very useful for statistics, especially when considering the expectation of continuous random variables.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measure_theory.with_density.compose_eq_multiply</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">μ</span><span class="o">:</span><span class="n">measure_theory.measure</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span><span class="o">:</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span><span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">H2</span><span class="o">:</span><span class="n">measurable</span> <span class="n">g</span><span class="o">):</span>
 <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">∂</span> <span class="o">(</span><span class="n">μ.with_density</span> <span class="n">f</span><span class="o">)</span>  <span class="bp">=</span>  <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,(</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span><span class="o">)</span> <span class="n">a</span> <span class="bp">∂</span> <span class="n">μ</span> <span class="o">:=</span>
</code></pre></div>

<p>The proof structure is straightforward, building from a simple restricted function, to a simple function, to the lemma above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measure_theory.simple_func.restrict.compose_eq_multiply</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">μ</span><span class="o">:</span><span class="n">measure_theory.measure</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span><span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span><span class="o">:</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">ennreal</span><span class="o">):</span>
    <span class="n">is_measurable</span> <span class="n">S</span> <span class="bp">→</span>
    <span class="o">((</span><span class="n">measure_theory.simple_func.const</span> <span class="bp">Ω</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">lintegral</span> <span class="o">(</span><span class="n">μ.with_density</span> <span class="n">f</span><span class="o">)</span>
    <span class="bp">=</span> <span class="o">(</span><span class="bp">∫⁻</span> <span class="n">a</span><span class="o">:</span><span class="bp">Ω</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="o">((</span><span class="n">measure_theory.simple_func.const</span> <span class="bp">Ω</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict</span> <span class="n">S</span><span class="o">))</span> <span class="n">a</span> <span class="bp">∂</span> <span class="n">μ</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>

<p>There is also the concept of a "piece" of a simple function, but that seems like a natural detail on the way.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measure_theory.simple_func.compose_eq_multiply</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span> <span class="o">(</span><span class="n">μ</span><span class="o">:</span><span class="n">measure_theory.measure</span> <span class="bp">Ω</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span><span class="bp">Ω</span> <span class="bp">→</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span><span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span><span class="n">g</span><span class="o">:</span><span class="n">measure_theory.simple_func</span> <span class="bp">Ω</span> <span class="n">ennreal</span><span class="o">}:</span>
    <span class="n">g.lintegral</span> <span class="o">(</span><span class="n">μ.with_density</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∫⁻</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">g</span><span class="o">)</span> <span class="n">a</span> <span class="bp">∂</span> <span class="n">μ</span> <span class="o">:=</span>
</code></pre></div>

<p>This would allow me to learn more about the style in the measure theory section before going on a grand adventure.<br>
Thanks again for the wonderful feedback!</p>



<a name="211638761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/211638761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Zinkevich <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#211638761">(Sep 29 2020 at 15:37)</a>:</h4>
<p>Oh, and perhaps this is part of the "structure" of the proof too. I defined a piece of a restrict, but cutting that definition away, there is the theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">measure_theory.simple_func.sum_restrict</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
  <span class="o">(</span><span class="n">g</span><span class="o">:</span><span class="n">measure_theory.simple_func</span> <span class="bp">Ω</span> <span class="n">ennreal</span><span class="o">):</span>
  <span class="n">g</span> <span class="bp">=</span> <span class="n">g.range.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">measure_theory.simple_func.const</span> <span class="bp">Ω</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">restrict</span> <span class="o">(</span><span class="n">g</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">x</span><span class="o">}))</span> <span class="o">:=</span>
</code></pre></div>

<p>giving a connection between simple functions and VERY simple functions. Or, I could just start sending pull requests.</p>



<a name="211645986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/211645986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#211645986">(Sep 29 2020 at 16:24)</a>:</h4>
<p>I think that "start sending PRs" is a good idea.</p>



<a name="211646178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/211646178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#211646178">(Sep 29 2020 at 16:25)</a>:</h4>
<p>Note that it's OK to make a PR with several almost trivial defs/theorems that you're going to use in the future PR to prove something mathematically meaningful.</p>



<a name="212237974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Radon-Nikodym%20Theorem/near/212237974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Zinkevich <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Radon-Nikodym.20Theorem.html#212237974">(Oct 04 2020 at 19:32)</a>:</h4>
<p>Alright PR 4350 wraps up "compose_eq_multiply" (renamed lintegral_with_density_eq_lintegral_mul).<br>
<a href="https://github.com/leanprover-community/mathlib/pull/4350">https://github.com/leanprover-community/mathlib/pull/4350</a> </p>
<p>That was much compacted, and turned into a dozen lines of code when it was all done (thanks urkud!).</p>
<p>One step for Radon-Nikodym (if we are focusing on unsigned measures) is the following partition theorem, similar to the Hahn decomposition theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hahn_unsigned_inequality_decomp'</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">M</span><span class="o">:</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]</span>
    <span class="o">(</span><span class="n">μ</span> <span class="n">ν</span><span class="o">:</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">A1</span><span class="o">:</span><span class="n">measure_theory.finite_measure</span> <span class="n">ν</span><span class="o">]:</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="n">X</span><span class="o">:</span><span class="n">set</span> <span class="n">α</span><span class="o">,</span> <span class="n">is_measurable</span> <span class="n">X</span> <span class="bp">∧</span>  <span class="n">μ.restrict</span> <span class="n">X</span> <span class="bp">≤</span> <span class="n">ν.restrict</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">ν.restrict</span> <span class="o">(</span><span class="n">X</span><span class="bp">ᶜ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">μ.restrict</span> <span class="o">(</span><span class="n">X</span><span class="bp">ᶜ</span><span class="o">))</span> <span class="o">:=</span>   <span class="n">sorry</span>
</code></pre></div>

<p>This has independent value: it is useful in reasoning about subtraction, infimum, and supremum.</p>
<p>Or, we could jump to non-negative subtraction (defined analogously to ennreal.has_sub):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">measure_theory.measure.has_sub</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">measurable_space</span> <span class="n">α</span><span class="o">]:</span><span class="n">has_sub</span> <span class="o">(</span><span class="n">measure_theory.measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span><span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">d</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">b</span><span class="o">}⟩</span>

<span class="kd">lemma</span> <span class="n">decomposition_nonneg_sub</span> <span class="o">{</span><span class="bp">Ω</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">measurable_space</span> <span class="bp">Ω</span><span class="o">]</span>
    <span class="o">(</span><span class="n">μ</span> <span class="n">ν</span><span class="o">:</span><span class="n">measure_theory.measure</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span><span class="o">:</span><span class="n">set</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">[</span><span class="n">A1</span><span class="o">:</span><span class="n">measure_theory.finite_measure</span> <span class="n">μ</span><span class="o">]:</span>
    <span class="n">is_measurable</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">is_measurable</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">μ.restrict</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">ν.restrict</span> <span class="n">S</span> <span class="bp">→</span>
    <span class="n">ν.restrict</span> <span class="n">S</span><span class="bp">ᶜ</span> <span class="bp">≤</span> <span class="n">μ.restrict</span> <span class="n">S</span><span class="bp">ᶜ</span> <span class="bp">→</span>
    <span class="o">(</span><span class="n">ν</span> <span class="bp">-</span> <span class="n">μ</span><span class="o">)</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">ν</span> <span class="o">(</span><span class="n">S</span> <span class="bp">∩</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-</span> <span class="n">μ</span> <span class="o">(</span><span class="n">S</span> <span class="bp">∩</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>

<p>Both of these rely on showing that <code>{S|is_measurable S ∧ μ.restrict S ≤ ν.restrict S}</code> is a ring of sets closed under (measurable) subset and countable union.</p>
<p>-Marty</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
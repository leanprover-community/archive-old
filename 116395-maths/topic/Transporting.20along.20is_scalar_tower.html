---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html">Transporting along is_scalar_tower</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="252589683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252589683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252589683">(Sep 09 2021 at 08:31)</a>:</h4>
<p>Yesterday, I finally understood what all the fuss around scalar actions was about (thanks Eric for your talk!) and I'm now having thinking about them.<br>
Right now I'm wondering whether we can think of <code>is_scalar_tower</code> as saying "here is a scalar action of <code>α</code> on <code>β</code> and another one of <code>β</code> on <code>γ</code>, please make the scalar action of <code>α</code> on <code>γ</code> that associates" and how far that leads.<br>
For example, <code>[is_scalar_tower α β γ] [smul_with_zero α β] [smul_with_zero β γ]</code>and "every <code>c : γ</code> can be written as <code>b • c'</code>" gives <code>smul_with_zero α γ</code> because <code>(0 : α) • c = 0 • b • c' = (0 • b) • c' = 0 • c = 0</code> and <code>a • (0 : γ) = a • (0 • 0) = (a • 0) • 0 = 0 • 0 = 0</code>.<br>
What instances can we get like that, and what's the canonical way to express "every <code>c : γ</code> can be written as <code>b • c'</code>"?</p>



<a name="252590326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252590326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252590326">(Sep 09 2021 at 08:36)</a>:</h4>
<p>I think you're confusing the typeclass <a href="https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower">docs#is_scalar_tower</a> with the type synonym <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars">docs#restrict_scalars</a>. The latter has a new scalar action, which is more like your description, while the former takes three scalar actions and asserts they commute.</p>



<a name="252590570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252590570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252590570">(Sep 09 2021 at 08:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower/near/252589683">said</a>:</p>
<blockquote>
<p>For example, <code>[is_scalar_tower α β γ] [smul_with_zero α β] [smul_with_zero β γ]</code></p>
</blockquote>
<p>This doesn't type check, right? You first need 3 <code>has_scalar</code> instances, before you can talk about a <code>is_scalar_tower X Y Z</code></p>



<a name="252590785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252590785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252590785">(Sep 09 2021 at 08:40)</a>:</h4>
<p>Nono, I did mean <code>is_scalar_tower</code> (although maybe <code>restrict_scalars</code> is what I'm after. I can't tell). I meant to have scalar action instances on <code>α β</code> and <code>β γ</code>, <code>has_scalar α γ</code> and then use <code>is_scalar_tower α β γ</code> to populate the naked <code>has_scalar α γ</code>.</p>



<a name="252590922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252590922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252590922">(Sep 09 2021 at 08:41)</a>:</h4>
<p>No, that doesn't work.</p>



<a name="252591015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591015">(Sep 09 2021 at 08:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">is_scalar_tower</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_9</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_10</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_11</span><span class="o">)</span>
  <span class="o">[</span><span class="n">has_scalar</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">N</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">M</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="252591032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591032">(Sep 09 2021 at 08:42)</a>:</h4>
<p>How would the typeclass system figure out which <code>β</code> to fill into <code>is_scalar_tower α β γ</code>?</p>



<a name="252591060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591060">(Sep 09 2021 at 08:42)</a>:</h4>
<p><code>is_scalar_tower</code> is a <code>Prop</code> that asserts that 3 scalar actions are compatible.</p>



<a name="252591244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591244">(Sep 09 2021 at 08:44)</a>:</h4>
<p>So for example, you're asking: "if I have <code>algebra α β</code>, <code>algebra β γ</code> and a bare <code>has_scalar α γ</code> such that <code>is_scalar_tower α β γ</code>, can I automatically derive <code>algebra α γ</code>?", right?</p>



<a name="252591265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591265">(Sep 09 2021 at 08:44)</a>:</h4>
<p>Yeah exactly</p>



<a name="252591308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591308">(Sep 09 2021 at 08:45)</a>:</h4>
<p>The point of <code>is_scalar_tower α β γ</code> is not to <em>populate</em> <code>has_scalar α γ</code>, it's to indicate that an existing instance is propositionally equal to the obvious population</p>



<a name="252591415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591415">(Sep 09 2021 at 08:46)</a>:</h4>
<p>It would be a nice trick, but the answer is not really. Because there is no automatic way for the typeclass system to choose the <code>β</code> for which it works. I guess the closest you could come is have a tactic figure it out based on what is in the context.</p>



<a name="252591459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591459">(Sep 09 2021 at 08:46)</a>:</h4>
<p>or even just an instance as a def?</p>



<a name="252591466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591466">(Sep 09 2021 at 08:46)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.is_scalar_tower">docs#restrict_scalars.is_scalar_tower</a> says "The  populated <code>algebra R (restrict_scalars R S A)</code> you're asking for is compatible with <code>algebra R S</code> and <code>algebra S A</code>"</p>



<a name="252591519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591519">(Sep 09 2021 at 08:47)</a>:</h4>
<p>Ah so yeah, that's kind of what I was thinking about.</p>



<a name="252591549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591549">(Sep 09 2021 at 08:47)</a>:</h4>
<p>There are a few defs, like <a href="https://leanprover-community.github.io/mathlib_docs/find/is_integral_of_is_scalar_tower">docs#is_integral_of_is_scalar_tower</a>, that do something similar.</p>



<a name="252591583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591583">(Sep 09 2021 at 08:47)</a>:</h4>
<p>But they all have to work manually</p>



<a name="252591593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591593">(Sep 09 2021 at 08:47)</a>:</h4>
<p>It's usually a bad idea to actually put the instance on <code>γ</code> as in your example, because frequently there will already be an instance on <code>γ</code> elsewhere and your new instance will form a diamond</p>



<a name="252591651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591651">(Sep 09 2021 at 08:48)</a>:</h4>
<p>Which is why we use the type synonym <code>restrict_scalars</code></p>



<a name="252591817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591817">(Sep 09 2021 at 08:49)</a>:</h4>
<p>So when I have a lemma that requires the 3 instances, and the first two allow to derive the last and <strong>the last doesn't appear in the statement</strong>, should I still ask for the 3?</p>



<a name="252591893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591893">(Sep 09 2021 at 08:50)</a>:</h4>
<p>I understand that if it did appear then yes, definitely, for defeqness issues.</p>



<a name="252591959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252591959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252591959">(Sep 09 2021 at 08:50)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> We used to have <code>algebra.comp R A B</code> which was a type alias that made <code>B</code> into an <code>R</code> algebra. It created all sorts of defeq problems, and very ugly code.</p>



<a name="252592031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592031">(Sep 09 2021 at 08:51)</a>:</h4>
<p>So, given the current state of lean and mathlib, I'm very much in favour of: add all the (redundant) data by hand, and on top of that, ask for compatibilities using classes like <code>is_scalar_tower</code></p>



<a name="252592117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592117">(Sep 09 2021 at 08:52)</a>:</h4>
<p>And then the burden of proving them is left on the end user who is working with concrete structures?</p>



<a name="252592118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592118">(Sep 09 2021 at 08:52)</a>:</h4>
<p>In principle you could try deriving it in the body, but why not make a separate global instance? Then it would be less risk of accidentally ending up in the lemma statement, and available to further developments.</p>



<a name="252592256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592256">(Sep 09 2021 at 08:53)</a>:</h4>
<p>E.g. <a href="https://github.com/leanprover-community/mathlib/issues/8761">#8761</a> was originally an inline <code>letI : algebra _ _ := _</code> which I later put into its own instance.</p>



<a name="252592485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592485">(Sep 09 2021 at 08:55)</a>:</h4>
<p>I see I see. Thanks for the explanations!</p>



<a name="252592705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592705">(Sep 09 2021 at 08:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower/near/252591817">said</a>:</p>
<blockquote>
<p>So when I have a lemma that requires the 3 instances, and the first two allow to derive the last and <strong>the last doesn't appear in the statement</strong>, should I still ask for the 3?</p>
</blockquote>
<p>If the lemma statement only requires 2 of them and the third is only needed by the proof, then arguably constructing it with <code>restrict_scalars</code> inside the lemma proof is sometimes the right thing to do</p>



<a name="252592729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252592729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252592729">(Sep 09 2021 at 08:57)</a>:</h4>
<p>Indeed, this is quite common for downgrading complex-modules to real-modules I think</p>



<a name="252593805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transporting%20along%20is_scalar_tower/near/252593805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transporting.20along.20is_scalar_tower.html#252593805">(Sep 09 2021 at 09:06)</a>:</h4>
<p>But usually, you'll end up also wanting a lemma that _does_ need all three instances in the statement, and for that one you should _not_ use restrict_scalars and will need the appropriate global instance like in <span class="user-mention" data-user-id="238446">@Anne Baanen</span>'s linked PR.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
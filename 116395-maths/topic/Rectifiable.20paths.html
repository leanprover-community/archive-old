---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Rectifiable.20paths.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html">Rectifiable paths</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="316567779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316567779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316567779">(Dec 18 2022 at 10:48)</a>:</h4>
<p>Hey, I foolishly decided I would start a christmas project consisting in formalizing rectifiable paths, in order to talk about path length, length spaces, etc.<br>
My strategy was that partitions are defined using list of points as in the code below.<br>
My problem is that all those <code>length_on</code> lemmas are a real pain to prove: they get confusing and I have to do case analysis in most of the cases (see my WIP <a href="https://github.com/bottine/mathlib/blob/bottine/path_metric/src/topology/metric_space/path.lean">here</a>).<br>
Does anyone have a better idea on how to define length and rectifiability of paths?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.ennreal</span>
<span class="kn">import</span> <span class="n">data.real.nnreal</span>
<span class="kn">import</span> <span class="n">data.set.intervals.basic</span>
<span class="kn">import</span> <span class="n">topology.metric_space.emetric_space</span>
<span class="kn">import</span> <span class="n">topology.metric_space.basic</span>
<span class="kn">import</span> <span class="n">data.list.destutter</span>

<span class="kd">noncomputable theory</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">ennreal</span>

<span class="kn">open</span> <span class="n">emetric</span> <span class="n">nnreal</span> <span class="n">set</span>

<span class="c1">-- TODO: allow `[emetric_space α]`</span>

<span class="kn">namespace</span> <span class="n">function</span>

<span class="kn">section</span> <span class="n">length_on</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">α</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">length_on</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">nnreal</span>
<span class="bp">|</span> <span class="n">list.nil</span>      <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">_</span><span class="o">]</span>           <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nndist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">length_on</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">length_on_destutter</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">list.destutter</span> <span class="o">(</span><span class="bp">≠</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>


<span class="kd">lemma</span> <span class="n">length_on_reverse</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="n">l.reverse</span> <span class="bp">=</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">length_on</span>

<span class="kn">section</span> <span class="n">path_length</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">s</span><span class="o">)</span>

<span class="sd">/--</span>
<span class="sd">The path length of `f` is the supremum over all strictly increasing partitions `l`</span>
<span class="sd">of the length of `f` for `l`</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">path_length</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="bp">⨆</span> <span class="n">l</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">s</span> <span class="bp">|</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)},</span> <span class="n">f.length_on</span> <span class="n">l</span>

<span class="kd">lemma</span> <span class="n">path_length_mono</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">inclusion</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="n">f.path_length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">path_length_comp</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="n">f.path_length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">path_length_reparametrize</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">[</span><span class="n">monotone</span> <span class="n">φ</span><span class="o">]</span> <span class="o">[</span><span class="n">surjective</span> <span class="n">φ</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">=</span> <span class="n">f.path_length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">path_length_reparametrize_anti</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">[</span><span class="n">antitone</span> <span class="n">φ</span><span class="o">]</span> <span class="o">[</span><span class="n">surjective</span> <span class="n">φ</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">=</span> <span class="n">f.path_length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">path_length_glue_split</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.path_length</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">inclusion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.1</span> <span class="o">:</span> <span class="o">{</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">|</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)))</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">+</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">inclusion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.1</span> <span class="o">:</span> <span class="o">{</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">|</span> <span class="n">y</span> <span class="bp">≥</span> <span class="n">x</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)))</span><span class="bp">.</span><span class="n">path_length</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="sd">/--</span>
<span class="sd">A path is rectifiable if any of its restriction to a close interval has finite length</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">is_rectifiable</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">inclusion</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≠</span> <span class="bp">⊤</span>


<span class="kd">end</span> <span class="n">path_length</span>

<span class="kd">end</span> <span class="n">function</span>
</code></pre></div>



<a name="316568846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316568846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316568846">(Dec 18 2022 at 10:58)</a>:</h4>
<p>We <strong>could</strong> want to define <code>function.length_on (f : X -&gt; Y) (s : finset X) -&gt; R</code> but that would be more work I think</p>



<a name="316568855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316568855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316568855">(Dec 18 2022 at 10:58)</a>:</h4>
<p>How about defining it as "sum (zip_with nndist (map f l) (map f (tail l)))"? Or proving the two are the same</p>



<a name="316568896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316568896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316568896">(Dec 18 2022 at 10:59)</a>:</h4>
<p>Then you get all the lemmas about how tail, map, zip_with operate on cons, append, etc, "for free"</p>



<a name="316569022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316569022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316569022">(Dec 18 2022 at 11:00)</a>:</h4>
<p>l.pairwise le is spelled "sorted" iirc</p>



<a name="316569822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316569822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316569822">(Dec 18 2022 at 11:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/316568855">said</a>:</p>
<blockquote>
<p>How about defining it as "sum (zip_with nndist (map f l) (map f (tail l)))"? Or proving the two are the same</p>
</blockquote>
<p>I have this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">length_on_cons_list_append_cons</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span>
  <span class="n">f.length_on</span> <span class="o">([</span><span class="n">a</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">z</span><span class="o">])</span> <span class="bp">=</span> <span class="o">(</span><span class="n">list.map₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">nndist</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span><span class="o">))</span> <span class="o">([</span><span class="n">a</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">z</span><span class="o">]))</span><span class="bp">.</span><span class="n">sum</span>
</code></pre></div>
<p>but your phrasing might be better indeed: it handles empty or singleton lists without problem I assume.</p>



<a name="316570061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316570061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316570061">(Dec 18 2022 at 11:07)</a>:</h4>
<p>Would you <em>define</em> the length as this zippy thing, or keep the original?</p>



<a name="316570944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316570944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316570944">(Dec 18 2022 at 11:14)</a>:</h4>
<p>Since they're provably the same, does it matter?</p>



<a name="316570963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316570963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316570963">(Dec 18 2022 at 11:14)</a>:</h4>
<p>I'm assuming that proving monotonicity is easier in the sum form</p>



<a name="316573607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316573607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316573607">(Dec 18 2022 at 11:36)</a>:</h4>
<p>Rémi, are you familier with Yuri's work on Riemann-like integration? There are probably ideas to take <a href="https://drops.dagstuhl.de/opus/volltexte/2022/16732/">there</a>.</p>



<a name="316583239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316583239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316583239">(Dec 18 2022 at 12:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/316573607">said</a>:</p>
<blockquote>
<p>Rémi, are you familier with Yuri's work on Riemann-like integration? There are probably ideas to take <a href="https://drops.dagstuhl.de/opus/volltexte/2022/16732/">there</a>.</p>
</blockquote>
<p>Not familiar, no, thanks for the link!</p>



<a name="316601820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316601820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316601820">(Dec 18 2022 at 15:06)</a>:</h4>
<p>I think the definition is pretty solid, actually:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">path_length</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="bp">⨆</span> <span class="n">l</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">s</span> <span class="bp">|</span> <span class="n">l.sorted</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)},</span> <span class="n">f.length_on</span> <span class="n">l</span>


<span class="kd">lemma</span> <span class="n">_root_.list.map_sorted</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">l.sorted</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">sorted</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">list.pairwise.rec</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.map_nil</span><span class="o">,</span> <span class="n">list.sorted_nil</span><span class="o">],</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">l</span> <span class="n">hi</span> <span class="n">sl</span> <span class="n">hiφ</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span> <span class="n">rotate</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">a'</span> <span class="n">a'mem</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_map</span><span class="o">]</span> <span class="n">at</span> <span class="n">a'mem</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">al</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">a'mem</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">mφ</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hi</span><span class="o">,</span> <span class="n">exact</span> <span class="n">al</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_comp</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">path_length</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">supr₂_le_iff</span><span class="o">],</span>
  <span class="n">rintro</span> <span class="n">l</span> <span class="n">ls</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">f.length_on_map</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">@</span><span class="n">le_supr₂</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">↥</span><span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">list.sorted</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">l</span><span class="o">),</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">f.length_on</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">))</span>
    <span class="o">(</span><span class="n">l.map</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">l.map_sorted</span> <span class="n">mφ</span> <span class="n">ls</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_mono</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">inclusion</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">path_length_comp</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">hb</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_reparametrize</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">sφ</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">=</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">f.path_length_comp</span> <span class="n">φ</span> <span class="n">mφ</span><span class="o">,</span>

  <span class="c1">-- Yael should know a lemma for this</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ψ</span><span class="o">,</span><span class="n">φψ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">sφ.has_right_inverse</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">mψ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">ψ</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span> <span class="n">l</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">le_total</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">y</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">this</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">let</span> <span class="o">:=</span> <span class="n">mφ</span> <span class="o">(</span><span class="n">this</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">φψ</span> <span class="n">x</span><span class="o">,</span> <span class="n">φψ</span> <span class="n">y</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="n">l</span> <span class="n">this</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>

  <span class="c1">--have fc : (f ∘ φ) ∘ ψ = f := by { ext, simp, rw φψ x, },</span>
  <span class="c1">--nth_rewrite_lhs 0 ←fc,</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length_comp</span> <span class="n">ψ</span> <span class="n">mψ</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">comp_app</span><span class="o">,</span> <span class="n">φψ</span> <span class="n">x</span><span class="o">],</span>

<span class="kd">end</span>
</code></pre></div>



<a name="316601864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316601864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316601864">(Dec 18 2022 at 15:07)</a>:</h4>
<p>I wouldn't have thought reparametrization would be so easy to show.</p>



<a name="316622499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316622499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316622499">(Dec 18 2022 at 18:22)</a>:</h4>
<p>We already have the definition and the main properties, see <a href="https://leanprover-community.github.io/mathlib_docs/find/has_bounded_variation_on">docs#has_bounded_variation_on</a> and the results in this file.</p>



<a name="316622721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316622721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316622721">(Dec 18 2022 at 18:25)</a>:</h4>
<p>Ah, good, but too bad!</p>



<a name="316626443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316626443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316626443">(Dec 18 2022 at 19:02)</a>:</h4>
<p>Ahah, I love being called out in Lean comments <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="316626626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316626626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316626626">(Dec 18 2022 at 19:03)</a>:</h4>
<p>I'm sure there's a lemma for it, but I'll have to dig. If you're searching it before I get to a computer, try looking around <a href="https://leanprover-community.github.io/mathlib_docs/find/real.sqrt">docs#real.sqrt</a>, whose definition proceeds the exact same way as your argument.</p>



<a name="316697802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316697802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316697802">(Dec 19 2022 at 09:25)</a>:</h4>
<p>I'd have thought there is some <code>order</code> lemma I can use for that purpose, no?</p>



<a name="316700028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316700028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316700028">(Dec 19 2022 at 09:38)</a>:</h4>
<p>I suspect it will be a definition instead. But yeah</p>



<a name="316882317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316882317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316882317">(Dec 20 2022 at 06:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> I'm wondering: what made you decide on this formulation for rectifiability/bounded variation, in terms of infinite sums rather than the more "basic" version I'm trying?</p>



<a name="316890007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316890007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316890007">(Dec 20 2022 at 07:38)</a>:</h4>
<p>It's not in terms of infinite sums, it's in terms of finite sums indexed by <code>range n</code>. And the reason was probably that we already have a big API around sums indexed by <code>range n</code> (and also it's the way I'd write it in a math paper!). Lists are probably more natural from a computability point of view, but I don't care about computability :-) In fact I wouldn't say your version is more basic, maybe more CS-y</p>



<a name="316911242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316911242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316911242">(Dec 20 2022 at 09:52)</a>:</h4>
<p>Mmh, sorry, I didn't read in details enough it seems!</p>



<a name="316943833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316943833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316943833">(Dec 20 2022 at 12:56)</a>:</h4>
<p>I'm still trying to figure out rectifiability with lists as first presented, and <a href="https://gist.github.com/bottine/98a65ad2b2b73b483c5eaaeb9daf80ad">my code</a> has plenty of strange issues.</p>
<ul>
<li>Sometimes a single <code>simp</code> doesn't simplify enough.</li>
<li>The <a href="https://gist.github.com/bottine/98a65ad2b2b73b483c5eaaeb9daf80ad#file-rectifiable-lean-L59"><code>sorry</code> line 59</a> should be <code>refl</code> but that doesn't work.</li>
<li>Similarly <a href="https://gist.github.com/bottine/98a65ad2b2b73b483c5eaaeb9daf80ad#file-rectifiable-lean-L363">at line 363</a>.</li>
</ul>
<p>I tried extracting a MWE but the issue disappeared. There also is some general slowness working with this file. What can be going wrong?</p>



<a name="316955525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316955525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316955525">(Dec 20 2022 at 13:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Leaving aside my own trials, in <code>bounded_variation.lean</code>:</p>
<ul>
<li>I don't see anything about precomposing your function with a monotone function. Is there a reason for it? With may list approach it seems to work fine; it should be fine with yours too ?</li>
<li>I don't see anything about arc-length parametrization. Would that fit here or should some other file in geometry be a better place for it?</li>
</ul>



<a name="316955683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316955683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316955683">(Dec 20 2022 at 13:56)</a>:</h4>
<p>Since you've done plenty of the work already, I believe it's better for me to contribute on that codebase, hence my questions.</p>



<a name="316959745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316959745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316959745">(Dec 20 2022 at 14:13)</a>:</h4>
<p>There should be no problem to prove things for composition with monotone functions, it's just that I haven't needed it -- and it should be an essentially trivial consequence of the definition. As for arc-length parametrization, what you want is to get a parametrization which becomes an isometry on its domain, right? I think it would amount to composing with the inverse of the function <code>t -&gt; evariation_on f (Icc 0 t)</code> (or a real version of this one), but that would definitely require some work.</p>



<a name="316960647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316960647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316960647">(Dec 20 2022 at 14:17)</a>:</h4>
<p>Indeed, I think as long as the space is not pseudo-metric, then <code>evariation_on f (Icc 0 t) = evariation_on f (Icc 0 t')</code> implies <code>f t = f t'</code>, and the the arc-length parametrization is well-defined.</p>



<a name="316960767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316960767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316960767">(Dec 20 2022 at 14:17)</a>:</h4>
<p>I'm not exactly sure about what kind of domain we can have for <code>f</code>: would assuming an interval be general enough?</p>



<a name="316962516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316962516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316962516">(Dec 20 2022 at 14:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">φ</span><span class="o">)</span>
<span class="o">{</span><span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">F</span><span class="o">]</span>
<span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span>


<span class="kn">namespace</span> <span class="n">evariation_on</span>

<span class="kn">include</span> <span class="n">hφ</span>
<span class="kd">lemma</span> <span class="n">mono'</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">φ</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span><span class="o">)</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">ut</span><span class="o">⟩⟩,</span>
  <span class="n">exact</span> <span class="n">le_supr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
    <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="bp">∘</span> <span class="n">u</span><span class="o">,</span> <span class="n">hφ.comp</span> <span class="n">hu</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">φst</span> <span class="o">(</span><span class="n">ut</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">evariation_on</span>
</code></pre></div>



<a name="316962605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316962605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316962605">(Dec 20 2022 at 14:26)</a>:</h4>
<p>easy enough :)</p>



<a name="316963756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316963756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316963756">(Dec 20 2022 at 14:31)</a>:</h4>
<p>You should rather write it assuming only that phi is monotone on <code>t</code>, and your assumption phist is <code>mapsto phi t s</code>.</p>



<a name="316963962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316963962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316963962">(Dec 20 2022 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/316960767">said</a>:</p>
<blockquote>
<p>I'm not exactly sure about what kind of domain we can have for <code>f</code>: would assuming an interval be general enough?</p>
</blockquote>
<p>I'd start with an interval, prove everything in this setting, and then check afterwards if things are easy to generalize or not.</p>



<a name="316964289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316964289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316964289">(Dec 20 2022 at 14:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/316963756">said</a>:</p>
<blockquote>
<p>You should rather write it assuming only that phi is monotone on <code>t</code>, and your assumption phist is <code>mapsto phi t s</code>.</p>
</blockquote>
<p>Mmh, yeah, and I'm now troubled by trying to prove that if <code>\phi</code> maps <code>t</code> onto <code>s</code> then the evariation is equal. When not working with sets, you can just construct an inverse, but here I'll need to construct some kind of partial inverse with trash values outside of <code>s</code> I guess?</p>



<a name="316966666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316966666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316966666">(Dec 20 2022 at 14:44)</a>:</h4>
<p>Ah, I think the API around <code>surj_on</code> is complete enough… let me see.</p>



<a name="316967392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316967392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316967392">(Dec 20 2022 at 14:48)</a>:</h4>
<p>Note that even when working with sets you have to be careful when <code>\phi</code> is only monotone, not strictly monotone. There is still a good notion of pseudo-inverse, where <code>f^{-1}(x) = Sup {y \in s | f y &lt;= x}</code> (or the dual version), but I am not sure we have anything on that in mathlib. The order experts would know!</p>



<a name="316967785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316967785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316967785">(Dec 20 2022 at 14:49)</a>:</h4>
<p>Are you talking about the arc-length parametrization question, or my last comment. If it's my last comment, I don't think we need any strictness. At least I didn't in my initial attempt.</p>



<a name="316968436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316968436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316968436">(Dec 20 2022 at 14:52)</a>:</h4>
<p>I mean, I agree you don't need any strictness, but the intuition works better when you have strictness since you have a genuine inverse on <code>s / t</code>.</p>



<a name="316969527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316969527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316969527">(Dec 20 2022 at 14:57)</a>:</h4>
<p>The whole point of <code>u : nat -&gt; \alpha</code> and not <code>Fin n -&gt; \alpha</code> is to get rid of the empty/singleton list troubles I have, right?</p>



<a name="316977419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316977419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316977419">(Dec 20 2022 at 15:33)</a>:</h4>
<p>Looks like the adjoint functor theorem to me <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="316978886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316978886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316978886">(Dec 20 2022 at 15:40)</a>:</h4>
<p>Just adapted my previous code: is it only slow for me?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2022 Sébastien Gouëzel. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Sébastien Gouëzel</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">measure_theory.measure.lebesgue</span>
<span class="kn">import</span> <span class="n">analysis.calculus.monotone</span>
<span class="kn">import</span> <span class="n">analysis.bounded_variation</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">nnreal</span> <span class="n">ennreal</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">measure_theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">F</span><span class="o">]</span>
<span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span>


<span class="kn">namespace</span> <span class="n">evariation_on</span>

<span class="kd">lemma</span> <span class="n">comp_mono</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">φ</span> <span class="n">t</span> <span class="o">)</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="n">set.maps_to</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span><span class="o">)</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">ut</span><span class="o">⟩⟩,</span>
  <span class="n">exact</span> <span class="n">le_supr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
    <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span>
    <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="bp">∘</span> <span class="n">u</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span> <span class="n">hφ</span> <span class="o">(</span><span class="n">ut</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">ut</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="n">xy</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">φst</span> <span class="o">(</span><span class="n">ut</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">eq_of_eq_on</span> <span class="o">{</span><span class="n">f</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">set.eq_on</span> <span class="n">f</span> <span class="n">f'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">evariation_on</span> <span class="n">f'</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">comp_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">φ</span> <span class="n">t</span> <span class="o">)</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="n">set.maps_to</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">φsur</span> <span class="o">:</span> <span class="n">set.surj_on</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span><span class="o">)</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>

  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">comp_mono</span> <span class="n">f</span> <span class="n">φ</span> <span class="n">hφ</span> <span class="n">φst</span><span class="o">,</span> <span class="o">},</span>

  <span class="k">let</span> <span class="n">ψ</span> <span class="o">:=</span> <span class="n">φ.inv_fun_on</span> <span class="n">t</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ψφs</span> <span class="o">:</span> <span class="n">set.eq_on</span> <span class="o">(</span><span class="n">φ</span><span class="bp">∘</span><span class="n">ψ</span><span class="o">)</span> <span class="n">id</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">φsur.right_inv_on_inv_fun_on</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ψts</span> <span class="o">:</span> <span class="n">set.maps_to</span> <span class="n">ψ</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">φsur.maps_to_inv_fun_on</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hψ</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">ψ</span> <span class="n">s</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">y</span> <span class="n">ys</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">rcases</span>  <span class="n">le_total</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">y</span><span class="o">)</span> <span class="k">with</span> <span class="o">(</span><span class="n">ψxy</span><span class="bp">|</span><span class="n">ψyx</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">ψxy</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">let</span> <span class="o">:=</span> <span class="n">hφ</span> <span class="o">(</span><span class="n">ψts</span> <span class="n">ys</span><span class="o">)</span> <span class="o">(</span><span class="n">ψts</span> <span class="n">xs</span><span class="o">)</span> <span class="n">ψyx</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">function.comp_app</span> <span class="n">φ</span> <span class="n">ψ</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ψφs</span> <span class="n">xs</span><span class="o">,</span><span class="n">ψφs</span> <span class="n">ys</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="n">l</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">refl</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>

  <span class="n">change</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">id</span><span class="o">)</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">eq_of_eq_on</span> <span class="o">(</span><span class="n">ψφs.comp_left</span> <span class="o">:</span> <span class="n">set.eq_on</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">φ</span><span class="bp">∘</span><span class="n">ψ</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">id</span><span class="o">)</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">comp_mono</span> <span class="n">_</span> <span class="n">ψ</span> <span class="n">hψ</span> <span class="n">ψts</span><span class="o">,</span>
<span class="kd">end</span>


<span class="kd">end</span> <span class="n">evariation_on</span>
</code></pre></div>



<a name="316985788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316985788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316985788">(Dec 20 2022 at 16:12)</a>:</h4>
<p>Seems longer than necessary?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2022 Sébastien Gouëzel. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Sébastien Gouëzel</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">measure_theory.measure.lebesgue</span>
<span class="kn">import</span> <span class="n">analysis.calculus.monotone</span>
<span class="kn">import</span> <span class="n">analysis.bounded_variation</span>
<span class="kn">import</span> <span class="n">tactic.swap_var</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">nnreal</span> <span class="n">ennreal</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">measure_theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">F</span><span class="o">]</span>
<span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span>


<span class="kn">namespace</span> <span class="n">evariation_on</span>

<span class="kd">lemma</span> <span class="n">eq_of_eq_on</span> <span class="o">{</span><span class="n">f</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">set.eq_on</span> <span class="n">f</span> <span class="n">f'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">evariation_on</span> <span class="n">f'</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="n">work_on_goal</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">swap_var</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">f'</span><span class="o">,</span> <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h.symm</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">all_goals</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">us</span><span class="o">⟩⟩,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">x</span><span class="o">))</span> <span class="bp">=</span>
           <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f'</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f'</span> <span class="o">(</span><span class="n">u</span> <span class="n">x</span><span class="o">)),</span> <span class="kd">by</span>
    <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">funext</span> <span class="n">n</span><span class="o">,</span> <span class="n">congr</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">h</span> <span class="o">(</span><span class="n">us</span> <span class="bp">$</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_supr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
      <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f'</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f'</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span>
      <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">us</span><span class="o">⟩⟩,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>end evariation_on</p>



<a name="316995441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316995441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316995441">(Dec 20 2022 at 17:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">eq_of_eq_on</span> <span class="o">{</span><span class="n">f</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">set.eq_on</span> <span class="n">f</span> <span class="n">f'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">evariation_on</span> <span class="n">f'</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">evariation_on</span><span class="o">],</span>
  <span class="n">congr'</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">p</span> <span class="o">:</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">congr'</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="bp">;</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">p.2.2.2</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="316995697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316995697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316995697">(Dec 20 2022 at 17:02)</a>:</h4>
<p><code>comp_eq</code> is slow for me too, and it's the final <code>apply</code>. If you change it to <code>exact</code> it becomes fast.</p>



<a name="316995880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316995880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316995880">(Dec 20 2022 at 17:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/316969527">said</a>:</p>
<blockquote>
<p>The whole point of <code>u : nat -&gt; \alpha</code> and not <code>Fin n -&gt; \alpha</code> is to get rid of the empty/singleton list troubles I have, right?</p>
</blockquote>
<p>Not only empty or singletons. Also when gluing two sequences into a bigger sequences it will make your life easier. Avoiding dependent type hell is always a good idea. That's why summing over <code>range n</code> is almost always a better idea than summing over <code>fin n</code>.</p>



<a name="316996480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316996480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316996480">(Dec 20 2022 at 17:06)</a>:</h4>
<p>As Kevin says, changing <code>apply</code> to <code>exact</code> makes it fast. Also, it would probably be a good idea to extract the lemma saying that the inverse of a monotone_on map is monotone_on (your <code>hψ</code>). Otherwise, this looks very good and pretty efficient!</p>



<a name="316999076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/316999076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#316999076">(Dec 20 2022 at 17:21)</a>:</h4>
<p>I'll try arc-length parametrization tomorrow, and then I can try to play with the length metric and more complicated stuff.</p>



<a name="317089272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317089272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317089272">(Dec 21 2022 at 06:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/316995697">said</a>:</p>
<blockquote>
<p><code>comp_eq</code> is slow for me too, and it's the final <code>apply</code>. If you change it to <code>exact</code> it becomes fast.</p>
</blockquote>
<p>It seems that <code>apply</code> is never the right choice: <code>refine</code> is more intelligent and <code>exact</code> faster ?!</p>



<a name="317091291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317091291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317091291">(Dec 21 2022 at 06:35)</a>:</h4>
<p>I've unfortunately also heard of cases where apply was much faster than exact</p>



<a name="317226288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317226288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317226288">(Dec 21 2022 at 18:49)</a>:</h4>
<p>I want to work on the <code>bounded_variation</code> code-base since it's already there, but kept exploring my initial approach and <a href="https://github.com/bottine/mathlib/blob/bottine/path_metric/src/topology/metric_space/path.lean">it turned out to work quite well imo</a> :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- definition 'length_on' depends on 'ennreal.canonically_ordered_comm_semiring</span>
<span class="c1">-- so says lean</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">length_on</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span>
<span class="n">list.rec</span> <span class="mi">0</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">),</span>
      <span class="n">list.rec</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">ih'</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">),</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">ih</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">length_on_nil</span> <span class="o">:</span> <span class="n">f.length_on</span> <span class="n">list.nil</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">length_on_singleton</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.length_on</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">length_on_cons_cons</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.length_on</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">length_on_pair</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f.length_on</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on_cons_cons</span><span class="o">,</span> <span class="n">length_on_singleton</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">length_on_append_cons_cons</span> <span class="o">:</span>
   <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">])</span> <span class="bp">=</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">a</span><span class="o">])</span> <span class="bp">+</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">list.nil_append</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">list.singleton_append</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on_cons_cons</span><span class="o">,</span> <span class="n">list.cons_append</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">list.cons_append</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">length_on_append_cons_cons</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_le_length_on_cons</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f.length_on</span> <span class="bp">$</span> <span class="n">c</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">l</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">le_zero_iff</span><span class="o">],</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">],</span> <span class="n">apply</span> <span class="n">self_le_add_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_drop_second_cons_le</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">[]</span>  <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">length_on_le_length_on_cons</span><span class="o">,</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">c</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="bp">←</span><span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">add_le_add_right</span> <span class="o">(</span><span class="n">edist_triangle</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">f.length_on</span> <span class="o">(</span><span class="n">c</span> <span class="o">::</span> <span class="n">l</span><span class="o">)),</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_append</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="n">l'</span><span class="o">,</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="bp">+</span> <span class="n">f.length_on</span> <span class="n">l'</span> <span class="bp">≤</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.nil_append</span><span class="o">,</span> <span class="n">length_on</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span> <span class="n">exact</span> <span class="n">le_refl</span> <span class="o">(</span><span class="n">f.length_on</span> <span class="n">l'</span><span class="o">),</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.singleton_append</span><span class="o">,</span> <span class="n">length_on</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">length_on_le_length_on_cons</span><span class="o">,</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.cons_append</span><span class="o">,</span> <span class="n">length_on</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">length_on_append</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">l'</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_reverse</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="n">l.reverse</span> <span class="bp">=</span> <span class="n">f.length_on</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on_append_cons_cons</span><span class="o">,</span> <span class="bp">←</span><span class="n">length_on_reverse</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">),</span> <span class="n">list.reverse_cons</span><span class="o">,</span>
               <span class="n">list.append_assoc</span><span class="o">,</span> <span class="n">list.singleton_append</span><span class="o">,</span> <span class="n">length_on_cons_cons</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">edist_comm</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_map</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">γ</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">φ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">length_on</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">list.map_nil</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">list.map</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>  <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on_cons_cons</span><span class="o">,</span> <span class="n">list.map</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">,</span> <span class="bp">←</span><span class="n">length_on_map</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)],</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_le_append_singleton_append</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">x</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">length_on_le_length_on_cons</span><span class="o">,</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="n">x</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">length_on_drop_second_cons_le</span><span class="o">,</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">x</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">change</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">),</span>
    <span class="n">change</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">),</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">add_le_add_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)),</span>
    <span class="n">exact</span> <span class="n">length_on_le_append_singleton_append</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">x</span> <span class="n">l'</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_append_singleton_append</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">),</span>
    <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">l</span> <span class="bp">++</span> <span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="bp">+</span> <span class="n">f.length_on</span> <span class="o">([</span><span class="n">x</span><span class="o">]</span> <span class="bp">++</span> <span class="n">l'</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">x</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">list.nil_append</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">]}</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="n">x</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">list.singleton_append</span><span class="o">,</span> <span class="n">list.cons_append</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span>
               <span class="n">list.nil_append</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">x</span> <span class="n">l'</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on_cons_cons</span><span class="o">,</span> <span class="n">list.cons_append</span><span class="o">,</span> <span class="n">list.append_assoc</span><span class="o">,</span> <span class="n">list.singleton_append</span><span class="o">,</span>
    <span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">list.cons_append</span> <span class="n">b</span> <span class="n">l</span><span class="o">,</span> <span class="bp">←@</span><span class="n">list.singleton_append</span> <span class="n">_</span> <span class="n">x</span> <span class="n">l'</span><span class="o">,</span><span class="bp">←</span><span class="n">list.append_assoc</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">length_on_append_singleton_append</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">x</span> <span class="n">l'</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">length_on_mono'</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;+</span> <span class="n">l'</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f.length_on</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">l'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">list.sublist.slnil</span>             <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">le_zero_iff</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.sublist.cons</span>  <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">f.length_on_drop_second_cons_le</span> <span class="n">x</span> <span class="n">a</span> <span class="n">l₁</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">length_on_mono'</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.sublist.cons2</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">length_on_mono'</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">length_on_mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;+</span> <span class="n">l'</span> <span class="bp">→</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="bp">≤</span> <span class="n">f.length_on</span> <span class="n">l'</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">list.sublist.slnil</span>             <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">length_on</span><span class="o">,</span> <span class="n">le_zero_iff</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.sublist.cons</span>  <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">f.length_on_le_length_on_cons</span> <span class="n">a</span> <span class="n">l₁</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">$</span> <span class="n">f.length_on_mono'</span> <span class="n">s</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.sublist.cons2</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f.length_on_mono'</span> <span class="n">s</span> <span class="n">a</span>

<span class="kd">lemma</span> <span class="n">edist_le_length_on_of_mem</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">al</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">bl</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">l.pair_mem_list</span> <span class="n">al</span> <span class="n">bl</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">ab</span><span class="bp">|</span><span class="n">ba</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">edist_self</span><span class="o">,</span> <span class="n">zero_le'</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">length_on_pair</span><span class="o">],</span> <span class="n">exact</span> <span class="n">f.length_on_mono</span> <span class="n">ab</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">edist_comm</span><span class="o">,</span> <span class="n">length_on_pair</span><span class="o">],</span> <span class="n">exact</span> <span class="n">f.length_on_mono</span> <span class="n">ba</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">length_on</span>

<span class="kn">section</span> <span class="n">path_length</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">γ</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span>

<span class="sd">/--</span>
<span class="sd">The path length of `f` is the supremum over all strictly increasing partitions `l`</span>
<span class="sd">of the length of `f` for `l`</span>
<span class="sd">-/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">path_length</span> <span class="o">:</span> <span class="n">ennreal</span> <span class="o">:=</span>
  <span class="bp">⨆</span> <span class="n">l</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)},</span> <span class="n">f.length_on</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">sorted_list_nonempty</span> <span class="o">:</span> <span class="n">set.nonempty</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">|</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)}</span> <span class="o">:=</span> <span class="o">⟨[],</span><span class="n">list.pairwise.nil</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">path_length_comp_mono</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">path_length</span><span class="o">,</span> <span class="n">supr₂_le_iff</span><span class="o">,</span> <span class="bp">←</span><span class="n">f.length_on_map</span> <span class="n">φ</span><span class="o">],</span>
  <span class="n">rintro</span> <span class="n">l</span> <span class="n">ls</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">@</span><span class="n">le_supr₂</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">H</span><span class="o">,</span> <span class="n">f.length_on</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">list.pairwise.map</span> <span class="n">φ</span> <span class="n">mφ</span> <span class="n">ls</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_comp_anti</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">antitone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">path_length</span><span class="o">,</span> <span class="n">supr₂_le_iff</span><span class="o">,</span> <span class="bp">←</span><span class="n">f.length_on_map</span> <span class="n">φ</span><span class="o">],</span>
  <span class="n">rintro</span> <span class="n">l</span> <span class="n">ls</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">f.length_on_reverse</span><span class="o">,</span> <span class="bp">←</span><span class="n">list.map_reverse</span><span class="o">],</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">le_supr₂</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>  <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">H</span><span class="o">,</span> <span class="n">f.length_on</span> <span class="n">l</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">list.pairwise.map</span> <span class="n">φ</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.pairwise_reverse.mpr</span> <span class="n">ls</span><span class="o">),</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mφ</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_reparametrize_mono</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">sφ</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">=</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">f.path_length_comp_mono</span> <span class="n">φ</span> <span class="n">mφ</span><span class="o">,</span>

  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ψ</span><span class="o">,</span><span class="n">φψ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">sφ.has_right_inverse</span><span class="o">,</span>

  <span class="n">convert</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length_comp_mono</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">right_inverse_monotone</span> <span class="n">φ</span> <span class="n">mφ</span> <span class="n">ψ</span> <span class="n">φψ</span><span class="o">),</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">comp_app</span><span class="o">,</span> <span class="n">φψ</span> <span class="n">x</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_reparametrize_anti</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">mφ</span> <span class="o">:</span> <span class="n">antitone</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">sφ</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">=</span> <span class="n">f.path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">f.path_length_comp_anti</span> <span class="n">φ</span> <span class="n">mφ</span><span class="o">,</span>

  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">ψ</span><span class="o">,</span><span class="n">φψ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">sφ.has_right_inverse</span><span class="o">,</span>

  <span class="n">convert</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">path_length_comp_anti</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">right_inverse_antitone</span> <span class="n">φ</span> <span class="n">mφ</span> <span class="n">ψ</span> <span class="n">φψ</span><span class="o">),</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">comp_app</span><span class="o">,</span> <span class="n">φψ</span> <span class="n">x</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_ge_parts</span> <span class="o">(</span><span class="n">l</span> <span class="n">r</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">lr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">r</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">β</span><span class="o">))</span><span class="bp">.</span><span class="n">path_length</span>
  <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subtype</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">β</span><span class="o">))</span><span class="bp">.</span><span class="n">path_length</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f.path_length</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">ennreal.bsupr_add_bsupr_le</span> <span class="n">sorted_list_nonempty</span> <span class="n">sorted_list_nonempty</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">left</span> <span class="n">lefts</span> <span class="n">right</span> <span class="n">rights</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">length_on_map</span> <span class="n">f</span> <span class="n">coe</span><span class="o">],</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">f.length_on_append</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">path_length</span><span class="o">],</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">le_supr₂</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">H</span><span class="o">,</span> <span class="n">f.length_on</span> <span class="n">l</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mem_set_of</span><span class="o">,</span> <span class="n">list.pairwise_append</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">list.pairwise.map</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span> <span class="n">lefts</span><span class="o">,</span>
          <span class="n">list.pairwise.map</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span> <span class="n">rights</span><span class="o">,</span>
          <span class="bp">λ</span> <span class="n">x</span> <span class="n">xleft</span> <span class="n">y</span> <span class="n">yright</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_map</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span>
             <span class="n">exists_eq_right</span><span class="o">]</span> <span class="n">at</span> <span class="n">xleft</span> <span class="n">yright</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">xl</span><span class="o">,</span><span class="n">xleft</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">xleft</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">yr</span><span class="o">,</span><span class="n">yright</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">yright</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">lr</span> <span class="n">x</span> <span class="n">xl</span> <span class="n">y</span> <span class="n">yr</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_length_glue_split</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.path_length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span><span class="o">))</span><span class="bp">.</span><span class="n">path_length</span>
                <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">}</span> <span class="bp">→</span> <span class="n">β</span><span class="o">))</span><span class="bp">.</span><span class="n">path_length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">path_length</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">supr₂_le_iff</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">l</span> <span class="n">ls</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">list.take_while_append_drop</span> <span class="o">(</span><span class="bp">≤</span><span class="n">m</span><span class="o">)</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">length_on_le_append_singleton_append</span> <span class="n">f</span> <span class="n">_</span> <span class="n">m</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">length_on_append_singleton_append</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">add_le_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">transitivity'</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">)</span><span class="bp">.</span><span class="n">length_on</span> <span class="o">(</span><span class="n">l.take_while_subtype</span> <span class="n">m</span> <span class="bp">++</span> <span class="o">[⟨</span><span class="n">m</span><span class="o">,</span><span class="n">le_refl</span> <span class="n">m</span><span class="o">⟩]),</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">f.length_on_map</span> <span class="n">coe</span><span class="o">,</span> <span class="n">list.map_append</span><span class="o">,</span> <span class="n">list.take_while_subtype_map_coe</span><span class="o">],</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.map</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span> <span class="n">exact</span> <span class="n">le_refl</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="bp">@</span><span class="n">le_supr₂</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">H</span><span class="o">,</span> <span class="n">length_on</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.pairwise_append</span><span class="o">,</span> <span class="n">mem_set_of_eq</span><span class="o">,</span> <span class="n">list.mem_singleton</span><span class="o">],</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">list.take_while_subtype_pairwise_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">list.pairwise_singleton</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rintro</span> <span class="n">y</span> <span class="n">yl</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">list.take_while_subtype_le_base</span> <span class="n">m</span> <span class="n">l</span> <span class="n">y</span> <span class="n">yl</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">transitivity'</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">)</span><span class="bp">.</span><span class="n">length_on</span>
        <span class="o">([(⟨</span><span class="n">m</span><span class="o">,</span><span class="n">le_refl</span> <span class="n">m</span><span class="o">⟩</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">})]</span> <span class="bp">++</span> <span class="o">(</span><span class="n">l.drop_while_subtype_ge</span> <span class="n">m</span> <span class="n">ls</span><span class="o">)),</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">f.length_on_map</span> <span class="n">coe</span><span class="o">,</span> <span class="n">list.map_append</span><span class="o">,</span> <span class="n">list.drop_while_subtype_ge_map_coe</span><span class="o">],</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.map</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span> <span class="n">exact</span> <span class="n">le_refl</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="bp">@</span><span class="n">le_supr₂</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">l</span> <span class="n">H</span><span class="o">,</span> <span class="n">length_on</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">coe</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.singleton_append</span><span class="o">,</span> <span class="n">mem_set_of_eq</span><span class="o">,</span> <span class="n">list.pairwise_cons</span><span class="o">,</span>
                   <span class="n">subtype.mk_le_mk</span><span class="o">],</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">list.drop_while_subtype_ge_ge_base</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
                <span class="n">list.drop_while_subtype_ge_pairwise_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">},</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">path_length_ge_parts</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x</span> <span class="n">xm</span> <span class="n">y</span> <span class="n">my</span><span class="o">,</span> <span class="n">apply</span> <span class="n">le_trans</span> <span class="n">xm</span> <span class="n">my</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- `xm.trans my` doesn't work</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">path_length</span>

<span class="kd">end</span> <span class="n">function</span>
</code></pre></div>
<p>There is some sorried-out stuff hiding in a side file, but still, the code looks more concise than the one for <code>bounded_variation</code>, doesn't it?</p>



<a name="317305301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317305301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317305301">(Dec 22 2022 at 07:59)</a>:</h4>
<p>I removed many uses of linarith here : <a href="https://github.com/leanprover-community/mathlib/pull/17998">https://github.com/leanprover-community/mathlib/pull/17998</a></p>



<a name="317316252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317316252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317316252">(Dec 22 2022 at 09:11)</a>:</h4>
<p>I need this one to get that the path metric is symmetric.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comp_antitone_mono</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">antitone_on</span> <span class="n">φ</span> <span class="n">t</span> <span class="o">)</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="n">set.maps_to</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span><span class="o">)</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">ut</span><span class="o">⟩⟩,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span>
         <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="bp">$</span> <span class="n">n</span><span class="bp">-</span><span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="bp">$</span> <span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.range_zero</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="n">finset.sum_range_succ'</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_sub_succ_eq_sub</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">nat.succ_add_sub_one</span><span class="o">,</span> <span class="n">tsub_zero</span><span class="o">,</span>
               <span class="n">function.comp_app</span><span class="o">]</span> <span class="n">at</span> <span class="n">ih</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">nth_rewrite_rhs</span> <span class="mi">0</span> <span class="n">edist_comm</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">change</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ru</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">rut</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">ru</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">ut</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hru</span> <span class="o">:</span> <span class="n">antitone</span> <span class="n">ru</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">l</span><span class="o">,</span> <span class="n">hu</span> <span class="o">(</span><span class="n">n.sub_le_sub_left</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">le_supr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
    <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span>
    <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="bp">∘</span> <span class="n">ru</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span> <span class="n">hφ</span> <span class="o">(</span><span class="n">rut</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">rut</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hru</span> <span class="n">xy</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">φst</span> <span class="o">(</span><span class="n">rut</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="317316431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317316431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317316431">(Dec 22 2022 at 09:12)</a>:</h4>
<p>I agree that your code looks nice! You are a little bit reinventing the wheel at the beginning with your inductive definition of <code>length_on</code>, though: instead, you should probably use <code>list.sum</code> with some zip operation or whatever. Also, there is no subset in sight (you are considering increasing lists without requiring that the points belong to a subset <code>s</code>) -- you can work this around using subtypes, but from an API point of view the subset approach is probably better.</p>



<a name="317316658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317316658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317316658">(Dec 22 2022 at 09:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/317316252">said</a>:</p>
<blockquote>
<p>I need this one to get that the path metric is symmetric.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comp_antitone_mono</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">antitone_on</span> <span class="n">φ</span> <span class="n">t</span> <span class="o">)</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="n">set.maps_to</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span><span class="o">)</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">ut</span><span class="o">⟩⟩,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span>
         <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="bp">$</span> <span class="n">n</span><span class="bp">-</span><span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="bp">$</span> <span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.range_zero</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="n">finset.sum_range_succ'</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_sub_succ_eq_sub</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">nat.succ_add_sub_one</span><span class="o">,</span> <span class="n">tsub_zero</span><span class="o">,</span>
               <span class="n">function.comp_app</span><span class="o">]</span> <span class="n">at</span> <span class="n">ih</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">nth_rewrite_rhs</span> <span class="mi">0</span> <span class="n">edist_comm</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">change</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ru</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">rut</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">ru</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">ut</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hru</span> <span class="o">:</span> <span class="n">antitone</span> <span class="n">ru</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">l</span><span class="o">,</span> <span class="n">hu</span> <span class="o">(</span><span class="n">n.sub_le_sub_left</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">le_supr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
    <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span>
    <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="bp">∘</span> <span class="n">ru</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span> <span class="n">hφ</span> <span class="o">(</span><span class="n">rut</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">rut</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hru</span> <span class="n">xy</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">φst</span> <span class="o">(</span><span class="n">rut</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I think the <code>have</code> here probably should be covered by a lemma telling us that reversing doesn't change sums, but couldn't find it.</p>



<a name="317318099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317318099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317318099">(Dec 22 2022 at 09:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/317316431">said</a>:</p>
<blockquote>
<p>I agree that your code looks nice! You are a little bit reinventing the wheel at the beginning with your inductive definition of <code>length_on</code>, though: instead, you should probably use <code>list.sum</code> with some zip operation or whatever. Also, there is no subset in sight (you are considering increasing lists without requiring that the points belong to a subset <code>s</code>) -- you can work this around using subtypes, but from an API point of view the subset approach is probably better.</p>
</blockquote>
<p>Thanks!</p>
<ul>
<li>Regarding reinventing the wheel, yeah, Yakov proposed <code>sum (zip_with nndist (map f l) (map f (tail l)))</code> above, but after trying this, lemmas that are very simple by induction become quite messy (imo), because of the multiple unpackings you have to do, and the tail being defined by cases, etc.</li>
<li>Regarding subset: that's a "design choice" I didn't even think of at first. It could probably be changed easily.</li>
</ul>
<p>If it seems like this is a reasonable alternative, I'd be happy to work on it some more and eventually do a swap. Otherwise I'll continue using the original code.</p>



<a name="317345281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317345281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317345281">(Dec 22 2022 at 11:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">β</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">linear_order</span> <span class="n">α</span>
<span class="n">_inst_2</span><span class="o">:</span> <span class="n">linear_order</span> <span class="n">β</span>
<span class="n">E</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span>
<span class="n">_inst_3</span><span class="o">:</span> <span class="n">pseudo_emetric_space</span> <span class="n">E</span>
<span class="n">f</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span>
<span class="n">s</span><span class="o">:</span> <span class="n">set</span> <span class="n">α</span>
<span class="n">t</span><span class="o">:</span> <span class="n">set</span> <span class="n">β</span>
<span class="n">φ</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">hφ</span><span class="o">:</span> <span class="n">antitone_on</span> <span class="n">φ</span> <span class="n">t</span>
<span class="n">φst</span><span class="o">:</span> <span class="n">maps_to</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span>
<span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">u</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">hu</span><span class="o">:</span> <span class="n">monotone</span> <span class="n">u</span>
<span class="n">ut</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span>
<span class="bp">⊢</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">((</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">((</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span>
</code></pre></div>
<p>I'm trying to change <code>n-x-1+1</code> to <code>n-x</code> here. I tried using <code>conv</code> but getting to the term I want doesn't include the assumption <code>x&lt;n</code> necessary for this rewrite to be legal.</p>



<a name="317347197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317347197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317347197">(Dec 22 2022 at 11:55)</a>:</h4>
<p>You'll need to use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_congr">docs#finset.sum_congr</a></p>



<a name="317351644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317351644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317351644">(Dec 22 2022 at 12:18)</a>:</h4>
<p>Not much shorter, but at least there is no induction going on in <code>comp_antitone_mono</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">finset.sum_range_reverse</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">finset.range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="bp">$</span> <span class="n">n</span><span class="bp">-</span><span class="n">x</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.range_zero</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_range_succ</span><span class="o">,</span> <span class="n">finset.sum_range_succ'</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">nat.succ_sub_succ_eq_sub</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">nat.succ_add_sub_one</span><span class="o">,</span> <span class="n">tsub_zero</span><span class="o">,</span>
             <span class="n">function.comp_app</span><span class="o">]</span> <span class="n">at</span> <span class="n">ih</span> <span class="bp">⊢</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ih</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">comp_antitone_mono</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">antitone_on</span> <span class="n">φ</span> <span class="n">t</span> <span class="o">)</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="n">set.maps_to</span> <span class="n">φ</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span><span class="o">)</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">ut</span><span class="o">⟩⟩,</span>
  <span class="n">change</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">φ</span> <span class="bp">$</span> <span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.sum_range_reverse</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">finset.range</span> <span class="n">n</span> <span class="bp">→</span>
                  <span class="n">edist</span> <span class="o">((</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">((</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)))</span> <span class="bp">=</span>
                  <span class="n">edist</span> <span class="o">((</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))))</span> <span class="o">((</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)))</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">edist_comm</span><span class="o">,</span> <span class="n">nat.sub_one</span><span class="o">,</span> <span class="n">nat.add_one</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">nat.succ_pred_eq_of_pos</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">tsub_pos_iff_lt</span><span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">]</span> <span class="n">using</span> <span class="n">hx</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">finset.sum_congr</span> <span class="n">rfl</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ru</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">rut</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">ru</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">ut</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">i</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hru</span> <span class="o">:</span> <span class="n">antitone</span> <span class="n">ru</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">l</span><span class="o">,</span> <span class="n">hu</span> <span class="o">(</span><span class="n">n.sub_le_sub_left</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">le_supr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
    <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span>
    <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="bp">∘</span> <span class="n">ru</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span> <span class="n">hφ</span> <span class="o">(</span><span class="n">rut</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">rut</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hru</span> <span class="n">xy</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">φst</span> <span class="o">(</span><span class="n">rut</span> <span class="n">i</span><span class="o">)⟩⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="317375925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317375925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317375925">(Dec 22 2022 at 14:17)</a>:</h4>
<p>I think we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_range_reflect">docs#finset.sum_range_reflect</a>.</p>



<a name="317386163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317386163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317386163">(Dec 22 2022 at 15:01)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/18001">https://github.com/leanprover-community/mathlib/pull/18001</a></p>



<a name="317386427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317386427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317386427">(Dec 22 2022 at 15:02)</a>:</h4>
<p>As said in the PR comment, I just don't know where <a href="https://github.com/leanprover-community/mathlib/pull/18001/files#diff-8f83cd8df3866520321429cb8c1bd3cacfa4143220b468452c348458a11a5e3bR533">those lemmas about inverse of mono/antitone maps</a> should go.</p>



<a name="317386686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317386686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317386686">(Dec 22 2022 at 15:03)</a>:</h4>
<p>The naming is not set in stone, but anything longer seemed overkill.</p>



<a name="317401136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/317401136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#317401136">(Dec 22 2022 at 16:14)</a>:</h4>
<p>I'll work on the path metric now because it's more fun, but I think I'll need to add some lemmas to <code>bounded_variation</code>, e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">constant_on</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">subsingleton</span><span class="o">)</span> <span class="o">:</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span> <span class="n">_</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">ut</span><span class="o">⟩⟩,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">hf</span> <span class="o">⟨</span><span class="n">u</span> <span class="n">i</span><span class="o">,</span> <span class="n">ut</span> <span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">u</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ut</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">le_zero_iff</span><span class="o">,</span> <span class="n">finset.sum_eq_zero_iff</span><span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">,</span> <span class="n">this</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.subsingleton</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">constant_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">hs.image</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="318561016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318561016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318561016">(Dec 30 2022 at 11:00)</a>:</h4>
<p>I'm getting kind of stuck on very basic stuff:</p>
<ul>
<li>I tried at first to define the path length metric, and this works <a href="https://github.com/bottine/mathlib/blob/d7222d0221012aaccb02deb743c4d56e62121fdb/src/topology/metric_space/path_metric.lean">here</a>, but it's the bare minimum (just that we have a coarser(finer?) metric).</li>
<li>Then I wanted to attack facts such as the property that taking the length metric is idempotent, and that's where I got into troubles:</li>
<li>For this I need to show that the arc-length function is continuous on its parameters (under suitable assumptions), and </li>
<li>For <em>that</em> I need to say that given a continuous path with finite variation, I can cut its domain into pieces in a way given by uniform continuity, and then that I can cut it even finer, etc.</li>
<li>So I thought all this talk of partitions is not going to cut it if I work with monotonous maps <code>u : nat -&gt; E</code> as a basis for the variation.</li>
<li>So I tried to actually port the <code>bounded_variation.lean</code> file to work with lists, as I initially planned <a href="https://github.com/bottine/mathlib/blob/bottine/analysis.bounded_variation/using_lists/src/analysis/bounded_variation_path.lean">here</a>, but for all my biais in its favour, I can't really claim that I gain much by working with that new definition, and the port isn't even complete.</li>
</ul>



<a name="318564339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318564339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318564339">(Dec 30 2022 at 11:22)</a>:</h4>
<p>I still kind of like this list approach better since:</p>
<ul>
<li>There is a clear separation between everything that concerns finite approximations of length with lists (<code>function.length_on l</code>) and the variation proper, which is just an appropriate <code>supr</code>.</li>
<li>This makes proofs less bulky and made of more small lemmas, which I believe is preferred for mathlib?</li>
<li>(Not really an argument but:) with <code>finset.sort</code>, we should easily be able to talk about approximation on finsets instead of lists, which is maybe actually a good idea?</li>
</ul>
<p>I'm not sure it's necessarily going to help with the kind of thing I need to talk about idempotence of the length metric though.</p>
<p>I'd like to get some opinions on the best approach to continue working on this and actually get something off the ground.<br>
For instance, what would a lemma proving "given a path, there exists a partition of its domain such that the images in each part are at distance at most eps from each other" look like? Is it somewhere in mathlib?</p>
<p>Anyway, I think I spent too much time blindly trying to force things to typecheck, and should let things rest for a while…</p>



<a name="318616948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318616948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318616948">(Dec 30 2022 at 16:21)</a>:</h4>
<blockquote>
<p>given a path, there exists a partition of its domain such that the images in each part are at distance at most eps from each other</p>
</blockquote>
<p>You can use <a href="https://leanprover-community.github.io/mathlib_docs/find/compact_space.uniform_continuous_of_continuous">docs#compact_space.uniform_continuous_of_continuous</a> with <a href="https://leanprover-community.github.io/mathlib_docs/find/metric.uniform_continuous_iff">docs#metric.uniform_continuous_iff</a> and just partition the interval into pieces of length &lt; delta.</p>



<a name="318697252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318697252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318697252">(Dec 31 2022 at 07:29)</a>:</h4>
<p>Several comments:<br>
In the <code>bounded_variation_path</code> file:</p>
<ul>
<li>I think you can just define <code>length_on</code> of a <code>list E</code> without mentioning the map <code>f : α → E</code>, and use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.map">docs#list.map</a> when you have a <code>list α</code>.</li>
<li>If you use a pattern match definition of <code>length_on</code>, you can probably prove the three lemmas by <code>rw length_on</code>, so you won't need to write them out.</li>
<li>If you no longer want to replace the whole file <code>bounded_variation.lean</code> with your version based on lists, you still have the option of building APIs around the original definition, including defining <code>length_on</code> and showing the original<code> evariation_on</code> is the supremum of <code>length_on</code>.</li>
<li>For <code>monotone_on.evariation_on_le</code> (which you stuck on), you could show by induction that the <code>length_on</code> of an ordered <code>list ℝ</code> is equal to the last element minus the first element; monotonicity guarantees orderedness via <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise.map">docs#list.pairwise.map</a>.</li>
</ul>
<p>In the <code>path_metric</code> file:</p>
<ul>
<li><code>expand_bot/top_half</code> could be defined using <a href="https://leanprover-community.github.io/mathlib_docs/find/set.proj_Icc">docs#set.proj_Icc</a>, which is used to define <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a>.</li>
<li>For idempotency of the path length metric, I think the proof doesn't invoke continuity the arc-length function; you can take a look at Burago-Burago-Ivanov 2001, Proposition 2.3.12. You do need that <code>to_length_metric</code> is continuous, so a path continuous in the path length metric is also continuous under the original topology. Then the fact that the length of the concatenation of finitely many paths is equal to the sum of the lengths should suffice to complete the proof. You may want to allow paths to take any (not necessarily closed) interval in ℝ as domains, as is done in [BBI]; they also have an axiomatic definition of length structures in 2.1.1 that would apply to lengths from a Riemannian metric, I think, and may be what you're trying to do with <code>paths_with_lengths</code> in <a href="#narrow/stream/116395-maths/topic/Path.20metric/near/298925524">your other topic</a>.</li>
</ul>



<a name="318703526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318703526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318703526">(Dec 31 2022 at 08:54)</a>:</h4>
<p>In the meantime, I've got this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">edist_sub_of_le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">edist_comm</span><span class="o">,</span> <span class="n">edist_dist</span><span class="o">,</span> <span class="n">real.dist_eq</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">abs_eq_self</span><span class="o">,</span> <span class="n">sub_nonneg</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">ab</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">edist_triangle_eq_of_aligned</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">bc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">edist</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">function.length_on_le_edist_of_monotone_on</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">lm</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">(</span><span class="n">ls</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span>
    <span class="o">(</span><span class="n">hxy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">∧</span>  <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">),</span> <span class="n">f.length_on</span> <span class="n">l</span> <span class="bp">≤</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">lm</span> <span class="n">ls</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hxy</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">function.length_on_nil</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="n">lm</span> <span class="n">ls</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hxy</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">function.length_on_singleton</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">lm</span> <span class="n">ls</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hxy</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">list.pairwise_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">lm</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">aabl</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">l</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">bbl</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">b</span><span class="o">::</span><span class="n">l</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">babl</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">l</span> <span class="o">:=</span> <span class="n">or.inr</span> <span class="n">bbl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">function.length_on_cons_cons</span><span class="o">,</span>
    <span class="n">transitivity'</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="n">y</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">add_le_add_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">function.length_on_le_edist_of_monotone_on</span> <span class="n">lm.right</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">cl</span><span class="o">,</span> <span class="n">ls</span> <span class="n">_</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">cl</span><span class="o">)),</span>
      <span class="n">refine</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">cl</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,(</span><span class="n">hxy</span> <span class="n">_</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">cl</span><span class="o">))</span><span class="bp">.</span><span class="n">right</span><span class="o">⟩,</span>
      <span class="n">apply</span> <span class="n">hf</span> <span class="o">(</span><span class="n">ls</span> <span class="n">_</span> <span class="n">babl</span><span class="o">)</span> <span class="o">(</span><span class="n">ls</span> <span class="n">_</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">cl</span><span class="o">))</span>
              <span class="o">(</span><span class="n">list.pairwise.rel_first_of_mem_cons</span> <span class="n">is_refl.reflexive</span> <span class="n">lm.right</span> <span class="n">cl</span><span class="o">),</span> <span class="o">},</span>
    <span class="o">{</span>  <span class="n">rw</span> <span class="n">edist_triangle_eq_of_aligned</span> <span class="o">(</span><span class="n">hf</span> <span class="o">(</span><span class="n">ls</span> <span class="n">_</span> <span class="n">aabl</span><span class="o">)</span> <span class="o">(</span><span class="n">ls</span> <span class="n">_</span> <span class="n">babl</span><span class="o">)</span> <span class="o">(</span><span class="n">lm.left</span> <span class="n">b</span> <span class="n">bbl</span><span class="o">))</span> <span class="o">(</span><span class="n">hxy</span> <span class="n">b</span> <span class="n">babl</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←@</span><span class="n">edist_triangle_eq_of_aligned</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">y</span> <span class="o">(</span><span class="n">hxy</span> <span class="n">a</span> <span class="n">aabl</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span> <span class="o">(</span><span class="n">hxy</span> <span class="n">a</span> <span class="n">aabl</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">self_le_add_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">}</span>
  <span class="kd">end</span>
</code></pre></div>
<p>which is not too bad I believe.</p>



<a name="318714217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318714217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318714217">(Dec 31 2022 at 10:45)</a>:</h4>
<p>Thanks a lot for the feedback, it's very helpful!</p>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318697252">said</a>:</p>
<blockquote>
<ul>
<li>I think you can just define <code>length_on</code> of a <code>list E</code> without mentioning the map <code>f : α → E</code>, and use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.map">docs#list.map</a> when you have a <code>list α</code>.</li>
</ul>
</blockquote>
<p>Indeed, it didn't seem useful at first, but lately I've been thinking it's probably the right way forward (if continuing with lists at all); see code below.<br>
The <code>monotone_on.evariation_on_le</code> lemma (and your proposal for solving it) makes such an approach more natural.</p>
<blockquote>
<ul>
<li>If you use a pattern match definition of <code>length_on</code>, you can probably prove the three lemmas by <code>rw length_on</code>, so you won't need to write them out.</li>
</ul>
</blockquote>
<p>I had a pattern-match at first, but it built an ugly term (not at all just a double <code>list.rec</code>, and troubles later on).</p>
<blockquote>
<ul>
<li>If you no longer want to replace the whole file <code>bounded_variation.lean</code> with your version based on lists, you still have the option of building APIs around the original definition, including defining <code>length_on</code> and showing the original<code> evariation_on</code> is the supremum of <code>length_on</code>.</li>
</ul>
</blockquote>
<p>Good point. If people are not convinced by the list approach, I think I'll do that.</p>
<blockquote>
<ul>
<li>For <code>monotone_on.evariation_on_le</code> (which you stuck on), you could show by induction that the <code>length_on</code> of an ordered <code>list ℝ</code> is equal to the last element minus the first element; monotonicity guarantees orderedness via <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pairwise.map">docs#list.pairwise.map</a>.</li>
</ul>
</blockquote>
<p>One of the reasons I was stuck is the "last" and "first" element thing, which I kind of had trouble formulating in a nice and usable fashion.<br>
Also, all we really need here is that the list has "metric triangle equalities" all the ways, so that the sum is just a big "triangle line" and the sum "squashes".</p>
<p>So, I tried defining <code>length_on</code> on lists with no function in sight <a href="https://gist.github.com/bottine/252f6f059bc2cd7126cf03fe6316251c">here</a>, and it's indeed much better.<br>
Here is a snippet:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">@[protected]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">edist</span> <span class="o">:</span> <span class="n">list</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">ennreal</span> <span class="o">:=</span>
<span class="n">list.rec</span> <span class="mi">0</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">),</span>
      <span class="n">list.rec</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">ih'</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">),</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">ih</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">edist_nil</span> <span class="o">:</span> <span class="n">edist</span> <span class="o">(</span><span class="bp">@</span><span class="n">list.nil</span> <span class="n">E</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">edist_singleton</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">edist</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">edist_cons_cons</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">edist</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">edist_pair</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">edist</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">edist_cons_cons</span><span class="o">,</span> <span class="n">edist_singleton</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">edist_eq_zip_sum</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">E</span><span class="o">),</span> <span class="n">edist</span> <span class="n">l</span> <span class="bp">=</span> <span class="o">(</span><span class="n">list.zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">l</span> <span class="n">l.tail</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">edist_nil</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">edist_singleton</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">edist_cons_cons</span><span class="o">,</span> <span class="n">edist_eq_zip_sum</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">l</span><span class="o">)]</span>

<span class="c">/-</span><span class="cm"> [...] -/</span>

<span class="kd">lemma</span> <span class="n">edist_of_triangles_eq</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">edist</span> <span class="n">y</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span> <span class="n">l</span><span class="o">),</span>
    <span class="n">l.edist</span> <span class="bp">≤</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hl</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">edist_nil</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hl</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">edist_singleton</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hl</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">chain_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span>
  <span class="k">calc</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::</span><span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">edist</span>
     <span class="bp">=</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">edist</span> <span class="o">:</span> <span class="n">edist_cons_cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
  <span class="bp">...≤</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">edist</span> <span class="n">y</span> <span class="n">b</span>    <span class="o">:</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="bp">@</span><span class="n">edist_of_triangles_eq</span> <span class="o">(</span><span class="n">y</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">b</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span>
  <span class="bp">...=</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">b</span>                <span class="o">:</span> <span class="n">hl.2.1</span>
  <span class="bp">...≤</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">edist</span> <span class="n">x</span> <span class="n">b</span>    <span class="o">:</span> <span class="n">self_le_add_left</span> <span class="n">_</span> <span class="n">_</span>
  <span class="bp">...=</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span>                <span class="o">:</span> <span class="n">hl.1</span><span class="o">,</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">edist_self</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">hl.2.2</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- mathlib?</span>
<span class="kd">lemma</span> <span class="n">_root_.real.edist_triangle_eq_of_aligned</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">bc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">edist</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">edist_of_monotone_le_real</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">l.edist</span> <span class="bp">≤</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">l</span> <span class="n">hl</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">edist_of_triangles_eq</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hl</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">l</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pairwise.nil</span><span class="o">,</span> <span class="n">not_mem_nil</span><span class="o">,</span> <span class="n">forall_const</span><span class="o">,</span> <span class="n">chain.nil</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hl</span> <span class="n">hab</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pairwise_cons</span><span class="o">]</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">chain.cons</span>
      <span class="o">(</span><span class="n">_root_.real.edist_triangle_eq_of_aligned</span> <span class="o">(</span><span class="n">hab</span> <span class="n">l_hd</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">))</span><span class="bp">.</span><span class="n">left</span> <span class="o">(</span><span class="n">hab</span> <span class="n">l_hd</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">))</span><span class="bp">.</span><span class="n">right</span><span class="o">)</span>
      <span class="o">(</span><span class="n">l_ih</span> <span class="n">hl.right</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">xl</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l_tl</span><span class="o">),</span> <span class="o">⟨</span><span class="n">hl.left</span> <span class="n">x</span> <span class="n">xl</span><span class="o">,</span> <span class="o">(</span><span class="n">hab</span> <span class="n">x</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">xl</span><span class="o">))</span><span class="bp">.</span><span class="n">right</span><span class="o">⟩))},</span>
<span class="kd">end</span>
</code></pre></div>
<p>and then the variation is defined as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">function.evariation_on</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⨆</span> <span class="n">l</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">l.pairwise</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">},</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">edist</span>
</code></pre></div>
<p>I feel this definition of <code>edist</code> for lists has some value in its own; and then it's a good building block for the variation.<br>
Can I get some kind of show of hands on whether merging <code>list.edist</code>somewhere in <code>topology.metric_space</code> and then redefining <code>evariation_on</code> would be acceptable?</p>



<a name="318718897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318718897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318718897">(Dec 31 2022 at 11:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318697252">said</a>:</p>
<blockquote>
<ul>
<li><code>expand_bot/top_half</code> could be defined using <a href="https://leanprover-community.github.io/mathlib_docs/find/set.proj_Icc">docs#set.proj_Icc</a>, which is used to define <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a>.</li>
</ul>
</blockquote>
<p>Indeed, I saw <code>set.proj_Icc</code>, but I don't think it's used to define <code>path.trans</code> (at least, it's not referred to directly in the code).<br>
and actually, <code>proj_Icc</code> is not exactly what I need I believe. <br>
I think the right way to do <code>expand_bot/top_half</code> would be to have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">shrink</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">\</span><span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">expand</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">\</span><span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>that would shrink <code>Icc a b</code> to <code>Icc c d</code> and back, essentially, by fixing everything inside <code>Icc c d</code> and projecting the rest (the two maps would be monotone and inverse of each other on <code>Icc c d</code>).</p>
<blockquote>
<ul>
<li>For idempotency of the path length metric, I think the proof doesn't invoke continuity the arc-length function; you can take a look at Burago-Burago-Ivanov 2001, Proposition 2.3.12. You do need that <code>to_length_metric</code> is continuous, so a path continuous in the path length metric is also continuous under the original topology. Then the fact that the length of the concatenation of finitely many paths is equal to the sum of the lengths should suffice to complete the proof. You may want to allow paths to take any (not necessarily closed) interval in ℝ as domains, as is done in [BBI]; they also have an axiomatic definition of length structures in 2.1.1 that would apply to lengths from a Riemannian metric, I think, and may be what you're trying to do with <code>paths_with_lengths</code> in <a href="#narrow/stream/116395-maths/topic/Path.20metric/near/298925524">your other topic</a>.</li>
</ul>
</blockquote>
<p>For idempotency, I believed I needed continuity, but maybe I actually don't. I feel BBI are going a bit fast and loose, but you're probably right: I'll check it again (I had Bridson &amp; Haefliger as another reference).<br>
In any case, continuity of the arc-length is an important thing to have I believe.<br>
As for path structures, and arbitrary intervals, that's a question I have: I started with <code>path</code> because it's already in mathlib, and so it's easier to base stuff on that primitive, and I'm not sure what exactly there is to gain by allowing arbitrary intervals when doing the length metric.<br>
For now, I feel like it would probably be good to have "general" things in <code>bounded_variation.lean</code>, and, for <code>length_metric</code>, restrict stuff to path from the unit interval, so that we can reuse as much as possible.</p>
<p>As for the axiomatic definition in BBI, I thought it was probably too general to start with. Isn't it better to  start with <strong>one</strong> working instance of path length, and, if need be, generalize it when time comes?</p>



<a name="318762777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318762777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318762777">(Dec 31 2022 at 16:58)</a>:</h4>
<p>I think the main reason that proofs are bulky with the current definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/evariation_on">docs#evariation_on</a> is the lack of API around the gadget consisting of a monotone function <code>ℕ → α</code> (with junk values) and a natural number, for example there's no definition of concatenation of two gadgets like this, while we readily have that for lists. Maybe we should make it a structure and develop APIs around it, and the main question is whether it's more convenient to work with this structure or with lists. If they both have their advantages, we could develop API to go from a list to this structure and back: there's a natural way to fill in the junk values, by repeating the last non-junk value, which is nice.</p>
<p><a href="https://en.wikipedia.org/wiki/Absolute_continuity#Generalizations">The setup of absolute continuity</a> indicates that we should instead define the <code>edist</code> of a list of pairs, and apply it to <a href="https://leanprover-community.github.io/mathlib_docs/find/list.zip">docs#list.zip</a> of <code>l : list E</code> with its tail in the setting of arclength. For absolute continuity I think we'd be dealing directly with a <code>list (α × α)</code> which pairwisely satisfies the relation <code>r</code> with <code>r a b := a.2 ≤ b.1</code>. (We could use this to do arclength as well, but it's probably more complicated.) (Is absolute continuity what <a href="https://github.com/leanprover-community/mathlib/blob/14e80e85cbca5872a329fbfd3d1f3fd64e306934/docs/undergrad.yaml#L548">this undergraduate item</a> is about? It's also used in a general fundamental theorem of calculus and in the theory of quasiconformal maps, among others.)</p>
<blockquote>
<p>Indeed, I saw set.proj_Icc, but I don't think it's used to define path.trans (at least, it's not referred to directly in the code).</p>
</blockquote>
<p>Yeah it's not a direct reference. <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a> is defined using <a href="https://leanprover-community.github.io/mathlib_docs/find/path.extend">docs#path.extend</a>, which is defined using <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Icc_extend">docs#set.Icc_extend</a>, which is defined using <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Icc_proj">docs#set.Icc_proj</a>. <code>set.Icc_proj 0 1 _ (2 * t)</code> is the way to use the way to define <code>extend_bot_half</code> for example, see also <a href="https://github.com/leanprover-community/mathlib/pull/16029/files#diff-35443a946bfb4160c3be54ebb207d160a45de14bc441c0f691ee019be5e5e07dR93">here</a>. The advantage of allowing arbitrary intervals as domains of paths seem to be to allow a separation between affine transformation of ℝ and concatenation of intervals, but I agree it's hard to assess whether it leads to a simplification without actually working on it.</p>



<a name="318767670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318767670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318767670">(Dec 31 2022 at 17:53)</a>:</h4>
<blockquote>
<p>You do need that to_length_metric is continuous, so a path continuous in the path length metric is also continuous under the original topology. </p>
</blockquote>
<p>Oh sorry I got it backwards: <code>from_length_metric</code> is always continuous (Lipschitz constant 1) but not the other way. But the conclusion (a path continuous in the path length metric is also continuous under the original topology) is still true, because I made two mistakes in my mind and they cancel out :)</p>



<a name="318830913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318830913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318830913">(Jan 01 2023 at 08:42)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> <br>
I tried my hands at it and have completed a proof of the crucial arclength continuity lemma at <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34">https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34</a>. Still using the original <code>evariation_on</code> definition. Happy new year!</p>



<a name="318831050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831050">(Jan 01 2023 at 08:44)</a>:</h4>
<p>Bridson-Haefliger invokes uniform continuity but you can see from my proof that it's not necessary. I even only assume continuity at one point from one side.</p>



<a name="318831348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831348">(Jan 01 2023 at 08:49)</a>:</h4>
<p>Wow, impressive! Did you get the proof from BBI ?</p>



<a name="318831418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831418">(Jan 01 2023 at 08:50)</a>:</h4>
<p>No, the idea is still from BH.</p>



<a name="318831528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831528">(Jan 01 2023 at 08:52)</a>:</h4>
<p>I don't really get what the first lemma is for: it looks at first sight like it's a defeq from the definition of variation</p>



<a name="318831542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831542">(Jan 01 2023 at 08:52)</a>:</h4>
<p>(haven't run it yet, though)</p>



<a name="318831588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831588">(Jan 01 2023 at 08:53)</a>:</h4>
<p>What's your takaway from this proof you did? Should I then stick with the <code>N -&gt; E</code>-with-junk-values approach?</p>



<a name="318831830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831830">(Jan 01 2023 at 08:57)</a>:</h4>
<p>The first lemma allows you to only cosider summing over a nonempty range, with left endpoint of the interval as the first point, and with the first point less than the second point.</p>



<a name="318831841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318831841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318831841">(Jan 01 2023 at 08:57)</a>:</h4>
<p>Ah, indeed, thanks!</p>



<a name="318832117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318832117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318832117">(Jan 01 2023 at 09:00)</a>:</h4>
<p>From my working on the proof, my assessment is that the current definition is nice enough to work with.</p>



<a name="318832163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318832163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318832163">(Jan 01 2023 at 09:01)</a>:</h4>
<p>I was thinking we should define the arclength like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">_root_.has_locally_bounded_variation_on.variation_on_from_to</span>
 <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span>
<span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="k">then</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span> <span class="k">else</span> <span class="bp">-</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span>
</code></pre></div>
<p>because I'm not entirely sure it's useful to deal with the generality of infinite length when proving interesting stuff about arclength.</p>



<a name="318832225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318832225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318832225">(Jan 01 2023 at 09:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318832117">said</a>:</p>
<blockquote>
<p>From my working on the proof, my assessment is that the current definition is nice enough to work with.</p>
</blockquote>
<p>What about your comment on absolute continuity? I haven't had time to look at it closely yet.</p>



<a name="318833689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318833689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318833689">(Jan 01 2023 at 09:24)</a>:</h4>
<p>I went for ennreal-valued variation because it made the proofs much much easier: when you take a supremum over ennreal, you don't need to worry whether the thing you're maximizing over is nonempty and bounded above. In fact, my first try was real-valued, and it was way more painful. Once the API is there and you don't need to talk about suprema any more, switching to the real-valued version if it helps is definitely a possibility.</p>



<a name="318833983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318833983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318833983">(Jan 01 2023 at 09:29)</a>:</h4>
<p>(OK, I spent too much time trying to port it not to at least create a branch, so here goes in the eventuality it's ever useful <a href="https://github.com/leanprover-community/mathlib/compare/bottine/analysis.bounded_variation/using_lists?expand=1">https://github.com/leanprover-community/mathlib/compare/bottine/analysis.bounded_variation/using_lists?expand=1</a>)</p>



<a name="318834094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318834094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318834094">(Jan 01 2023 at 09:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Ah, I didn't mean to say that the evariation shouldn't be ennreal-valued, but thinking that when talking specifically about continuity of the arc-length and stuff, it may be easier to only assume <code>has_locally_bounded_variation_on</code> and get a real value, as in the def I wrote above.</p>



<a name="318834273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318834273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318834273">(Jan 01 2023 at 09:33)</a>:</h4>
<p>And if I'm not mistaken, I can use exactly this definition to <del>"simplify"</del> refactor your proof of the fact that a real function with locally finite variation is a difference of monotone functions: simply extract your <code>p</code> in the proof, which is just this function.</p>



<a name="318891213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318891213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318891213">(Jan 01 2023 at 18:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318832163">said</a>:</p>
<blockquote>
<p>I was thinking we should define the arclength like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">_root_.has_locally_bounded_variation_on.variation_on_from_to</span>
 <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span>
<span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="k">then</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span> <span class="k">else</span> <span class="bp">-</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span>
</code></pre></div>
<p>because I'm not entirely sure it's useful to deal with the generality of infinite length when proving interesting stuff about arclength.</p>
</blockquote>
<p>I think we shouldn't pass to real numbers too early, because we're gonna define the path length (pseudo_e)metric as the infimum of arclengths, and there could legitimately exist no (rectifiable) paths between two points, in which case we want the infimum to be infinity rather than 0 (a junk value), so we want ennreal/ereal rather than real. Using e(nn)real also allows you to take infimum over all (continuous) paths instead of only rectifiable paths, so one less condition to deal with.</p>



<a name="318892865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318892865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318892865">(Jan 01 2023 at 18:31)</a>:</h4>
<p>I agree with this, and in this case we can just use the variation itself.<br>
What I meant was that in the context of talking about the <strong>continuity</strong> of the arc-length, or its monotonicity as a signed function, we might as well restrict our attention to when it is finite, no?</p>



<a name="318892963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318892963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318892963">(Jan 01 2023 at 18:32)</a>:</h4>
<p>As below:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">has_locally_bounded_variation_on</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">variation_from_to</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="k">then</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span> <span class="k">else</span>
            <span class="bp">-</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_self</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">if_pos</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">),</span> <span class="n">Icc_self</span><span class="o">,</span> <span class="n">evariation_on.subsingleton</span><span class="o">,</span> <span class="n">ennreal.zero_to_real</span><span class="o">],</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hx.2.trans</span> <span class="n">hy.2.symm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_nonneg_of_le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to</span><span class="o">],</span> <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ennreal.to_real_nonneg</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_nonpos_of_ge</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="n">h</span> <span class="n">h_1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Icc_self</span><span class="o">,</span> <span class="n">evariation_on.subsingleton</span><span class="o">,</span> <span class="n">ennreal.zero_to_real</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hx.2.trans</span> <span class="n">hy.2.symm</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">right.neg_nonpos_iff</span><span class="o">,</span> <span class="n">ennreal.to_real_nonneg</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_eq_of_le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span> <span class="o">:=</span> <span class="n">if_pos</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_eq_of_ge</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">to_real</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to</span><span class="o">],</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="n">h</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Icc_self</span><span class="o">,</span> <span class="n">evariation_on.subsingleton</span><span class="o">,</span> <span class="n">ennreal.zero_to_real</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">neg_zero</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hx.2.trans</span> <span class="n">hy.2.symm</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_eq_neg_swap</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">hf.variation_from_to</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">ab</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="n">ba</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">ab.le</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">ab.not_le</span><span class="o">,</span> <span class="n">neg_neg</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to_self</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">variation_from_to</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">ba.le</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">ba.not_le</span><span class="o">,</span> <span class="n">neg_neg</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">variation_from_to_add</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">hf.variation_from_to</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">ab</span><span class="bp">|</span><span class="n">ba</span><span class="bp">;</span>
  <span class="n">rcases</span> <span class="n">le_total</span> <span class="n">a</span> <span class="n">c</span> <span class="k">with</span> <span class="n">ac</span><span class="bp">|</span><span class="n">ca</span><span class="bp">;</span>
  <span class="n">rcases</span> <span class="n">le_total</span> <span class="n">b</span> <span class="n">c</span> <span class="k">with</span> <span class="n">bc</span><span class="bp">|</span><span class="n">cb</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">ab</span><span class="o">,</span>
        <span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">bc</span><span class="o">,</span>
        <span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">ac</span><span class="o">,</span>
        <span class="bp">←</span><span class="n">ennreal.to_real_add</span> <span class="o">(</span><span class="n">hf</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hb</span> <span class="n">hc</span><span class="o">),</span>
        <span class="n">evariation_on.Icc_add_Icc</span> <span class="n">f</span> <span class="n">ab</span> <span class="n">bc</span> <span class="n">hb</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hf.variation_from_to_eq_of_ge</span> <span class="n">cb</span><span class="o">,</span>
        <span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">ab</span><span class="o">,</span>
        <span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">ac</span><span class="o">,</span>
        <span class="bp">←</span><span class="n">sub_eq_add_neg</span><span class="o">,</span>
        <span class="n">sub_eq_iff_eq_add</span><span class="o">,</span>
        <span class="bp">←</span><span class="n">ennreal.to_real_add</span> <span class="o">(</span><span class="n">hf</span> <span class="n">a</span> <span class="n">c</span> <span class="n">ha</span> <span class="n">hc</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">c</span> <span class="n">b</span> <span class="n">hc</span> <span class="n">hb</span><span class="o">),</span>
        <span class="n">evariation_on.Icc_add_Icc</span> <span class="n">f</span> <span class="n">ac</span> <span class="n">cb</span> <span class="n">hc</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">ab.trans</span> <span class="n">bc</span><span class="o">)</span> <span class="n">ca</span><span class="o">,</span> <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="n">ab</span> <span class="n">bc</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hf.variation_from_to_self</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">ab</span><span class="o">,</span>
        <span class="n">hf.variation_from_to_eq_of_ge</span> <span class="n">ca</span><span class="o">,</span>
        <span class="n">hf.variation_from_to_eq_of_ge</span> <span class="n">cb</span><span class="o">,</span>
        <span class="bp">←</span><span class="n">sub_eq_add_neg</span><span class="o">],</span>
    <span class="n">rw</span>  <span class="n">sub_eq_iff_eq_add</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">sub_eq_add_neg</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sub_eq_iff_eq_add</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">ennreal.to_real_add</span> <span class="o">(</span><span class="n">hf</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="n">c</span> <span class="n">a</span> <span class="n">hc</span> <span class="n">ha</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">evariation_on.Icc_add_Icc</span> <span class="n">f</span> <span class="n">ca</span> <span class="n">ab</span> <span class="n">ha</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">ba.trans</span> <span class="n">ac</span><span class="o">)</span> <span class="n">cb</span><span class="o">,</span> <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="n">ba</span> <span class="n">ac</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hf.variation_from_to_self</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- Probably simply `monotone` holds with no reference to `s`, but then we can't use `variation_from_to_add` and it's</span>
<span class="c1">-- not very useful anyway ?</span>
<span class="kd">lemma</span> <span class="n">variation_from_monotone_on</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone_on</span> <span class="o">(</span><span class="n">hf.variation_from_to</span> <span class="n">a</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">b</span> <span class="n">bs</span> <span class="n">c</span> <span class="n">cs</span> <span class="n">bc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">hf.variation_from_to_add</span> <span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span><span class="o">,</span>
  <span class="n">nth_rewrite_lhs</span> <span class="mi">0</span> <span class="bp">←</span><span class="n">add_zero</span> <span class="o">(</span><span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">hf.variation_from_to_nonneg_of_le</span> <span class="n">bc</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">variation_to_antitone_on</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">bs</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">antitone_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">as</span> <span class="n">c</span> <span class="n">cs</span> <span class="n">ac</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">hf.variation_from_to_add</span> <span class="n">as</span> <span class="n">cs</span> <span class="n">bs</span><span class="o">,</span>
  <span class="n">nth_rewrite_lhs</span> <span class="mi">0</span> <span class="bp">←</span><span class="n">zero_add</span> <span class="o">(</span><span class="n">hf.variation_from_to</span> <span class="n">c</span> <span class="n">b</span><span class="o">),</span>
  <span class="n">refine</span> <span class="n">add_le_add_right</span> <span class="o">(</span><span class="n">hf.variation_from_to_nonneg_of_le</span> <span class="n">ac</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sub_le_sub''</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">c</span><span class="o">,</span> <span class="kd">by</span> <span class="n">abel</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">tsub_le_iff_right</span><span class="o">,</span> <span class="n">this</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">self_sub_variation_from_monotone_on</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">b</span> <span class="n">bs</span> <span class="n">c</span> <span class="n">cs</span> <span class="n">bc</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sub_le_sub''</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">c</span>
     <span class="bp">≤</span> <span class="bp">|</span><span class="n">f</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">f</span> <span class="n">c</span><span class="bp">|</span> <span class="o">:</span> <span class="n">le_abs_self</span> <span class="n">_</span>
  <span class="bp">...=</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span>  <span class="o">(</span><span class="n">f</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span>
  <span class="bp">...=</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">c</span><span class="o">)</span>  <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">dist_comm</span> <span class="n">_</span> <span class="n">_</span>
  <span class="bp">...≤</span> <span class="n">hf.variation_from_to</span> <span class="n">c</span> <span class="n">b</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">hf.variation_from_to_eq_of_le</span> <span class="n">bc</span><span class="o">}</span>
  <span class="bp">...=</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:</span> <span class="gr">sorry</span>

<span class="kd">end</span>
<span class="c1">-- TODO arc-length parameterization!</span>

<span class="kd">end</span> <span class="n">has_locally_bounded_variation_on</span>
</code></pre></div>



<a name="318893042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318893042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318893042">(Jan 01 2023 at 18:33)</a>:</h4>
<p>My goal here for now is just to use this to extract stuff from <code>has_locally_bounded_variation_on.exists_monotone_on_sub_monotone_on</code></p>



<a name="318893533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318893533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318893533">(Jan 01 2023 at 18:38)</a>:</h4>
<p>By the way, for the length metric, I wonder how a more-but-not-too-general construction would look like.<br>
Something like constructing a length metric for a family of sets of paths (with fixed domain the unit interval or not?) with a "reversal" and "concatenation" operation. <br>
Say, have a way to at least be able to restrict to either continuous, or piecewise smooth paths would be a good goal?</p>



<a name="318894236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318894236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318894236">(Jan 01 2023 at 18:46)</a>:</h4>
<p>You might want to check how APIs are built around <a href="https://leanprover-community.github.io/mathlib_docs/find/interval_integral">docs#interval_integral</a>, specifically <a href="https://leanprover-community.github.io/mathlib_docs/find/interval_integral.integral_add_adjacent_intervals">docs#interval_integral.integral_add_adjacent_intervals</a> (and it just occurred to me that Riemann integrals also have a similar setup involving partitions). I think we want to state additivity in greatest generality allowing infinite length, but certainly cases involving infinity minus infinity need to be excluded.</p>



<a name="318894923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318894923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318894923">(Jan 01 2023 at 18:53)</a>:</h4>
<p>This is the definition on BBI of a length structure; is it too general?<br>
<a href="/user_uploads/3121/8s8eJB3it-2xKQa9eIr3tkzl/image.png">image.png</a><br>
<a href="/user_uploads/3121/I7NWLpQYqC2pRWdhHx8fOFMR/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/8s8eJB3it-2xKQa9eIr3tkzl/image.png" title="image.png"><img src="/user_uploads/3121/8s8eJB3it-2xKQa9eIr3tkzl/image.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/I7NWLpQYqC2pRWdhHx8fOFMR/image.png" title="image.png"><img src="/user_uploads/3121/I7NWLpQYqC2pRWdhHx8fOFMR/image.png"></a></div>



<a name="318900606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318900606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318900606">(Jan 01 2023 at 20:00)</a>:</h4>
<p>In the above, paths are still parametrized by an interval in ℝ, but maybe a more convenient approach in Lean would be making <code>path</code> a structure consisting of a continuous function <code>ℝ → E</code> and two points <code>start end : ℝ</code> (not sure if it's necessary to enforce <code>start ≤ end</code>). It's only necessary to require the path to be continuous on the closed interval, but it's not less general to require it to be continuous on ℝ, because we have <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous.Icc_extend'">docs#continuous.Icc_extend'</a>. I'm planning to define the path length metric as the infimum over such paths; it's nice to get rid of the <code>2 *</code> involved in <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a>.</p>
<p>On a second thought, maybe we can still use <code>C(set.Icc start end, E)</code> in the structure, but provide a coercion to <code>ℝ → E</code> via <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Icc_extend">docs#set.Icc_extend</a>`.</p>



<a name="318900726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318900726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318900726">(Jan 01 2023 at 20:01)</a>:</h4>
<p>Even in homotopy theory, paths indexed by variable intervals are used: <a href="https://en.wikipedia.org/wiki/Path_space_fibration#Moore's_path_space">https://en.wikipedia.org/wiki/Path_space_fibration#Moore's_path_space</a></p>



<a name="318937882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318937882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318937882">(Jan 02 2023 at 05:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318894923">said</a>:</p>
<blockquote>
<p>This is the definition on BBI of a length structure; is it too general?<br>
<a href="/user_uploads/3121/8s8eJB3it-2xKQa9eIr3tkzl/image.png">image.png</a><br>
<a href="/user_uploads/3121/I7NWLpQYqC2pRWdhHx8fOFMR/image.png">image.png</a></p>
</blockquote>
<p>Two concerns for me:</p>
<ul>
<li>
<p>Isn't there a point to be made for "approximate concatenation": instead of stating that the concatenation of paths in the family must also be a family, something like: Given two paths in the family and an eps, there exists a "concatenated" path of length less than eps plus the sum?<br>
  This would allow, say, talking about smooth paths, instead of piecewise smooth ones. But maybe it's a stupid idea?</p>
</li>
<li>
<p>It would be nice to have a definition that covers the path metric on graphs, whene there is no such thing as a <code>C(Icc 0 1, X)</code> since <code>X</code> is just a simple graph, but that's mybe too general.</p>
</li>
</ul>



<a name="318943445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318943445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318943445">(Jan 02 2023 at 07:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318900606">said</a>:</p>
<blockquote>
<p>In the above, paths are still parametrized by an interval in ℝ, but maybe a more convenient approach in Lean would be making <code>path</code> a structure consisting of a continuous function <code>ℝ → E</code> and two points <code>start end : ℝ</code> (not sure if it's necessary to enforce <code>start ≤ end</code>). It's only necessary to require the path to be continuous on the closed interval, but it's not less general to require it to be continuous on ℝ, because we have <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous.Icc_extend'">docs#continuous.Icc_extend'</a>. I'm planning to define the path length metric as the infimum over such paths; it's nice to get rid of the <code>2 *</code> involved in <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a>.</p>
<p>On a second thought, maybe we can still use <code>C(set.Icc start end, E)</code> in the structure, but provide a coercion to <code>ℝ → E</code> via <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Icc_extend">docs#set.Icc_extend</a>`.</p>
</blockquote>
<p>I feel it's maybe easier indeed to just let paths be maps from the reals, even though it kind of feel hackish. This way, restricting to subintervals and such doesn't require any coercion.</p>



<a name="318949270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318949270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318949270">(Jan 02 2023 at 08:14)</a>:</h4>
<p>I made a PR with the definition I mentionned here: <a href="https://github.com/leanprover-community/mathlib/pull/18040">https://github.com/leanprover-community/mathlib/pull/18040</a></p>



<a name="318952481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318952481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318952481">(Jan 02 2023 at 08:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318937882">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/318894923">said</a>:</p>
<blockquote>
<p>This is the definition on BBI of a length structure; is it too general?</p>
</blockquote>
<p>Two concerns for me:<br>
...</p>
</blockquote>
<p>Oh sorry I misread, you want a <strong>more</strong>-but-not-too-general construction, not a less general one. Indeed I think it's probably pointless to avoid piecewise-ness in the smooth setting. For simple graphs, I think you can take its "geometric realization" that adds edges of appropriate lengths; the edges can't pop out from nowhere just from the construction of the path length metric. Without adding the edges, even if you get a metric on the vertices, this is not an intrinsic metric / length space, as there are no paths between the vertices. (I think the BBI definition is meant to yield a length space via the path length metric construction.)</p>



<a name="318954003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318954003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318954003">(Jan 02 2023 at 08:52)</a>:</h4>
<blockquote>
<p>For simple graphs, I think you can take its "geometric realization" that adds edges of appropriate lengths; the edges can't pop out from nowhere just from the construction of the path length metric. Without adding the edges, even if you get a metric on the vertices, this is not an intrinsic metric / length space, as there are no paths between the vertices. (I think the BBI definition is meant to yield a length space via the path length metric construction.)</p>
</blockquote>
<p>Well, the point is that maybe, as in this other thread I made that you linked to, there should be some generic infrastructure to allow constructing a metric out of some abstract notion of "paths", that doesn't have to be actual topological paths. I don't really believe constructing metric spaces out of some "path length" idea should need to invoke topology. But that's probably too far out.</p>



<a name="318955622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318955622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318955622">(Jan 02 2023 at 09:04)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span>  </p>
<blockquote>
<p>I'm planning to define the path length metric as the infimum over such paths;</p>
</blockquote>
<p>Can you expand some on these plans (so that I don't spend too much time working on redundant things)?</p>



<a name="318960105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/318960105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#318960105">(Jan 02 2023 at 09:42)</a>:</h4>
<p>Ah, it seems that BBI do exactly the same proof as you did for continuity of the arclength. <a href="/user_uploads/3121/G9JB2yqItMxc4Fu9dSui5b48/Screenshot-from-2023-01-02-10-41-34.png">Screenshot-from-2023-01-02-10-41-34.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/G9JB2yqItMxc4Fu9dSui5b48/Screenshot-from-2023-01-02-10-41-34.png" title="Screenshot-from-2023-01-02-10-41-34.png"><img src="/user_uploads/3121/G9JB2yqItMxc4Fu9dSui5b48/Screenshot-from-2023-01-02-10-41-34.png"></a></div>



<a name="319014412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319014412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319014412">(Jan 02 2023 at 15:34)</a>:</h4>
<p>I tried defining the arc-length parameterization again, using the definitions in my PR:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2022 Sébastien Gouëzel. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Sébastien Gouëzel</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">measure_theory.measure.lebesgue</span>
<span class="kn">import</span> <span class="n">analysis.calculus.monotone</span>
<span class="kn">import</span> <span class="n">data.set.function</span>
<span class="kn">import</span> <span class="bp">.</span><span class="n">bounded_variation</span>


<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">nnreal</span> <span class="n">ennreal</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">measure_theory</span>
<span class="kn">open</span> <span class="n">classical</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">10</span><span class="o">]</span> <span class="n">prop_decidable</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">β</span><span class="o">]</span>
<span class="o">{</span><span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">F</span><span class="o">]</span>
<span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">evariation_on</span>

<span class="kd">lemma</span> <span class="n">edist_congr_left</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">zero_add</span> <span class="o">(</span><span class="n">edist</span> <span class="n">b</span> <span class="n">c</span><span class="o">),</span> <span class="bp">←</span><span class="n">hab</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">edist_triangle</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">edist_comm</span> <span class="n">at</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">zero_add</span> <span class="o">(</span><span class="n">edist</span> <span class="n">a</span> <span class="n">c</span><span class="o">),</span> <span class="bp">←</span><span class="n">hab</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">edist_triangle</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">lemma</span> <span class="n">edist_congr_right</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">edist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">edist</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">edist</span> <span class="n">c</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">edist_comm</span> <span class="n">c</span> <span class="n">a</span><span class="o">,</span> <span class="n">edist_comm</span> <span class="n">c</span> <span class="n">b</span><span class="o">],</span> <span class="n">apply</span> <span class="n">edist_congr_left</span> <span class="n">hab</span><span class="o">,</span>  <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">eq_of_edist_zero_on</span> <span class="o">{</span><span class="n">f</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">evariation_on</span> <span class="n">f'</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">evariation_on</span><span class="o">],</span>
  <span class="n">congr'</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">p</span> <span class="o">:</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">congr'</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">edist_congr_left</span> <span class="o">(</span><span class="n">h</span> <span class="bp">$</span> <span class="n">p.snd.prop.2</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="n">edist_congr_right</span> <span class="o">(</span><span class="n">h</span> <span class="bp">$</span> <span class="n">p.snd.prop.2</span> <span class="n">i</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">evariation_on</span>

<span class="kn">namespace</span> <span class="n">has_locally_bounded_variation_on</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span>


<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">arc_length_parameterization_or</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="k">then</span> <span class="n">f</span> <span class="n">h.some</span> <span class="k">else</span> <span class="n">e</span>

<span class="sd">/--</span>
<span class="sd">In a metric space, precomposing arc-length parameterization with variation yields the original</span>
<span class="sd">map.</span>
<span class="sd">-/</span>
<span class="kd">lemma</span> <span class="n">arc_length_parameterization_edist_zero</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">bs</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hf.arc_length_parameterization_or</span> <span class="n">as</span> <span class="n">e</span> <span class="o">(</span><span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">arc_length_parameterization_or</span><span class="o">],</span>

  <span class="k">let</span> <span class="n">cc</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">hf.variation_from_to</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">bs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">cc</span><span class="o">],</span>
  <span class="c">/-</span><span class="cm">let c := cc.some,</span>
<span class="cm">  let cs := cc.some_spec.1,</span>
<span class="cm">  let cb := cc.some_spec.2,</span>
<span class="cm">  rw [←hf.variation_from_to_add as bs cs, add_right_eq_self] at cb,</span>
<span class="cm">  rw [←ennreal.bot_eq_zero, eq_bot_iff, ennreal.bot_eq_zero],</span>
<span class="cm">  by_cases h : b ≤ c,</span>
<span class="cm">  { rw [←ennreal.of_real_zero, ←cb, hf.variation_from_to_eq_of_le h,</span>
<span class="cm">        ennreal.of_real_to_real (hf b c bs cs)],</span>
<span class="cm">    apply evariation_on.edist_le f,</span>
<span class="cm">    exact ⟨bs, ⟨le_refl _, h⟩⟩,</span>
<span class="cm">    exact ⟨cs, ⟨h, le_refl _⟩⟩, },</span>
<span class="cm">  { replace h : c ≤ b := (lt_of_not_le h).le,</span>
<span class="cm">    rw [hf.variation_from_to_eq_neg_swap, neg_eq_zero] at cb,</span>
<span class="cm">    rw [edist_comm, ←ennreal.of_real_zero, ←cb, hf.variation_from_to_eq_of_le h,</span>
<span class="cm">        ennreal.of_real_to_real (hf c b cs bs)],</span>
<span class="cm">    apply evariation_on.edist_le f,</span>
<span class="cm">    exact ⟨cs, ⟨le_refl _, h⟩⟩,</span>
<span class="cm">    exact ⟨bs, ⟨h, le_refl _⟩⟩, }-/</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">has_locally_bounded_variation_on</span>
</code></pre></div>
<p>but get an error at the <code>simp [dif_pos cc]</code> line. I believe there is some instance trouble going on here?</p>



<a name="319015087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319015087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319015087">(Jan 02 2023 at 15:38)</a>:</h4>
<p>At first I defined the arc-length parameterization only on <code>s.image $ hf.variation_from_to a</code>, but then you have to coerce a lot to be able to piece the different functions together.</p>



<a name="319016910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319016910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319016910">(Jan 02 2023 at 15:50)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Concerning the lemma in your proof of continuity. Would it make sense to generalize it to something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">evariation_eq_bsupr</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">),</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">},</span>
          <span class="bp">∃</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">},</span>
          <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">q.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">q.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">q.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">&gt;</span>
          <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">⨆</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">u</span> <span class="bp">∈</span> <span class="n">F</span><span class="o">}),</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="319017183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319017183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319017183">(Jan 02 2023 at 15:52)</a>:</h4>
<p>As in you may want to say that the supr is the same as when restricting only to <code>u</code>s that are:</p>
<ul>
<li>strictly monotonous</li>
<li>have a range containing the range of a given fixed <code>u</code></li>
<li>have endpoints the max and min of <code>s</code></li>
<li>…</li>
</ul>



<a name="319024702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319024702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319024702">(Jan 02 2023 at 16:41)</a>:</h4>
<p>Well, the lemma itself is not specific to evariation, but I wonder if there can be some infrastructure in place to facilitate such statements</p>



<a name="319156301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319156301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319156301">(Jan 03 2023 at 09:42)</a>:</h4>
<blockquote>
<p>there should be some generic infrastructure to allow constructing a metric out of some abstract notion of "paths", that doesn't have to be actual topological paths.</p>
</blockquote>
<p>Yeah, continuity and intervals are not involved there, and I guess we can worry about them later :)</p>
<blockquote>
<p>Can you expand some on these plans (so that I don't spend too much time working on redundant things)?</p>
</blockquote>
<p>I was distracted by other tasks and haven't written any code to redefine the path length metric yet, and I also haven't got time to review your <a href="https://github.com/leanprover-community/mathlib/pull/18040">#18040</a> or diagnose your arclength parametrization code (which depends on <a href="https://github.com/leanprover-community/mathlib/pull/18040">#18040</a>) either.</p>
<p>But at least I've just now completed the proof that the arclength function is continuous on the closed interval, using <a href="https://github.com/leanprover-community/mathlib/pull/18037">#18037</a> to transfer right continuity to left continuity: <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34">https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">evariation_eq_bsupr</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">$</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>I haven't been able to decipher the statement yet; will think about it later!</p>



<a name="319161589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319161589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319161589">(Jan 03 2023 at 10:14)</a>:</h4>
<p>In the meantime, I've tried showing 1.20.(7) of Bridson-Haefliger, but get stuck on dealing with coercions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">),</span> <span class="n">ε</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">evariation_on.subsingleton</span> <span class="n">f</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_le'</span><span class="o">,</span> <span class="n">filter.eventually_true</span><span class="o">,</span> <span class="n">implies_true_iff</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="o">(</span><span class="n">hs</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">hx</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">emetric.tendsto_uniformly_on_iff</span> <span class="n">at</span> <span class="n">hF</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">n</span><span class="o">,⟨</span><span class="n">u</span><span class="o">,</span><span class="n">um</span><span class="o">,</span><span class="n">us</span><span class="o">⟩⟩,</span><span class="n">hlt</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">eps_approx</span> <span class="n">hs</span> <span class="n">hf</span> <span class="o">((</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hε</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">ennreal.div_zero_iff</span><span class="o">,</span> <span class="n">ennreal.coe_eq_zero</span><span class="o">,</span> <span class="n">ennreal.bit0_eq_top_iff</span><span class="o">,</span>
                    <span class="n">ennreal.one_ne_top</span><span class="o">,</span> <span class="n">or_self</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">]}),</span>
  <span class="n">specialize</span> <span class="n">hF</span> <span class="o">((</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="mi">4</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span>
    <span class="o">(</span><span class="kd">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hε</span><span class="o">,</span> <span class="n">gt_iff_lt</span><span class="o">,</span> <span class="n">ennreal.div_pos_iff</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">ennreal.coe_eq_zero</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span>
                    <span class="n">with_top.mul_eq_top_iff</span><span class="o">,</span> <span class="n">ennreal.nat_ne_top</span><span class="o">,</span> <span class="n">and_false</span><span class="o">,</span> <span class="n">ennreal.bit0_eq_top_iff</span><span class="o">,</span>
                    <span class="n">ennreal.one_ne_top</span><span class="o">,</span> <span class="n">false_and</span><span class="o">,</span> <span class="n">or_self</span><span class="o">,</span> <span class="n">and_self</span><span class="o">],}),</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">hF.mono</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">hlt.le.trans</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="o">(</span><span class="n">sum_le</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span> <span class="n">um</span> <span class="n">us</span><span class="o">)</span> <span class="n">ε</span><span class="o">))),</span>
  <span class="n">clear</span> <span class="n">hlt</span> <span class="n">hF</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">↑</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">↑</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">),</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ennreal.add_halves</span><span class="o">],</span>
  <span class="n">nth_rewrite_rhs</span> <span class="mi">0</span> <span class="n">this</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">add_assoc</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">add_le_add_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">calc</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span>
     <span class="bp">≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="bp">+</span> <span class="bp">↑</span><span class="n">ε</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span>
  <span class="kd">begin</span>
    <span class="n">refine</span> <span class="n">finset.sum_le_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span> <span class="n">jn</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">edist_triangle4</span> <span class="n">_</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*↑</span><span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ε</span><span class="bp">/</span><span class="o">(</span><span class="mi">4</span><span class="bp">*</span><span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="n">ε</span><span class="bp">/</span><span class="o">(</span><span class="mi">4</span><span class="bp">*</span><span class="n">n</span><span class="o">),</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">ennreal.add_div</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">two_mul</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="bp">←</span><span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">add_le_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">nth_rewrite_lhs</span> <span class="mi">0</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">refine</span> <span class="n">add_le_add_left</span> <span class="o">((</span><span class="n">hi</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">j.succ</span><span class="o">))</span><span class="bp">.</span><span class="n">le</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">edist_comm</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hi</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">j</span><span class="o">))</span><span class="bp">.</span><span class="n">le</span><span class="o">,</span>  <span class="o">}</span>
  <span class="kd">end</span>
  <span class="bp">...=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="bp">+</span> <span class="n">n</span><span class="bp">*</span><span class="o">(</span><span class="bp">↑</span><span class="n">ε</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span> <span class="o">:</span>
  <span class="kd">by</span>  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.sum_add_distrib</span><span class="o">,</span> <span class="n">finset.sum_const</span><span class="o">,</span> <span class="n">finset.card_range</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">]</span>
  <span class="bp">...≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">↑</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span>
  <span class="kd">begin</span>
    <span class="n">refine</span> <span class="n">add_le_add_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
<span class="kd">end</span>
</code></pre></div>



<a name="319223622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319223622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319223622">(Jan 03 2023 at 15:50)</a>:</h4>
<p>Should we state it with <a href="https://leanprover-community.github.io/mathlib_docs/find/lower_semicontinuous">docs#lower_semicontinuous</a> (as on BBI)?</p>



<a name="319224056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319224056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319224056">(Jan 03 2023 at 15:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319223622">said</a>:</p>
<blockquote>
<p>Should we state it with <a href="https://leanprover-community.github.io/mathlib_docs/find/lower_semicontinuous">docs#lower_semicontinuous</a> (as on BBI)?</p>
</blockquote>
<p>Ah, yes, let me try (I don't (yet?) know my way around topology in <del>general</del>mathlib ).</p>



<a name="319225630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319225630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319225630">(Jan 03 2023 at 15:59)</a>:</h4>
<p>How do I tell lean I want the uniform convergence topology?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">evariation_on_lower_continuous'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lower_semicontinuous_at</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">g</span> <span class="n">s</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="319235428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319235428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319235428">(Jan 03 2023 at 16:46)</a>:</h4>
<p>Mmh, we actually probably don't even need to have <code>has_bounded_variation_on f s</code> as an assumption</p>



<a name="319237709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319237709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319237709">(Jan 03 2023 at 16:58)</a>:</h4>
<p>I'll try and adapt the proof tomorrow</p>



<a name="319240817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319240817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319240817">(Jan 03 2023 at 17:12)</a>:</h4>
<blockquote>
<p>How do I tell lean I want the uniform convergence topology?</p>
</blockquote>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/uniform_fun">docs#uniform_fun</a>, but maybe you want <a href="https://leanprover-community.github.io/mathlib_docs/find/uniform_on_fun">docs#uniform_on_fun</a> (with <code>𝔖 := {s}</code>)</p>



<a name="319261307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319261307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319261307">(Jan 03 2023 at 19:03)</a>:</h4>
<p>I think the commonality between continuous vs. graph path length metric is that you have a set <code>L x y</code> of ennreals (lengths) between any two points/vertices <code>x</code> and <code>y</code>, satisfying <code>0 ∈ L x x</code>, <code>L x y = L y x</code>, and <code>L x y + L y z ⊆ L x z</code> (pointwise addition) (or you may relax this to <code>∀ l ∈ L x y + L y z, ∃ l' ≤ l, l' ∈ L x z</code>).<br>
It's convenient to work with ennreal since we can assign weight 1 to edges and infinite weight to non-edges, so we can consider all maps <code>fin n → G.verts</code> (or <code>ℕ</code> or <code>ℤ</code> as the domain) rather than only walks.</p>
<p>A crucial difference between the two is that, in the continuous case we start from a emetric, while the weights on (non-)edges in a graph don't satisfy triangle inequality. So I'm thinking we should probably generalize <a href="https://leanprover-community.github.io/mathlib_docs/find/evariation">docs#evariation</a> from <code>pseudo_emetric_space</code> to <code>has_edist</code> whenever possible, and we can show that when applied to a map <code>f : ℤ → E</code>, <code>arclength f m n</code> is simply the sum over the interval [m,n) of all adjacent <code>edist</code>s. Notice that in the continuous case the resulting path metric is bounded below by the original, while in the graph/discrete case it's bounded above by the original (because there is no continuity restriction; even if you impose it it would be vacuous since ℤ is discrete).</p>
<p>Here's my tentative definition of the path length metric that covers both continuous and discrete cases: <br>
<a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34#file-continuous_arclength-lean-L15-L31">https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34#file-continuous_arclength-lean-L15-L31</a></p>



<a name="319329593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319329593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319329593">(Jan 04 2023 at 06:19)</a>:</h4>
<p>OK, I've got the rectifiability assumption out; remains to rewrite it in terms of continuity.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">eps_approx'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span><span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">monotone</span> <span class="n">u</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}),</span>
    <span class="n">v</span> <span class="bp">&lt;</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">((</span><span class="n">p.2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">i</span><span class="o">))</span>  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra'</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">h</span> <span class="o">(</span><span class="n">supr_le</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">hn</span> <span class="n">x</span><span class="o">)))</span><span class="bp">.</span><span class="n">ne</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">evariation_on_lower_continuous</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hF</span> <span class="o">:</span> <span class="n">tendsto_uniformly_on</span> <span class="n">F</span> <span class="n">f</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">),</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">evariation_on.subsingleton</span> <span class="n">f</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">hs</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">hx</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">elim</span><span class="o">)],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">implies_true_iff</span><span class="o">,</span> <span class="n">not_lt_zero</span><span class="o">,</span> <span class="n">is_empty.forall_iff</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">emetric.tendsto_uniformly_on_iff</span> <span class="n">at</span> <span class="n">hF</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v'</span><span class="o">,</span><span class="n">vv'</span><span class="o">,</span><span class="n">v'var</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exists_between</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">n</span><span class="o">,⟨</span><span class="n">u</span><span class="o">,</span><span class="n">um</span><span class="o">,</span><span class="n">us</span><span class="o">⟩⟩,</span><span class="n">hlt</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">eps_approx'</span> <span class="n">hs</span> <span class="n">v'</span> <span class="n">v'var</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span><span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hvp</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">vv'</span><span class="o">,</span> <span class="n">tsub_pos_iff_lt</span><span class="o">],},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span> <span class="bp">≠</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="n">ennreal.sub_ne_top</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">v'var</span> <span class="n">le_top</span><span class="o">)),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">v'</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">add_tsub_cancel_of_le</span> <span class="n">vv'.le</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hε</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">ε</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">ennreal.div_pos_iff</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">hvp.ne.symm</span><span class="o">,</span> <span class="n">mul_ne_top</span> <span class="n">two_ne_top</span> <span class="o">(</span><span class="n">nat_ne_top</span> <span class="n">n</span><span class="o">)⟩,</span> <span class="o">},</span>
  <span class="n">specialize</span> <span class="n">hF</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hF.mono</span><span class="o">,</span> <span class="n">clear</span> <span class="n">hF</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">v'</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="n">this</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">ennreal.add_lt_add_iff_right</span> <span class="o">‹</span><span class="n">v'</span><span class="bp">-</span><span class="n">v</span><span class="bp">≠⊤</span><span class="o">›,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">calc</span> <span class="n">v'</span>
     <span class="bp">&lt;</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span>  <span class="o">:</span> <span class="n">hlt</span>
  <span class="bp">...≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span>
  <span class="kd">begin</span>
    <span class="n">refine</span> <span class="n">finset.sum_le_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span> <span class="n">jn</span><span class="o">,</span> <span class="o">(</span><span class="n">edist_triangle4</span> <span class="n">_</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">two_mul</span><span class="o">,</span> <span class="bp">←</span><span class="n">add_assoc</span> <span class="n">_</span> <span class="n">ε</span> <span class="n">ε</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">_</span> <span class="n">ε</span><span class="o">,</span> <span class="bp">←</span><span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">add_le_add</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="o">(</span><span class="n">hi</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">j.succ</span><span class="o">))</span><span class="bp">.</span><span class="n">le</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">edist_comm</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hi</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">j</span><span class="o">))</span><span class="bp">.</span><span class="n">le</span><span class="o">,</span>
  <span class="kd">end</span>
  <span class="bp">...=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">*</span><span class="n">ε</span> <span class="o">:</span>
  <span class="kd">begin</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.sum_add_distrib</span><span class="o">,</span> <span class="n">finset.sum_const</span><span class="o">,</span> <span class="n">finset.card_range</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span>
               <span class="bp">←</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">_</span> <span class="o">(</span><span class="mi">2</span><span class="o">:</span><span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">)],</span>
  <span class="kd">end</span>
  <span class="bp">...≤</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span> <span class="o">(</span><span class="n">u</span> <span class="n">j</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="kd">begin</span>
    <span class="n">refine</span> <span class="n">add_le_add_left</span> <span class="o">(</span><span class="n">mul_div_le</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="kd">end</span>
  <span class="bp">...≤</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span>  <span class="bp">+</span> <span class="o">(</span><span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_le_add_right</span> <span class="o">(</span><span class="n">sum_le</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="n">_</span> <span class="n">um</span> <span class="n">us</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span> <span class="bp">-</span> <span class="n">v</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="319331484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319331484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319331484">(Jan 04 2023 at 06:40)</a>:</h4>
<p>Sorry, I realized the idea in my last post doesn't work: if ab and bc are edges but ac is not, then the map 0-&gt;a, 1-&gt;b, 2-&gt;c would have unbounded variation between 0 and 2 (because the variation is a supremum, and infinity is achieved at the monotone map 0-&gt;0, 1-&gt;2 (which omits b)). So it doesn't make sense to generalize evariation from pseudo_emetric_space to has_edist.</p>



<a name="319331870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319331870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319331870">(Jan 04 2023 at 06:45)</a>:</h4>
<p>I expect this can be golfed to one line (note that I'm using the "original" lower semicontinuity lemma) :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">evariation_on_lower_continuous'</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">lower_semicontinuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">{</span><span class="n">s</span><span class="o">},</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">f</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">evariation_on_lower_continuous</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">s</span><span class="o">},</span> <span class="n">tendsto_uniformly_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">{</span><span class="n">s</span><span class="o">}),</span> <span class="n">n</span><span class="o">)</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span> <span class="n">t</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">this</span> <span class="n">s</span> <span class="o">(</span><span class="n">set.mem_singleton</span> <span class="n">s</span><span class="o">),</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">uniform_on_fun.tendsto_iff_tendsto_uniformly_on</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">filter.tendsto_id</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">hv</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'll probably clean it up some more and open a PR</p>



<a name="319332346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319332346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319332346">(Jan 04 2023 at 06:50)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Your proposal in terms of ennreals (<code>L x y</code>) differs from my "paths with length stub" in that you simply forget about the original paths and only look at the set of lengths, right?</p>



<a name="319332718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319332718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319332718">(Jan 04 2023 at 06:54)</a>:</h4>
<p>for your <code>path_btw</code>, you don't care about generalizing to graphs or other things, right (just trying to know the context)?</p>



<a name="319332751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319332751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319332751">(Jan 04 2023 at 06:54)</a>:</h4>
<blockquote>
<p>Your proposal in terms of ennreals (L x y) differs from my "paths with length stub" in that you simply forget about the original paths and only look at the set of lengths, right?</p>
</blockquote>
<p>Probably, I don't remember all details in your code. Maybe we want to keep the indexing type as we normally do in type theory, or maybe not.</p>



<a name="319332789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319332789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319332789">(Jan 04 2023 at 06:55)</a>:</h4>
<p>If we're staying purely in the topological realm, would it make sense to have a <code>path</code> type that would then be extended by the already present <code>path</code> ? (In order to keep some kind of coherent hierarchy)</p>



<a name="319332821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319332821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319332821">(Jan 04 2023 at 06:55)</a>:</h4>
<blockquote>
<p>for your path_btw, you don't care about generalizing to graphs or other things, right (just trying to know the context)?</p>
</blockquote>
<p>I attempted to cover the graph case but it doesn't actually work as I just found out. I should probably stick with <code>real</code> rather than <code>M</code> in my current code ...</p>



<a name="319333097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319333097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319333097">(Jan 04 2023 at 06:59)</a>:</h4>
<p>If <code>path x y</code> is a function from R to the space, then equality becomes kind of meaningless, no?</p>



<a name="319333113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319333113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319333113">(Jan 04 2023 at 06:59)</a>:</h4>
<p>I think I still prefer having <code>paths</code> with the correct domain</p>



<a name="319333609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319333609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319333609">(Jan 04 2023 at 07:05)</a>:</h4>
<p>Well, you could add</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">constant_below</span> <span class="o">:</span> <span class="bp">\</span><span class="k">forall</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">source</span><span class="o">,</span> <span class="n">path</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">path</span> <span class="n">source</span><span class="o">)</span>
<span class="o">(</span><span class="n">constant_above</span> <span class="o">:</span> <span class="bp">\</span><span class="k">forall</span> <span class="n">m</span> <span class="bp">≥</span> <span class="n">target</span><span class="o">,</span> <span class="n">path</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">path</span> <span class="n">target</span><span class="o">)</span>
</code></pre></div>



<a name="319335358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319335358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319335358">(Jan 04 2023 at 07:23)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/18058">https://github.com/leanprover-community/mathlib/pull/18058</a></p>



<a name="319337337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319337337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319337337">(Jan 04 2023 at 07:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319331484">said</a>:</p>
<blockquote>
<p>Sorry, I realized the idea in my last post doesn't work: if ab and bc are edges but ac is not, then the map 0-&gt;a, 1-&gt;b, 2-&gt;c would have unbounded variation between 0 and 2 (because the variation is a supremum, and infinity is achieved at the monotone map 0-&gt;0, 1-&gt;2 (which omits b)). So it doesn't make sense to generalize evariation from pseudo_emetric_space to has_edist.</p>
</blockquote>
<p>Is that not fixed by redefining the <code>evariation</code> as the infimum over all paths of the supremum of &lt;whatever is in the current definition&gt;?</p>



<a name="319341467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319341467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319341467">(Jan 04 2023 at 08:25)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  do you mean defining the evariation for paths in graphs as the supremum over the <code>u</code>s such that consecutive values of <code>u</code> are adjacent or equal, say?</p>



<a name="319343651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319343651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319343651">(Jan 04 2023 at 08:42)</a>:</h4>
<p>I think the only common theme between the graph and metric cases is that we have a type of "Paths between _ and _" for any pair of points, with associated lengths satisfying some reflexivity, symmetry, and transitivity properties. Extending <code>evariation</code> to graph-theoretical walks seems probably pointless.</p>



<a name="319344049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319344049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319344049">(Jan 04 2023 at 08:45)</a>:</h4>
<p>Also, if we go as far as defining such a general framework, it would probably be helpful to be able to allow different weighs on the edges of a <code>simple_graph</code>, when defining the metric.</p>



<a name="319346767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319346767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319346767">(Jan 04 2023 at 09:04)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span>, also, I think<code>(le : source ≤ target)</code> is better than <code>(lt : source &lt; target)</code>: Then we can define <code>path.refl</code> as having domain <code>Icc 0 0</code> and concatenation with <code>path.refl</code> is almost defeq equal to the original path.</p>



<a name="319356129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319356129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319356129">(Jan 04 2023 at 10:08)</a>:</h4>
<p>Also, is there much point to have an arbitrary <code>start</code> value?</p>



<a name="319356941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319356941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319356941">(Jan 04 2023 at 10:14)</a>:</h4>
<p>What about this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.ennreal</span>
<span class="kn">import</span> <span class="n">data.real.nnreal</span>
<span class="kn">import</span> <span class="n">topology.metric_space.emetric_space</span>

<span class="kd">noncomputable theory</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">nnreal</span> <span class="n">ennreal</span>

<span class="kn">open</span> <span class="n">emetric</span> <span class="n">ennreal</span>
<span class="kn">open</span> <span class="n">emetric</span> <span class="n">nnreal</span>

<span class="kn">section</span> <span class="n">path_emetric</span>

<span class="kd">variables</span>  <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">path_btw</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">path</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_source</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">t</span><span class="o">⦄,</span> <span class="n">t</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">path</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_target</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">t</span><span class="o">⦄,</span> <span class="n">l</span> <span class="bp">≤</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">path</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">-- (continuous : continuous_on path (set.Icc 0 l))</span>

<span class="kd">def</span> <span class="n">path_btw.trans</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">path_btw</span> <span class="n">l</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">p'</span> <span class="o">:</span> <span class="n">path_btw</span> <span class="n">l'</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">path_btw</span> <span class="o">(</span><span class="n">l</span><span class="bp">+</span><span class="n">l'</span><span class="o">)</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">path</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">l</span> <span class="k">then</span> <span class="n">p.path</span> <span class="n">t</span> <span class="k">else</span> <span class="n">p'.path</span> <span class="o">(</span><span class="n">l</span> <span class="bp">+</span> <span class="n">t</span><span class="o">),</span>
  <span class="n">map_source</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_target</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">path_btw.symm</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">path_btw</span> <span class="n">l</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">path_btw</span> <span class="n">l</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">path</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">p.path</span> <span class="o">(</span><span class="n">l</span><span class="bp">-</span><span class="n">t</span><span class="o">),</span>
  <span class="n">map_source</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_target</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">}</span>


<span class="kd">end</span> <span class="n">path_emetric</span>
</code></pre></div>



<a name="319357452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319357452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319357452">(Jan 04 2023 at 10:18)</a>:</h4>
<p>Are you aware of <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a>, which is already used in mathlib to construct the fundamental group?</p>



<a name="319357598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319357598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319357598">(Jan 04 2023 at 10:20)</a>:</h4>
<p>It already has nice API, like <a href="https://leanprover-community.github.io/mathlib_docs/find/path.extend">docs#path.extend</a>, which corresponds to your extended version to the whole real line.</p>



<a name="319359171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319359171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319359171">(Jan 04 2023 at 10:28)</a>:</h4>
<p>I am. I don't believe I mind working with <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a>, but you get into a bit of trouble because of reparameterization, and not having a fixed domain (the entire real line) to work on: instead having to deal with compositions and subtypes and stuff. Or at least that's what I believe the motivation for a different type for <code>path</code> is (<span class="user-mention" data-user-id="224323">@Junyan Xu</span> )?</p>



<a name="319362013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319362013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319362013">(Jan 04 2023 at 10:45)</a>:</h4>
<p>Normally, that's the role of the API around <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a>. If there are things that are painful to do, it might mean that the API is lacking, and it would probably be worth extending the API to make things smoother, instead of trying to come up with a different implementation. Ideally, proving that the evariation of a composition of paths is bounded by the sum of the evariations should be pretty smooth -- if it's not, we definitely need to improve something!</p>



<a name="319364334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319364334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319364334">(Jan 04 2023 at 10:59)</a>:</h4>
<p>I've got to go, but in the meantime: I'm restating lower semicontinuity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lower_continuous_aux</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">p.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">}</span> <span class="o">(</span><span class="n">hv</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>but couldn't seem to find something like <code>tendsto_on</code> for my <code>Ffs</code> assumption. Where should I look?</p>



<a name="319366378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319366378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319366378">(Jan 04 2023 at 11:10)</a>:</h4>
<p>I think your current formulation is fine. We have the topology of pointwise convergence on the whole space (that's the default topology on function spaces), but I don't think we have ever needed to spell out pointwise convergence on a subset.</p>



<a name="319366536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319366536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319366536">(Jan 04 2023 at 11:11)</a>:</h4>
<p>The closest would be uniform on the family of singletons of elements of <code>s</code> I guess.</p>



<a name="319366686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319366686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319366686">(Jan 04 2023 at 11:12)</a>:</h4>
<p>Aside: please don't write <code>p.tendsto f q</code>, use instead <code>tendsto f p q</code>. It's closer to the intended mathematical content.</p>



<a name="319366760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319366760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319366760">(Jan 04 2023 at 11:13)</a>:</h4>
<p>So, should I still have the non-aux statement, e.g. like :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lower_continuous</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">lower_semicontinuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">(</span><span class="n">s.image</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">}),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>or just have the "manual" statement that doesn't explicitely use <code>lower_semicontinuous</code> ?</p>



<a name="319368069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319368069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319368069">(Jan 04 2023 at 11:20)</a>:</h4>
<p>I'd write the statement with <code>lower_continuous</code> for the uniform convergence topology, with a docstring explaining the situation, and the manual statement as you did above.</p>



<a name="319368199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319368199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319368199">(Jan 04 2023 at 11:21)</a>:</h4>
<p>Note that the proof of the manual statement can be done without any epsilon: just say that the sum for <code>F n</code> converges to the sum for <code>f</code>, and the latter is <code>&gt; v</code>, so the former is eventually <code>&gt; v</code> (I'm trying to spare you a lot of useless pain here :-)</p>



<a name="319400670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319400670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319400670">(Jan 04 2023 at 14:29)</a>:</h4>
<p>Thanks, this filter-based infrastructure is very neat but I need a bit of time to get acquainted.</p>



<a name="319402243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319402243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319402243">(Jan 04 2023 at 14:37)</a>:</h4>
<p>(lower semicontinuity is continuity relative to the <code>Iio</code> i.e. <code>]x,\infty[</code> topology, right?)</p>



<a name="319406891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319406891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319406891">(Jan 04 2023 at 14:59)</a>:</h4>
<p>I would think it's better to stick to neighborhoods instead of having the indexed family as I did before, no ?:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lower_continuous_aux'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">),</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">}</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="n">g</span> <span class="k">in</span> <span class="n">nhds</span> <span class="n">f</span><span class="o">,</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">g</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">um</span><span class="o">,</span> <span class="n">us</span><span class="o">⟩⟩,</span> <span class="n">hlt</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">lt_supr_iff.mp</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">hlt</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">filter.tendsto</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">),</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">replace</span> <span class="n">this</span> <span class="o">:=</span> <span class="o">(</span><span class="n">eventually_gt_of_tendsto_gt</span> <span class="n">hlt</span> <span class="n">this</span><span class="o">),</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">this.mono</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span> <span class="n">lt_of_lt_of_le</span> <span class="n">h</span> <span class="o">(</span><span class="n">sum_le</span> <span class="n">g</span> <span class="n">n</span> <span class="n">um</span> <span class="n">us</span><span class="o">)),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="319408572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319408572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319408572">(Jan 04 2023 at 15:07)</a>:</h4>
<p>No, please use a general filter. Here you are using the filter of pointwise convergence on the whole space, which has nothing to do with the question at hand (in your snippet, your assumption <code>Ffs</code> is true by definition, by the way!)</p>
<p>I know filters look strange at first, but they are really the right level of generality. If you like, you can write your proof first for <code>F : nat → α → E</code> assuming that, for all <code>x</code> in <code>s</code>, then <code>F n x</code> tends to <code>f x</code> as <code>n</code> tends to infinity (i.e., using the <code>at_top</code> filter on <code>nat</code>). And then generalize <code>nat</code> to a general type, <code>at_top</code> to a general filter, and see that it doesn't make the slightest difference.</p>



<a name="319409447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319409447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319409447">(Jan 04 2023 at 15:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319408572">said</a>:</p>
<blockquote>
<p>No, please use a general filter. Here you are using the filter of pointwise convergence on the whole space, which has nothing to do with the question at hand (in your snippet, your assumption <code>Ffs</code> is true by definition, by the way!)</p>
</blockquote>
<p>Can you expand on that?  I was thinking along the lines that the original way was proving stuff about filters with one level of indirection to many.</p>



<a name="319410092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319410092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319410092">(Jan 04 2023 at 15:14)</a>:</h4>
<p>As in, given the topological spaces <code>A</code> <code>B</code> and <code>f : A -&gt; B</code>, instead of showing simply that the pullback of a neighborhood filter in <code>nhds (f x)</code> is contained in neigborhood filter <code>nhds x</code>, it showed that given a third map <code>F : I -&gt; A</code> and a filter on <code>I</code> such that the pullback of <code>nhds (F)</code> is contained in the filter, the composite <code>f \circ F</code> also behave that way, which is equivalent to the simpler form by just taking F be the identity.</p>



<a name="319410291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319410291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319410291">(Jan 04 2023 at 15:15)</a>:</h4>
<p>I believe modulo mistakes <strong>and the problem of taking the right topology</strong>, what I wrote above is right. Does the problem then arise from this difference in topologies, or am I mistaken somewhere else?</p>



<a name="319410862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319410862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319410862">(Jan 04 2023 at 15:18)</a>:</h4>
<p>Ah, yes, I think that's it: because with the snippet above, <code>nhds f</code> takes pointwise topology, and then the <code>Ffs</code> is really just a restatement of that topology.</p>



<a name="319411006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319411006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319411006">(Jan 04 2023 at 15:19)</a>:</h4>
<p>But say I wasn't dealing with two different topologies, then should the form in the snippet be preferred?</p>



<a name="319412274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319412274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319412274">(Jan 04 2023 at 15:25)</a>:</h4>
<p>Indeed, the problem is that <code>nhds f</code> uses the global pointwise convergence topology, not pointwise convergence topology on <code>s</code>. If you had the right topology, then yes the two statements (with a general filter or with <code>nhds f</code>) would indeed be equivalent. And I'd probably state the lemma as you did, i.e., without <code>Ffs</code> and with a conclusion <code>∀ᶠ g in nhds f, v &lt; evariation_on g s</code>.</p>
<p>Note however that, often, for applications, the version with a general filter is more convenient to use. This is explained in the library note <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#continuity%20lemma%20statement">https://leanprover-community.github.io/mathlib_docs/notes.html#continuity%20lemma%20statement</a> (for continuity, but the same goes for limits). So in many cases, I give both versions as separate lemmas, deducing one from the other.</p>



<a name="319414177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319414177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319414177">(Jan 04 2023 at 15:34)</a>:</h4>
<p>Thanks! I think I need to familiarize myself some more with the API: are there a few pedagogically useful files you recommend? Beside I guess <code>filter</code> and <code>topological_space</code></p>



<a name="319414878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319414878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319414878">(Jan 04 2023 at 15:38)</a>:</h4>
<p>(I know "nets"/generalized sequences/directed sets already, but the filter approach is kind of backwards in my head, it gets confusing!)</p>



<a name="319417224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319417224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319417224">(Jan 04 2023 at 15:50)</a>:</h4>
<p>OK, not there yet but looking better (I mean, the statements typecheck at least :) ):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lower_continuous_aux</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">}</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">lower_semicontinuous</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">lower_semicontinuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">(</span><span class="n">s.image</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">}),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">lower_continuous_aux</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">(</span><span class="n">s.image</span> <span class="n">singleton</span><span class="o">))</span> <span class="n">id</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span> <span class="n">f</span> <span class="n">s</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">filter.tendsto</span> <span class="n">id</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">filter.tendsto_id</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">uniform_on_fun.tendsto_iff_tendsto_uniformly_on</span><span class="o">,</span> <span class="n">mem_image</span><span class="o">,</span> <span class="n">forall_exists_index</span><span class="o">,</span>
             <span class="n">and_imp</span><span class="o">,</span> <span class="n">forall_apply_eq_imp_iff₂</span><span class="o">,</span>
             <span class="n">tendsto_uniformly_on_singleton_iff_tendsto</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="319420304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319420304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319420304">(Jan 04 2023 at 16:07)</a>:</h4>
<p>When trying to make progress on <code>lower_continuous_aux</code> I get a strange instance problem:</p>
<p>At the <code>let := @emetric.…</code> line,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lower_continuous_aux</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">}</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">um</span><span class="o">,</span> <span class="n">us</span><span class="o">⟩⟩,</span> <span class="n">hlt</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">lt_supr_iff.mp</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">hlt</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span>
    <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">j</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">F</span> <span class="n">j</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))</span> <span class="n">p</span>
    <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="k">let</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">emetric.tendsto_nhds</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="n">ι</span> <span class="n">_</span> <span class="n">p</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">j</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">F</span> <span class="n">j</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">))),</span>
    <span class="gr">sorry</span><span class="o">,</span>
   <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">eventually_gt_of_tendsto_gt</span> <span class="n">hlt</span> <span class="n">this</span><span class="o">)</span><span class="bp">.</span><span class="n">mono</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span> <span class="n">lt_of_lt_of_le</span> <span class="n">h</span> <span class="o">(</span><span class="n">sum_le</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span> <span class="n">um</span> <span class="n">us</span><span class="o">)),</span>
<span class="kd">end</span>
</code></pre></div>
<p>I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="n">α</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">,</span>
<span class="n">_inst_3</span> <span class="o">:</span> <span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">,</span>
<span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span>
<span class="n">Ffs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">F</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)),</span>
<span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">,</span>
<span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span>
<span class="n">um</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">u</span><span class="o">,</span>
<span class="n">us</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span>
<span class="n">hlt</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">))</span>
<span class="bp">⊢</span> <span class="n">pseudo_emetric_space</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span>
</code></pre></div>



<a name="319427104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319427104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319427104">(Jan 04 2023 at 16:41)</a>:</h4>
<p>There is no emetric_space instance on ennreal, because the topology induced by the to-be edistance would not be the right one (there would be no finite sequence tending to infinity for the edistance, because the edistance would always be infinite).</p>



<a name="319429361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319429361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319429361">(Jan 04 2023 at 16:53)</a>:</h4>
<p>Ah, so I have to deal with this differently, thanks!</p>



<a name="319431687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319431687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319431687">(Jan 04 2023 at 17:04)</a>:</h4>
<p>You should just apply the lemma saying that sums on finsets are continuous, I think.</p>



<a name="319432179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319432179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319432179">(Jan 04 2023 at 17:06)</a>:</h4>
<p>Have a link by any chance ?</p>



<a name="319432247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319432247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319432247">(Jan 04 2023 at 17:07)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_finset_sum">docs#continuous_finset_sum</a></p>



<a name="319437658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319437658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319437658">(Jan 04 2023 at 17:39)</a>:</h4>
<p>Or <a href="https://leanprover-community.github.io/mathlib_docs/find/tendsto_finset_sum">docs#tendsto_finset_sum</a></p>



<a name="319465290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319465290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319465290">(Jan 04 2023 at 20:14)</a>:</h4>
<blockquote>
<p>Or at least that's what I believe the motivation for a different type for path is (@Junyan Xu )?</p>
</blockquote>
<p>There are several motivations:</p>
<ol>
<li>
<p>Using variable interval as domain is what's on the textbooks (BBI and BH) and also come up in homotopy theory (which is the main customer of <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a> at the moment, I think). I don't completely get their motivation yet, we'll see. I'll see if I can complete the proof of idempotency with the current <code>path</code>.</p>
</li>
<li>
<p>To consider arclength parametrization you have to use an interval of length equal to the length of the path, though the left endpoint could be chosen to be 0. If you just want a constant speed parametrization then [0,1] (as in <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a>) is good enough, but <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a> of two constant speed paths may not be constant speed. So either develop a version of <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a> that joins two paths not just at 1/2 but at any point in [0,1] (involves division which introduce unnecessary complexity), or paths with variable start/end points are needed.</p>
</li>
</ol>



<a name="319466726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319466726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319466726">(Jan 04 2023 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319366686">said</a>:</p>
<blockquote>
<p>Aside: please don't write <code>p.tendsto f q</code>, use instead <code>tendsto f p q</code>. It's closer to the intended mathematical content.</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/pull/18062">#18062</a></p>



<a name="319467310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319467310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319467310">(Jan 04 2023 at 20:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319356941">said</a>:</p>
<blockquote>
<p>What about this?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">map_source</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">t</span><span class="o">⦄,</span> <span class="n">t</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">path</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_target</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">t</span><span class="o">⦄,</span> <span class="n">l</span> <span class="bp">≤</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">path</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I agree this is a nice way to restore extensionality; and this is equivalent to the more succinct <code>set.Icc_extend (zero_le l) (path ∘ coe) = path</code> which has some API like <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous.Icc_extend'">docs#continuous.Icc_extend'</a>.</p>



<a name="319467844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319467844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319467844">(Jan 04 2023 at 20:30)</a>:</h4>
<blockquote>
<p>Aside: please don't write p.tendsto f q, use instead tendsto f p q. It's closer to the intended mathematical content.</p>
</blockquote>
<p><del>Is writing <code>p.tendsto f q</code> really so counterintuitive? It could be written as <code>x → p ⇒ f x → q</code> in usual mathematical notation, where <code>f</code> is between <code>p</code> and <code>q</code> (although it's probably more commonly written as <code>f x → q as x → p</code>.</del><br>
Oh sorry, these are filters, so I don't know what the usual mathematical notations are... but I like infix notations which can be thought of as <code>l₁ --f-→ l₂</code>.<br>
If you really want to put <code>pp_nodot</code>, though, you should probably do the same for <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.map">docs#filter.map</a>.</p>



<a name="319527241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319527241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319527241">(Jan 05 2023 at 07:24)</a>:</h4>
<p>Is there a one-liner for the sorried-out lemma?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">emetric.tendsto_edist'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">(</span><span class="n">Ff</span> <span class="o">:</span> <span class="n">filter.tendsto</span> <span class="n">F</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">))</span> <span class="o">(</span><span class="n">Gg</span> <span class="o">:</span> <span class="n">filter.tendsto</span> <span class="n">G</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">g</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="n">i</span><span class="o">))</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="bp">$</span> <span class="n">edist</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">lower_continuous_aux</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">ι</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">F</span> <span class="n">i</span> <span class="n">x</span><span class="o">)</span> <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)))</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">}</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀ᶠ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">p</span><span class="o">,</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">evariation_on</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">um</span><span class="o">,</span> <span class="n">us</span><span class="o">⟩⟩,</span> <span class="n">hlt</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">lt_supr_iff.mp</span> <span class="n">hv</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">F</span> <span class="n">j</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">F</span> <span class="n">j</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))</span>
           <span class="n">p</span> <span class="o">(</span><span class="n">nhds</span> <span class="o">(</span><span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)))),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">tendsto_finset_sum</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">emetric.tendsto_edist'</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">Ffs</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">i</span><span class="o">))</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">eventually_gt_of_tendsto_gt</span> <span class="n">hlt</span> <span class="n">this</span><span class="o">)</span><span class="bp">.</span><span class="n">mono</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span> <span class="n">lt_of_lt_of_le</span> <span class="n">h</span> <span class="o">(</span><span class="n">sum_le</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="n">n</span> <span class="n">um</span> <span class="n">us</span><span class="o">)),</span>
<span class="kd">end</span>

<span class="sd">/--</span>
<span class="sd">`λ f, evariation_on f s` is lower semicontinuous for pointwise convergence *on `s`*.</span>
<span class="sd">Pointwise convergence on `s` is encoded here as uniform convergence on the family consisting of the</span>
<span class="sd">singletons of elements of `s`.</span>
<span class="sd">-/</span>
<span class="kd">lemma</span> <span class="n">lower_semicontinuous</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">lower_semicontinuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">(</span><span class="n">s.image</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span><span class="o">}),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">lower_continuous_aux</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">uniform_on_fun</span> <span class="n">α</span> <span class="n">E</span> <span class="o">(</span><span class="n">s.image</span> <span class="n">singleton</span><span class="o">))</span> <span class="n">id</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">)</span> <span class="n">f</span> <span class="n">s</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">uniform_on_fun.tendsto_iff_tendsto_uniformly_on</span><span class="o">,</span> <span class="n">mem_image</span><span class="o">,</span> <span class="n">forall_exists_index</span><span class="o">,</span>
             <span class="n">and_imp</span><span class="o">,</span> <span class="n">forall_apply_eq_imp_iff₂</span><span class="o">,</span>
             <span class="n">tendsto_uniformly_on_singleton_iff_tendsto</span><span class="o">]</span> <span class="n">using</span> <span class="bp">@</span><span class="n">filter.tendsto_id</span> <span class="n">_</span> <span class="o">(</span><span class="n">nhds</span> <span class="n">f</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="319527358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319527358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319527358">(Jan 05 2023 at 07:25)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/filter.tendsto.edist">docs#filter.tendsto.edist</a></p>



<a name="319527607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319527607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319527607">(Jan 05 2023 at 07:27)</a>:</h4>
<p>Also, please use <code>𝓝</code> instead of <code>nhds</code> (opening the locale <code>topological_space</code>).</p>



<a name="319527633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319527633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319527633">(Jan 05 2023 at 07:27)</a>:</h4>
<p>:) I was looking at <code>emetric.tends_to_nhbds</code></p>



<a name="319527738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319527738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319527738">(Jan 05 2023 at 07:28)</a>:</h4>
<p>In general, we have lemmas with dot notation for most convergence results, so that it is straightforward to build convergence statements from the different constituants.</p>



<a name="319529469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319529469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319529469">(Jan 05 2023 at 07:42)</a>:</h4>
<p>Updated: <a href="https://github.com/leanprover-community/mathlib/pull/18058">https://github.com/leanprover-community/mathlib/pull/18058</a></p>



<a name="319529555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319529555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319529555">(Jan 05 2023 at 07:43)</a>:</h4>
<p>I actually also removed a coercion in the def of the variation, after seeing a comment of Junyan, and it does cut elaboration time by a lot, but since it's not the purpose of the PR, I can revert that change (it just happened to be on the branch I was working on)</p>



<a name="319553067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319553067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319553067">(Jan 05 2023 at 10:24)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/18040/files">https://github.com/leanprover-community/mathlib/pull/18040/files</a> &lt;- updated the <code>variation_from_to</code> PR</p>



<a name="319742138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319742138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319742138">(Jan 06 2023 at 09:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319465290">said</a>:</p>
<blockquote>
<blockquote>
<p>Or at least that's what I believe the motivation for a different type for path is (@Junyan Xu )?</p>
</blockquote>
<ol start="2">
<li>To consider arclength parametrization you have to use an interval of length equal to the length of the path, though the left endpoint could be chosen to be 0. If you just want a constant speed parametrization then [0,1] (as in <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a>) is good enough, but <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a> of two constant speed paths may not be constant speed. So either develop a version of <a href="https://leanprover-community.github.io/mathlib_docs/find/path.trans">docs#path.trans</a> that joins two paths not just at 1/2 but at any point in [0,1] (involves division which introduce unnecessary complexity), or paths with variable start/end points are needed.</li>
</ol>
</blockquote>
<p>I wouldn't use a new structure for that: only a function defined on the whole real-line, and in relevant lemmas I would put an assumption <code>is_arclength_on f a b</code> (meaning that for all <code>c, d</code> in <code>[a, b]</code>, the variation of <code>f</code> from <code>c</code> to <code>d</code> is <code>d - c</code>). Introducing new types has a cost (you need to build a whole API around it, and make sure it interacts nicely with as much as you can), so it shoudn't be done lightly. For instance, the structure <code>path x y</code> is necessary because fundamental groups are built as quotients of these, so you can't just get away with an assumption you put in some lemmas. Here, it's not obvious to me which problem it would solve. (I'm not saying: "don't do it"; I'm saying "do it if you really thought the design through and it's the best solution").</p>



<a name="319743604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319743604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319743604">(Jan 06 2023 at 09:19)</a>:</h4>
<p>Should we keep an "indexing set" <code>s</code> for your <code>is_arclength_on</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_linearly_parameterized_on_by</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">l</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="o">))</span>
</code></pre></div>



<a name="319793870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319793870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319793870">(Jan 06 2023 at 14:39)</a>:</h4>
<p>Uh, that's wrong, we want only to quantify over <code>x y</code> in <code>s</code> I believe</p>



<a name="319914575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319914575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319914575">(Jan 07 2023 at 07:21)</a>:</h4>
<p>I saw that you posted a <a href="https://github.com/leanprover-community/mathlib/pull/18040#discussion_r1063246799">comment on GitHub</a> as well.</p>
<p>I think it's good to keep an indexing set <code>s</code>, because we do want to consider (half-)infinite paths/geodesics (<a href="https://en.wikipedia.org/wiki/Busemann_function#Definition_and_elementary_properties">example</a>), and that shows my <code>path_btw</code> is too restrictive; a remedy could be allowing <code>ereal</code> values for source/target, but it maybe easier to just allow the generality of an arbitrary indexing set, which may be required to be <a href="https://leanprover-community.github.io/mathlib_docs/find/set.ord_connected">docs#set.ord_connected</a> (which covers all kinds of intervals including <code>Ioo</code>) in theorems.</p>
<p>Assuming <code>s</code> is ord_connected, which says <code>Icc x y</code> is included in <code>s</code> whenever <code>x</code> and <code>y</code> are, we may simplify <code>evariation_on f (s ∩ Icc x y)</code> to <code>evariation_on f (Icc x y)</code>, which is exactly my <code>arclength f x y</code>. For this reason, I'm not sure whether I should include <code>s</code> into <code>arclength</code>, since I can't think of situations in which we want to consider <code>s</code> that are not intervals/ord_connected.</p>
<p>On GitHub I said there are four specializations of <code>evariation_on</code> that could be done independently:</p>
<blockquote>
<p>(1) restrict to intervals (replace <code>s</code> by <code>s ∩ Icc x y</code>)<br>
(2) upgrade to the signed version (ennreal -&gt; ereal, nnreal -&gt; real)<br>
(3) specialize to the bounded variation / finite length case (ennreal -&gt; nnreal, ereal -&gt; real)<br>
(4) stop carrying around the set <code>s</code> (i.e. take <code>s := univ</code>)</p>
</blockquote>
<p>I did (1)&amp;(4) in <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34">the arclength gist</a> while you did (1)(2)(3) in <a href="https://github.com/leanprover-community/mathlib/pull/18040">#18040</a>. Item (1) is common to both, and I feel that it's reasonable to bundle (2)&amp;(3) together (as you did). You said on GitHub that "(1) probably should not be changed for as long as possible" but in your <code>is_linearly_parameterized_on_by</code>, what you do is exactly item (1), and none of (2)(3)(4). Maybe my description of the four items has some ambiguity so you didn't catch my intended meaning?</p>
<p>If I keep <code>s</code> around in my gist (i.e. don't do item (4)), then you'd be able to define your <code>variation_on_from_to</code> in terms of my <code>arclength</code>. However, now I think it's better to keep the two separate, and I'd be happy to see <a href="https://github.com/leanprover-community/mathlib/pull/18040">#18040</a> go through, after refactoring a proof to use <code>multiplicative_of_total</code> (now in <a href="https://github.com/leanprover-community/mathlib/pull/18080">#18080</a>).</p>
<p>I think your formulation of uniqueness of natural parametrization is probably true (when <code>l, l' &gt; 0</code>) for general <code>s</code> (it would have to be dense in an interval in order to naturally parametrize some curve, though), no matter you use <code>s ∩ Icc x y</code> or just <code>Icc x y</code> in the definition of linear parametrization. Monotonicity can probably be replaced by injectivity if <code>s</code> is ord_connected. I'm also thinking a statement of the form</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="n">ψ</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φm</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">φ</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ψm</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">ψ</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">is_naturally_parameterized_on</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hψ</span> <span class="o">:</span> <span class="n">is_naturally_parameterized_on</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">ψ</span><span class="o">)</span> <span class="o">(</span><span class="n">ψ</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">ψ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">φ</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">r</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> should be replaced by eq_on -/</span> <span class="o">:=</span>
</code></pre></div>
<p>but it's not true because if <code>f</code> stops at a point during some interval then there's freedom to change a value of ψ or φ in that interval to any other point in the same interval.</p>



<a name="319930891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319930891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319930891">(Jan 07 2023 at 10:08)</a>:</h4>
<p>What I meant I think was about your item 4 actually: We should keep <code>s</code> as long as possible, in order to allow to talk about functions that might be badly behaved outside of a given <code>s</code>. E.g. talking about arc-length of functions that are defined on all of <code>real</code> but that we really mean as path from some interval.<br>
As for my snippet above, to be clear, I meant it as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_linearly_parameterized_on_by</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="bp">\</span><span class="k">in</span> <span class="n">s</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">l</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="o">))</span>
</code></pre></div>
<p>and in that case, I agree that it might be easier to replace <code>s ∩ Icc x y</code> by <code>Icc x y</code>,  but I think I wouldn't do it: it might be helpful to allow removing "singularities" from the domain, no, like if we start with piecewise smooth functions, we might get in situation where the easiest is just to drop the non-smooth parts from <code>s</code> ?</p>



<a name="319931335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319931335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319931335">(Jan 07 2023 at 10:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/319914575">said</a>:</p>
<blockquote>
<p>If I keep <code>s</code> around in my gist (i.e. don't do item (4)), then you'd be able to define your <code>variation_on_from_to</code> in terms of my <code>arclength</code>. However, now I think it's better to keep the two separate, and I'd be happy to see <a href="https://github.com/leanprover-community/mathlib/pull/18040">#18040</a> go through, after refactoring a proof to use <code>multiplicative_of_total</code> (now in <a href="https://github.com/leanprover-community/mathlib/pull/18080">#18080</a>).</p>
</blockquote>
<p>I'm getting a bit lost: Would you have two different definitions of "variation"/arclength that are so close together yet not defined in terms of each other? What kind of hierarchy of definitions do you envision, and where would <code>is_linearly_parameterized_on_by</code> (or equivalent) sit?</p>



<a name="319996480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/319996480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#319996480">(Jan 07 2023 at 18:57)</a>:</h4>
<blockquote>
<p>it might be helpful to allow removing "singularities" from the domain, no, like if we start with piecewise smooth functions, we might get in situation where the easiest is just to drop the non-smooth parts from s ?</p>
</blockquote>
<p>I don't know what removing "singularities" buys you when it comes to <code>evariation_on</code>. The curve would still have to continuous everywhere (in an interval) right? I think when <code>f</code> is continuous you can show <code>evariation_on f (closure s) = evariation_on f s</code>. Unfortunately it's not necessarily true that <code>evariation_on f (closure s ∩ Icc x y) = evariation_on f (s ∩ Icc x y)</code>, for example when <code>s = {-1/n, 1 + 1/n | n &gt; 0}</code>, <code>x = 0</code> and <code>y = 1</code> (LHS is {0, 1} while RHS is empty). When <code>t</code> is open, I think we do have <code>evariation_on f (closure s ∩ t) = evariation_on f (s ∩ t)</code> though, because of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_open.closure_inter">docs#is_open.closure_inter</a>.</p>



<a name="320502029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320502029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320502029">(Jan 10 2023 at 17:17)</a>:</h4>
<p>What about this for the path metric? Tomorrow, I plan on trying to set up the infrastructure to show that the path metric is idempotent, leaving the necessary technical lemmas out, in order to get something going, and see what formulations of the lemmas (E.g. continuity of variation, and rectifiability of paths wrt the path metric) are necessary. <br>
<span class="user-mention" data-user-id="224323">@Junyan Xu</span> If you already have something fleshed out, can you share it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">path_emetric.edist</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="o">:=</span>
  <span class="bp">⨅</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">continuous_on</span> <span class="n">p</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="mi">0</span> <span class="n">l</span><span class="o">)),</span>
    <span class="n">evariation_on</span> <span class="n">p</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="mi">0</span> <span class="n">l</span><span class="o">)</span>
</code></pre></div>



<a name="320510740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320510740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320510740">(Jan 10 2023 at 17:59)</a>:</h4>
<p>It's not clear to me if the definition will work out better by allowing a varying <code>l</code> as you do, or just fixing <code>l = 1</code> for definiteness. Probably the difference won't really matter anyway.</p>



<a name="320646919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320646919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320646919">(Jan 11 2023 at 08:46)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> I haven't got a chance to work on path metric/idempotency yet; mostly dealing with algebra PRs these days. You can find latest updates on the continuity results <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34/revisions">here</a> (made some adjustments to make them hopefully easier to apply).</p>



<a name="320738427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320738427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320738427">(Jan 11 2023 at 16:05)</a>:</h4>
<p>I got to that: plenty of sorrys remaining, and it's not very satisfying:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.emetric_space</span>
<span class="kn">import</span> <span class="n">analysis.bounded_variation</span>
<span class="kn">import</span> <span class="n">topology.metric_space.lipschitz</span>

<span class="kd">noncomputable theory</span>

<span class="n">open_locale</span> <span class="n">nnreal</span> <span class="n">ennreal</span> <span class="n">big_operators</span>

<span class="kn">section</span> <span class="n">real_line_map</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">continuous_line_map</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">surj_on_unit_interval_line_map_of_le</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.surj_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="n">unit_interval</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">maps_to_unit_interval_line_map_of_le</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.maps_to</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="n">unit_interval</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">monotone_line_map_of_le</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">surj_on_unit_interval_line_map_of_ge</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.surj_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="n">unit_interval</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">maps_to_unit_interval_line_map_of_ge</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.maps_to</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="n">unit_interval</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">antitone_line_map_of_ge</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">antitone</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span><span class="bp">*</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">real_line_map</span>

<span class="kn">namespace</span> <span class="n">evariation_on</span>

<span class="kd">lemma</span> <span class="n">sum_on_Icc_le</span> <span class="o">{</span><span class="n">α</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">s</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">s</span> <span class="n">us</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.range_zero</span><span class="o">,</span> <span class="n">finset.sum_empty</span><span class="o">,</span> <span class="n">zero_le'</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">s</span> <span class="n">us</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="bp">@</span><span class="n">n_ih</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">n_n</span><span class="o">}</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>  <span class="o">⟨</span><span class="n">us</span> <span class="n">i</span> <span class="o">(</span><span class="n">hi.trans</span> <span class="o">(</span><span class="n">nat.le_succ</span> <span class="n">_</span><span class="o">)),</span> <span class="n">hu</span> <span class="n">hi</span><span class="o">⟩),</span>
    <span class="n">rw</span> <span class="n">finset.sum_range_succ</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n_n</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">∩</span>
                                                           <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">n_n</span><span class="o">})</span>
         <span class="bp">=</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n_n</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">s</span><span class="o">),</span> <span class="kd">by</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">finset.sum_congr</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">congr'</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:</span> <span class="mi">1</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h.1</span><span class="o">,</span><span class="n">h.2.1</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h.1</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h.2</span><span class="o">,</span> <span class="n">h.1.2.trans</span> <span class="o">(</span><span class="n">hu</span> <span class="o">(</span><span class="n">nat.succ_le_of_lt</span> <span class="n">_</span><span class="o">))⟩⟩⟩,</span>
      <span class="n">rw</span> <span class="n">finset.mem_range</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hi</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">add_le_add_right</span> <span class="n">n_ih</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">((</span><span class="n">add_le_union</span> <span class="n">f</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">mono</span> <span class="n">f</span> <span class="n">_</span><span class="o">)),</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">hx</span><span class="o">⟩</span> <span class="n">y</span> <span class="o">⟨⟨</span><span class="n">hy</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">hx.trans</span> <span class="n">hy</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="o">(⟨</span><span class="n">h</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">h</span><span class="o">⟩)</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">evariation_on</span>

<span class="kn">section</span> <span class="n">path_emetric</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kn">private</span> <span class="kd">abbreviation</span> <span class="bp">𝕀</span> <span class="o">:=</span> <span class="n">unit_interval</span>

<span class="kd">def</span> <span class="n">path_emetric</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">E</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">to_path_emetric</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">path_emetric</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>
<span class="kd">def</span> <span class="n">from_path_emetric</span> <span class="o">:</span> <span class="n">path_emetric</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">id</span>
<span class="kd">abbreviation</span> <span class="n">of</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">path_emetric</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">to_path_emetric</span>
<span class="kd">abbreviation</span> <span class="n">fo</span> <span class="o">:</span> <span class="n">path_emetric</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">from_path_emetric</span>

<span class="kd">lemma</span> <span class="n">from_to_path_emetric</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">from_path_emetric</span> <span class="o">(</span><span class="n">to_path_emetric</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">to_from_path_emetric</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">path_emetric</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_path_emetric</span> <span class="o">(</span><span class="n">from_path_emetric</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">path_emetric.edist</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="o">:=</span>
  <span class="bp">⨅</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">p</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">continuous_on</span> <span class="n">p</span> <span class="bp">𝕀</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">p</span> <span class="bp">𝕀</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">pseudo_emetric_space</span> <span class="o">(</span><span class="n">path_emetric</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edist</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">path_emetric.edist</span> <span class="o">(</span><span class="n">from_path_emetric</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">from_path_emetric</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">edist_self</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">path_emetric.edist</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="n">_</span> <span class="n">zero_le'</span><span class="o">,</span>
    <span class="n">transitivity'</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">fo</span> <span class="n">x</span><span class="o">)</span> <span class="bp">𝕀</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">infi₂_le</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">fo</span> <span class="n">x</span><span class="o">)</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">,</span> <span class="n">continuous_on_const</span><span class="o">⟩,</span>  <span class="o">},</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">eq.le</span> <span class="o">(</span><span class="n">evariation_on.constant_on</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.nonempty.image_const</span><span class="o">,</span> <span class="n">set.nonempty_Icc</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="o">,</span> <span class="n">set.subsingleton_singleton</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
  <span class="n">edist_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">le_antisymm</span><span class="bp">;</span>
    <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">path_emetric.edist</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">le_infi₂</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">p</span> <span class="o">⟨</span><span class="n">px</span><span class="o">,</span><span class="n">py</span><span class="o">,</span><span class="n">pc</span><span class="o">⟩,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">evariation_on.comp_eq_of_antitone_on</span> <span class="n">p</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="n">u</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">infi₂_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_sub</span><span class="o">,</span> <span class="n">neg_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">py</span><span class="o">],</span> <span class="o">},</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">px</span><span class="o">,</span> <span class="n">zero_sub</span><span class="o">,</span> <span class="n">neg_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span>
                   <span class="bp">←</span><span class="n">sub_eq_add_neg</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">],</span> <span class="o">},</span>
      <span class="n">apply</span> <span class="n">pc.comp</span> <span class="o">(</span><span class="n">continuous_line_map</span> <span class="mi">1</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_on</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">maps_to_unit_interval_line_map_of_ge</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">(</span><span class="n">zero_le_one</span><span class="o">),</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">antitone_line_map_of_ge</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">(</span><span class="n">zero_le_one</span><span class="o">))</span><span class="bp">.</span><span class="n">antitone_on</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">maps_to_unit_interval_line_map_of_ge</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">(</span><span class="n">zero_le_one</span><span class="o">),</span>
      <span class="n">exact</span> <span class="n">surj_on_unit_interval_line_map_of_ge</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">(</span><span class="n">zero_le_one</span><span class="o">),</span> <span class="o">},</span> <span class="o">},</span>
  <span class="n">edist_triangle</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">path_emetric.edist</span><span class="o">],</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">ennreal.infi_add</span><span class="o">,</span> <span class="n">ennreal.add_infi</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">le_infi</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">le_infi</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">le_infi</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="n">le_infi</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hq</span><span class="o">,</span> <span class="n">_</span><span class="o">)))),</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">px</span><span class="o">,</span><span class="n">py</span><span class="o">,</span><span class="n">pc</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">qy</span><span class="o">,</span><span class="n">qz</span><span class="o">,</span><span class="n">qc</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hq</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">evariation_on</span> <span class="n">p</span> <span class="bp">𝕀</span> <span class="bp">+</span> <span class="n">evariation_on</span> <span class="n">q</span> <span class="bp">𝕀</span> <span class="bp">=</span>
           <span class="n">evariation_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">≤</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span> <span class="k">then</span> <span class="n">p</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">t</span><span class="o">)</span> <span class="k">else</span> <span class="n">q</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">t</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">𝕀</span><span class="o">,</span> <span class="kd">by</span>
    <span class="o">{</span> <span class="n">nth_rewrite_rhs</span> <span class="mi">0</span> <span class="bp">←</span><span class="n">set.inter_self</span> <span class="bp">𝕀</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">evariation_on.Icc_add_Icc</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">≤</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span> <span class="k">then</span> <span class="n">p</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">t</span><span class="o">)</span> <span class="k">else</span> <span class="n">q</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">t</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="gr">sorry</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">half_le_self</span> <span class="n">zero_le_one</span><span class="o">)</span> <span class="gr">sorry</span><span class="o">,</span>
      <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
      <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">infi₂_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">¬</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_div</span><span class="o">,</span> <span class="n">inv_nonneg</span><span class="o">,</span> <span class="n">zero_le_bit0</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">if_true</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">px</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">}</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">path_emetric.edist_le</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">p</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">pt</span> <span class="o">:</span> <span class="n">p</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">pc</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">p</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">s</span> <span class="n">t</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="o">(</span><span class="n">of</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">of</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">p</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">evariation_on</span> <span class="n">p</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">s</span> <span class="bp">+</span> <span class="o">(</span><span class="n">t</span><span class="bp">-</span><span class="n">s</span><span class="o">)</span><span class="bp">*</span><span class="n">u</span><span class="o">))</span> <span class="bp">𝕀</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">apply</span> <span class="n">evariation_on.comp_eq_of_monotone_on</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">monotone_line_map_of_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">st</span><span class="o">)</span><span class="bp">.</span><span class="n">monotone_on</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">maps_to_unit_interval_line_map_of_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">st</span><span class="o">),</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">surj_on_unit_interval_line_map_of_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">st</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">infi₂_le</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">add_sub_cancel'_right</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">ps</span><span class="o">,</span> <span class="n">pt</span><span class="o">,</span> <span class="n">pc.comp</span> <span class="o">(</span><span class="n">continuous_line_map</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_on</span>
                         <span class="o">(</span><span class="n">maps_to_unit_interval_line_map_of_le</span> <span class="n">s</span> <span class="n">t</span> <span class="n">st</span><span class="o">)⟩,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">from_path_emetric_nonexpanding</span> <span class="o">:</span>
  <span class="n">lipschitz_with</span> <span class="mi">1</span> <span class="o">(</span><span class="n">from_path_emetric</span> <span class="o">:</span> <span class="n">path_emetric</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">edist</span><span class="o">,</span> <span class="n">path_emetric.edist</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ennreal.coe_one</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">le_infi₂_iff</span><span class="o">],</span>
  <span class="n">rintro</span> <span class="n">p</span> <span class="o">⟨</span><span class="n">px</span><span class="o">,</span> <span class="n">py</span><span class="o">,</span> <span class="n">pc</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">px</span><span class="o">,</span> <span class="bp">←</span><span class="n">py</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">evariation_on.edist_le</span> <span class="n">p</span> <span class="n">unit_interval.zero_mem</span> <span class="n">unit_interval.one_mem</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">continuous_for_path_metric_of_bounded_variation_of_continuous</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">(</span><span class="n">fc</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="bp">𝕀</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_bounded_variation_on</span> <span class="n">f</span> <span class="bp">𝕀</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous_on</span> <span class="o">(</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="bp">𝕀</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">sum_for_path_metric_le_evariation_on_of_bounded_variation</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">fc</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">us</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">u</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">um</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">((</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">((</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">calc</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">edist</span> <span class="o">((</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">((</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">))</span>
     <span class="bp">≤</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span>
  <span class="kd">begin</span>
    <span class="n">refine</span> <span class="n">finset.sum_le_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">edist_comm</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">path_emetric.edist_le</span> <span class="o">(</span><span class="n">um</span> <span class="o">(</span><span class="n">i.le_succ</span><span class="o">))</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="o">(</span><span class="n">continuous_on.mono</span> <span class="n">fc</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hs</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">t</span> <span class="n">ht.left</span> <span class="n">ht.right</span><span class="o">,</span>
  <span class="kd">end</span>
  <span class="bp">...=</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset.range</span> <span class="n">n</span><span class="o">,</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set.inter_eq_self_of_subset_left</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hs</span> <span class="o">(</span><span class="n">u</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">t</span> <span class="n">ht.left</span> <span class="n">ht.right</span><span class="o">,</span> <span class="o">}</span>
  <span class="bp">...≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:</span> <span class="n">evariation_on.sum_on_Icc_le</span> <span class="n">f</span> <span class="n">n</span> <span class="n">um</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">us</span> <span class="n">i</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">evariation_on_for_path_metric_le_evariation_on_of_bounded_variation</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span>  <span class="o">(</span><span class="n">fc</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">evariation_on</span> <span class="o">(</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">evariation_on</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">supr_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">um</span><span class="o">,</span> <span class="n">us</span><span class="o">⟩⟩,</span>
  <span class="n">apply</span> <span class="n">sum_for_path_metric_le_evariation_on_of_bounded_variation</span> <span class="n">hs</span> <span class="n">fb</span> <span class="n">fc</span> <span class="n">n</span> <span class="n">us</span> <span class="n">um</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">path_metric_idempotent</span> <span class="o">:</span> <span class="n">isometry</span> <span class="o">(</span><span class="n">of</span> <span class="o">:</span> <span class="n">path_emetric</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">path_emetric</span> <span class="o">(</span><span class="n">path_emetric</span> <span class="n">E</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">edist</span><span class="o">,</span> <span class="n">from_path_emetric</span><span class="o">,</span> <span class="n">path_emetric.edist</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">le_infi_iff</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">fx</span><span class="o">,</span> <span class="n">fy</span><span class="o">,</span> <span class="n">fc</span><span class="o">⟩,</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="bp">𝕀</span> <span class="bp">≠</span> <span class="bp">⊤</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">evariation_on_for_path_metric_le_evariation_on_of_bounded_variation</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">zx</span><span class="o">,</span><span class="n">xo</span><span class="o">⟩</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">zy</span><span class="o">,</span><span class="n">yo</span><span class="o">⟩</span> <span class="n">u</span> <span class="n">xu</span> <span class="n">uy</span><span class="o">,</span> <span class="o">⟨</span><span class="n">zx.trans</span> <span class="n">xu</span><span class="o">,</span> <span class="n">uy.trans</span> <span class="n">yo</span><span class="o">⟩</span> <span class="o">)</span> <span class="o">(</span><span class="n">has_bounded_variation_on.has_locally_bounded_variation_on</span> <span class="n">h</span><span class="o">)</span> <span class="n">fc</span><span class="o">),</span>
      <span class="n">refine</span> <span class="n">infi₂_le</span> <span class="o">(</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">⟨</span><span class="n">congr_arg</span> <span class="n">of</span> <span class="n">fx</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">of</span> <span class="n">fy</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="n">continuous_for_path_metric_of_bounded_variation_of_continuous</span> <span class="n">fc</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">not_not.mp</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_top</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">f'</span> <span class="o">⟨</span><span class="n">f'x</span><span class="o">,</span> <span class="n">f'y</span><span class="o">,</span> <span class="n">f'c</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">evariation_on</span> <span class="n">f'</span> <span class="bp">𝕀</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">evariation_on</span> <span class="n">f'</span> <span class="bp">𝕀</span><span class="o">),</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">one_mul</span><span class="o">],</span> <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="o">(((</span><span class="n">from_path_emetric_nonexpanding</span><span class="o">)</span><span class="bp">.</span><span class="n">lipschitz_on_with</span> <span class="n">set.univ</span><span class="o">)</span><span class="bp">.</span><span class="n">comp_evariation_on_le</span> <span class="o">(</span><span class="n">set.maps_to_univ</span> <span class="n">_</span> <span class="n">_</span><span class="o">)),</span>
    <span class="n">refine</span> <span class="n">infi₂_le</span> <span class="o">(</span><span class="n">fo</span> <span class="bp">∘</span> <span class="n">f'</span><span class="o">)</span> <span class="o">⟨</span><span class="n">congr_arg</span> <span class="n">fo</span> <span class="n">f'x</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">fo</span> <span class="n">f'y</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">from_path_emetric_nonexpanding.continuous.continuous_on.comp</span> <span class="n">f'c</span> <span class="o">(</span><span class="n">set.maps_to_univ</span> <span class="n">_</span> <span class="bp">𝕀</span><span class="o">),</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">path_emetric</span>
</code></pre></div>



<a name="320741473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320741473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320741473">(Jan 11 2023 at 16:17)</a>:</h4>
<p>But I'd welcome feedback on the formulation of it: is that architecturally what you were thinking of, <span class="user-mention" data-user-id="224323">@Junyan Xu</span> ?</p>



<a name="320743372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320743372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320743372">(Jan 11 2023 at 16:26)</a>:</h4>
<p>Maybe it would be easier to just have <code>continuous p</code> as an assumption for the distance, since it allows using <code>continuous.if_le</code></p>



<a name="320746413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320746413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320746413">(Jan 11 2023 at 16:39)</a>:</h4>
<p>I'll do that, at least for the time being.</p>



<a name="320977257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320977257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320977257">(Jan 12 2023 at 16:15)</a>:</h4>
<p>I think it's looking OK, and it's better to use <code>path x y</code> and add some API around it, like I tried to do here.<br>
Some questions:</p>
<ul>
<li>I need the following:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">comp</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">φc</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">φ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="o">(</span><span class="n">φ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">extend_comp</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">φc</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">φ</span> <span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">γ.comp</span> <span class="n">φ</span> <span class="n">φc</span><span class="o">)</span><span class="bp">.</span><span class="n">extend</span> <span class="bp">=</span> <span class="n">φ</span> <span class="bp">∘</span> <span class="n">γ.extend</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>This should be somewhere in mathlib, no?</p>
<ul>
<li>I used the following statement for continuity of arc-length: </li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">variation_on_from_to_continuous_on</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">⦃</span><span class="n">z</span><span class="o">⦄</span> <span class="o">(</span><span class="n">zs</span> <span class="o">:</span> <span class="n">z</span><span class="bp">∈</span><span class="n">s</span><span class="o">),</span> <span class="n">set.Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fc</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous_on</span> <span class="o">(</span><span class="n">variation_on_from_to</span> <span class="n">f</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Does that look reasonable?</p>



<a name="320977982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/320977982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#320977982">(Jan 12 2023 at 16:19)</a>:</h4>
<p>Mmh, we can probably drop the <code>a \in s</code> assumption here.</p>



<a name="321156084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321156084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321156084">(Jan 13 2023 at 13:05)</a>:</h4>
<p>OK, the way I used <code>variation_on_from_to</code> was kind of a détour, I'm using this now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">continuous_right_self_evariation'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hcont</span> <span class="o">:</span> <span class="n">continuous_within_at</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> f is right continuous at a -/</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span>
    <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="o">(</span><span class="n">set.Ici</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">continuous_right_self_evariation</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">⦃</span><span class="n">z</span><span class="o">⦄</span> <span class="o">(</span><span class="n">zs</span> <span class="o">:</span> <span class="n">z</span><span class="bp">∈</span><span class="n">s</span><span class="o">),</span> <span class="n">set.Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hcont</span> <span class="o">:</span> <span class="n">continuous_within_at</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">set.Ici</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> f is right continuous at a -/</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
    <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">set.Ici</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">emetric.tendsto_within_nhds_ennreal_zero</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">&gt;</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">bs</span><span class="o">,</span><span class="n">ab</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">let</span> <span class="o">:=</span> <span class="n">continuous_right_self_evariation'</span> <span class="n">ab</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span><span class="n">zero_lt_one</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">dxa</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">xs</span><span class="o">,</span><span class="n">xa</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)</span> <span class="n">xa</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">evariation_on.subsingleton</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">:</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">subsingleton</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">hε</span><span class="o">,</span> <span class="o">},</span>

<span class="kd">end</span>
<span class="kd">theorem</span> <span class="n">continuous_left_self_evariation'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span>  <span class="o">(</span><span class="n">ba</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Ioc</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hcont</span> <span class="o">:</span> <span class="n">continuous_within_at</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Ioc</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> f is left continuous at a -/</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">x</span> <span class="n">a</span><span class="o">))</span>
    <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="o">(</span><span class="n">set.Iic</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">continuous_left_self_evariation</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">⦃</span><span class="n">z</span><span class="o">⦄</span> <span class="o">(</span><span class="n">zs</span> <span class="o">:</span> <span class="n">z</span><span class="bp">∈</span><span class="n">s</span><span class="o">),</span> <span class="n">set.Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hcont</span> <span class="o">:</span> <span class="n">continuous_within_at</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">set.Iic</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> f is left continuous at a -/</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span>
    <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">set.Iic</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I believe the non-prime versions follow from the prime ones, (not finished the proof though).<br>
I wrote everything in terms of <code>tendsto … (nhds 0)</code> because writing in terms of continuity felt kind of wrong.</p>



<a name="321156667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321156667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321156667">(Jan 13 2023 at 13:07)</a>:</h4>
<p>I used the following too, which I couldn't find in mathlib because ennreal complicates epsilon-delta arguments it seems:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">emetric.tendsto_within_nhds_ennreal_zero</span>
  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="n">f</span> <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">),</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span>
      <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">has_edist.edist</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ennreal.tendsto_nhds_zero</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">ε'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">⊓</span> <span class="mi">1</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">ε'</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">lt_inf_iff.mpr</span> <span class="o">⟨(</span><span class="n">ennreal.half_pos</span> <span class="n">hε.lt.ne.symm</span><span class="o">),</span><span class="n">zero_lt_one</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">ε'</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">,</span> <span class="kd">by</span>
    <span class="o">{</span> <span class="n">by_cases</span> <span class="n">ht</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">cases</span> <span class="n">ht</span><span class="o">,</span> <span class="n">rw</span> <span class="n">inf_lt_iff</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ennreal.one_lt_top</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">inf_lt_iff</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">ennreal.half_lt_self</span> <span class="n">hε.lt.ne.symm</span> <span class="n">ht</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="n">ε'</span> <span class="o">‹</span><span class="n">ε'</span><span class="bp">&gt;</span><span class="mi">0</span><span class="o">›,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">δ</span><span class="o">,</span><span class="n">hδ</span><span class="o">,</span><span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">emetric.mem_nhds_within_iff.mp</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">δ</span><span class="o">,</span><span class="n">hδ</span><span class="o">,</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">dxa</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">lt_of_le_of_lt</span> <span class="o">(</span><span class="n">h</span> <span class="o">⟨</span><span class="n">dxa</span><span class="o">,</span><span class="n">xs</span><span class="o">⟩)</span> <span class="o">‹</span><span class="n">ε'</span><span class="bp">&lt;</span><span class="n">ε</span><span class="o">›,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">δ</span><span class="o">,</span><span class="n">hδ</span><span class="o">,</span><span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">filter.eventually</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">emetric.mem_nhds_within_iff</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">δ</span><span class="o">,</span><span class="n">hδ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">hx.2</span> <span class="n">hx.1</span><span class="o">)</span><span class="bp">.</span><span class="n">le</span><span class="o">⟩,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="321157008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321157008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321157008">(Jan 13 2023 at 13:09)</a>:</h4>
<p>And then the proof that a continuous rectifiable curve stays continuous looks like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">continuous_for_path_metric_of_bounded_variation_of_continuous</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">⦃</span><span class="n">z</span><span class="o">⦄</span> <span class="o">(</span><span class="n">zs</span> <span class="o">:</span> <span class="n">z</span><span class="bp">∈</span><span class="n">s</span><span class="o">),</span> <span class="n">set.Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fc</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">fb</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous_on</span> <span class="o">(</span><span class="n">of</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">emetric.continuous_on_iff</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">b</span> <span class="n">bs</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">hleft</span> <span class="o">:=</span> <span class="n">continuous_right_self_evariation</span> <span class="n">hs</span> <span class="n">fb</span> <span class="n">bs</span>
                 <span class="o">((</span><span class="n">fc.continuous_within_at</span> <span class="n">bs</span><span class="o">)</span><span class="bp">.</span><span class="n">mono</span> <span class="o">(</span><span class="n">set.inter_subset_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="n">emetric.tendsto_within_nhds_ennreal_zero</span> <span class="n">at</span> <span class="n">hleft</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">δl</span><span class="o">,</span><span class="n">hδl</span><span class="o">,</span><span class="n">hl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hleft</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">hright</span> <span class="o">:=</span> <span class="n">continuous_left_self_evariation</span> <span class="n">hs</span> <span class="n">fb</span> <span class="n">bs</span>
                 <span class="o">((</span><span class="n">fc.continuous_within_at</span> <span class="n">bs</span><span class="o">)</span><span class="bp">.</span><span class="n">mono</span> <span class="o">(</span><span class="n">set.inter_subset_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="n">emetric.tendsto_within_nhds_ennreal_zero</span> <span class="n">at</span> <span class="n">hright</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">δr</span><span class="o">,</span><span class="n">hδr</span><span class="o">,</span><span class="n">hr</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hright</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">δl</span> <span class="bp">⊓</span> <span class="n">δr</span><span class="o">,</span> <span class="n">lt_inf_iff.mpr</span> <span class="o">⟨</span><span class="n">hδl.lt</span><span class="o">,</span><span class="n">hδr.lt</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">as</span> <span class="n">hab</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">],</span>
  <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="o">(</span><span class="n">ab</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">|</span><span class="n">ba</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">lt_of_le_of_lt</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">edist_le</span> <span class="n">ab.le</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="o">(</span><span class="n">fc.mono</span> <span class="o">(</span><span class="n">hs</span> <span class="n">as</span> <span class="n">bs</span><span class="o">)),</span>
    <span class="n">apply</span> <span class="n">hr</span> <span class="o">⟨</span><span class="n">as</span><span class="o">,</span><span class="n">ab.le</span><span class="o">⟩</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">hab</span> <span class="n">inf_le_right</span><span class="o">),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">edist_self</span><span class="o">],</span> <span class="n">exact</span> <span class="n">hε</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">edist_comm</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">lt_of_le_of_lt</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">edist_le</span> <span class="n">ba.le</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="o">(</span><span class="n">fc.mono</span> <span class="o">(</span><span class="n">hs</span> <span class="n">bs</span> <span class="n">as</span><span class="o">)),</span>
    <span class="n">refine</span> <span class="n">hl</span> <span class="o">⟨</span><span class="n">as</span><span class="o">,</span><span class="n">ba.le</span><span class="o">⟩</span> <span class="o">(</span><span class="n">lt_of_lt_of_le</span> <span class="n">hab</span> <span class="n">inf_le_left</span><span class="o">),</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>That's probably heavily simplifiable.</p>



<a name="321157646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321157646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321157646">(Jan 13 2023 at 13:12)</a>:</h4>
<p>I'll continue and try to clean everything up, and then try with a PR when satisfied with how it looks. Hope I'm going in the right direction.</p>



<a name="321200437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321200437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321200437">(Jan 13 2023 at 16:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/321157646">said</a>:</p>
<blockquote>
<p>I'll continue and try to clean everything up, and then try with a PR when satisfied with how it looks. Hope I'm going in the right direction.</p>
</blockquote>
<p>That looks definitely like the right direction!</p>



<a name="321518293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321518293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321518293">(Jan 15 2023 at 18:22)</a>:</h4>
<p><code>path.comp</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/path.map">docs#path.map</a> in mathlib:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.path_connected</span>
<span class="kn">namespace</span> <span class="n">path</span>

<span class="kd">def</span> <span class="n">comp</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">φc</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">φ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="o">(</span><span class="n">φ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">γ.map</span> <span class="n">φc</span>

<span class="kd">lemma</span> <span class="n">extend_comp</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">φc</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">φ</span> <span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">γ.comp</span> <span class="n">φ</span> <span class="n">φc</span><span class="o">)</span><span class="bp">.</span><span class="n">extend</span> <span class="bp">=</span> <span class="n">φ</span> <span class="bp">∘</span> <span class="n">γ.extend</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="c">/-</span><span class="cm"> a bit weird this isn't stated as a lemma, even though it holds by definition. -/</span>
<span class="kd">end</span> <span class="n">path</span>
</code></pre></div>
<p>And here <code>hs</code> is exactly <a href="https://leanprover-community.github.io/mathlib_docs/find/set.ord_connected">docs#set.ord_connected</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">variation_on_from_to_continuous_on</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">pseudo_emetric_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span><span class="bp">∈</span><span class="n">s</span><span class="o">)</span> <span class="o">⦃</span><span class="n">z</span><span class="o">⦄</span> <span class="o">(</span><span class="n">zs</span> <span class="o">:</span> <span class="n">z</span><span class="bp">∈</span><span class="n">s</span><span class="o">),</span> <span class="n">set.Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>



<a name="321520671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321520671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321520671">(Jan 15 2023 at 18:47)</a>:</h4>
<p>I now think maybe we needn't to use <a href="https://leanprover-community.github.io/mathlib_docs/find/path.extend">docs#path.extend</a> much, which maybe in some sense goes into implementation details of <a href="https://leanprover-community.github.io/mathlib_docs/find/path">docs#path</a> and sort of breaks API. I'm trying to see if this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">length</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="o">:=</span> <span class="n">evariation_on</span> <span class="n">p</span> <span class="n">set.univ</span>
</code></pre></div>



<a name="321521336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321521336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321521336">(Jan 15 2023 at 18:55)</a>:</h4>
<p>It's what I had I first, and found it to be messier, but you may have more success than I did.</p>



<a name="321522011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321522011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321522011">(Jan 15 2023 at 19:03)</a>:</h4>
<p>Btw, I tried to adapt your <code>arclength</code> code to my needs (which ended up being practically nothing), in order to get the lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">continuous_right_self_arclength</span>
  <span class="o">(</span><span class="n">hcont</span> <span class="o">:</span> <span class="n">continuous_within_at</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> f is right continuous at a -/</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="n">arclength</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="o">(</span><span class="n">set.Ici</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and respectively <code>continuous_left_self_arclength</code>:</p>
<ul>
<li>Are you planning to open a PR with that code? </li>
<li>If so, can you include that lemma/formulation?</li>
<li>If not, should I do it? </li>
<li><code>def arclength</code> seems a bit on the edge of being worth it: it and the lemmas that you defined shorten a lot of things, but at the same time it really only calls already present <code>evariation_on</code> code. Should we keep it?</li>
</ul>



<a name="321523241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321523241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321523241">(Jan 15 2023 at 19:17)</a>:</h4>
<p>I guess I'll wait after we make sure the proof of idempotency works before PR'ing arclength continuity. Whatever lemmas that ends up in the final proof will certainly get PR'd. This particular lemma is easy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">continuous_right_self_arclength</span>
  <span class="o">(</span><span class="n">hcont</span> <span class="o">:</span> <span class="n">continuous_within_at</span> <span class="n">f</span> <span class="o">(</span><span class="n">set.Ico</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> f is right continuous at a -/</span> <span class="o">:</span>
  <span class="n">filter.tendsto</span> <span class="o">(</span><span class="n">arclength</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">nhds_within</span> <span class="n">a</span> <span class="o">(</span><span class="n">set.Ici</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">continuous_right_self_arclength</span> <span class="n">f</span> <span class="n">hab</span> <span class="n">hrect</span> <span class="n">hcont</span><span class="o">,</span> <span class="n">rw</span> <span class="n">arclength_self</span> <span class="o">}</span>
</code></pre></div>
<p>I guess it becomes <code>continuous_right_self_evariation'</code> in your code.</p>
<blockquote>
<p><code>def arclength</code> seems a bit on the edge of being worth it: it and the lemmas that you defined shorten a lot of things, but at the same time it really only calls already present evariation_on code. Should we keep it?</p>
</blockquote>
<p>So you propose to inline <code>arclength</code> as <code>evariation_on</code> everywhere? I think there are enough lemmas about it to deserve a separate definition; we would need some docstring to explain its similarity and difference with <code>evariation_on_from_to</code> though.</p>



<a name="321523660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321523660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321523660">(Jan 15 2023 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Rectifiable.20paths/near/321523241">said</a>:</p>
<blockquote>
<p>So you propose to inline <code>arclength</code> as <code>evariation_on</code> everywhere? I think there are enough lemmas about it to deserve a separate definition; we would need some docstring to explain its similarity and difference with <code>evariation_on_from_to</code> though.</p>
</blockquote>
<p>Well, I tried it and it got too much hassle and I gave up, which kind of shows its utility, but assuming <code>evariation_on_from_to</code> stays, that would make 3 similar-ish definitions, and I seem to have been drilled to think that the number of defs should be minimized as much as possible…</p>



<a name="321523708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321523708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321523708">(Jan 15 2023 at 19:23)</a>:</h4>
<p>Where would you include this definition?</p>



<a name="321523875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321523875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321523875">(Jan 15 2023 at 19:25)</a>:</h4>
<p>But I guess, too, that having this "set of discourse" <code>s</code> everywhere is kind of useless when talking specifically about rectifiablity, and then we could base everything on <code>arclength</code>, but then again, we'd have to make a new definition for a "signed" arclength.</p>



<a name="321524099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321524099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321524099">(Jan 15 2023 at 19:28)</a>:</h4>
<p>All code in mathlib are built upon existing code, and I think it's good to specialize general APIs to make statements more like what you see on books. I think maths works best when you make abstraction at the right level, and I don't think minimizing the number of defs is the right philosophy.</p>



<a name="321524323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321524323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321524323">(Jan 15 2023 at 19:31)</a>:</h4>
<p>I guess I'll include the definition in the bounded_variation file. Making a "variation" folder that include the bounded_variation file and a new arclength file would also be an option; the bounded_variation file is a bit long and we may consider break it down, though some proofs look golf-able.</p>



<a name="321524450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321524450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321524450">(Jan 15 2023 at 19:33)</a>:</h4>
<p>splitting the file would be nice, already just to make it easier to work on it without waiting for the orange bars to disappear.</p>



<a name="321524641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321524641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321524641">(Jan 15 2023 at 19:35)</a>:</h4>
<p>I guess there no way to make <code>evariation_on_from_to</code> and <code>arclength</code> more compatible, because <code>arclength</code> is essentially an alias for choosing endpoints, while <code>evariation_on_from_to</code> chooses endpoints _and_ is signed, in addition to keeping <code>s</code> and passing to reals.</p>



<a name="321524843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321524843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321524843">(Jan 15 2023 at 19:37)</a>:</h4>
<p>Well, we could have <code>(unsigned_)evariation_on_from_to : ennreal</code> and <code>signed_evariation_on_from_to : ereal</code> and <code>arclength := (unsigned_)evariation_on_from_to set.univ</code></p>



<a name="321524871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321524871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321524871">(Jan 15 2023 at 19:37)</a>:</h4>
<p>taking into account your last comment on the <code>from_to</code> PR</p>



<a name="321525415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321525415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321525415">(Jan 15 2023 at 19:44)</a>:</h4>
<p>Yeah the "set of discourse" is probably useless in this context.<br>
However, I'm not fully convinced that a signed version of <code>arclength</code> is strictly necessary; can you give an example where it's used? And I think we may consider using <code>evariation_on_from_to</code> when we need it.</p>



<a name="321525562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321525562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321525562">(Jan 15 2023 at 19:46)</a>:</h4>
<p>Can you rephrase that last sentence, I'm not sure I follow? Are you saying we should maybe not rush merging <code>evariation_on_from_to</code> ?<br>
In general, I don't really have any other example for a signed arclength/variation than the arc-length parameterization I guess. So I agree we might want to work with an "on-use" approach: <code>arclength</code> is useful already, while <code>evariation_on_from_to</code> hasn't proven useful beyond its own definition/lemmas. But for a fullest formulation of the arclength parameterization, I think we'll probably still need <code>evariation_on_from_to : real</code>.</p>



<a name="321526372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321526372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321526372">(Jan 15 2023 at 19:58)</a>:</h4>
<p>I mean that in the cases we need the signed version, we're probably in the finite case, and can then use <code>evariation_on_from_to</code> specialized to <code>s = univ</code> (but then we probably need to build some APIs around the specialization).<br>
<code>evariation_on_from_to</code> was used to golf the proof that BV functions to the reals are differences of monotone functions, so I'd say it has proved its utility there but not in the path length context.<br>
Arclength parametrization can be characterized by considering only ordered pairs of points <code>x ≤ y</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_linearly_parameterized_on_by</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">),</span> <span class="n">evariation_on</span> <span class="n">f</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">l</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="o">))</span>
<span class="c">/-</span><span class="cm"> or ∀ {x y} (h : x ≤ y), (arclength f x y).to_real = l * (y - x) which seems better -/</span>
</code></pre></div>
<p>so it seems to me that a signed version isn't strictly necessary.(In fact your original definition already doesn't use a signed version, but relied on truncation of <a href="https://leanprover-community.github.io/mathlib_docs/find/ennreal.of_real">docs#ennreal.of_real</a> at 0, while if you consider ordered pairs then it doesn't rely on the truncation.)</p>



<a name="321527031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321527031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321527031">(Jan 15 2023 at 20:07)</a>:</h4>
<p>Mmh, but when you define the arc-length parameterization, say for a function on all of <code>real</code>, you'll have to choose a basepoint, and before this basepoint, you'll want to have negative values I believe.<br>
I mean, the endgoal being to be able to say that a sufficiently nice function <code>f</code> can be written as <code>f' \circ \phi</code> where <code>\phi</code> is arc-length of <code>f</code>, and <code>f'</code> is linearly parameterized.</p>



<a name="321527106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321527106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321527106">(Jan 15 2023 at 20:08)</a>:</h4>
<p>(gtg)</p>



<a name="321527290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321527290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321527290">(Jan 15 2023 at 20:11)</a>:</h4>
<p>Indeed, for paths parametrized by left-infinite intervals it's more convenient to have a signed version of arclength.</p>



<a name="321665417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321665417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321665417">(Jan 16 2023 at 15:17)</a>:</h4>
<p>I made some progress with <a href="https://github.com/bottine/mathlib/blob/bottine/analysis.bounded_variation/natural_parameterization_two/src/analysis/natural_parameterization.lean">https://github.com/bottine/mathlib/blob/bottine/analysis.bounded_variation/natural_parameterization_two/src/analysis/natural_parameterization.lean</a></p>



<a name="321665472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321665472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321665472">(Jan 16 2023 at 15:17)</a>:</h4>
<p>I'll try and actually prove this thing about arc-length parameterization tomorrow</p>



<a name="321766034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321766034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321766034">(Jan 17 2023 at 07:12)</a>:</h4>
<p>Great, I've now filled up sorries and cleaned up your idempotency proof: <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34">609 lines</a> with a few unnecessary lemmas.</p>
<ul>
<li>
<p>I proved the general versions of arclength continuity lemmas for ord_connected sets that you formulated, for which I generalized the hypotheses of the intermediate continuity lemmas used.</p>
</li>
<li>
<p>I've chosen <code>evariation_on p set.univ</code> as the definition of <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34#file-length_space_path_emetric-lean-L416">path.length</a>, and showed it's the same as your definition in <code>evariation_on_extend_unit_interval_eq_length</code>. My definition seems to be easier to work with when proving symmetry and transitivity of length, but when showing continuity of paths in path metric, I converted to your definition. Maybe that's unnecessary but I need to think about it.</p>
</li>
</ul>



<a name="321774172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321774172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321774172">(Jan 17 2023 at 08:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">length</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">path</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="bp">∞</span> <span class="o">:=</span> <span class="n">evariation_on</span> <span class="n">p</span> <span class="n">set.univ</span> <span class="c1">--arclength p 0 1</span>
</code></pre></div>
<p>Didn't use <code>arclength p 0 1</code> because <code>univ</code> is easier to work with ?</p>



<a name="321822223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321822223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321822223">(Jan 17 2023 at 12:49)</a>:</h4>
<p><a href="https://github.com/bottine/mathlib/blob/bottine/analysis.bounded_variation/natural_parameterization_two/src/analysis/natural_parameterization.lean">https://github.com/bottine/mathlib/blob/bottine/analysis.bounded_variation/natural_parameterization_two/src/analysis/natural_parameterization.lean</a> &lt;- How does that look?</p>



<a name="321910607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321910607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321910607">(Jan 17 2023 at 19:33)</a>:</h4>
<p>I'm quite happy with it: I have e.g. the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_linearly_parameterized_on_by.ratio</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">φm</span> <span class="o">:</span> <span class="n">monotone_on</span> <span class="n">φ</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">φst</span> <span class="o">:</span> <span class="n">s.maps_to</span> <span class="n">φ</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">φst'</span> <span class="o">:</span> <span class="n">s.surj_on</span> <span class="n">φ</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">hl'</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">l'</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hfφ</span> <span class="o">:</span> <span class="n">is_linearly_parameterized_on_by</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="n">s</span> <span class="n">l</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">is_linearly_parameterized_on_by</span> <span class="n">f</span> <span class="n">t</span> <span class="n">l'</span><span class="o">)</span>
  <span class="o">⦃</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">⦄</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.eq_on</span> <span class="n">φ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">l</span> <span class="bp">/</span> <span class="n">l'</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">φ</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">natural_parameterization</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">E</span> <span class="o">:=</span>
<span class="n">f</span> <span class="bp">∘</span> <span class="o">(</span><span class="bp">@</span><span class="n">function.inv_fun_on</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">a</span><span class="o">⟩</span> <span class="o">(</span><span class="n">variation_on_from_to</span> <span class="n">f</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">natural_parameterization_edist_zero</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">bs</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">edist</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">(((</span><span class="n">natural_parameterization</span> <span class="n">f</span> <span class="n">as</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">variation_on_from_to</span> <span class="n">f</span> <span class="n">s</span> <span class="n">a</span><span class="o">))</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="bp">.</span>

<span class="kd">lemma</span> <span class="n">natural_parameterization_is_naturally_parameterized</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_locally_bounded_variation_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_naturally_parameterized_on</span> <span class="o">(</span><span class="n">natural_parameterization</span> <span class="n">f</span> <span class="n">as</span><span class="o">)</span> <span class="o">(</span><span class="n">variation_on_from_to</span> <span class="n">f</span> <span class="n">s</span> <span class="n">a</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span>
</code></pre></div>



<a name="321912521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/321912521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#321912521">(Jan 17 2023 at 19:44)</a>:</h4>
<p>This is essentially what I was aiming for. I'll try for a PR soon-ish, knowing that it depends on the <code>variation_on_from_to</code> PR.</p>



<a name="322024373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322024373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322024373">(Jan 18 2023 at 11:04)</a>:</h4>
<p>Here we go: <a href="https://github.com/leanprover-community/mathlib/pull/18208">https://github.com/leanprover-community/mathlib/pull/18208</a><br>
Feedback welcome</p>



<a name="322962237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322962237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322962237">(Jan 23 2023 at 08:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> In your opinion, how much work would it be to prove that arclength = integral of speed ? Is everything needed already in mathlib?</p>



<a name="322966527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322966527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322966527">(Jan 23 2023 at 08:56)</a>:</h4>
<p>If I understand correctly the question, that's not true in general: there exist continuous functions which are differentiable Lebesgue almost everwyhere with derivative equal to zero Lebesgue almost everywhere but which are not constant (google Cantor staircase). You need an additional assumption of absolute continuity. See for instance Rudin, Real and Complex Analysis, Theorem 8.18 for instance.</p>



<a name="322967364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322967364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322967364">(Jan 23 2023 at 09:01)</a>:</h4>
<p>Ah, sorry, I meant "under reasonable assumptions"</p>



<a name="322967616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322967616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322967616">(Jan 23 2023 at 09:02)</a>:</h4>
<p>The correct assumption is called absolute continuity. It holds for instance for Lipschitz functions. I don't think we have anything on these yet in mathlib, so these would be prerequisites.</p>



<a name="322969940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322969940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322969940">(Jan 23 2023 at 09:16)</a>:</h4>
<p>I see, thanks. I guess C¹ by parts would also suffice, and with more prerequisites already present?</p>



<a name="322974878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322974878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322974878">(Jan 23 2023 at 09:42)</a>:</h4>
<p>For <code>C^1</code> functions, we already have the result. But <code>C^1</code> by parts is a pain to work with formally...</p>



<a name="322975827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322975827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322975827">(Jan 23 2023 at 09:47)</a>:</h4>
<p>ah, neat, what's the name of the lemma/theorem?</p>



<a name="322977245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/322977245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#322977245">(Jan 23 2023 at 09:54)</a>:</h4>
<p>There are many versions, you can browse around <a href="https://leanprover-community.github.io/mathlib_docs/find/integral_eq_sub_of_has_deriv_at_of_le">docs#integral_eq_sub_of_has_deriv_at_of_le</a></p>



<a name="323183829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/323183829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#323183829">(Jan 24 2023 at 07:51)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> I'm trying to make your latest iteration of the path_emetric into something PR-able:</p>
<ul>
<li>
<p>Should your <code>unit_interval</code> lemmas be put in the <code>unit_interval</code> file?<br>
  I'd say everything up to <code>two_mul_div_two</code> should, and the three others left here.</p>
</li>
<li>
<p>Is <code>div_two</code> better than <code>half</code> ?</p>
</li>
<li>What about the <code>affine_map</code> and related lemmas?</li>
<li>(<span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>  too:) How should we deal with arclength? it seems quite clear to me that it should have its own file rather than taking half or more of the <code>path_emetric</code> file, but where? </li>
<li>Also, it seems a bit of a missed opportunity not to have the continuity lemmas be stated for <code>evariation_on</code> and put in the <code>bounded_variation</code> file, no?</li>
</ul>



<a name="323305696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/323305696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#323305696">(Jan 24 2023 at 17:04)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span>, thanks for doing this! Here are my opinions:</p>
<ul>
<li>
<p>Yes the <code>unit_intervals</code> should be put in the <code>unit_interval</code> file should be put in the <code>unit_interval</code> file, and I don't see an obvious reason why "the three others" should be left here ... Even the <code>affine_map</code> stuff can be moved there, because <a href="https://leanprover-community.github.io/mathlib_docs/find/affine_homeomorph_image_I">docs#affine_homeomorph_image_I</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/Icc_homeo_I">docs#Icc_homeo_I</a> (though there's also <a href="https://leanprover-community.github.io/mathlib_docs/find/set.image_affine_Icc'">docs#set.image_affine_Icc'</a> in a probably earlier file).</p>
</li>
<li>
<p>I'm fine with <code>half</code> if you are happy with it.</p>
</li>
<li>
<p>I think the arclength and length space stuff should be put under topology.metric_space, where <a href="https://leanprover-community.github.io/mathlib_docs/find/pseudo_emetric_space">docs#pseudo_emetric_space</a> is located. And you're welcome to generalize the results to <code>evariation_on</code>!</p>
</li>
<li>
<p>I made just a bit of <a href="https://gist.github.com/alreadydone/a8e58edee5d9f1642d548da0c1640d34/revisions#diff-989d00abb8423b7ae9fd455ec5e2cfdd0d3ecc4c0c9131926c2385aad94e1040">revision to my gist</a> in the meantime.</p>
</li>
</ul>



<a name="323317662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Rectifiable%20paths/near/323317662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Rectifiable.20paths.html#323317662">(Jan 24 2023 at 17:59)</a>:</h4>
<p>Thanks, will try to put everything where it belongs, and ping here when it's done/I get stuck.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
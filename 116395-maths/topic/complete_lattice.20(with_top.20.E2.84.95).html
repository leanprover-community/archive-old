---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html">complete_lattice (with_top ℕ)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226161461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226161461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226161461">(Feb 12 2021 at 16:40)</a>:</h4>
<p>Is this missing, or untrue?</p>



<a name="226162141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226162141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226162141">(Feb 12 2021 at 16:45)</a>:</h4>
<p>I could only find</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">bounded_lattice</span> <span class="n">enat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inf</span> <span class="o">:=</span> <span class="n">min</span><span class="o">,</span>
  <span class="n">inf_le_left</span> <span class="o">:=</span> <span class="n">min_le_left</span><span class="o">,</span>
  <span class="n">inf_le_right</span> <span class="o">:=</span> <span class="n">min_le_right</span><span class="o">,</span>
  <span class="n">le_inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">le_min</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">enat.order_top</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">enat.semilattice_sup_bot</span> <span class="o">}</span>
</code></pre></div>



<a name="226162273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226162273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226162273">(Feb 12 2021 at 16:46)</a>:</h4>
<p>Yeah, I can find a <code>bounded_lattice</code> on <code>with_top nat</code> too</p>



<a name="226162343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226162343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226162343">(Feb 12 2021 at 16:46)</a>:</h4>
<p>My motivation was to apply <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_mem_eq_sup">docs#exists_mem_eq_sup</a>, so I guess the assumptions on that lemma are too strict</p>



<a name="226162371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226162371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226162371">(Feb 12 2021 at 16:46)</a>:</h4>
<p>And therfore a new <code>bounded_linear_order</code> typeclass is needed?<br>
(<code>class bounded_linear_order extends bounded_lattice β, linear_order β</code>)</p>



<a name="226162712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226162712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226162712">(Feb 12 2021 at 16:48)</a>:</h4>
<p>You should get it from <a href="https://leanprover-community.github.io/mathlib_docs/find/with_top.complete_linear_order">docs#with_top.complete_linear_order</a> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[instance]</span>
<span class="kd">def</span> <span class="n">with_top.complete_linear_order</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">conditionally_complete_linear_order_bot</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
<span class="n">complete_linear_order</span> <span class="o">(</span><span class="n">with_top</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>since we have that N is a <code>conditionally_complete_linear_order_bot</code></p>



<a name="226162969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226162969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226162969">(Feb 12 2021 at 16:50)</a>:</h4>
<p>Thanks, I needed to <code>import order.conditionally_complete_lattice</code></p>



<a name="226163407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226163407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226163407">(Feb 12 2021 at 16:53)</a>:</h4>
<p>and there is also <a href="https://leanprover-community.github.io/mathlib_docs/find/enat.complete_linear_order">docs#enat.complete_linear_order</a></p>



<a name="226163944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226163944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226163944">(Feb 12 2021 at 16:57)</a>:</h4>
<p>Bad things seem to happen when I use that instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.conditionally_complete_lattice</span>
<span class="kn">import</span> <span class="n">data.finset.lattice</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">def</span> <span class="n">min_or_zero</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">option.get_or_else</span> <span class="o">(</span><span class="n">univ.sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">foo</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)</span> <span class="mi">0</span>

<span class="kd">lemma</span> <span class="n">exists_eq_min_or_zero</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">v</span><span class="o">,</span> <span class="n">foo</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">min_or_zero</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v'</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">hv'</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">exists_mem_eq_sup</span> <span class="n">finset.univ</span> <span class="n">univ_nonempty</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">foo</span> <span class="n">v</span> <span class="o">:</span> <span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">v'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">unfold</span> <span class="n">min_or_zero</span><span class="o">,</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">option.get_or_else_coe</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hv'</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="c1">-- canonically_linear_ordered_add_monoid.semilattice_sup_bot = semilattice_sup_bot_of_bounded_lattice (with_top ℕ)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226164182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226164182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226164182">(Feb 12 2021 at 16:58)</a>:</h4>
<p>The <code>enat</code> version works, but <code>roption.get_or_else</code> is hard to use</p>



<a name="226164214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226164214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226164214">(Feb 12 2021 at 16:59)</a>:</h4>
<p>this is the same issue as the other day with ennreal, with <code>canonically_linear_ordered_add_monoid</code> causing duplicate sup/bot when using that instance of <code>semilattice_sup_bot</code></p>



<a name="226164429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226164429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226164429">(Feb 12 2021 at 17:00)</a>:</h4>
<p>The full state is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">canonically_linear_ordered_add_monoid.semilattice_sup_bot</span> <span class="o">(</span><span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">with_top.canonically_linear_ordered_add_monoid</span> <span class="n">ℕ</span> <span class="n">nat.canonically_linear_ordered_add_monoid</span><span class="o">)</span> <span class="bp">=</span>
    <span class="bp">@</span><span class="n">semilattice_sup_bot_of_bounded_lattice</span> <span class="o">(</span><span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">complete_lattice.to_bounded_lattice</span> <span class="o">(</span><span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)</span>
         <span class="o">(</span><span class="bp">@</span><span class="n">complete_linear_order.to_complete_lattice</span> <span class="o">(</span><span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">@</span><span class="n">with_top.complete_linear_order</span> <span class="n">ℕ</span> <span class="n">nat.conditionally_complete_linear_order_bot</span><span class="o">)))</span>
</code></pre></div>



<a name="226164902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226164902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226164902">(Feb 12 2021 at 17:03)</a>:</h4>
<p>On <a href="https://github.com/leanprover-community/mathlib/tree/ennreal_lattice_issue">branch#ennreal_lattice_issue</a> I tried removing the instance <code>canonically_linear_ordered_add_monoid.semilattice_sup_bot</code> and after a small fix to one lemma about finsupp, it does not seem to cause any issue. But then you can't use any lemma for <code>semilattice_sup_bot</code> on a <code>canonically_linear_ordered_add_monoid</code>, which is a shame. I don't know enough about how those things work to be able to fix it</p>



<a name="226165362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226165362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226165362">(Feb 12 2021 at 17:06)</a>:</h4>
<p>The semilattice and order_bot parts of semilattice_sup_bot come from two different ancestors of canonically_linear_ordered_add_monoid. It looks like the way they are combined is not correct (in a way I don't understand)</p>



<a name="226173211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/complete_lattice%20%28with_top%20%E2%84%95%29/near/226173211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/complete_lattice.20(with_top.20.E2.84.95).html#226173211">(Feb 12 2021 at 17:56)</a>:</h4>
<p>This gives some hints of exactly what doesn't match - it's just the <code>sup</code>, the other operators are fine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.conditionally_complete_lattice</span>
<span class="kn">import</span> <span class="n">data.finset.lattice</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">def</span> <span class="n">min_or_zero</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">option.get_or_else</span> <span class="o">(</span><span class="n">univ.sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">foo</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)</span> <span class="mi">0</span>

<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">semilattice_sup_bot.ext</span> <span class="o">[</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">semilattice_sup_bot</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_bot</span> <span class="o">:</span> <span class="n">a.bot</span> <span class="bp">=</span> <span class="n">b.bot</span><span class="o">)</span> <span class="o">(</span><span class="n">h_sup</span> <span class="o">:</span> <span class="n">a.sup</span> <span class="bp">=</span> <span class="n">b.sup</span><span class="o">)</span> <span class="o">(</span><span class="n">h_le</span> <span class="o">:</span> <span class="n">a.le</span> <span class="bp">=</span> <span class="n">b.le</span><span class="o">)</span> <span class="o">(</span><span class="n">h_lt</span> <span class="o">:</span> <span class="n">a.lt</span> <span class="bp">=</span> <span class="n">b.lt</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">casesI</span> <span class="n">a</span><span class="o">,</span> <span class="n">casesI</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">assumption'</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">exists_eq_min_or_zero</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">v</span><span class="o">,</span> <span class="n">foo</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">min_or_zero</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">v'</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">hv'</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">exists_mem_eq_sup</span> <span class="n">finset.univ</span> <span class="n">univ_nonempty</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">foo</span> <span class="n">v</span> <span class="o">:</span> <span class="n">with_top</span> <span class="n">ℕ</span><span class="o">)),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">v'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">unfold</span> <span class="n">min_or_zero</span><span class="o">,</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">option.get_or_else_coe</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hv'</span><span class="o">,</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">semilattice_sup_bot.sup</span> <span class="n">lattice.sup</span> <span class="n">bounded_lattice.sup</span> <span class="n">complete_lattice.sup</span>
      <span class="n">complete_linear_order.sup</span> <span class="n">semilattice_sup_top.sup</span><span class="o">,</span>
    <span class="c1">-- max = λ (o₁ o₂ : with_top ℕ), option.bind o₁ (λ (a : ℕ), option.map (λ (b : ℕ), a ⊔ b) o₂)</span>
    <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
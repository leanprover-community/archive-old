---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Transitive.20classes.20for.203.CA.B3.E1.B5.88.20iso.20thm.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transitive.20classes.20for.203.CA.B3.E1.B5.88.20iso.20thm.html">Transitive classes for 3ʳᵈ iso thm</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="177520138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transitive%20classes%20for%203%CA%B3%E1%B5%88%20iso%20thm/near/177520138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Visa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transitive.20classes.20for.203.CA.B3.E1.B5.88.20iso.20thm.html#177520138">(Oct 07 2019 at 13:43)</a>:</h4>
<p>Hi, I post here outcomes of my attempts to formalize the third isomorphism theorem (see <a href="/user_uploads/3121/IjuEtpbhqgkszSrmWewa1tIi/Problems-with-3rd-iso-thm.lean" target="_blank" title="Problems-with-3rd-iso-thm.lean">Problems-with-3rd-iso-thm.lean</a>). The idea was to encode substructure relation as a type class constraint. This raised multiple elaboration issues which could be useful to take into account in Lean 4. Especially inferring transitive classes could make this a compelling approach to use heavily in the algebra library. As such none of the attempts was really satisfactory.</p>



<a name="177521031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Transitive%20classes%20for%203%CA%B3%E1%B5%88%20iso%20thm/near/177521031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Transitive.20classes.20for.203.CA.B3.E1.B5.88.20iso.20thm.html#177521031">(Oct 07 2019 at 13:53)</a>:</h4>
<p>For convenience, here's the file inline in a post:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">coset</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">matrix</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">determinant</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">gcd_domain</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">modeq</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">quotient_group</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">subgroup</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">fin_cases</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span> <span class="n">data</span><span class="bp">.</span><span class="n">lazy_list</span> <span class="n">category</span><span class="bp">.</span><span class="n">monad</span><span class="bp">.</span><span class="n">cont</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">function</span> <span class="n">quotient_group</span> <span class="n">group</span> <span class="n">is_group_hom</span> <span class="n">set</span> <span class="n">classical</span> <span class="n">tactic</span>

<span class="c1">--- Notes on attempts to formalize the 3ʳᵈ group isomorphism theorem (K/G) / (H/G) ≅ K / H ---</span>
<span class="c1">---------------------------------------------------------------------------------------------</span>
<span class="c1">--The purpose of this document is to 1) present an encoding of subgroup relation as type class, 2) demonstrate type class inference problems and workarounds (especially inferring transitive classes—if possible in Lean 4—will solve the root problem), and 3) point out an auto_param bug.</span>

<span class="kn">variables</span><span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}[</span><span class="n">group</span> <span class="n">G</span><span class="o">][</span><span class="n">group</span> <span class="n">H</span><span class="o">][</span><span class="n">group</span> <span class="n">K</span><span class="o">]</span>
<span class="c1">--The setup for the third isomorphism theorem for groups is that G ≤ H ⊴ K and G ⊴ K, which then imply G ⊴ H and H/G ⊴ K/G so that all the involved quotients are defined. The main problem in formalizing this is to have H/G become a subgroup of K/G. At the time of writing subgroup is defined to be a relation between a set and a type:</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_subgroup</span> <span class="n">G</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">@</span><span class="n">normal_subgroup</span> <span class="n">G</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="c1">--Within the context of Coq this problem was solved by &quot;simulating set theory&quot;. Essentially one works with subsets of a type 𝔾 with axiomless group operations. Groups that have the same 𝔾 are subgroups of each other iff they are subsets of each other. This readily enables hierarchy like G≤H≤K. Groups with different 𝔾 can still not be compared, but it turns out that in practice 𝔾 usually ends up the same when needed. For example quotient H/G of 𝔾-groups H,G has different operational structure, but the new structure 𝔾/G only depends on G, and hence H/G and K/G are comparable. Even though this approach worked well for the odd order theorem, it has many drawbacks:</span>
<span class="c1">--additional 𝔾 layer complicates casual use</span>
<span class="c1">--backward incompatible with mathlib</span>
<span class="c1">--ℤ ≤ ℚ ≤ ℝ ≤ ℂ fails (or requires defining ℤ, ℚ and ℝ as subsets of ℂ)</span>
<span class="c1">--how does this fit to the algebraic hierarchy???</span>
<span class="c1">--not all natural group theoretic relations are captured, e.g. G ≰ G⋊H</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">xx</span> <span class="o">:=</span> <span class="n">tidy</span> <span class="c1">--can&#39;t be inlined</span>

<span class="c1">--Lean&#39;s implicit coercions make it feasible to mix elements from different types. Exploiting this I experimented representing subgroup relations by type classes.</span>
<span class="n">class</span> <span class="n">embed</span><span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">group</span> <span class="n">G</span><span class="o">][</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">fn</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">inj</span><span class="o">:</span> <span class="n">injective</span> <span class="n">fn</span><span class="bp">.</span> <span class="n">xx</span><span class="o">)</span>
<span class="o">(</span><span class="n">hom</span><span class="o">:</span> <span class="n">is_group_hom</span> <span class="n">fn</span><span class="bp">.</span> <span class="n">xx</span><span class="o">)</span>
<span class="kn">infixr</span> <span class="bp">`</span><span class="err">↪</span><span class="bp">`</span><span class="o">:</span><span class="mi">22</span> <span class="o">:=</span> <span class="n">embed</span>

<span class="kn">namespace</span> <span class="n">embed</span>
<span class="c1">--Embedding can be interpreted as homomorphism and coercion.</span>
<span class="kn">instance</span><span class="o">:</span> <span class="n">has_coe_to_fun</span><span class="o">(</span><span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">F</span><span class="o">:=</span><span class="bp">λ_</span><span class="o">,</span><span class="n">G</span><span class="bp">→</span><span class="n">H</span><span class="o">,</span> <span class="n">coe</span><span class="o">:=</span> <span class="bp">λ</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">fn</span><span class="o">}</span>
<span class="kn">instance</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">]:</span> <span class="n">has_coe</span> <span class="n">G</span> <span class="n">H</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">⟩</span>
<span class="kn">instance</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">]:</span> <span class="n">is_group_hom</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span><span class="bp">.</span><span class="n">hom</span>
<span class="kn">instance</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">]:</span> <span class="n">is_subgroup</span><span class="o">(</span><span class="n">range</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="c1">--Existing formalization of subgroups can be reused.</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">quot_by_embed</span><span class="o">(</span><span class="n">H</span> <span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">group</span> <span class="n">G</span><span class="o">][</span><span class="n">group</span> <span class="n">H</span><span class="o">][</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">]</span> <span class="o">:=</span> <span class="n">quotient_group</span><span class="bp">.</span><span class="n">quotient</span><span class="o">(</span><span class="n">range</span> <span class="n">i</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∕</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">quot_by_embed</span>

<span class="c1">--Subgroup relations can be added retroactively by will.</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">instance ℤℚ: multiplicative ℤ ↪ multiplicative ℚ := sorry</span>
<span class="cm">instance ℚℝ: multiplicative ℚ ↪ multiplicative ℝ := sorry</span>
<span class="cm">instance set{S: set G}[is_subgroup S]: S ↪ G := {fn:=subtype.val}</span>

<span class="cm">--PROBLEM 1: ↪ has to be transitive. Direct instance loops the type class inference:</span>
<span class="cm">instance[i: G↪H][j: H↪K]: G↪K := sorry</span>
<span class="cm">#check multiplicative ℝ ∕ multiplicative ℤ</span>
<span class="cm">--/</span>
<span class="c1">--Coercions overcome the problem of transitivity by using two classes: single-step and transitive one. With embeddings this is not ideal (messy details are exposed to users), but works.</span>
<span class="n">class</span> <span class="n">embed1</span><span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">group</span> <span class="n">G</span><span class="o">][</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">fn</span><span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">inj</span><span class="o">:</span> <span class="n">injective</span> <span class="n">fn</span><span class="bp">.</span> <span class="n">xx</span><span class="o">)</span>
<span class="o">(</span><span class="n">hom</span><span class="o">:</span> <span class="n">is_group_hom</span> <span class="n">fn</span><span class="bp">.</span> <span class="n">xx</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">trans</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">][</span><span class="n">j</span><span class="o">:</span> <span class="n">H</span><span class="err">↪</span><span class="n">K</span><span class="o">]:</span> <span class="n">G</span><span class="err">↪</span><span class="n">K</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">fn</span><span class="o">:=</span> <span class="n">j</span> <span class="err">∘</span> <span class="n">i</span><span class="bp">.</span><span class="n">fn</span><span class="o">,</span>
    <span class="n">inj</span><span class="o">:=</span><span class="k">by</span><span class="o">{</span><span class="k">have</span><span class="o">:=</span><span class="n">i</span><span class="bp">.</span><span class="n">inj</span><span class="o">,</span> <span class="k">have</span><span class="o">:=</span><span class="n">j</span><span class="bp">.</span><span class="n">inj</span><span class="o">,</span> <span class="n">xx</span><span class="o">},</span>
    <span class="n">hom</span><span class="o">:=</span><span class="bp">@</span><span class="n">is_group_hom</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">i</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">j</span><span class="bp">.</span><span class="n">hom</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">single</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">]:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span> <span class="o">:=</span> <span class="o">{</span><span class="bp">..</span><span class="n">i</span><span class="o">}</span>

<span class="c1">--Other instances are to be declared as single step ones.</span>
<span class="kn">instance</span> <span class="bp">ℤ</span><span class="n">ℚ</span><span class="o">:</span> <span class="n">embed1</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">instance</span> <span class="n">ℚℝ</span><span class="o">:</span> <span class="n">embed1</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">instance</span> <span class="n">set</span><span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">}[</span><span class="n">is_subgroup</span> <span class="n">S</span><span class="o">]:</span> <span class="n">embed1</span> <span class="n">S</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">{</span><span class="n">fn</span><span class="o">:=</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span><span class="o">}</span>

<span class="c1">--Now the basic example works, though because of general inefficiency in type class inference/hierarchy, a shortcut instance is needed.</span>
<span class="kn">instance</span> <span class="n">groupℚ</span><span class="o">:</span> <span class="n">group</span><span class="o">(</span><span class="n">multiplicative</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">multiplicative</span> <span class="n">ℝ</span> <span class="err">∕</span> <span class="n">multiplicative</span> <span class="bp">ℤ</span>


<span class="c1">--Next the normality is added to the embeddings. Note that embed_normal is not an extension of embed_group but instead a property for it. This way it should be applicable to compositions of embeddings more flexibly.</span>
<span class="n">class</span> <span class="n">embed_normal</span><span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">group</span> <span class="n">G</span><span class="o">][</span><span class="n">group</span> <span class="n">H</span><span class="o">][</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span><span class="n">normal</span><span class="o">:</span> <span class="n">normal_subgroup</span><span class="o">(</span><span class="n">range</span> <span class="n">i</span><span class="o">)}</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⊴</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">embed_normal</span>

<span class="c1">--Basic instances.</span>
<span class="kn">instance</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">][</span><span class="n">n</span><span class="o">:</span> <span class="n">G</span><span class="err">⊴</span><span class="n">H</span><span class="o">]:</span> <span class="n">normal_subgroup</span><span class="o">(</span><span class="n">range</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span><span class="bp">.</span><span class="n">normal</span>
<span class="kn">instance</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">][</span><span class="n">G</span><span class="err">⊴</span><span class="n">H</span><span class="o">]:</span> <span class="n">group</span><span class="o">(</span><span class="n">H</span><span class="err">∕</span><span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="c1">--PROBLEM 2: Unlike coercions embeddings appear as assumptions. When they do, one should use the transitive closure version ↪ to maximize usability, as is done so far. But assumptions also need to be transitively joined!</span>
<span class="c1">--instance[i: G↪H][j: H↪K][G⊴K/-Uuh!-/]: G⊴H := sorry</span>

<span class="c1">--A solution is to use auxiliarity definitions that only assume single step embeddings and then convert these into more flexible ones with a function like</span>
<span class="n">def</span> <span class="n">atomic_trans</span><span class="o">{</span><span class="n">R</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}(</span><span class="n">F</span><span class="o">:</span> <span class="bp">∀</span><span class="o">[</span><span class="n">i₁</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">],</span> <span class="n">R</span> <span class="n">i₁</span><span class="o">)[</span><span class="n">i</span><span class="o">:</span> <span class="n">G</span><span class="err">↪</span><span class="n">H</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">F</span><span class="o">{</span><span class="bp">..</span><span class="n">i</span><span class="o">}</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">instance_normal_in_sub</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">][</span><span class="n">j</span><span class="o">:</span> <span class="n">H</span><span class="err">↪</span><span class="n">K</span><span class="o">][</span><span class="n">G</span><span class="err">⊴</span><span class="n">K</span><span class="o">]:</span> <span class="n">G</span><span class="err">⊴</span><span class="n">H</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">instance</span> <span class="n">normal_in_sub</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">atomic_trans</span> <span class="n">G</span> <span class="n">H</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">instance_normal_in_sub</span> <span class="n">G</span> <span class="n">H</span> <span class="n">K</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">instance_embed_quot</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">][</span><span class="n">j</span><span class="o">:</span> <span class="n">H</span><span class="err">↪</span><span class="n">K</span><span class="o">][</span><span class="n">G</span><span class="err">⊴</span><span class="n">K</span><span class="o">][</span><span class="n">H</span><span class="err">⊴</span><span class="n">K</span><span class="o">]:</span> <span class="n">H</span><span class="err">∕</span><span class="n">G</span> <span class="err">↪</span> <span class="n">K</span><span class="err">∕</span><span class="n">G</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">instance</span> <span class="n">embed_quot</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">atomic_trans</span> <span class="n">G</span> <span class="n">H</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">instance_embed_quot</span> <span class="n">G</span> <span class="n">H</span> <span class="n">K</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">instance_quot_normal</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">][</span><span class="n">j</span><span class="o">:</span> <span class="n">H</span><span class="err">↪</span><span class="n">K</span><span class="o">][</span><span class="n">G</span><span class="err">⊴</span><span class="n">K</span><span class="o">][</span><span class="n">H</span><span class="err">⊴</span><span class="n">K</span><span class="o">]:</span> <span class="n">H</span><span class="err">∕</span><span class="n">G</span> <span class="err">⊴</span> <span class="n">K</span><span class="err">∕</span><span class="n">G</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">instance</span> <span class="n">quot_normal</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">atomic_trans</span> <span class="n">G</span> <span class="n">H</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">instance_quot_normal</span> <span class="n">G</span> <span class="n">H</span> <span class="n">K</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">embed</span><span class="bp">.</span><span class="n">quot_normal</span> <span class="n">G</span> <span class="n">H</span> <span class="n">K</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="c1">-- Π [i : G↪H] [j : H↪K] [_inst_4 : G ⊴ K] [_inst_5 : H ⊴ K], H ∕ G ⊴ K ∕ G</span>


<span class="c1">--Define the isomorphicity of groups.</span>
<span class="kn">structure</span> <span class="n">group_equiv</span><span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)[</span><span class="n">group</span> <span class="n">G</span><span class="o">][</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">G</span> <span class="err">≃</span> <span class="n">H</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">hom</span><span class="o">:</span> <span class="n">is_group_hom</span> <span class="n">to_fun</span><span class="o">)</span>
    <span class="o">(</span><span class="n">inv_hom</span><span class="o">:</span> <span class="n">is_group_hom</span> <span class="n">inv_fun</span><span class="o">)</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≅</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">group_equiv</span>


<span class="c1">--PROBLEM 3: This results in an undebuggable mess—the failing instance trace doesn&#39;t even show up (for me)!</span>
<span class="c1">--set_option trace.class_instances true</span>
<span class="kn">private</span> <span class="n">def</span> <span class="n">isomorphism_theorem_3&#39;</span><span class="o">[</span><span class="n">i</span><span class="o">:</span> <span class="n">embed1</span> <span class="n">G</span> <span class="n">H</span><span class="o">][</span><span class="n">j</span><span class="o">:</span> <span class="n">H</span><span class="err">↪</span><span class="n">K</span><span class="o">][</span><span class="n">G</span><span class="err">⊴</span><span class="n">K</span><span class="o">][</span><span class="n">H</span><span class="err">⊴</span><span class="n">K</span><span class="o">]:</span> <span class="o">(</span><span class="n">K</span><span class="err">∕</span><span class="n">G</span><span class="o">)</span> <span class="err">∕</span> <span class="o">(</span><span class="n">H</span><span class="err">∕</span><span class="n">G</span><span class="o">)</span> <span class="err">≅</span> <span class="n">K</span> <span class="err">∕</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">--I was able to formalize a version of the third isomorphism theorem using this approach and packed groups.</span>
<span class="kn">structure</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">(</span><span class="n">base</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">struct</span><span class="o">:</span> <span class="n">group</span> <span class="n">base</span><span class="o">)</span>
<span class="c1">--This is however incompatible with mathlib, complicates casual use, and possibly reproduces the inference problems once number of defined class instances increases.</span>
<span class="kn">end</span> <span class="n">embed</span>
<span class="c1">--------------------------------------------------------------------------------------------</span>


<span class="c1">--Another way to overcome problem 1 is to apply custom transitivity-aware inference via auto_params. Quotient ∕ and normality ⊴ are changed so that instead of type class search [i: G↪H] they use custom search (i: G↪H. custom_trans_inf_tactic). In addition to just sequencing embeddings transitively such custom search must do general type class inference (already here embed_quot must be used to type quot_normal). Currently type class inference can&#39;t be hooked (auto_params remain passive during inference, but just activating them wouldn&#39;t give required control). Hence the custom search had to reimplement type class search in Lean. This way neither single-step class nor atomic_trans are needed, and the third isomorphism theorem can be formalized as:</span>
<span class="c1">--theorem isomorphism_theorem_3{i: G↪H}{j: H↪K}[nj: H⊴K][nji: G⊴K]:</span>
<span class="c1">--  let hg:=H∕G, kg:=K∕G in kg∕hg ≅ K∕H --The let...in is necessary!</span>
<span class="c1">--:= ...</span>
<span class="c1">--PROBLEM 4: The goal auto_param should fullfill is not always revealed. Instead it shows up as unassigned meta variable. This happens when inferences are nested or multiple parameters need to be inferred. The problem occures only with result types, not with parameter types. Nesting can be worked around using lets, which is what happens in the isomorphism_theorem_3 above. Minimal examples follow.</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="bp">&gt;&gt;</span> <span class="n">assumption</span> <span class="c1">--Print the goal and guess solution.</span>
<span class="n">def</span> <span class="n">A</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">Type</span><span class="o">)(</span><span class="bp">_</span><span class="o">:</span><span class="n">x</span><span class="bp">.</span> <span class="n">a</span><span class="o">)(</span><span class="bp">_</span><span class="o">:</span><span class="n">x</span><span class="bp">.</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>
<span class="n">def</span> <span class="n">B</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">Type</span><span class="o">)(</span><span class="n">i</span><span class="o">:</span><span class="n">x</span><span class="o">):</span> <span class="n">A</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">i</span> <span class="c1">--A doesn&#39;t see its first goal.</span>
<span class="n">def</span> <span class="n">C</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">Type</span><span class="o">)(</span><span class="bp">_</span><span class="o">:</span><span class="n">x</span><span class="bp">.</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>
<span class="n">def</span> <span class="n">D</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">Type</span><span class="o">)(</span><span class="bp">_</span><span class="o">:</span><span class="n">x</span><span class="bp">.</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>
<span class="n">def</span> <span class="n">E</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">Type</span><span class="o">)(</span><span class="n">i</span><span class="o">:</span><span class="n">x</span><span class="o">):</span> <span class="n">D</span><span class="o">(</span><span class="n">C</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">i</span> <span class="c1">--D doesn&#39;t see that goal is C x.</span>
<span class="c1">--This problem likely exists for a reason: how could the system decide which auto_param to solve first? As with hooking the type class search, this ideally asks an intelligent default or fine grained control over, how auto_params interact with elaboration and each others. In any case the current behavior obviously ignores available data.</span>

<span class="c1">--Full code is available at https://github.com/0function/storage in files group_isomorphicity.lean and transitive_class_inference.lean.</span>
</pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
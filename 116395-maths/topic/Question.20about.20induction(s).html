---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Question.20about.20induction(s).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html">Question about induction(s)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257492819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257492819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257492819">(Oct 14 2021 at 07:40)</a>:</h4>
<p>Hi</p>
<p>I'd like to formalize a second lemma in topology.connected, namely that if you have a chain of connected topological spaces, each one meeting the next one, then the union is connected. This interacts with set theory machinery that I still don't understand to do in Lean, especially induction.</p>
<p>Here are my questions.<br>
Bourbaki has only one such lemma, for a chain indexed by integers (ℕ), but it makes sense on finite chains as well, well ordered sets too, and also on other ordered sets which are not well ordered, such as ℤ.<br>
And, in fact, for sets indexed by the vertices of a connected graph such that intersections of sets related by and edge are connected. </p>
<p>Both statements, chains indexed by well ordered sets and families indexed by vertices of a connected graph, are related, but they're not equivalent. Maybe both could be added.</p>
<p>Specific questions: <br>
1) what type should one use for finite chains? <code>fin n</code> ? <br>
2) where to look at examples of proof for finite induction, or well_founded induction?</p>
<p>Thanks</p>



<a name="257492993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257492993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257492993">(Oct 14 2021 at 07:42)</a>:</h4>
<p>Note that well ordered sets form a connected graph, because they are transitive so they have lots and lots of connections</p>



<a name="257493117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493117">(Oct 14 2021 at 07:43)</a>:</h4>
<p>Yes, but I think the condition on the topological spaces indexed by the graph is different from the condition for the well-ordered chains, if I understand <span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> correctly.</p>



<a name="257493284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493284">(Oct 14 2021 at 07:45)</a>:</h4>
<p>The connectedness graph condition can be stated as: for any nonempty disjoint sets <code>A, B \sub G</code> there exists <code>R a b</code> or <code>R b a</code> with <code>a \in A</code> and <code>b \in B</code></p>



<a name="257493374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493374">(Oct 14 2021 at 07:46)</a>:</h4>
<p>this is true for well ordered sets, or indeed any totally ordered set, since if <code>A</code> and <code>B</code> are nonempty with <code>a : A</code> and <code>b : B</code>, then <code>a &lt; b</code> or <code>b &lt; a</code></p>



<a name="257493475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493475">(Oct 14 2021 at 07:47)</a>:</h4>
<p>In this form, you don't need any induction to deduce the theorem, from connected graph relations to connected topological spaces</p>



<a name="257493804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493804">(Oct 14 2021 at 07:50)</a>:</h4>
<p>But I don't think mathlib has much about connected graphs. So I think going in that direction might require some work.</p>



<a name="257493846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493846">(Oct 14 2021 at 07:51)</a>:</h4>
<p>It always boils down to the same thing... <a href="https://github.com/leanprover-community/mathlib/issues/8737">#8737</a></p>



<a name="257493855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493855">(Oct 14 2021 at 07:51)</a>:</h4>
<p>The version with chains might be a job for ordered indexing types, with a <code>succ_order</code>?</p>



<a name="257493871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493871">(Oct 14 2021 at 07:51)</a>:</h4>
<p>Is there some induction principle for <code>succ_order</code>s?</p>



<a name="257493873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493873">(Oct 14 2021 at 07:51)</a>:</h4>
<p>mathlib has lots about conencted graphs on the wait.</p>



<a name="257493904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257493904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257493904">(Oct 14 2021 at 07:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Question.20about.20induction.28s.29/near/257493871">said</a>:</p>
<blockquote>
<p>Is there some induction principle for <code>succ_order</code>s?</p>
</blockquote>
<p>Nope, because you need some archimedean condition.</p>



<a name="257494182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257494182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257494182">(Oct 14 2021 at 07:54)</a>:</h4>
<p>I've thought about this already and I couldn't find any existing typeclass that would abstract this properly, so I might define <code>succ_archimedean</code> to mean that <code>a &lt; b</code> implies <code>b ≤ succ^[n] a</code> for some <code>n</code>. And I might as well need to define <code>pred_archimedean</code> for the dual notion.</p>



<a name="257494242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257494242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257494242">(Oct 14 2021 at 07:55)</a>:</h4>
<p>Correct me if I'm wrong, but if we consider the long line as the vertices of a graph and connect vertices of distance less than 1, then we get a graph which is connected in my sense (no disconnection) but not connected in the sense of having a finite length path from any vertex to any other</p>



<a name="257494349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257494349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257494349">(Oct 14 2021 at 07:56)</a>:</h4>
<p>Regarding that PR <a href="https://github.com/leanprover-community/mathlib/issues/8737">#8737</a>, I believe one should do general graphs (quivers, and orientations, etc.) rather than focusing straight away on simple graphs.</p>



<a name="257494401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257494401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257494401">(Oct 14 2021 at 07:56)</a>:</h4>
<p>the problem with generality in graph theory is that it completely changes the data structures</p>



<a name="257494459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257494459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257494459">(Oct 14 2021 at 07:57)</a>:</h4>
<p>which basically means that the specific theory is not a specialization of the general theory</p>



<a name="257494481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257494481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257494481">(Oct 14 2021 at 07:57)</a>:</h4>
<p>Welcome to stream#graph-theory, where everything needs to be done and hardly anything has been figured out <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="257496282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257496282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257496282">(Oct 14 2021 at 08:11)</a>:</h4>
<p>As a general rule of thumb, the right generality in mathlib is the one that suits the applications. So often a theorem is proved in the generality which is needed for the applications. And if later on it is needed in greater generality, then it will be extended at that time. This works pretty well, because refactoring theorems is not painful in general (one can state the very general version under a different name, then give a two-line proof of the original theorem based on the new general version, and all the applications don't need changing). And also it makes it possible to prove interesting theorems (otherwise, you get stuck on generalizing too much the basics, and you don't get anywhere). So, my advice would be to try to formalize your theorem indexed by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">N</span></span></span></span> for now.</p>
<p>NB: the question of <em>definitions</em> is completely different, because refactoring definitions is much more painful. So those should be done in the right generality from the start. That's one of the reasons why formalizing definitions is much harder than formalizing theorems (and why we encourage newcomers to work on theorems first).</p>



<a name="257514710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257514710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257514710">(Oct 14 2021 at 10:49)</a>:</h4>
<p>How about the following approach using relations instead of graphs. If you have a family of subspaces of <code>X</code> indexed by some type <code>I</code>, you get a relation on <code>I</code> saying "subspace <code>i</code> meets subspace <code>j</code>". The theorem says that if the <code>quot</code> by this relation has a unique element, then the union is connected.</p>



<a name="257517062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257517062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257517062">(Oct 14 2021 at 11:10)</a>:</h4>
<p>Right, and <a href="https://leanprover-community.github.io/mathlib_docs/find/eqv_gen">docs#eqv_gen</a> is the inductive proposition you can induct on to prove it</p>



<a name="257524177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257524177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257524177">(Oct 14 2021 at 12:15)</a>:</h4>
<p>I think that's a useful observation. But in some sense, it solves only half the problem. Because we still need to know that if you <code>quot</code> the naturals (or ℤ, or <code>fin n</code>) by the relation that relates <code>n</code> and <code>n+1</code>, that you get a type with a unique element.</p>



<a name="257527428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257527428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257527428">(Oct 14 2021 at 12:42)</a>:</h4>
<p>WHat do you think of <code>succ_archimedean</code> and <code>pred_archimedean</code> for that? I can get them PR-ready quickly.</p>



<a name="257533723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257533723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257533723">(Oct 14 2021 at 13:23)</a>:</h4>
<p>Related to <span class="user-mention" data-user-id="130377">@David Wärn</span>'s approach, maybe you can set up the union as a colimit of topological spaces (as a functor from some indexing category to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow><annotation encoding="application/x-tex">\mathrm{Top}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">Top</span></span></span></span></span>) -- maybe there a general enough condition on when colimits are connected?  (Finite) chains correspond to functors from the poset category <code>ℕ</code> or <code>fin n</code> (with <code>a &lt; b</code> corresponding to a morphism <code>a -&gt; b</code>).  For the case of spaces indexed by a connected graph, you can consider functors from a category whose objects are the disjoint union of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> and whose morphisms are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">v\to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">e\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> an incident edge.</p>
<p>This would be for topological spaces themselves.  It sounds like you might want a version involving subspaces of some larger space.</p>



<a name="257543876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257543876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257543876">(Oct 14 2021 at 14:24)</a>:</h4>
<p>It's true that a connected colimit (that is, where the index category is connected) of connected topological spaces is connected. This follows by considering the various images of inclusion maps, and applying the theorem about connected subspaces of an ambient space. But simply working with subspaces is surely easier</p>



<a name="257544580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257544580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257544580">(Oct 14 2021 at 14:28)</a>:</h4>
<p>If you just want to prove the statement I sketched above, you don't really need <code>eqv_gen</code> or any form of induction, you just need <code>quot.lift</code>. The argument would go something like this: suppose <code>X i</code> are connected subspaces, and <code>U</code> is an open subset of their union. Since each <code>X i</code> is connected, either it's contained in <code>U</code> or it's disjoint from <code>U</code>. Whenever <code>i</code> is related to <code>j</code>, you get that <code>X j</code> is contained in <code>U</code> if <code>X i</code> is. So the function <code>I -&gt; Prop</code> that says "<code>X i</code> is contained in U" factors through the <code>quot</code>. Hence if some <code>X i</code> is contained in <code>U</code>, then all of them are.</p>



<a name="257561084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257561084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257561084">(Oct 14 2021 at 16:08)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/9714">#9714</a></p>



<a name="257561165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257561165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257561165">(Oct 14 2021 at 16:08)</a>:</h4>
<p>I will provide the instances for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">N</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> and co in another PR.</p>



<a name="257566224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257566224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257566224">(Oct 14 2021 at 16:42)</a>:</h4>
<p>Thanks, you got a <code>bors d+</code> (-;</p>



<a name="257737215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Question%20about%20induction%28s%29/near/257737215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Question.20about.20induction(s).html#257737215">(Oct 15 2021 at 17:46)</a>:</h4>
<p>And <a href="https://github.com/leanprover-community/mathlib/issues/9730">#9730</a>, <a href="https://github.com/leanprover-community/mathlib/issues/9731">#9731</a> for you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
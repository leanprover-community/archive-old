---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/preserve.20filtered.20colimits.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html">preserve filtered colimits</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207962735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207962735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207962735">(Aug 25 2020 at 13:31)</a>:</h4>
<p>I've been trying to show that <code>forget CommRing</code> preserves filtered colimits (as this is something now blocking schemes).</p>
<p>I'm completely stuck, however, on the <a href="https://github.com/leanprover-community/mathlib/compare/preserves_filtered_colimits?expand=1#diff-d27a630fd2328a19457dfb973f26891bR487">following lemma</a>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">filtered_exact</span> <span class="o">[</span><span class="n">is_filtered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">CommRing</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">{</span><span class="n">jx</span> <span class="n">jy</span> <span class="o">:</span> <span class="n">J</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jx</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jy</span><span class="o">}</span>
  <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">relation</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">of</span> <span class="n">jx</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="o">(</span><span class="n">of</span> <span class="n">jy</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">jx</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">iy</span> <span class="o">:</span> <span class="n">jy</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">ix</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">iy</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>

<span class="kn">end</span>
</code></pre></div>


<p>at <a href="https://github.com/leanprover-community/mathlib/tree/preserves_filtered_colimits">branch#preserves_filtered_colimits</a></p>
<p>Here <code>of</code> is building the big inductive type we use to build colimits, and <code>relation F</code> is the relation on it.</p>
<p>I want to do something like:</p>
<ol>
<li>generalize one side of <code>w</code></li>
<li>use <code>quot.exact</code> to get an <code>eqv_gen (relation F)</code> hypothesis</li>
<li>do induction on that, obtaining a huge case base.</li>
</ol>
<p>I don't mind having to do a big case bash: I'd just like to get to the point I can start. All my attempts to generalize and/or induct so far quickly lose the connection with the <code>x</code> and <code>y</code> terms.</p>



<a name="207962837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207962837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207962837">(Aug 25 2020 at 13:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, any suggestions? It this or similar something you did previously when you were looking at filtered colimits? I don't remember seeing this.</p>



<a name="207963625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207963625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207963625">(Aug 25 2020 at 13:39)</a>:</h4>
<p>(<span class="user-mention" data-user-id="110087">@Scott Morrison</span> The period at the end of the branch link breaks the link.)</p>



<a name="207963934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207963934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207963934">(Aug 25 2020 at 13:42)</a>:</h4>
<p>I don't remember proving anything like this.</p>



<a name="207964472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207964472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207964472">(Aug 25 2020 at 13:47)</a>:</h4>
<p>I think I understand your problem. It might be worth keeping in mind that the fact that <code>comm_ring</code> only has finitary operations is required for this to be true.</p>



<a name="207964562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207964562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207964562">(Aug 25 2020 at 13:48)</a>:</h4>
<p>Yes.</p>



<a name="207964633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207964633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207964633">(Aug 25 2020 at 13:49)</a>:</h4>
<p>(I should have done the <code>Mon</code> case instead, if I knew I was going to need to ask for help, just to keep the clutter down.)</p>



<a name="207964878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207964878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207964878">(Aug 25 2020 at 13:51)</a>:</h4>
<p>Maybe you would need to generalize to something like: for any two terms in the free algebra that become equal in the quotient, there's some <code>j : J</code> and a bunch of maps to it from all the places where the <code>of</code>s live, such that if you map all those guys forward to <code>j</code>, the two terms are already equal there.</p>



<a name="207964901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207964901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207964901">(Aug 25 2020 at 13:51)</a>:</h4>
<p>Which sounds pretty dreadful</p>



<a name="207964959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207964959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207964959">(Aug 25 2020 at 13:51)</a>:</h4>
<p>Another approach that might be easier would be to instead put a ring structure on the Set-colimit and prove it has the right universal property</p>



<a name="207965194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965194">(Aug 25 2020 at 13:53)</a>:</h4>
<p>That does sound rather more pleasant, I guess. (Now that you say it I think I've tried that before... I guess time for another go.)</p>



<a name="207965197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965197">(Aug 25 2020 at 13:53)</a>:</h4>
<p>I think there is or was a direct construction of most of this in the algebra library</p>



<a name="207965341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965341">(Aug 25 2020 at 13:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/preserve.20filtered.20colimits/near/207964959">said</a>:</p>
<blockquote>
<p>Another approach that might be easier would be to instead put a ring structure on the Set-colimit and prove it has the right universal property</p>
</blockquote>
<p>I think the law of "conservation of work" will apply here :-/</p>



<a name="207965461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965461">(Aug 25 2020 at 13:55)</a>:</h4>
<p>I want to try out the lemma from this branch, but I'm just waiting for the oleans to be available.</p>



<a name="207965648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965648">(Aug 25 2020 at 13:56)</a>:</h4>
<p>can you get away with directed instead of filtered, btw? Should be okay for now right?</p>



<a name="207965786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965786">(Aug 25 2020 at 13:57)</a>:</h4>
<p>Yeah that should be fine for sheaves on topological spaces</p>



<a name="207965854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965854">(Aug 25 2020 at 13:58)</a>:</h4>
<p>yes</p>



<a name="207965988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207965988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207965988">(Aug 25 2020 at 13:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/preserve.20filtered.20colimits/near/207965197">said</a>:</p>
<blockquote>
<p>I think there is or was a direct construction of most of this in the algebra library</p>
</blockquote>
<p>oh no I'm wrong, it was always using the free ring-style construction even though it assumed directedness</p>



<a name="207966186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207966186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207966186">(Aug 25 2020 at 14:00)</a>:</h4>
<p>oh but actually it might prove the result you wanted originally</p>



<a name="207966320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207966320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207966320">(Aug 25 2020 at 14:01)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ring.direct_limit.of.zero_exact">docs#ring.direct_limit.of.zero_exact</a></p>



<a name="207966464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207966464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207966464">(Aug 25 2020 at 14:02)</a>:</h4>
<p>The docstring should say "some bigger ring" not "some bigger module"</p>



<a name="207966504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207966504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207966504">(Aug 25 2020 at 14:03)</a>:</h4>
<p>It looks like Kenny used the argument I was sketching</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">of</span><span class="bp">.</span><span class="n">zero_exact_aux</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">free_comm_ring</span> <span class="err">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">direct_limit</span> <span class="n">G</span> <span class="n">f</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">j</span> <span class="n">s</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">k</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">G</span> <span class="n">i</span><span class="o">,</span> <span class="n">k</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">k</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">j</span><span class="o">),</span> <span class="n">is_supported</span> <span class="n">x</span> <span class="n">s</span> <span class="bp">∧</span>
    <span class="n">lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ix</span> <span class="o">:</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">ix</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">j</span> <span class="o">(</span><span class="n">H</span> <span class="n">ix</span> <span class="n">ix</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="n">ix</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">restriction</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">G</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>



<a name="207967854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207967854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207967854">(Aug 25 2020 at 14:14)</a>:</h4>
<p>So here's a gigantic case-by-case start:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">filtered_exact</span> <span class="o">[</span><span class="n">is_filtered</span> <span class="n">J</span><span class="o">]</span> <span class="o">{</span><span class="n">jx</span> <span class="n">jy</span> <span class="o">:</span> <span class="n">J</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jx</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jy</span><span class="o">}</span>
  <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">relation</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">of</span> <span class="n">jx</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="o">(</span><span class="n">of</span> <span class="n">jy</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">jx</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">iy</span> <span class="o">:</span> <span class="n">jy</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">ix</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">iy</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">replace</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">exact</span> <span class="bp">_</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">w_a</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207968359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207968359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207968359">(Aug 25 2020 at 14:18)</a>:</h4>
<p>won't this generate subgoals involving stuff to which the inductive hypothesis won't apply?</p>



<a name="207968410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207968410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207968410">(Aug 25 2020 at 14:19)</a>:</h4>
<p>yeah... look at the third goal, for example</p>



<a name="207968442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207968442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207968442">(Aug 25 2020 at 14:19)</a>:</h4>
<p>because you're using <code>cases</code>, not <code>induction</code>, you've got nothing to work with there</p>



<a name="207968570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207968570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207968570">(Aug 25 2020 at 14:20)</a>:</h4>
<p>but even using induction won't work, because you'll get <code>relation</code>s between stuff not of the form <code>of jz z</code></p>



<a name="207968764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207968764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207968764">(Aug 25 2020 at 14:21)</a>:</h4>
<p>yes, hence the idea to somehow generalize one side...?</p>



<a name="207968784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207968784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207968784">(Aug 25 2020 at 14:21)</a>:</h4>
<p>but I don't see it.</p>



<a name="207969015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207969015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207969015">(Aug 25 2020 at 14:23)</a>:</h4>
<p>Basically you need to do what Kenny did</p>



<a name="207969286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207969286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207969286">(Aug 25 2020 at 14:25)</a>:</h4>
<p>I think the viable options are to reuse Kenny's construction, or build the ring structure on the Set-colimit (I really think this is a lot easier if you're going to build from scratch, but maybe just because I am bad at <code>finset</code>)</p>



<a name="207969559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207969559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207969559">(Aug 25 2020 at 14:27)</a>:</h4>
<p>For the latter it might be a good idea to prove first that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \mapsto X \times X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> (and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">X \mapsto *</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>) preserves filtered colimits</p>



<a name="207970230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207970230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207970230">(Aug 25 2020 at 14:32)</a>:</h4>
<p>Then I feel like the rest is just a series of diagram chases</p>



<a name="207972192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207972192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207972192">(Aug 25 2020 at 14:47)</a>:</h4>
<p>Would it perhaps make sense to replace <code>relation.map</code> by this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">|</span> <span class="n">map</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">jx</span> <span class="n">jy</span> <span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jx</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jy</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">jx</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">iy</span> <span class="o">:</span> <span class="n">jy</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">),</span>
    <span class="n">relation</span> <span class="o">(</span><span class="n">of</span> <span class="bp">_</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">ix</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">of</span> <span class="bp">_</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">iy</span> <span class="n">y</span><span class="o">))</span> <span class="bp">→</span> <span class="n">relation</span> <span class="o">(</span><span class="n">of</span> <span class="n">jx</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">of</span> <span class="n">jy</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="207993075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207993075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207993075">(Aug 25 2020 at 17:23)</a>:</h4>
<p>Okay, I think I have something working... <del>what's the easiest way to obtain a common <code>j</code> with maps <code>jx \hom j</code> and <code>jy \hom j</code> given <code>jx jy : J</code> and <code>is_filtered J</code> ?</del> found it: <code>is_filtered_or_empty.cocone_objs</code>.</p>



<a name="207998996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/207998996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#207998996">(Aug 25 2020 at 18:05)</a>:</h4>
<p>Oh no! I ran into a point where I have to prove that <code>prequotient.of</code>is injective. That's unprovable right?</p>



<a name="208038496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208038496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208038496">(Aug 25 2020 at 23:49)</a>:</h4>
<p>No, rather there should be an automatically generated lemma for it.</p>



<a name="208038568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208038568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208038568">(Aug 25 2020 at 23:50)</a>:</h4>
<p><code>prequotient.of.inj</code></p>



<a name="208040497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208040497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208040497">(Aug 26 2020 at 00:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  I tried doing something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">filtered_exact</span> <span class="o">[</span><span class="n">is_filtered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">prequotient</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">relation</span> <span class="n">F</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">jx</span> <span class="n">jy</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jx</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jy</span><span class="o">),</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">of</span> <span class="n">jx</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">of</span> <span class="n">jy</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">jx</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">iy</span> <span class="o">:</span> <span class="n">jy</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">ix</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">iy</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>At least the induction gets started this way.</p>



<a name="208042889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208042889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208042889">(Aug 26 2020 at 01:00)</a>:</h4>
<p>That lemma does seem provable. But can we actually deduce the lemma I was after from it?</p>



<a name="208043178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208043178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208043178">(Aug 26 2020 at 01:06)</a>:</h4>
<p>I haven't tried. I didn't have much time for lean today.</p>



<a name="208043296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208043296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208043296">(Aug 26 2020 at 01:08)</a>:</h4>
<p>I think it may be. There's actually something pretty stupid going on in the construction of colimits here --- we go to all the effort of making <code>relation F</code> an equivalence relation, and then use <code>quot</code> instead of <code>quotient</code>.</p>



<a name="208043410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208043410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208043410">(Aug 26 2020 at 01:11)</a>:</h4>
<p>oh, this isn't a problem in the construction, just in the lemmas I'm trying to prove now. maybe not a big deal</p>



<a name="208043784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208043784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208043784">(Aug 26 2020 at 01:19)</a>:</h4>
<p>It's possible to just get rid of refl, symm and trans in the definition of relation</p>



<a name="208043887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208043887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208043887">(Aug 26 2020 at 01:21)</a>:</h4>
<p>It is strange that <code>quot.mk</code> is used sometimes as opposed to <code>quotient.mk</code>, given that there is a setoid around</p>



<a name="208044605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208044605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208044605">(Aug 26 2020 at 01:37)</a>:</h4>
<p>Renaming your <code>filtered_exact</code> to <code>filtered_exact'</code>, the original <code>filtered_exact</code> is indeed provable from it:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">filtered_exact</span> <span class="o">[</span><span class="n">is_filtered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">CommRing</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">{</span><span class="n">jx</span> <span class="n">jy</span> <span class="o">:</span> <span class="n">J</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jx</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">jy</span><span class="o">}</span>
  <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">of</span> <span class="n">jx</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">of</span> <span class="n">jy</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">ix</span> <span class="o">:</span> <span class="n">jx</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">iy</span> <span class="o">:</span> <span class="n">jy</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">ix</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">iy</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="n">w</span> <span class="k">with</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span> <span class="bp">_</span> <span class="n">tz</span> <span class="bp">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">filtered_exact&#39;</span> <span class="n">F</span> <span class="o">(</span><span class="n">relation</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">let</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">relation</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">filtered_exact&#39;</span> <span class="n">F</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">let</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">relation</span><span class="bp">.</span><span class="n">trans</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">filtered_exact&#39;</span> <span class="n">F</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">filtered_exact&#39;</span> <span class="n">F</span> <span class="bp">_</span><span class="n">x</span> <span class="o">((</span><span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">y</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208045217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208045217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208045217">(Aug 26 2020 at 01:51)</a>:</h4>
<p>Ah, no, but the <code>trans</code> case of your lemma is simply not provable. I don't think this is going to work.</p>



<a name="208045607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208045607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208045607">(Aug 26 2020 at 01:58)</a>:</h4>
<p>What of we get rid of trans from relation?</p>



<a name="208045611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208045611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208045611">(Aug 26 2020 at 01:58)</a>:</h4>
<p>And just never define a setoid?</p>



<a name="208045623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208045623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208045623">(Aug 26 2020 at 01:59)</a>:</h4>
<p>(same with symm and refl)</p>



<a name="208045728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208045728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208045728">(Aug 26 2020 at 02:00)</a>:</h4>
<p>This would be a hack anyway... There must be a better way!</p>



<a name="208046278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208046278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208046278">(Aug 26 2020 at 02:10)</a>:</h4>
<p>I don't think that the setoid business is an issue.</p>



<a name="208046319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208046319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208046319">(Aug 26 2020 at 02:11)</a>:</h4>
<p>You have a choice whether you deal with transitivity as a case of the relation, or as a case of <code>eqv_gen</code> if you decide not to use a setoid.</p>



<a name="208053206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208053206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208053206">(Aug 26 2020 at 05:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> or <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>, I can prove the diagonal functor preserves filtered colimits. But could you sketch out for me a bit more detail how you thought that would be useful defining a ring structure on the type level colimit?</p>



<a name="208060739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208060739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208060739">(Aug 26 2020 at 07:35)</a>:</h4>
<p>Oh, I see, multiplication gives a natural transformation <code>F ⋙ Δ ⟶ F</code>, and we can take the induced map on colimits, and since <code>Δ</code> preserves filtered colimits, we can turn that into a morphism <code>Δ (colimit F) ⟶ colimit F</code>, which is what we wanted.</p>



<a name="208070049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208070049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208070049">(Aug 26 2020 at 09:31)</a>:</h4>
<p>I can use this to construct <code>one</code> and <code>mul</code> quite slickly on the type level colimit, but so far my efforts to check the axioms just result in big messes. :-(</p>



<a name="208081117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208081117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208081117">(Aug 26 2020 at 11:50)</a>:</h4>
<p>Now you should prove that, say, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>X</mi><mo>×</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \mapsto X \times X \times X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> also preserves filtered colimits and therefore any axiom involving 3 variables follows from the fact that, by construction, the maps to the colimit preserve the addition and multiplication you just defined.</p>



<a name="208081467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208081467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208081467">(Aug 26 2020 at 11:55)</a>:</h4>
<p>That is, if we switch to a more comfortable notation denoting a typical input ring as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and their colimit in Set as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, you've constructed addition on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> as the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R \times R \to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that the squares formed together with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>×</mo><msub><mi>R</mi><mi>i</mi></msub><mo>→</mo><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i \times R_i \to R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> commute, and similarly for multiplication. In other words, each map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R_i \to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> now preserves <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>.</p>



<a name="208081684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208081684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208081684">(Aug 26 2020 at 11:57)</a>:</h4>
<p>Now, suppose we want to prove that say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>b</mi><mo>+</mo><mi>a</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a * (b + c) = a * b + a * c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> is satisfied in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>. Look at the diagram formed by the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>a</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>R</mi><mi>i</mi></msub><mo>×</mo><msub><mi>R</mi><mi>i</mi></msub><mo>×</mo><msub><mi>R</mi><mi>i</mi></msub><mo>→</mo><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(a, b, c) \mapsto a * (b + c) : R_i \times R_i \times R_i \to R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Because the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R_i \to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> preserve addition and multiplication, we can extend this diagram to include the corresponding map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R \times R \times R \to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>.</p>



<a name="208081768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208081768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208081768">(Aug 26 2020 at 11:58)</a>:</h4>
<p>If we instead used the expression <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>+</mo><mi>a</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a * b + a * c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>, we'd get the same maps for all the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, of course, and a priori a different map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R \times R \times R \to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, but we can conclude that they're actually equal because there's only one map that fits there by the universal property of the colimit.</p>



<a name="208081813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208081813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208081813">(Aug 26 2020 at 11:59)</a>:</h4>
<p>The same kind of argument will appear later when you want to verify the universal property, whicih amounts to showing that the map you get from the universal property in Set is also a ring homomorphism.</p>



<a name="208082094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082094">(Aug 26 2020 at 12:02)</a>:</h4>
<p>I'm a bit confused as to how this solves the original issue of proving the <code>filtered_exact</code> lemma from before. It seems that one would just have to prove a similar lemma for colimits in the category <code>Type*</code> (which is certainly a sensible thing to do), and it seems to me that this would have similar issues with getting the induction right. That is unless mathlib already has an analogue of <code>filtered_exact</code> for colimits in <code>Type*</code>?</p>



<a name="208082130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082130">(Aug 26 2020 at 12:02)</a>:</h4>
<p>Also, with this formulation it feels like we should just define sheaves of rings to be internal ring objects in the category of sheaves of sets.</p>



<a name="208082195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082195">(Aug 26 2020 at 12:03)</a>:</h4>
<p>The point is that in Set, any element of a colimit (even one that isn't filtered) is actually of the form <code>of _</code></p>



<a name="208082211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082211">(Aug 26 2020 at 12:03)</a>:</h4>
<p>and so the corresponding fact for Set is very easy</p>



<a name="208082327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082327">(Aug 26 2020 at 12:05)</a>:</h4>
<p>Well, we already know this for colimits (in the filtered case) in CRing from <code>of_surjective</code> which is a lemma in the file that Scott was working with.</p>



<a name="208082803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082803">(Aug 26 2020 at 12:10)</a>:</h4>
<p>Ok, I think I see why it is easier in the <code>Type*</code>. The point is that we would define the relation whose quotient is the colimit directly on the disjoint union of the components, as opposed to working with an auxiliary <code>prequotient</code> type.</p>



<a name="208082823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082823">(Aug 26 2020 at 12:10)</a>:</h4>
<p>And yes I agree the induction would be much smoother.</p>



<a name="208082971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208082971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208082971">(Aug 26 2020 at 12:12)</a>:</h4>
<p>Hmm, it's possible you could use the surjectivity somehow, but it's not clear to me. The relations are also more complicated, involving multiple variables.</p>



<a name="208083032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208083032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208083032">(Aug 26 2020 at 12:12)</a>:</h4>
<p>I might be misunderstanding the root of the issue, but it seems to be coming from using this auxiliary <code>prequotient</code> thing.</p>



<a name="208083627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208083627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208083627">(Aug 26 2020 at 12:19)</a>:</h4>
<p>Ha, I guess there is not induction at all in the case of <code>Type*</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span><span class="bp">.</span><span class="n">limits</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span><span class="bp">.</span><span class="n">types</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kn">open</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">small_category</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">colimit</span>
<span class="n">def</span> <span class="n">relation</span> <span class="o">:</span> <span class="o">(</span><span class="err">Σ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Σ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">j₁</span><span class="o">,</span><span class="n">x₁</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">j₂</span><span class="o">,</span><span class="n">x₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">j₁</span> <span class="err">⟶</span> <span class="n">j₂</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">x₂</span>
<span class="kn">end</span> <span class="n">colimit</span>

<span class="n">def</span> <span class="n">colimit</span> <span class="o">:=</span> <span class="n">quot</span> <span class="o">(</span><span class="n">colimit</span><span class="bp">.</span><span class="n">relation</span> <span class="n">F</span><span class="o">)</span>
</code></pre></div>


<p>I think that's the right construction?</p>



<a name="208087405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208087405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208087405">(Aug 26 2020 at 12:59)</a>:</h4>
<p>Okay, it works for colimits of types :)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span><span class="bp">.</span><span class="n">limits</span>
<span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span><span class="bp">.</span><span class="n">types</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kn">open</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">limits</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">small_category</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">colimit</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">relation</span> <span class="o">:</span> <span class="o">(</span><span class="err">Σ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Σ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="err">⟶</span> <span class="n">y</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">y</span><span class="bp">.</span><span class="mi">2</span>
<span class="kn">end</span> <span class="n">colimit</span>

<span class="n">def</span> <span class="n">colimit</span> <span class="o">:=</span> <span class="n">quot</span> <span class="o">(</span><span class="n">colimit</span><span class="bp">.</span><span class="n">relation</span> <span class="n">F</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">filtered_exact</span> <span class="o">[</span><span class="n">is_filtered</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">obj</span> <span class="n">j</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">colimit</span><span class="bp">.</span><span class="n">relation</span> <span class="n">F</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">colimit</span><span class="bp">.</span><span class="n">relation</span> <span class="n">F</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">i1</span> <span class="o">:</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">i2</span> <span class="o">:</span> <span class="n">y</span><span class="bp">.</span><span class="mi">1</span> <span class="err">⟶</span> <span class="n">j</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">i1</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">map</span> <span class="n">i2</span> <span class="n">y</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">j1</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">j2</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">quot</span><span class="bp">.</span><span class="n">exact</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h_a</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">⟨</span><span class="n">h_y</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">h_a_w</span><span class="o">,</span><span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span><span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">h_ih</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span><span class="n">i1</span><span class="o">,</span><span class="n">i2</span><span class="o">,</span><span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span><span class="n">i2</span><span class="o">,</span><span class="n">i1</span><span class="o">,</span><span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">h_ih_a</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">j1</span><span class="o">,</span><span class="n">i11</span><span class="o">,</span><span class="n">i12</span><span class="o">,</span><span class="n">h1</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h_ih_a_1</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">j2</span><span class="o">,</span><span class="n">i21</span><span class="o">,</span><span class="n">i22</span><span class="o">,</span><span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">is_filtered_or_empty</span><span class="bp">.</span><span class="n">cocone_objs</span> <span class="n">j1</span> <span class="n">j2</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span><span class="n">i1</span><span class="o">,</span><span class="n">i2</span><span class="o">,</span><span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">is_filtered_or_empty</span><span class="bp">.</span><span class="n">cocone_maps</span> <span class="o">(</span><span class="n">i12</span> <span class="err">≫</span> <span class="n">i1</span><span class="o">)</span> <span class="o">(</span><span class="n">i21</span> <span class="err">≫</span> <span class="n">i2</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">jj</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">hh</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">jj</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">i11</span> <span class="err">≫</span> <span class="n">i1</span> <span class="err">≫</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">i22</span> <span class="err">≫</span> <span class="n">i2</span> <span class="err">≫</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">functor_to_types</span><span class="bp">.</span><span class="n">map_comp_apply</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span><span class="err">←</span><span class="n">h2</span><span class="o">],</span>
    <span class="n">simp_rw</span> <span class="err">←</span><span class="n">functor_to_types</span><span class="bp">.</span><span class="n">map_comp_apply</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hh</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="208087745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208087745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208087745">(Aug 26 2020 at 13:03)</a>:</h4>
<p>right, I think that's what I proved <a href="https://github.com/leanprover-community/mathlib/commit/bc457fb5716fbffe63cbcc10b4ce7a253c720f84#diff-b99529211f61cfc9437470fc7ea6ed1aR131-R132">here</a></p>



<a name="208088001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208088001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208088001">(Aug 26 2020 at 13:06)</a>:</h4>
<p>By the way, isn't there some general category theory voodoo which tells us that the underlying type of the colimits in CRing are the same as the colimits of the underlying type, using the fact that the forgetful functor from CRing to Set is a right adjoint?</p>



<a name="208088518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208088518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208088518">(Aug 26 2020 at 13:11)</a>:</h4>
<p>Oh, no, right adjoints preserve limits.</p>



<a name="208088660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208088660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208088660">(Aug 26 2020 at 13:12)</a>:</h4>
<p>And anyway, this is only true for filtered colimits.</p>



<a name="208097181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/208097181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#208097181">(Aug 26 2020 at 14:19)</a>:</h4>
<p>I guess there is some general-nonsense type theorem that this fits into (something about algebras for Lawvere theories, etc.) but the proof seems to boil down to the fact that filtered colimits commute with finite limits in Set, so one would have to do the work that Reid is suggesting anyway :)</p>



<a name="252522581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252522581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252522581">(Sep 08 2021 at 19:55)</a>:</h4>
<p>As I've written <a href="#narrow/stream/113488-general/topic/status.20of.20schemes/near/252005927">here</a>, I am taking on the project to prove that forgetful functors preserve filtered colimits. I just PR'd a working draft for <code>Mon</code>: <a href="https://github.com/leanprover-community/mathlib/issues/9101">#9101</a>. Before I apply my approach to other algebraic categories like <code>CommRing</code>, I thought I'd ask for feedback on the general design (or just a go-head signal if you think it looks good). <span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>



<a name="252524970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252524970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252524970">(Sep 08 2021 at 20:10)</a>:</h4>
<p>Have you seen the discussion starting <a href="#narrow/stream/116395-maths/topic/preserve.20filtered.20colimits/near/208053206">here</a> on this same topic from last year? It seems that your PR does a lot of work to check what basically amounts to the fact that the functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \mapsto X \times X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> on Set preserves filtered colimits. Specifically, if I have a filtered diagram <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(M_i)_{i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span></span></span></span> of monoids and I denote by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> the colimit in Set (for now) of the underlying sets, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mi>i</mi></msub><mo>×</mo><msub><mi>M</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mo>→</mo><mi>M</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">(M_i \times M_i)_{i \in I} \to M \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is also a colimit diagram in Set.<br>
Once you know this fact, there is a proof where you just fill in the multiplication map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M \times M \to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> on the colimit of underlying sets to be the unique thing that fits in the diagram. On paper, this should be a lot slicker because the hard work occurs in the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \mapsto X \times X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> preserves filtered colimits, which I believe Scott proved in mathlib at some point in the past year. I don't know whether the slickness would necessarily preserve formalization though.</p>



<a name="252531280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252531280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252531280">(Sep 08 2021 at 20:55)</a>:</h4>
<p>More explicitly,</p>
<ul>
<li>
<p>(if this doesn't already exist) Define functors <code>square</code> and <code>cube</code> and <code>punit</code> which are given on objects by <code>square.obj X = X × X</code> and <code>cube.obj X = X × X × X</code> and <code>punit.obj X = punit</code>. Using the concrete built-in products (rather than <code>fin 2 -&gt; X</code> or something) will make the later parts of the argument easier, and has a cost that only gets paid once. Prove that these functors preserve filtered counits, possibly using <code>bowtie</code> and <code>tulip</code> if there isn't already something more convenient.<br>
Then to construct the colimit of a filtered diagram <code>F</code> in Mon,</p>
</li>
<li>
<p>Define the carrier <code>M</code> of the colimit as the <code>colimit</code> of <code>(F ⋙ forget Mon)</code>, and define <code>mk j : F.obj j -&gt; M</code> using the structure maps <code>ι</code> of the colimit. </p>
</li>
<li>Define the multiplication <code>mu : M × M -&gt; M</code> by using the universal property of <code>M × M</code> as a colimit (because <code>square</code> preserves filtered colimits). That makes sense because the maps in the diagram <code>F</code> preserve multiplication. Then define <code>*</code> on <code>M</code> by <code>a * b = mu (a, b)</code>.</li>
<li><code>mk j x * mk j y = mk j (x * y)</code> by the construction of <code>mu</code>.</li>
<li>To prove that <code>*</code> is associative, consider the two maps <code>assoc1, assoc2 : M × M × M -&gt; M</code> defined by <code>assoc1 x y z = (x * y) * z</code>, <code>assoc2 x y z = x * (y * z)</code>. Because <code>M × M × M</code> is a colimit, in order to check <code>assoc1 = assoc2</code>, it suffices to check that they agree back in each <code>F.obj j ×  F.obj j × F.obj j</code>. That holds because we can move <code>mk</code> past <code>*</code> and because <code>F.obj j</code> is associative.</li>
<li>Repeat these last two steps for <code>eta : punit -&gt; M</code> which is going to be the map picking out the unit, and the unit laws. Then we can make <code>M</code> into a monoid.</li>
<li>To check an instance of the universal property of <code>M</code> in Mon: we know there's a unique map on underlying sets which makes everything commute. To see that it's a monoid homomorphism again amounts to checking that two maps out of <code>M × M</code> are equal and two maps out of <code>punit</code> are equal, and we can check these using uniqueness of maps out of a colimit again.</li>
</ul>



<a name="252551355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252551355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252551355">(Sep 08 2021 at 23:53)</a>:</h4>
<p>I think the last thing I PR'd was <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.colimit_limit_to_limit_colimit_is_iso/src">src#category_theory.limits.colimit_limit_to_limit_colimit_is_iso</a>, which says:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">#</span> <span class="n">Filtered</span> <span class="n">colimits</span> <span class="n">commute</span> <span class="k">with</span> <span class="n">finite</span> <span class="n">limits.</span>

<span class="n">We</span> <span class="k">show</span> <span class="n">that</span> <span class="n">for</span> <span class="n">a</span> <span class="n">functor</span> <span class="bp">`</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="bp">×</span> <span class="n">K</span> <span class="bp">⥤</span> <span class="kt">Type</span> <span class="n">v</span><span class="bp">`</span><span class="o">,</span> <span class="n">when</span> <span class="bp">`</span><span class="n">J</span><span class="bp">`</span> <span class="n">is</span> <span class="n">finite</span> <span class="n">and</span> <span class="bp">`</span><span class="n">K</span><span class="bp">`</span> <span class="n">is</span> <span class="n">filtered</span><span class="o">,</span>
<span class="n">the</span> <span class="n">universal</span> <span class="n">morphism</span> <span class="bp">`</span><span class="n">colimit_limit_to_limit_colimit</span> <span class="n">F</span><span class="bp">`</span> <span class="n">comparing</span> <span class="n">the</span>
<span class="n">colimit</span> <span class="o">(</span><span class="n">over</span> <span class="bp">`</span><span class="n">K</span><span class="bp">`</span><span class="o">)</span> <span class="n">of</span> <span class="n">the</span> <span class="n">limits</span> <span class="o">(</span><span class="n">over</span> <span class="bp">`</span><span class="n">J</span><span class="bp">`</span><span class="o">)</span> <span class="k">with</span> <span class="n">the</span> <span class="n">limit</span> <span class="n">of</span> <span class="n">the</span> <span class="n">colimits</span> <span class="n">is</span> <span class="n">an</span> <span class="n">isomorphism.</span>

<span class="o">(</span><span class="n">In</span> <span class="n">fact</span><span class="o">,</span> <span class="n">to</span> <span class="n">prove</span> <span class="n">that</span> <span class="n">it</span> <span class="n">is</span> <span class="n">injective</span> <span class="n">only</span> <span class="n">requires</span> <span class="n">that</span> <span class="bp">`</span><span class="n">J</span><span class="bp">`</span> <span class="n">has</span> <span class="n">finitely</span> <span class="n">many</span> <span class="n">objects.</span><span class="o">)</span>
</code></pre></div>



<a name="252551371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252551371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252551371">(Sep 08 2021 at 23:53)</a>:</h4>
<p>but I suspect there is a branch with more of Reid's proposal implemented.</p>



<a name="252559559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252559559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252559559">(Sep 09 2021 at 01:54)</a>:</h4>
<p>Ah, I found the branch that I was working in a long time back... It is a mess and broken in places, but <a href="https://github.com/leanprover-community/mathlib/tree/preserves_filtered_colimits">branch#preserves_filtered_colimits</a> may have some useful stuff.</p>



<a name="252586701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252586701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252586701">(Sep 09 2021 at 08:06)</a>:</h4>
<p>Thanks so much for the detailed explanation <span class="user-mention" data-user-id="110032">@Reid Barton</span> !<br>
I saw the discussion you mentioned. I have to admit, I didn't look into it that much. The last thing I saw is there was <a href="#narrow/stream/116395-maths/topic/limits.20in.20functor.20categories">some universe issue</a> arising when proving that some functor category has limits. Instead of trying to understand this in detail, I figured I'd just start from scratch and discover any issues by my own. My approach goes as follows:</p>
<ul>
<li>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(M_i)_{i\in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span></span></span></span> be a filtered diagram of monoids. Goal: Install a monoid structure on the colimit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msub><mo>⨆</mo><mi>i</mi></msub><msub><mi>M</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mo>∼</mo></mrow><annotation encoding="application/x-tex">M=\bigsqcup_i M_i/\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨆</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span></span></span></span>. Denote its element as equivalence classes of dependent pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x\in M_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</li>
<li>Define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">1_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>j</mi><mn>0</mn></msub><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j_0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>j</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">j_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is an arbitrarily chosen object. Show this to be independent of the choice of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>j</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">j_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</li>
<li>Define multiplication <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⋅</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,x]\cdot[j,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> by passing to a common successor level <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>→</mo><mi>k</mi><mo>←</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\to k \leftarrow j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> and then multiply in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">M_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Show this to be well-defined in both slots (that's where you need a tulip diagram) and also independent of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> (that's where you need a bowtie).</li>
<li>Monoid laws are easily verified, as we can unfold the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">1_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋅</mo><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\cdot_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59445em;vertical-align:-0.15em;"></span><span class="mord"><span class="mbin">⋅</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> at any custom index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">j\in I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>. For example, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>1</mn><mi>M</mi></msub><mo>⋅</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>⋅</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo>⋅</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">1_M\cdot[j,x]=[j,1]\cdot[j,x]=[j,1\cdot x]=[j,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span>. Similarly for associativity.</li>
</ul>
<p>For now, I'd argue that this approach is more straightforward than the one you mentioned. Although the approach via the functor <code>X↦X×X</code> looks slicker on paper, I have the feeling we'd have to be currying and uncurrying the multiplication <code>mu : M × M → M</code> all the time. Similarly, translating from <code>eta : punit → M</code> to <code>1 : M</code> and back. That said, I didn't seriously give this approach a try. I'm definitely going to do some experiments, now that I understand it better. The question now is, whether it's worth switching to the other approach now.</p>



<a name="252586908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252586908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252586908">(Sep 09 2021 at 08:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/preserve.20filtered.20colimits/near/252559559">said</a>:</p>
<blockquote>
<p>Ah, I found the branch that I was working in a long time back... It is a mess and broken in places, but <a href="https://github.com/leanprover-community/mathlib/tree/preserves_filtered_colimits">branch#preserves_filtered_colimits</a> may have some useful stuff.</p>
</blockquote>
<p>I saw this branch, that's where I stole your bowtie from <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> (<a href="https://github.com/leanprover-community/mathlib/issues/9099">#9099</a>)</p>



<a name="252590808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252590808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252590808">(Sep 09 2021 at 08:40)</a>:</h4>
<p>Sorry, yes, I've started to read your PRs since writing this and realised you must have found it!</p>



<a name="252598231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252598231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252598231">(Sep 09 2021 at 09:43)</a>:</h4>
<p>The main point is really that the same statement and proof also work for commutative monoids and groups and abelian groups and rings and commutative rings and modules and probably we want most of these facts as well. So, it would be best to minimize the work that is specific to the case of monoids. In that context, it seems wrong to be invoking stuff like <code>tulip</code> directly in a context where we are specifically talking about monoids. However, the monoids part of your PR is certainly not that long already and experimentation is definitely needed to know whether the alternative strategy I outlined would actually come out shorter.</p>



<a name="252598456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252598456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252598456">(Sep 09 2021 at 09:45)</a>:</h4>
<p>(It's also the case that the alternative strategy gives more generally preservation of <a href="https://ncatlab.org/nlab/show/sifted+colimit">sifted colimits</a>, basically filtered colimits plus reflexive coequalizers, though I've personally never cared about reflexive coequalizers as much as I think I'm supposed to.)</p>



<a name="252599450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252599450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252599450">(Sep 09 2021 at 09:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="384542">Justus Springer</span> <a href="#narrow/stream/116395-maths/topic/preserve.20filtered.20colimits/near/252586701">said</a>:</p>
<blockquote>
<p>I have the feeling we'd have to be currying and uncurrying the multiplication <code>mu : M × M → M</code> all the time. Similarly, translating from <code>eta : punit → M</code> to <code>1 : M</code> and back.</p>
</blockquote>
<p>I think it won't be so bad; this is the sort of thing Lean is very good at. I have an old branch <a href="https://github.com/leanprover-community/mathlib/commit/d4477fa7f79beea1058f72fc3741c88a1832d9a1#diff-1877ef03abd5d5a24980277d502e71d2418728fcf33ec4a8d26cacb0526245eeR565">https://github.com/leanprover-community/mathlib/commit/d4477fa7f79beea1058f72fc3741c88a1832d9a1#diff-1877ef03abd5d5a24980277d502e71d2418728fcf33ec4a8d26cacb0526245eeR565</a> with a similar sort of argument for Ore localization (not using the category theory library, but similarly obtaining the monoid structure from a universal property). In your situation it will be even simpler, because the universal property just involves maps in Set.</p>



<a name="252599548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252599548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252599548">(Sep 09 2021 at 09:55)</a>:</h4>
<p>But this is why I think it's important to literally use <code>M × M</code> and not, say, <code>fin 2 -&gt; M</code> or some abstractly-given product functor on Set.</p>



<a name="252599707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252599707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252599707">(Sep 09 2021 at 09:56)</a>:</h4>
<p>By the way, there could be other ways to reduce duplication between the proofs for monoids, rings, etc. (In the limit, one invents universal algebra but it's probably too much to bite off for now.)</p>



<a name="252609514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252609514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252609514">(Sep 09 2021 at 11:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/preserve.20filtered.20colimits/near/252599707">said</a>:</p>
<blockquote>
<p>By the way, there could be other ways to reduce duplication between the proofs for monoids, rings, etc. (In the limit, one invents universal algebra but it's probably too much to bite off for now.)</p>
</blockquote>
<p>I was planning to build things up incrementally. E.g. if I already have the additive monoid structure on <code>M</code>, I can build upon it for the ring structure etc. Hopefully <code>@[to_additive]</code> helps as well. Either way, there will of course be duplication. The question is how bad it gets...</p>



<a name="252609812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252609812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252609812">(Sep 09 2021 at 11:33)</a>:</h4>
<p>To be honest, I only care about the case of commutative rings anyway, so I'm not motivated enough to go down the universal algebra path... But of course I care about getting things right and stating it at the "correct" level of abstraction.</p>



<a name="252609945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/252609945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#252609945">(Sep 09 2021 at 11:34)</a>:</h4>
<p>So thanks again for the input! That's exactly why I'm PRing it now, before spending a lot more time duplicating this design to other algebraic categories.</p>



<a name="253261069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253261069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253261069">(Sep 14 2021 at 14:30)</a>:</h4>
<p>I've transported my approach to other algebraic categories and removed the WIP label from <a href="https://github.com/leanprover-community/mathlib/issues/9101">#9101</a> and <a href="https://github.com/leanprover-community/mathlib/issues/9099">#9099</a>. It should be ready for review now.</p>



<a name="253261816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253261816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253261816">(Sep 14 2021 at 14:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I did some experiments, but then decided against changing original my approach. Most of the repetition is not because I need to define binary operations <code>M×M→ M</code> all the time. In fact, I define multiplication only once for monoids and then build upon it for other algebraic structures. Still, there is a lot of boilerplate code, as the basic pattern is the same for all the categories, and we need to verify all the axioms for every algebraic structure. But I think that would be the same with both approaches.</p>



<a name="253406059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253406059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253406059">(Sep 15 2021 at 12:39)</a>:</h4>
<p>I've kicked the bowtie-and-tulip PR on the queue.</p>



<a name="253406123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253406123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253406123">(Sep 15 2021 at 12:39)</a>:</h4>
<p>how appropriate that a Dutchman did it</p>



<a name="253406726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253406726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253406726">(Sep 15 2021 at 12:45)</a>:</h4>
<p>I don't think I've ever touched a bowtie in my life</p>



<a name="253406760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253406760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253406760">(Sep 15 2021 at 12:45)</a>:</h4>
<p>Maybe a Brit could have kicked that part of the PR.</p>



<a name="253406906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253406906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253406906">(Sep 15 2021 at 12:46)</a>:</h4>
<p>Even when that picture was taken?</p>



<a name="253407070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253407070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253407070">(Sep 15 2021 at 12:48)</a>:</h4>
<p>I think I see a bowtie on <a href="avatar/112680/medium?v=2">https://leanprover.zulipchat.com/avatar/112680/medium?v=2</a></p>



<a name="253410129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253410129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253410129">(Sep 15 2021 at 13:10)</a>:</h4>
<p>ooh lol, I might have been wearing a bowtie during my PhD defense <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span> I happily forgot that part of the ceremony</p>



<a name="253421159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253421159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Justus Springer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253421159">(Sep 15 2021 at 14:15)</a>:</h4>
<p>It was a tough and well considered decision how to call the second diagram: Tulip, crown or trident.</p>



<a name="253421876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253421876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253421876">(Sep 15 2021 at 14:20)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> The Dutch are very proud of you now (-;</p>



<a name="253422032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253422032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253422032">(Sep 15 2021 at 14:20)</a>:</h4>
<p>Next time you are looking for a name: we are also very fond of windmills, wooden shoes, and cheese.</p>



<a name="253436489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/preserve%20filtered%20colimits/near/253436489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/preserve.20filtered.20colimits.html#253436489">(Sep 15 2021 at 15:46)</a>:</h4>
<p>Oh funny: I thought beer was also your cup of tea.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html">Well-founded recursion for pgames</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="239345240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345240">(May 19 2021 at 00:11)</a>:</h4>
<p>I've been stuck on a big proof for surreal numbers for quite some time now.</p>
<p>I'm trying to prove a complicated theorem <code>f(x, y)</code> for <code>{x y : pgames}</code> by recursion.<br>
I end up having to use statements like <code>f(x - xL i, yL j)</code>, <code>f(xL k, yR l - y)</code>,  etc in the proof where <code>xL _</code> are the left moves of <code>x</code> and <code>xR _</code> are the right moves of <code>x</code> and similarly for <code>y</code>.  Note that the "depth" always increases and there are no terms of the form <code>f(x - xL i, y)</code> so mathematically the recursion is fine.</p>
<p>Lean is unable to prove well-founded recursion for this.  I tried doing a trace and it seems to be that the terms of the form <code>x - xL i</code> are throwing it off.</p>
<p>I'm not sure if I can come up with a mwe for this. I can post my big messy proof here.</p>
<p>Any suggestions on how to prove that this kind of recursion is well-founded?</p>



<a name="239345443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345443">(May 19 2021 at 00:14)</a>:</h4>
<p>You might have to post. Sometimes if you're really suffering with a well-founded recursion, it can be helpful to work out how to instead do a inductive proof on <code>nat</code> itself. (e.g. introduce a complexity measure, and hypotheses that explicitly control your arguments in terms of it). If nothing else sometimes it's helpful as a paper-proof step, to make sure you're really doing a sensible induction.</p>



<a name="239345623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345623">(May 19 2021 at 00:16)</a>:</h4>
<p>Usually surreal numbers require a much higher order induction than <code>nat</code> though</p>



<a name="239345625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345625">(May 19 2021 at 00:16)</a>:</h4>
<p>From the looks of the terms you mention, no lexicographic ordering on the arguments is going to help you, so you're certainly going to have to introduce by hand a different complexity measure, whether you do it with <code>using_well_founded</code>, or by induction on nat</p>



<a name="239345634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345634">(May 19 2021 at 00:16)</a>:</h4>
<p>Ah, good point.</p>



<a name="239345646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345646">(May 19 2021 at 00:17)</a>:</h4>
<p>probably you can do it using a surreal number or ordinal as the measure though</p>



<a name="239345737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239345737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239345737">(May 19 2021 at 00:18)</a>:</h4>
<p>I suspect though <span class="user-mention" data-user-id="245078">@Apurva Nakade</span> might be talking about Theorem 3.8 of <a href="http://www.cs.cmu.edu/afs/cs/academic/class/15859-s05/www/lecture-notes/comb-games-notes.pdf">http://www.cs.cmu.edu/afs/cs/academic/class/15859-s05/www/lecture-notes/comb-games-notes.pdf</a>, which claims to work by induction on a tuple of natural numbers.</p>



<a name="239347534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239347534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239347534">(May 19 2021 at 00:42)</a>:</h4>
<p>I'll clean up the code a bit and post it soon.</p>
<p>Yes, I'm trying to prove a weaker version of Theorem 3.8 from those notes. The theorem as it is in the notes is too hard to code. They prove inequalities involving sums of products, which is insane!</p>
<p>In those notes they define a "depth" which I think in Conway's terms might be "day" on which the numbers are born. I think I might need to prove some well_foundedness in terms of "depth". Tbh I've been using the tactic blindly and don't understand well_foundedness much. Is there any reference for this? Or some existing theorems about well_foundedness in mathlib?</p>



<a name="239348090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239348090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239348090">(May 19 2021 at 00:50)</a>:</h4>
<p>Here's the code</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.surreal</span>

<span class="kn">namespace</span> <span class="n">pgame</span>
<span class="kn">open</span> <span class="n">pgame</span>

<span class="c1">-- some lemmas first</span>
<span class="kd">theorem</span> <span class="n">numeric_sub</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">(</span><span class="n">ox</span> <span class="o">:</span> <span class="n">numeric</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">oy</span> <span class="o">:</span> <span class="n">numeric</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">numeric</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">numeric_add</span> <span class="n">ox</span> <span class="o">(</span><span class="n">numeric_neg</span> <span class="n">oy</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">zero_le₁</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span> <span class="o">:</span> <span class="n">x.right_moves</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x.move_right</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">le_def_lt</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">hl</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩</span> <span class="n">j</span><span class="o">,</span> <span class="n">hr</span> <span class="n">j</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">hr</span><span class="o">,</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨</span> <span class="o">⟩,</span> <span class="n">hr</span><span class="o">⟩⟩</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">le_zero₁</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">x.left_moves</span><span class="o">,</span> <span class="n">x.move_left</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">le_def_lt</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">hl</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩</span> <span class="n">i</span><span class="o">,</span> <span class="n">hl</span> <span class="n">i</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">hl</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hl</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨</span> <span class="o">⟩⟩⟩</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">zero_lt₁</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">x.left_moves</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x.move_left</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">lt_def_le</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="n">forall_pempty</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">lt_zero₁</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">j</span> <span class="o">:</span> <span class="n">x.right_moves</span><span class="o">,</span> <span class="n">x.move_right</span> <span class="n">j</span> <span class="bp">≤</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">lt_def_le</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="n">forall_pempty</span><span class="o">]</span> <span class="o">}</span>

<span class="c1">-- missing trans rules for pgames</span>
<span class="kd">@[trans]</span> <span class="kd">theorem</span> <span class="n">lt_of_lt_of_equiv'</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≈</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">lt_of_lt_of_le</span> <span class="n">h₁</span> <span class="n">h₂.1</span>
<span class="kd">@[trans]</span> <span class="kd">theorem</span> <span class="n">le_of_le_of_equiv'</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≈</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="n">h₁</span> <span class="n">h₂.1</span>
<span class="kd">@[trans]</span> <span class="kd">theorem</span> <span class="n">lt_of_equiv_of_lt'</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≈</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">lt_of_le_of_lt</span> <span class="n">h₁.1</span> <span class="n">h₂</span>
<span class="kd">@[trans]</span> <span class="kd">theorem</span> <span class="n">le_of_equiv_of_le'</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≈</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="n">h₁.1</span> <span class="n">h₂</span>

<span class="c1">--problem will well-founded recursion :(</span>

<span class="kd">set_option</span> <span class="n">trace.solve_by_elim</span> <span class="n">true</span>

<span class="kd">theorem</span> <span class="n">foobar</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">},</span>
<span class="o">(</span><span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∧</span>
<span class="o">(</span><span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span> <span class="o">(</span><span class="n">mk</span> <span class="n">yl</span> <span class="n">yr</span> <span class="n">yL</span> <span class="n">yR</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">yl</span> <span class="n">yr</span> <span class="n">yL</span> <span class="n">yR</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">ox</span> <span class="n">oy</span> <span class="n">pos_x</span> <span class="n">pos_y</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">nonneg_x</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_of_lt</span> <span class="n">numeric_zero</span> <span class="n">ox</span> <span class="n">pos_x</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">nonneg_y</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_of_lt</span> <span class="n">numeric_zero</span> <span class="n">oy</span> <span class="n">pos_y</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">zero_lt₁.1</span> <span class="n">pos_x</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">zero_lt₁.1</span> <span class="n">pos_y</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">zero_lt₁</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">sum.inl</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
    <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">yL</span> <span class="n">j</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span><span class="o">)</span>
           <span class="o">:</span> <span class="n">foobar.2</span> <span class="o">(</span><span class="n">oy.2.1</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">numeric_sub</span> <span class="n">ox</span> <span class="o">(</span><span class="n">ox.2.1</span> <span class="n">i</span><span class="o">))</span>
            <span class="n">hj</span> <span class="o">((</span><span class="bp">@</span><span class="n">le_iff_sub_nonneg</span> <span class="o">(</span><span class="n">xL</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="o">(</span><span class="n">ox.2.1</span> <span class="n">i</span><span class="o">)</span> <span class="n">ox</span> <span class="o">(</span><span class="n">ox.move_left_lt</span> <span class="n">i</span><span class="o">)))</span>
       <span class="bp">...</span> <span class="bp">≈</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span>
           <span class="o">:</span> <span class="n">mul_comm_equiv</span> <span class="n">_</span> <span class="n">_</span>
       <span class="bp">...</span> <span class="bp">≈</span> <span class="mi">0</span> <span class="bp">+</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span>
           <span class="o">:</span> <span class="o">(</span><span class="n">zero_add_equiv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
       <span class="bp">...</span> <span class="bp">≤</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span>
           <span class="o">:</span> <span class="n">add_le_add_right</span> <span class="bp">$</span> <span class="n">foobar.2</span> <span class="o">(</span><span class="n">ox.2.1</span> <span class="n">i</span><span class="o">)</span> <span class="n">oy</span> <span class="n">hi</span> <span class="n">nonneg_y</span>
       <span class="bp">...</span> <span class="bp">≈</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span>
           <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">quotient.exact</span> <span class="n">pgame</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">ox</span> <span class="n">oy</span> <span class="n">nonneg_x</span> <span class="n">nonneg_y</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hx'</span> <span class="o">:=</span> <span class="n">zero_le₁.1</span> <span class="n">nonneg_x</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="n">hx'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hy'</span> <span class="o">:=</span> <span class="n">zero_le₁.1</span> <span class="n">nonneg_y</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="n">hy'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">zero_le₁</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="o">(⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">⟩</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">⟩),</span>
    <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">xL</span> <span class="n">i</span><span class="o">,</span>
      <span class="o">{</span> <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="n">foobar.2</span> <span class="o">(</span><span class="n">ox.2.1</span> <span class="n">i</span><span class="o">)</span> <span class="n">oy</span> <span class="n">h</span> <span class="n">nonneg_y</span>
      <span class="bp">...</span> <span class="bp">≈</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">add_zero_equiv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
      <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span>
          <span class="o">:</span> <span class="n">add_lt_add_left</span> <span class="bp">$</span> <span class="n">foobar.1</span> <span class="o">(</span><span class="n">numeric_sub</span> <span class="n">ox</span> <span class="o">(</span><span class="n">ox.2.1</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">oy.2.2</span> <span class="n">j</span><span class="o">)</span>
                                <span class="o">(</span><span class="n">lt_iff_sub_pos.1</span> <span class="o">(</span><span class="n">ox.move_left_lt</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">hy'</span> <span class="n">j</span><span class="o">)</span>
      <span class="bp">...</span> <span class="bp">≈</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span>
          <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">quotient.exact</span> <span class="n">pgame</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">not_le</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">calc</span> <span class="mi">0</span>  <span class="bp">≤</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span>
                <span class="o">:</span> <span class="n">foobar.2</span> <span class="n">ox</span> <span class="o">(</span><span class="n">oy.2.2</span> <span class="n">j</span><span class="o">)</span> <span class="n">nonneg_x</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">numeric_zero</span> <span class="o">(</span><span class="n">oy.2.2</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">hy'</span> <span class="n">j</span><span class="o">))</span>
          <span class="bp">...</span> <span class="bp">≈</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span> <span class="bp">+</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">add_zero_equiv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
          <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">yR</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">y</span><span class="o">)</span>
                <span class="o">:</span> <span class="n">add_lt_add_left</span> <span class="bp">$</span> <span class="n">foobar.1</span> <span class="o">(</span><span class="n">numeric_sub</span> <span class="n">numeric_zero</span> <span class="o">(</span><span class="n">ox.2.1</span> <span class="n">i</span><span class="o">))</span>
                                       <span class="o">(</span><span class="n">numeric_sub</span> <span class="o">(</span><span class="n">oy.2.2</span> <span class="n">j</span><span class="o">)</span> <span class="n">oy</span><span class="o">)</span>
                                       <span class="o">(</span><span class="n">lt_iff_sub_pos.1</span> <span class="n">h</span><span class="o">)</span>
                                       <span class="o">(</span><span class="n">lt_iff_sub_pos.1</span> <span class="o">(</span><span class="n">oy.lt_move_right</span> <span class="n">j</span><span class="o">))</span>
          <span class="bp">...</span> <span class="bp">≈</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">xL</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">yR</span> <span class="n">j</span>
              <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">quotient.exact</span> <span class="n">pgame</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">yL</span> <span class="n">j</span><span class="o">,</span>
    <span class="o">{</span><span class="k">calc</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">yL</span> <span class="n">j</span><span class="o">)</span>
            <span class="o">:</span> <span class="n">foobar.1</span> <span class="o">(</span><span class="n">ox.2.2</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">numeric_sub</span> <span class="n">oy</span> <span class="o">(</span><span class="n">oy.2.1</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">hx'</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">lt_iff_sub_pos.1</span> <span class="o">(</span><span class="n">oy.move_left_lt</span> <span class="n">j</span><span class="o">))</span>
     <span class="bp">...</span> <span class="bp">≈</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">yL</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">zero_add_equiv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
     <span class="bp">...</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">yL</span> <span class="n">j</span><span class="o">)</span>
         <span class="o">:</span> <span class="n">add_le_add_right</span> <span class="bp">$</span> <span class="n">foobar.2</span> <span class="n">ox</span> <span class="o">(</span><span class="n">oy.2.1</span> <span class="n">j</span><span class="o">)</span> <span class="n">nonneg_x</span> <span class="n">h</span>
     <span class="bp">...</span> <span class="bp">≈</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">quotient.exact</span> <span class="n">pgame</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span><span class="n">rw</span> <span class="n">not_le</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">calc</span> <span class="mi">0</span>
         <span class="bp">&lt;</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">-</span> <span class="n">yL</span> <span class="n">j</span><span class="o">)</span>
         <span class="o">:</span> <span class="n">foobar.1</span> <span class="o">(</span><span class="n">numeric_sub</span> <span class="o">(</span><span class="n">ox.2.2</span> <span class="n">i</span><span class="o">)</span> <span class="n">ox</span><span class="o">)</span> <span class="o">(</span><span class="n">numeric_sub</span> <span class="n">numeric_zero</span> <span class="o">(</span><span class="n">oy.2.1</span> <span class="n">j</span><span class="o">))</span>
           <span class="o">(</span><span class="n">lt_iff_sub_pos.1</span> <span class="o">(</span><span class="n">ox.lt_move_right</span> <span class="n">i</span><span class="o">))</span>
           <span class="o">(</span><span class="n">lt_iff_sub_pos.1</span> <span class="n">h</span><span class="o">)</span>
      <span class="bp">...</span> <span class="bp">≈</span> <span class="mi">0</span> <span class="bp">+</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">-</span> <span class="n">yL</span> <span class="n">j</span><span class="o">)</span>
          <span class="o">:</span> <span class="o">(</span><span class="n">zero_add_equiv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
      <span class="bp">...</span> <span class="bp">≤</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">-</span> <span class="n">yL</span> <span class="n">j</span><span class="o">)</span>
          <span class="o">:</span> <span class="n">add_le_add_right</span> <span class="bp">$</span> <span class="n">foobar.2</span> <span class="o">(</span><span class="n">ox.2.2</span> <span class="n">i</span><span class="o">)</span> <span class="n">oy</span>
                                  <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">numeric_zero</span> <span class="o">(</span><span class="n">ox.2.2</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hx'</span> <span class="n">i</span><span class="o">))</span> <span class="n">nonneg_y</span>
      <span class="bp">...</span> <span class="bp">≈</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span> <span class="bp">-</span> <span class="n">xR</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">yL</span> <span class="n">j</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">quotient.exact</span> <span class="n">pgame</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">dec_tac</span> <span class="o">:=</span> <span class="n">pgame_wf_tac</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">pgame</span>
</code></pre></div>



<a name="239348521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239348521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239348521">(May 19 2021 at 00:58)</a>:</h4>
<p>The notes prove the following instead by expanding everything out</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="n">w.numeric</span> <span class="bp">→</span> <span class="n">z.numeric</span> <span class="bp">→</span>
<span class="o">(</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="n">w</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span>
<span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">w</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">w</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>but we can transfer all the variables to one side and reduce the theorem to <code>mul_pos</code>. Because <code>le</code> and <code>lt</code> are defined in terms of each other, we end up having to prove the two theorems simultaneously.</p>



<a name="239348647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239348647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239348647">(May 19 2021 at 00:59)</a>:</h4>
<p>(deleted)</p>



<a name="239350666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239350666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239350666">(May 19 2021 at 01:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/239345646">said</a>:</p>
<blockquote>
<p>probably you can do it using a surreal number or ordinal as the measure though</p>
</blockquote>
<p>How would one go about doing this? I think any connection between <code>pgame</code> and <code>ordinal</code> would be great. Does there exist a map <code>pgame \to ordinals</code>?</p>



<a name="239350987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239350987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239350987">(May 19 2021 at 01:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.game</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal_arithmetic</span>

<span class="kn">namespace</span> <span class="n">pgame</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">bday</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ordinal.sup.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="bp">$</span>
  <span class="n">sum.elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">xL</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">bday.succ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">bday.succ</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">pgame</span>
</code></pre></div>



<a name="239351792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239351792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239351792">(May 19 2021 at 01:42)</a>:</h4>
<p>Great, thanks! I should be able to prove that <code>bday</code> behaves well under arithmetic operations of <code>pgame</code>s.</p>
<p>Given such a functor, how does one prove something is <code>well_founded</code>? Mathematically, I want to say that any descending chain of ordinals is finite but I dunno how this is encoded into <code>well_founded</code> in lean.</p>



<a name="239352266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239352266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239352266">(May 19 2021 at 01:50)</a>:</h4>
<p>(deleted)</p>



<a name="239352980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239352980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239352980">(May 19 2021 at 01:59)</a>:</h4>
<p>there is an instance already saying that ordinals are well ordered by <code>&lt;</code></p>



<a name="239353151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239353151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239353151">(May 19 2021 at 02:00)</a>:</h4>
<p>So you would use something like <code>inv_image (&lt;) bday</code> and typeclass inference knows that this relation has a well founded instance</p>



<a name="239353998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239353998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239353998">(May 19 2021 at 02:08)</a>:</h4>
<p>Awesome, thanks again! I'll try this out.</p>



<a name="239373759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239373759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239373759">(May 19 2021 at 06:38)</a>:</h4>
<p>Re <code>foo</code> -- can you deduce it from (z-y)*(w-x)&gt;0? I have this vague memory that there are problems with distributivity though...</p>



<a name="239415327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239415327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239415327">(May 19 2021 at 12:36)</a>:</h4>
<p>Yeah, this is exactly what i'm trying to prove. Distributivity is fine as we've already shown all the ring properties for pgames up to equivalence.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mul_pos</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="n">w.numeric</span> <span class="bp">→</span> <span class="n">z.numeric</span> <span class="bp">→</span>
<span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">w</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="bp">-</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span>
<span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">w</span>  <span class="bp">-</span> <span class="n">x</span><span class="o">)(</span><span class="n">z</span>  <span class="bp">-</span>  <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>You can't prove the above theorem by itself as <code>&lt;</code> is defined in terms of <code>\le</code> so you end up having to prove both simultaneously.</p>



<a name="239415580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239415580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239415580">(May 19 2021 at 12:38)</a>:</h4>
<p>I am asking whether it's easier to prove a&gt;0 and b&gt;0 and a,b numeric implies ab&gt;0 (two variables not four), but I don't know anything about this stuff.</p>



<a name="239415717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239415717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239415717">(May 19 2021 at 12:39)</a>:</h4>
<p>Yups, this is the theorem I'm currently trying:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foobar</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">},</span>
<span class="o">(</span><span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∧</span>
<span class="o">(</span><span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="239415935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239415935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239415935">(May 19 2021 at 12:40)</a>:</h4>
<p>Really hoping to make the well-founded recursion problem go away for this.</p>



<a name="239416013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239416013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239416013">(May 19 2021 at 12:41)</a>:</h4>
<p>so what happens when you just try doing this by induction on birthday?</p>



<a name="239416041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239416041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239416041">(May 19 2021 at 12:41)</a>:</h4>
<p>That's how Conway would do it, right?</p>



<a name="239416439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239416439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239416439">(May 19 2021 at 12:44)</a>:</h4>
<p>I haven't tried it yet. But hopefully it works after that.</p>
<p>Yes! That's my thought too, just need to set it up.  <br>
Need to prove a few lemmas about birthday first. I think this might take some time...</p>



<a name="239416952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239416952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239416952">(May 19 2021 at 12:47)</a>:</h4>
<p>Conway seems to give an argument in his proof of Theorem 8(iii) on p19 of ONAG</p>



<a name="239417150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239417150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239417150">(May 19 2021 at 12:49)</a>:</h4>
<p>and, as you originally suggested, he proved x&gt;0 and y&gt;0 implies xy&gt;0 from this more general statement you were originally considering.</p>



<a name="239417973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239417973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239417973">(May 19 2021 at 12:54)</a>:</h4>
<p>I looking at his proofs, he is proving the theorem with 4 variables directly <span aria-label="scared" class="emoji emoji-1f628" role="img" title="scared">:scared:</span> <br>
There are lots of WALOGs and "... can be deduced from ..." in there.</p>



<a name="239758252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239758252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239758252">(May 21 2021 at 14:20)</a>:</h4>
<p>One very basic question: <code>ordinal</code> has a <code>preorder</code> instance. From this, how do I extract <code>ordinal.le_trans</code>? I tried the following but it did not quite work</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.game</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal_arithmetic</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">temp</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">ordinal</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="k">#check</span> <span class="n">temp.le_trans</span>           <span class="c1">-- unknown identifier</span>
<span class="k">#check</span> <span class="n">ordinal.le_trans</span>       <span class="c1">-- unknown identifier</span>
</code></pre></div>



<a name="239758830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239758830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239758830">(May 21 2021 at 14:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">le_trans</span> <span class="n">ordinal</span> <span class="n">_</span>  <span class="c1">-- ∀ {a b c : ordinal}, a ≤ b → b ≤ c → a ≤ c</span>
</code></pre></div>



<a name="239759313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759313">(May 21 2021 at 14:26)</a>:</h4>
<p>Although <code>#check temp.le_trans</code> works for me?</p>



<a name="239759453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759453">(May 21 2021 at 14:27)</a>:</h4>
<p>Oh, I've <code>open pgame</code> at the start, I should add that to the mwe</p>



<a name="239759619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759619">(May 21 2021 at 14:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.game</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal_arithmetic</span>

<span class="kn">open</span> <span class="n">pgame</span>
<span class="kn">namespace</span> <span class="n">pgame</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">temp</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">ordinal</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="k">#check</span> <span class="n">temp.le_trans</span>           <span class="c1">-- unknown identifier</span>
<span class="k">#check</span> <span class="n">ordinal.le_trans</span>       <span class="c1">-- unknown identifier</span>

<span class="kd">end</span> <span class="n">pgame</span>
</code></pre></div>



<a name="239759668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759668">(May 21 2021 at 14:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">pgame.temp.le_trans</span>
</code></pre></div>



<a name="239759707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759707">(May 21 2021 at 14:29)</a>:</h4>
<p>Named instances are only accessible via their fully-qualified name; <code>instance</code> is roughly short for <code>@[instance] protected def</code></p>



<a name="239759772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759772">(May 21 2021 at 14:29)</a>:</h4>
<p>Oh, wow!</p>



<a name="239759778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759778">(May 21 2021 at 14:29)</a>:</h4>
<p>Thanks, this worked!</p>



<a name="239759836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239759836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239759836">(May 21 2021 at 14:29)</a>:</h4>
<p>Ah, I see</p>



<a name="239760042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239760042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239760042">(May 21 2021 at 14:30)</a>:</h4>
<p>Although it's unlikely you actually need to specify which <code>le_trans</code> you want here anyway</p>



<a name="239760713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239760713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239760713">(May 21 2021 at 14:34)</a>:</h4>
<p>There's also the <code>le_trans</code> coming from <code>pgame</code></p>



<a name="239760749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239760749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239760749">(May 21 2021 at 14:34)</a>:</h4>
<p><code>_root_.le_trans</code> will avoid that ambiguity</p>



<a name="239761317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239761317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239761317">(May 21 2021 at 14:38)</a>:</h4>
<p>Great, this worked perfectly, thanks!</p>



<a name="239762958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239762958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239762958">(May 21 2021 at 14:49)</a>:</h4>
<p>Is there any way to use <code>_root_.le_trans</code> in <code>calc</code> mode?</p>



<a name="239763519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239763519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239763519">(May 21 2021 at 14:53)</a>:</h4>
<p><code>local attribute [-trans] pgame.le_trans</code>?</p>



<a name="239763521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239763521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239763521">(May 21 2021 at 14:53)</a>:</h4>
<p>(deleted)</p>



<a name="239763788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239763788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239763788">(May 21 2021 at 14:55)</a>:</h4>
<p>I'm getting <code>300:1: cannot remove attribute [trans]</code><br>
I tried putting it inside a <code>section</code> and <code>namespace</code> still the same error.</p>



<a name="239763813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239763813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239763813">(May 21 2021 at 14:55)</a>:</h4>
<p>Then instead, remove the <code>@[trans]</code> from pgame.le_trans and add <code>local attribute [trans] pgame.le_trans</code> only where you need it</p>



<a name="239763984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239763984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239763984">(May 21 2021 at 14:56)</a>:</h4>
<p>This will be too complicated. <code>pgame.le_trans</code> is used in almost every single proof :(</p>



<a name="239764042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239764042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239764042">(May 21 2021 at 14:57)</a>:</h4>
<p>Sure, but you can add the attribute locally at the top of the section</p>



<a name="239764198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239764198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239764198">(May 21 2021 at 14:58)</a>:</h4>
<p>Ah I see, cool, I'll try it out. Will need to shuffle the current proofs around a bit.</p>



<a name="239870930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239870930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239870930">(May 22 2021 at 12:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="245078">Apurva Nakade</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/239345240">said</a>:</p>
<blockquote>
<p>I've been stuck on a big proof for surreal numbers for quite some time now.</p>
<p>I'm trying to prove a complicated theorem <code>f(x, y)</code> for <code>{x y : pgames}</code> by recursion.<br>
I end up having to use statements like <code>f(x - xL i, yL j)</code>, <code>f(xL k, yR l - y)</code>,  etc in the proof where <code>xL _</code> are the left moves of <code>x</code> and <code>xR _</code> are the right moves of <code>x</code> and similarly for <code>y</code>.  Note that the "depth" always increases and there are no terms of the form <code>f(x - xL i, y)</code> so mathematically the recursion is fine.</p>
<p>Lean is unable to prove well-founded recursion for this.  I tried doing a trace and it seems to be that the terms of the form <code>x - xL i</code> are throwing it off.</p>
<p>I'm not sure if I can come up with a mwe for this. I can post my big messy proof here.</p>
<p>Any suggestions on how to prove that this kind of recursion is well-founded?</p>
</blockquote>
<p>I think this recursion is not well-founded. It could happen that <code>(x - xL i).bday &gt; x.bday</code> (for example, <code>x = n</code> and <code>xL i = -1</code>.</p>
<p>I dunno how to prove <code>numeric_mul</code> anymore :( <br>
The math proofs I've seen require you to prove things like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">:</span> <span class="n">x.numeric</span> <span class="bp">→</span> <span class="n">y.numeric</span> <span class="bp">→</span> <span class="n">w.numeric</span> <span class="bp">→</span> <span class="n">z.numeric</span> <span class="bp">→</span>
<span class="o">(</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="n">w</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span>
<span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">w</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">w</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>But the LHS and RHS of these inequalities will have <code>16</code> terms so we'll end up having to prove <code>32</code> inequalities!<br>
Most texts simply wave their hands and say that we'll do one case and the rest are similar, I'm not sure if this is actually true. </p>
<p>Dunno how to proceed from here.</p>



<a name="239871084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/239871084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#239871084">(May 22 2021 at 12:54)</a>:</h4>
<p>Moreover, you cannot even prove <code>(x &lt; w) → (y &lt; z) →(x * z + w * y &lt; x * y + w * z)</code> by itself. Instead you simultaneously have to <code>mul_congr</code>!</p>



<a name="280332571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280332571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280332571">(Apr 27 2022 at 10:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/239350987">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.game</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal_arithmetic</span>

<span class="kn">namespace</span> <span class="n">pgame</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">bday</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ordinal.sup.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="bp">$</span>
  <span class="n">sum.elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">xL</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">bday.succ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">bday.succ</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">pgame</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This is now in mathlib as <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.birthday">docs#pgame.birthday</a></p>



<a name="280332766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280332766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280332766">(Apr 27 2022 at 10:57)</a>:</h4>
<p>Although the definition is now instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">birthday</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">xl</span><span class="o">,</span> <span class="n">xr</span><span class="o">,</span> <span class="n">xL</span><span class="o">,</span> <span class="n">xR</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">max</span> <span class="o">(</span><span class="n">ordinal.lsub.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">birthday</span> <span class="o">(</span><span class="n">xL</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">ordinal.lsub.</span><span class="o">{</span><span class="n">u</span> <span class="n">u</span><span class="o">}</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">birthday</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>
<p>I assume the difference isn't important? Or do you think your formulation is more convenient <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  than <span class="user-mention" data-user-id="459227">@Violeta Hernández</span>'s</p>



<a name="280332927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280332927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280332927">(Apr 27 2022 at 10:58)</a>:</h4>
<p>no, I imagine that will work out basically the same</p>



<a name="280343054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280343054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280343054">(Apr 27 2022 at 12:35)</a>:</h4>
<p>The supremum of a set of successors is definitionally what <code>lsub</code> is</p>



<a name="280954400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954400">(May 03 2022 at 01:03)</a>:</h4>
<p>Oh I hadn't noticed that this thread was for the exact thing I've been struggling with for the past week</p>



<a name="280954466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954466">(May 03 2022 at 01:04)</a>:</h4>
<p>But yeah, as for the surreal multiplication proof</p>



<a name="280954475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954475">(May 03 2022 at 01:04)</a>:</h4>
<p>It can be proven by a very specific induction on birthdays</p>



<a name="280954695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954695">(May 03 2022 at 01:08)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/6d7ead9ed67cf7ce04fe63829f7388b9b521e05b/src/set_theory/surreal/basic.lean#L318">https://github.com/leanprover-community/mathlib/blob/6d7ead9ed67cf7ce04fe63829f7388b9b521e05b/src/set_theory/surreal/basic.lean#L318</a></p>



<a name="280954719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954719">(May 03 2022 at 01:09)</a>:</h4>
<p>This is <em>basically</em> the Schleicher proof, except that I figured out you could use birthdays instead of "depth", and also that P2 and P4 could be merged into a single statement</p>



<a name="280954803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954803">(May 03 2022 at 01:10)</a>:</h4>
<p>The induction, despite being quite complex, relies on a single nontrivial statement on birthdays, which is <code>birthday x &lt; birthday y → birthday (z + x) &lt; birthday (z + y)</code></p>



<a name="280954891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954891">(May 03 2022 at 01:12)</a>:</h4>
<p>This can be proven easily from <code>birthday x ≤ birthday y → birthday (z + x) ≤ birthday (z + y)</code>, which can be done by unfolding the definition of <code>birthday (x + y)</code> into the maximum of four <code>lsub</code>s and proving each less-equal by the induction hypothesis</p>



<a name="280954912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280954912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280954912">(May 03 2022 at 01:13)</a>:</h4>
<p>The only reason I haven't done this yet is that I'm waiting for <a href="https://github.com/leanprover-community/mathlib/pull/13611">#13611</a> to pass, which makes working with addition much less painful</p>



<a name="280955040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280955040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280955040">(May 03 2022 at 01:15)</a>:</h4>
<p>If anyone wants to help fill the proof up, it would be greatly appreciated</p>



<a name="280955084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280955084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280955084">(May 03 2022 at 01:16)</a>:</h4>
<p>The calculations themselves are basically the same as those in the Schleicher PDF</p>



<a name="280979405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280979405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280979405">(May 03 2022 at 08:09)</a>:</h4>
<p>Two updates!</p>



<a name="280979444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280979444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280979444">(May 03 2022 at 08:09)</a>:</h4>
<p>First, most of the proof has now been written down</p>



<a name="280979466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280979466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280979466">(May 03 2022 at 08:09)</a>:</h4>
<p>Second, I found another simplification of the argument in the PDF</p>



<a name="280979522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280979522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280979522">(May 03 2022 at 08:10)</a>:</h4>
<p>Turns out that you don't actually need P1 to conclude P4</p>



<a name="280979576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280979576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280979576">(May 03 2022 at 08:10)</a>:</h4>
<p>Schleicher invokes P1 to conclude (xy)^L &lt; xy and xy &lt; (xy)^R, but these inequalities hold for all games, not just numeric games</p>



<a name="280979590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280979590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280979590">(May 03 2022 at 08:11)</a>:</h4>
<p>What might not hold is (xy)^L &lt; (xy)^R, which fortunately isn't used</p>



<a name="280980804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280980804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280980804">(May 03 2022 at 08:24)</a>:</h4>
<p>So you can in fact prove the following statement: for any <code>x₁, x₂, y</code>, the following hold simultaneously:</p>
<ul>
<li>if <code>x₁ = x₂</code>, then <code>x₁ * y</code> is numeric.</li>
<li>If <code>x₁ ≈ x₂</code>, then <code>x₁ * y ≈ x₂ * y</code>.</li>
<li>If <code>x₁ &lt; x₂</code>, then,</li>
<li>
<ul>
<li>For any left option <code>yL</code>, <code>x₂ * yL + x₁ * y &lt; x₁ * yL + x₂ * y</code>.</li>
</ul>
</li>
<li>
<ul>
<li>For any left option <code>yR</code>, <code>x₂ * y + x₁ * yR &lt; x₁ * y + x₂ * yR</code>.</li>
</ul>
</li>
</ul>



<a name="280980821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280980821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280980821">(May 03 2022 at 08:24)</a>:</h4>
<p>And you can prove this by bare Conway induction on <code>x₁ + x₂ + y + y</code></p>



<a name="280980849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280980849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280980849">(May 03 2022 at 08:25)</a>:</h4>
<p>(this wasn't possible before due to that single application of P1)</p>



<a name="280985564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985564">(May 03 2022 at 09:13)</a>:</h4>
<p>Checking the induction hypothesis pretty much amounts to verifying a bunch of goals similar to "yL + yR + x1 + x2 is subsequent to x1 + x2 + y + y up to relabelling"</p>



<a name="280985702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985702">(May 03 2022 at 09:15)</a>:</h4>
<p>If the arguments we're in the correct order, this could be done via <code>solve_by_elim</code></p>



<a name="280985739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985739">(May 03 2022 at 09:15)</a>:</h4>
<p>And, if addition were commutative, we could use <code>abel</code> for this</p>



<a name="280985752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985752">(May 03 2022 at 09:15)</a>:</h4>
<p>Unfortunately we run into the issue of relabellings</p>



<a name="280985815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985815">(May 03 2022 at 09:16)</a>:</h4>
<p>So I'm thinking, perhaps we should have a type of pregames quotiented by relabelling?</p>



<a name="280985846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985846">(May 03 2022 at 09:16)</a>:</h4>
<p>How is that different from <code>game</code>?</p>



<a name="280985861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985861">(May 03 2022 at 09:16)</a>:</h4>
<p><code>game</code> is a much stronger quotient</p>



<a name="280985865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985865">(May 03 2022 at 09:16)</a>:</h4>
<p>It quotients by antisymmetry</p>



<a name="280985936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280985936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280985936">(May 03 2022 at 09:17)</a>:</h4>
<p>So for instance, the empty pregame { | } and the pregame { 1 | -1 } are equal as games but they're not relabellings of one another</p>



<a name="280986260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986260">(May 03 2022 at 09:21)</a>:</h4>
<p>Conversely, the empty pregame with move types <code>pempty</code> and the empty pregame with move types <code>fin 0</code> are relabellings but can't be proven equal</p>



<a name="280986303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986303">(May 03 2022 at 09:21)</a>:</h4>
<p>And as mentioned, another annoying consequence is that <code>x + y</code> is not always equal to <code>y + x</code>, even though they're relabellings</p>



<a name="280986582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986582">(May 03 2022 at 09:24)</a>:</h4>
<p>Is <code>x + 0</code> a relabelling of <code>x</code>?</p>



<a name="280986597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986597">(May 03 2022 at 09:24)</a>:</h4>
<p>Indeed</p>



<a name="280986684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986684">(May 03 2022 at 09:25)</a>:</h4>
<p>But <code>a * (b + c)</code> is not a relabelling of <code>a * b + a * c</code>?</p>



<a name="280986707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986707">(May 03 2022 at 09:25)</a>:</h4>
<p>It also is</p>



<a name="280986807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986807">(May 03 2022 at 09:26)</a>:</h4>
<p>Pre-games up to relabelling are an abelian monoid with commutative and distributive multiplication</p>



<a name="280986811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986811">(May 03 2022 at 09:26)</a>:</h4>
<p>What's the strongest you can prove about your <code>relabeled_pgame</code>s?</p>



<a name="280986833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986833">(May 03 2022 at 09:26)</a>:</h4>
<p>They don't have additive nor multiplicative inverses though</p>



<a name="280986918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280986918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280986918">(May 03 2022 at 09:27)</a>:</h4>
<p>They don't have a partial order (neither do games), but they have all covariant instances for addition (as do pre-games)</p>



<a name="280987000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987000">(May 03 2022 at 09:28)</a>:</h4>
<p>Oh and addition and multiplication are also associative</p>



<a name="280987001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987001">(May 03 2022 at 09:28)</a>:</h4>
<p>That sounds good enough to want another type.</p>



<a name="280987024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987024">(May 03 2022 at 09:28)</a>:</h4>
<p>Glad you agree</p>



<a name="280987039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987039">(May 03 2022 at 09:28)</a>:</h4>
<p>What I'm wondering is nomenclature</p>



<a name="280987068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987068">(May 03 2022 at 09:29)</a>:</h4>
<p>I would go for something short, like <code>rgame</code>.</p>



<a name="280987097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987097">(May 03 2022 at 09:29)</a>:</h4>
<p>I like that</p>



<a name="280987394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987394">(May 03 2022 at 09:33)</a>:</h4>
<p>Btw, if you're interested in another refactor, you can redefine <code>game</code> as <code>antisymmetrization (≤) pgame</code>.</p>



<a name="280987807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987807">(May 03 2022 at 09:37)</a>:</h4>
<p>That might be nice</p>



<a name="280987815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/280987815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#280987815">(May 03 2022 at 09:37)</a>:</h4>
<p>I'll look into that</p>



<a name="281072069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072069">(May 03 2022 at 20:27)</a>:</h4>
<p>Oh wait</p>



<a name="281072104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072104">(May 03 2022 at 20:27)</a>:</h4>
<p>Turns out <code>rgame</code> isn't as strong as I thought</p>



<a name="281072220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072220">(May 03 2022 at 20:28)</a>:</h4>
<p>You can define multiplication, and it satisfies <code>x * 0 = 0</code>, <code>x * 1 = 1</code>, <code>x * y = y * x</code>, and <code>(-x) * y = x * (-y) = -(x * y)</code></p>



<a name="281072264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072264">(May 03 2022 at 20:28)</a>:</h4>
<p>But unfortunately it isn't distributive nor associative</p>



<a name="281072571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072571">(May 03 2022 at 20:31)</a>:</h4>
<p>That said, these properties should still make it much easier to deal with multiplication in games</p>



<a name="281072618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072618">(May 03 2022 at 20:31)</a>:</h4>
<p>Since you can convert inequalities about <code>game</code> to inequalities about <code>rgame</code> and then use these laws via <code>rw</code></p>



<a name="281072636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072636">(May 03 2022 at 20:31)</a>:</h4>
<p>What I don't know is what structure these form</p>



<a name="281072744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281072744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281072744">(May 03 2022 at 20:32)</a>:</h4>
<p>I think it's just a unital magma? lol</p>



<a name="281073455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281073455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281073455">(May 03 2022 at 20:38)</a>:</h4>
<p><code>mul_zero_one_class</code> and <code>has_distrib_neg</code> ;b</p>



<a name="281073466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281073466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281073466">(May 03 2022 at 20:38)</a>:</h4>
<p>old-school names are for old-school people</p>



<a name="281073477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281073477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281073477">(May 03 2022 at 20:38)</a>:</h4>
<p>oh wait, is that distrib_neg? or sth else</p>



<a name="281073505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281073505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281073505">(May 03 2022 at 20:38)</a>:</h4>
<p>Oh cool</p>



<a name="281073513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281073513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281073513">(May 03 2022 at 20:38)</a>:</h4>
<p>It's good to know that there's names for these in <code>mathlib</code></p>



<a name="281079630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281079630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281079630">(May 03 2022 at 21:27)</a>:</h4>
<p>I sometimes feel like we just made them to make fun of the people who study hierarchies of algebraic structures</p>



<a name="281106984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281106984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281106984">(May 04 2022 at 03:30)</a>:</h4>
<p>I wonder if people have thought about defining <code>pgame</code> as the type of types (of positions) equipped with two relations L and R (moves) such that the union of both relations is well-founded, together with the starting position. Seems closer to the definition in <em>ONAG</em> than the current inductive type definition, and would be easier to extend to <a href="https://people.math.carleton.ca/~svenjahuntemann/CapitalGames/SlidesSeminar20200730.pdf">loopy games</a> by dropping the well-founded condition. <del>Moreover, you should be able to get rid of all the <code>relabelling</code> stuff.</del>(maybe not)<br>
<a href="/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png" title="image.png"><img src="/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png"></a></div>



<a name="281141568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281141568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281141568">(May 04 2022 at 11:29)</a>:</h4>
<p>I tried something like this (it was my first attempt to work in Lean, so don't be too critical...).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">games</span>

<span class="c1">-- We really would like to do the following:</span>

<span class="c1">-- inductive Game : Type</span>
<span class="c1">-- | make : set Game → set Game → Game</span>

<span class="c1">-- but Lean complains of missing "positivity"...</span>

<span class="c1">-- so we have to do it in a more pedestrian way.</span>

<span class="c1">-- Define the type of (Conway) games.</span>
<span class="kd">constant</span> <span class="n">Game</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="c1">-- Each game has a set of left and a set of right options,</span>
<span class="c1">-- which are themselves games.</span>
<span class="kd">constants</span> <span class="n">L_opts</span> <span class="n">R_opts</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">Game</span>

<span class="c1">-- We can construct a game from its left and right options.</span>
<span class="kd">noncomputable</span> <span class="kd">constant</span> <span class="n">make</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Game</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">Game</span> <span class="bp">→</span> <span class="n">Game</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="n">G1</span> <span class="bp">`|`</span> <span class="n">G2</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">make</span> <span class="n">G1</span> <span class="n">G2</span>

<span class="c1">-- The following state that these two operations are inverses.</span>
<span class="kd">@[simp]</span> <span class="kd">axiom</span> <span class="n">make_LR</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">make</span> <span class="o">(</span><span class="n">L_opts</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">R_opts</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span>
<span class="kd">@[simp]</span> <span class="kd">axiom</span> <span class="n">make_L</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">L_opts</span> <span class="o">(</span><span class="n">make</span> <span class="n">GL</span> <span class="n">GR</span><span class="o">)</span> <span class="bp">=</span> <span class="n">GL</span>
<span class="kd">@[simp]</span> <span class="kd">axiom</span> <span class="n">make_R</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">R_opts</span> <span class="o">(</span><span class="n">make</span> <span class="n">GL</span> <span class="n">GR</span><span class="o">)</span> <span class="bp">=</span> <span class="n">GR</span>

<span class="c1">-- A simple consequence is that it suffices to check equality</span>
<span class="c1">-- of the left and right options to conclude that two games are the same.</span>
<span class="kd">theorem</span> <span class="n">eq_LR</span> <span class="o">(</span><span class="n">G1</span> <span class="n">G2</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">G2</span> <span class="bp">↔</span> <span class="n">L_opts</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">L_opts</span> <span class="n">G2</span> <span class="bp">∧</span> <span class="n">R_opts</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">R_opts</span> <span class="n">G2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
    <span class="n">tauto</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">make_LR</span> <span class="n">G1</span><span class="o">,</span> <span class="bp">←</span> <span class="n">make_LR</span> <span class="n">G2</span><span class="o">],</span> <span class="n">cases</span> <span class="n">hyp</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">],</span>
<span class="kd">end</span>

<span class="c1">-- For applications in proofs, this implication is useful.</span>
<span class="kd">theorem</span> <span class="n">eq_of_eq_LR</span> <span class="o">(</span><span class="n">G1</span> <span class="n">G2</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">L_opts</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">L_opts</span> <span class="n">G2</span> <span class="bp">∧</span> <span class="n">R_opts</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">R_opts</span> <span class="n">G2</span> <span class="bp">→</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">G2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">eq_LR</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- We define the notion of "option" of a game.</span>
<span class="kd">def</span> <span class="n">is_option</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">G'</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">G</span> <span class="bp">∨</span> <span class="n">G'</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">G</span>

<span class="c1">-- We note that the elements of `L_opts G` and of `R_opts G` are options of `G`.</span>
<span class="kd">lemma</span> <span class="n">L_is_option</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">is_option</span> <span class="n">GL</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_option</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">R_is_option</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">is_option</span> <span class="n">GR</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">is_option</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">--------------------------------------------------------------------</span>
<span class="c1">-- The induction principle</span>
<span class="c1">--------------------------------------------------------------------</span>

<span class="c1">-- This is the "descending game condition":</span>
<span class="c1">-- the relation "is option of" is well-founded.</span>
<span class="kd">axiom</span> <span class="n">DGC</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">is_option</span>

<span class="c1">-- This gives us Conway induction for statements involving a single game.</span>
<span class="kd">theorem</span> <span class="n">Conway_ind_opt</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">G'</span><span class="o">,</span> <span class="n">is_option</span> <span class="n">G'</span> <span class="n">G</span> <span class="bp">→</span>  <span class="n">P</span> <span class="n">G'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">,</span> <span class="n">P</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">DGC.fix</span> <span class="n">hyp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- A variant that inducts explicitly on the left and right options.</span>
<span class="kd">theorem</span> <span class="n">Conway_ind_LR</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">,</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">G</span><span class="o">,</span> <span class="n">P</span> <span class="n">GL</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">G</span><span class="o">,</span> <span class="n">P</span> <span class="n">GR</span><span class="o">))</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">,</span> <span class="n">P</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">Conway_ind_opt</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">G</span> <span class="n">hyp1</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hyp</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">GL</span> <span class="n">GLG</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hyp1</span> <span class="n">GL</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">is_option</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">GR</span> <span class="n">GRG</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hyp1</span> <span class="n">GR</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_option</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>


<span class="c1">-- Now repeat for pairs of games, when we replace one or both of them by an option.</span>
<span class="kd">def</span> <span class="n">is_option_2</span> <span class="o">(</span><span class="n">GG1</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">GG1.fst</span> <span class="bp">=</span> <span class="n">GG.fst</span> <span class="bp">∧</span> <span class="n">is_option</span> <span class="n">GG1.snd</span> <span class="n">GG.snd</span><span class="o">)</span>
   <span class="bp">∨</span> <span class="o">(</span><span class="n">is_option</span> <span class="n">GG1.fst</span> <span class="n">GG.fst</span> <span class="bp">∧</span> <span class="n">GG1.snd</span> <span class="bp">=</span> <span class="n">GG.snd</span><span class="o">)</span>
   <span class="bp">∨</span> <span class="o">(</span><span class="n">is_option</span> <span class="n">GG1.fst</span> <span class="n">GG.fst</span> <span class="bp">∧</span> <span class="n">is_option</span> <span class="n">GG1.snd</span> <span class="n">GG.snd</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">L_opts1_is_option_2</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">GG.fst</span> <span class="bp">→</span> <span class="n">is_option_2</span> <span class="o">(</span><span class="n">GL</span><span class="o">,</span> <span class="n">GG.snd</span><span class="o">)</span> <span class="n">GG</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">is_option_2</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">L_is_option</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">R_opts1_is_option_2</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">GG.fst</span> <span class="bp">→</span> <span class="n">is_option_2</span> <span class="o">(</span><span class="n">GR</span><span class="o">,</span> <span class="n">GG.snd</span><span class="o">)</span> <span class="n">GG</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">is_option_2</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">R_is_option</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">L_opts2_is_option_2</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">GG.snd</span> <span class="bp">→</span> <span class="n">is_option_2</span> <span class="o">(</span><span class="n">GG.fst</span><span class="o">,</span> <span class="n">GL</span><span class="o">)</span> <span class="n">GG</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">is_option_2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">L_is_option</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">R_opts2_is_option_2</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">GG.snd</span> <span class="bp">→</span> <span class="n">is_option_2</span> <span class="o">(</span><span class="n">GG.fst</span><span class="o">,</span> <span class="n">GR</span><span class="o">)</span> <span class="n">GG</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">is_option_2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">R_is_option</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Note that this is a subrelation of the lexicographic product.</span>
<span class="kd">lemma</span> <span class="n">is_option_2_sub_lex</span> <span class="o">:</span> <span class="n">subrelation</span> <span class="n">is_option_2</span> <span class="o">(</span><span class="n">prod.lex</span> <span class="n">is_option</span> <span class="n">is_option</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">subrelation</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">GG1</span> <span class="n">GG2</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">refine</span> <span class="o">(</span><span class="n">prod.lex_def</span> <span class="n">is_option</span> <span class="n">is_option</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">is_option_2</span> <span class="n">at</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Then we can use existing machinery to deduce that this is well-founded.</span>
<span class="kd">lemma</span> <span class="n">DGC_2</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">is_option_2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">subrelation.wf</span> <span class="n">is_option_2_sub_lex</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">prod.lex_wf</span> <span class="n">DGC</span> <span class="n">DGC</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- ... and derive the induction principle.</span>
<span class="kd">theorem</span> <span class="n">Conway_ind_opt_2</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">GG</span><span class="o">,</span> <span class="n">is_option_2</span> <span class="n">GG</span> <span class="n">G</span> <span class="bp">→</span>  <span class="n">P</span> <span class="n">GG</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">,</span> <span class="n">P</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">DGC_2.fix</span> <span class="n">hyp</span><span class="o">,</span>
<span class="kd">end</span>

 <span class="o">(</span><span class="n">etc.</span><span class="o">)</span>
</code></pre></div>
<p>It was not clear to me, however, how to show in Lean that a structure exists that satisfies the axioms.</p>



<a name="281148141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281148141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281148141">(May 04 2022 at 12:36)</a>:</h4>
<p>I'll take a closer look at your code when I have more time. Here's an attempt I started last night, where I constructed a game from the smaller games after left/right moves, but am yet to prove well-foundedness.  Negation of a game is obtained by switching L and R, and sum of two games have <code>pos</code> defined to be the product of the two <code>pos</code>; I've yet to think about multiplication (of surreals). (corrected to add the starting position in <code>structure pgame</code>.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">pgame</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">L</span> <span class="n">R</span> <span class="o">:</span> <span class="n">pos</span> <span class="bp">→</span> <span class="n">pos</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">wf</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">L</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">start</span> <span class="o">:</span> <span class="n">pos</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">pgame</span>
<span class="kn">open</span> <span class="n">sum</span>

<span class="c">/-</span><span class="cm"> special case of sigma.lex -/</span>
<span class="kd">inductive</span> <span class="n">sigma_disjoint</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">T</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">a</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sigma_disjoint</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">x</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">y</span><span class="o">⟩</span>

<span class="sd">/-- construct a game from left/right options -/</span>
<span class="kd">def</span> <span class="n">of_L_R</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pos</span> <span class="o">:=</span> <span class="o">((</span><span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span><span class="o">)</span> <span class="bp">⊕</span> <span class="bp">Σ</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">pos</span><span class="o">)</span> <span class="bp">⊕</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">start</span> <span class="o">:=</span> <span class="n">inr</span> <span class="o">(),</span>
  <span class="n">L</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">match</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inl</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">⟩),</span> <span class="n">inr</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">start</span>
    <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inl</span> <span class="n">p₁</span><span class="o">),</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inl</span> <span class="n">p₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sigma_disjoint</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">L</span><span class="o">)</span> <span class="n">p₁</span> <span class="n">p₂</span>
    <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inr</span> <span class="n">p₁</span><span class="o">),</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inr</span> <span class="n">p₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sigma_disjoint</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">L</span><span class="o">)</span> <span class="n">p₁</span> <span class="n">p₂</span>
    <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">false</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="n">R</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">match</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inr</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">p</span><span class="o">⟩),</span> <span class="n">inr</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">start</span>
    <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inl</span> <span class="n">p₁</span><span class="o">),</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inl</span> <span class="n">p₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sigma_disjoint</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">R</span><span class="o">)</span> <span class="n">p₁</span> <span class="n">p₂</span>
    <span class="bp">|</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inr</span> <span class="n">p₁</span><span class="o">),</span> <span class="n">inl</span> <span class="o">(</span><span class="n">inr</span> <span class="n">p₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sigma_disjoint</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">R</span><span class="o">)</span> <span class="n">p₁</span> <span class="n">p₂</span>
    <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">false</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="n">wf</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">⟩}</span>

<span class="kd">def</span> <span class="n">neg</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">g.pos</span><span class="o">,</span>
  <span class="n">L</span> <span class="o">:=</span> <span class="n">g.R</span><span class="o">,</span>
  <span class="n">R</span> <span class="o">:=</span> <span class="n">g.L</span><span class="o">,</span>
  <span class="n">wf</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">g.wf</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">or.comm</span> <span class="o">},</span>
  <span class="n">start</span> <span class="o">:=</span> <span class="n">g.start</span> <span class="o">}</span>

<span class="kd">inductive</span> <span class="n">game_sum_rel</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">r₁</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">r₂</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">fst</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">a'</span> <span class="n">b</span><span class="o">,</span> <span class="n">r₁</span> <span class="n">a</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">game_sum_rel</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">a'</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">snd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b'</span><span class="o">,</span> <span class="n">r₂</span> <span class="n">b</span> <span class="n">b'</span> <span class="bp">→</span> <span class="n">game_sum_rel</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b'</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">g₁</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">g₂</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">g₁.pos</span> <span class="bp">×</span> <span class="n">g₂.pos</span><span class="o">,</span>
  <span class="n">L</span> <span class="o">:=</span> <span class="n">game_sum_rel</span> <span class="n">g₁.L</span> <span class="n">g₂.L</span><span class="o">,</span>
  <span class="n">R</span> <span class="o">:=</span> <span class="n">game_sum_rel</span> <span class="n">g₁.R</span> <span class="n">g₂.R</span><span class="o">,</span>
  <span class="n">wf</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">start</span> <span class="o">:=</span> <span class="o">(</span><span class="n">g₁.start</span><span class="o">,</span> <span class="n">g₂.start</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">pgame</span>
</code></pre></div>



<a name="281169003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281169003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281169003">(May 04 2022 at 15:05)</a>:</h4>
<p>Here is another snippet from my attempt:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Define the four simplest games.</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">G0</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">{}</span> <span class="bp">|</span> <span class="o">{}</span> <span class="o">]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">G1</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">{</span><span class="n">G0</span><span class="o">}</span> <span class="bp">|</span> <span class="o">{}</span> <span class="o">]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Gn1</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">{}</span> <span class="bp">|</span> <span class="o">{</span><span class="n">G0</span><span class="o">}</span> <span class="o">]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">Gstar</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">{</span><span class="n">G0</span><span class="o">}</span> <span class="bp">|</span> <span class="o">{</span><span class="n">G0</span><span class="o">}</span> <span class="o">]</span>

<span class="c1">-- Note that `Game` is inhabited.</span>
<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">Game_inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">Game</span> <span class="o">:=</span> <span class="o">⟨</span> <span class="n">G0</span> <span class="o">⟩</span>

<span class="c1">-- Define negation of games.</span>
<span class="c1">-- We use well-founded recursion for that.</span>
<span class="c1">-- Ideally, we want to have</span>
<span class="c1">--   `make {f GR (R_is_option G GR h) GR | h : GR ∈ R_opts G} {f GL ... | GL ∈ L_opts G}` ,</span>
<span class="c1">-- but `{f x | x ...}` is not legal set syntax.</span>

<span class="c1">-- This describes the recursive construction:</span>
<span class="c1">-- we assume that `f G'` gives `-G'` for the options `G'` of `G` and construct `-G` out of these values.</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">neg_help</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">G1</span><span class="o">,</span> <span class="n">is_option</span> <span class="n">G1</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span>
  <span class="n">make</span> <span class="o">{</span><span class="n">GNL</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">G</span><span class="o">),</span> <span class="n">GNL</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">GR</span> <span class="o">(</span><span class="n">R_is_option</span> <span class="n">G</span> <span class="n">GR</span> <span class="n">h</span><span class="o">)}</span>
            <span class="o">{</span><span class="n">GNR</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">G</span><span class="o">),</span> <span class="n">GNR</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">GL</span> <span class="o">(</span><span class="n">L_is_option</span> <span class="n">G</span> <span class="n">GL</span> <span class="n">h</span><span class="o">)}</span>
<span class="c1">-- Now apply the fixed point operator for the recursion.</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">neg</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span><span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span>
  <span class="n">DGC.fix</span> <span class="n">neg_help</span> <span class="n">G</span>

<span class="c1">--noncomputable instance Game_has_neg : has_neg Game := ⟨ neg ⟩</span>

<span class="kd">notation</span> <span class="bp">`-`</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">neg</span> <span class="n">G</span>

<span class="c1">-- The following basically establish rewrite rules.</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">L_opts_of_neg</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">L_opts</span> <span class="o">(</span><span class="bp">-</span><span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">GRN</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">R_opts</span> <span class="n">G</span><span class="o">),</span> <span class="n">GRN</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">GR</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rw</span> <span class="n">DGC.fix_eq</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">neg_help</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">R_opts_of_neg</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">R_opts</span> <span class="o">(</span><span class="bp">-</span><span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">GLN</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">L_opts</span> <span class="n">G</span><span class="o">),</span> <span class="n">GLN</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">GL</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rw</span> <span class="n">DGC.fix_eq</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">neg_help</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Show that `-(-G) = G`.</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">neg_neg</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">G</span><span class="o">,</span>
  <span class="c1">-- We use Conway induction for this.</span>
  <span class="k">have</span> <span class="n">ind</span> <span class="o">:=</span> <span class="n">Conway_ind_opt</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span><span class="o">),</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">ind</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ind</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">G</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="c1">-- It is sufficient to show that the sets of left/right options agree.</span>
  <span class="n">rw</span> <span class="n">eq_LR</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="n">refine</span> <span class="n">set.ext</span> <span class="n">_</span><span class="o">,</span> <span class="n">intro</span> <span class="n">G1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">hyp1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">GLN</span> <span class="n">hyp1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">hyp1</span> <span class="n">hyp2</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">GL</span> <span class="n">hyp1</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">hyp11</span> <span class="n">hyp12</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hyp</span> <span class="n">GL</span> <span class="o">(</span><span class="n">L_is_option</span> <span class="n">G</span> <span class="n">GL</span> <span class="n">hyp11</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hyp2</span><span class="o">,</span> <span class="n">hyp12</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
      <span class="n">assumption</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hyp</span> <span class="n">G1</span> <span class="o">(</span><span class="n">L_is_option</span> <span class="n">G</span> <span class="n">G1</span> <span class="n">h1</span><span class="o">),</span>
    <span class="n">use</span> <span class="bp">-</span><span class="n">G1</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">G1</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>

    <span class="n">simp</span><span class="o">,</span> <span class="n">refine</span> <span class="n">set.ext</span> <span class="n">_</span><span class="o">,</span> <span class="n">intro</span> <span class="n">G1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">hyp1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">GRN</span> <span class="n">hyp1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">hyp1</span> <span class="n">hyp2</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">GR</span> <span class="n">hyp1</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hyp1</span> <span class="k">with</span> <span class="n">hyp11</span> <span class="n">hyp12</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hyp</span> <span class="n">GR</span> <span class="o">(</span><span class="n">R_is_option</span> <span class="n">G</span> <span class="n">GR</span> <span class="n">hyp11</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hyp2</span><span class="o">,</span> <span class="n">hyp12</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
      <span class="n">assumption</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hyp</span> <span class="n">G1</span> <span class="o">(</span><span class="n">R_is_option</span> <span class="n">G</span> <span class="n">G1</span> <span class="n">h1</span><span class="o">),</span>
    <span class="n">use</span> <span class="bp">-</span><span class="n">G1</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">G1</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- We get the fact that negation is injective.</span>
<span class="kd">lemma</span> <span class="n">neg_inj</span> <span class="o">(</span><span class="n">G1</span> <span class="n">G2</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="n">G1</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">G2</span> <span class="bp">→</span> <span class="n">G1</span> <span class="bp">=</span> <span class="n">G2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">neg_neg</span> <span class="n">G1</span><span class="o">),</span> <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">neg_neg</span> <span class="n">G2</span><span class="o">),</span> <span class="n">rw</span> <span class="n">hyp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Also, `G₁ = -G₂` implies `G₂ = -G₁`.</span>
<span class="kd">lemma</span> <span class="n">neg_swap</span> <span class="o">(</span><span class="n">G₁</span> <span class="n">G₂</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">G₂</span> <span class="bp">→</span> <span class="n">G₂</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">G₁</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">neg_neg</span> <span class="n">G₂</span><span class="o">,</span> <span class="n">apply</span> <span class="n">eq.symm</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Some simple statements on the simplest games and negation.</span>
<span class="kd">lemma</span> <span class="n">G0_neg</span> <span class="o">:</span> <span class="bp">-</span><span class="n">G0</span> <span class="bp">=</span> <span class="n">G0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">eq_LR</span> <span class="o">(</span><span class="bp">-</span><span class="n">G0</span><span class="o">)</span> <span class="n">G0</span><span class="o">),</span> <span class="n">unfold</span> <span class="n">G0</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">G1_neg</span> <span class="o">:</span> <span class="bp">-</span><span class="n">G1</span> <span class="bp">=</span> <span class="n">Gn1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">eq_LR</span> <span class="o">(</span><span class="bp">-</span><span class="n">G1</span><span class="o">)</span> <span class="n">Gn1</span><span class="o">),</span> <span class="n">unfold</span> <span class="n">Gn1</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">G1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">G0_neg</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">Gstar_neg</span> <span class="o">:</span> <span class="bp">-</span><span class="n">Gstar</span> <span class="bp">=</span> <span class="n">Gstar</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="n">eq_LR</span> <span class="o">(</span><span class="bp">-</span><span class="n">Gstar</span><span class="o">)</span> <span class="n">Gstar</span><span class="o">),</span> <span class="n">unfold</span> <span class="n">Gstar</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply</span> <span class="n">G0_neg</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Now we do addition.</span>
<span class="c1">-- To use Conway induction on pairs of games,</span>
<span class="c1">-- we need to work with the product type.</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">add_help</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">GG1</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">),</span> <span class="n">is_option_2</span> <span class="n">GG1</span> <span class="n">GG</span> <span class="bp">→</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span>
  <span class="n">make</span> <span class="o">{</span><span class="n">GAL</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">GG.fst</span><span class="o">),</span> <span class="n">GAL</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">GL</span><span class="o">,</span> <span class="n">GG.snd</span><span class="o">)</span> <span class="o">(</span><span class="n">L_opts1_is_option_2</span> <span class="n">GL</span> <span class="n">GG</span> <span class="n">h</span><span class="o">))</span>
                          <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">GG.snd</span><span class="o">),</span> <span class="n">GAL</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">GG.fst</span><span class="o">,</span> <span class="n">GL</span><span class="o">)</span> <span class="o">(</span><span class="n">L_opts2_is_option_2</span> <span class="n">GL</span> <span class="n">GG</span> <span class="n">h</span><span class="o">))}</span>
       <span class="o">{</span><span class="n">GAR</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">GG.fst</span><span class="o">),</span> <span class="n">GAR</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">GR</span><span class="o">,</span> <span class="n">GG.snd</span><span class="o">)</span> <span class="o">(</span><span class="n">R_opts1_is_option_2</span> <span class="n">GR</span> <span class="n">GG</span> <span class="n">h</span><span class="o">))</span>
                          <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">GG.snd</span><span class="o">),</span> <span class="n">GAR</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">GG.fst</span><span class="o">,</span> <span class="n">GR</span><span class="o">)</span> <span class="o">(</span><span class="n">R_opts2_is_option_2</span> <span class="n">GR</span> <span class="n">GG</span> <span class="n">h</span><span class="o">))}</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">add_pair</span> <span class="o">(</span><span class="n">GG</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">×</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span>
  <span class="n">DGC_2.fix</span> <span class="n">add_help</span> <span class="n">GG</span>

<span class="c1">-- Translate  `Game × Game → Game`  into  `Game → Game → Game` .</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">G1</span> <span class="n">G2</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">Game</span> <span class="o">:=</span>  <span class="n">add_pair</span> <span class="o">(</span><span class="n">G1</span><span class="o">,</span> <span class="n">G2</span><span class="o">)</span>

<span class="c1">--noncomputable Game_has_add : has_add Game := ⟨ add ⟩</span>

<span class="kd">notation</span> <span class="n">G1</span> <span class="bp">`</span> <span class="bp">+</span> <span class="bp">`</span> <span class="n">G2</span> <span class="o">:=</span> <span class="n">add</span> <span class="n">G1</span> <span class="n">G2</span>

<span class="c1">-- Lemmas that can be used for simplification.</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">L_opts_of_add</span> <span class="o">(</span><span class="n">G1</span> <span class="n">G2</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">L_opts</span> <span class="o">(</span><span class="n">G1</span> <span class="bp">+</span> <span class="n">G2</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">{</span><span class="n">GAL</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">G1</span><span class="o">),</span> <span class="n">GAL</span> <span class="bp">=</span> <span class="n">GL</span> <span class="bp">+</span> <span class="n">G2</span><span class="o">)</span>
                <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GL</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GL</span> <span class="bp">∈</span> <span class="n">L_opts</span> <span class="n">G2</span><span class="o">),</span> <span class="n">GAL</span> <span class="bp">=</span> <span class="n">G1</span> <span class="bp">+</span> <span class="n">GL</span><span class="o">)}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">add</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">add_pair</span><span class="o">,</span> <span class="n">rw</span> <span class="n">DGC_2.fix_eq</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">add_help</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">R_opts_of_add</span> <span class="o">(</span><span class="n">G1</span> <span class="n">G2</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">:</span> <span class="n">R_opts</span> <span class="o">(</span><span class="n">G1</span> <span class="bp">+</span> <span class="n">G2</span><span class="o">)</span> <span class="bp">=</span>
  <span class="o">{</span><span class="n">GAR</span> <span class="o">:</span> <span class="n">Game</span> <span class="bp">|</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">G1</span><span class="o">),</span> <span class="n">GAR</span> <span class="bp">=</span> <span class="n">GR</span> <span class="bp">+</span> <span class="n">G2</span><span class="o">)</span>
                <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">GR</span> <span class="o">:</span> <span class="n">Game</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">GR</span> <span class="bp">∈</span> <span class="n">R_opts</span> <span class="n">G2</span><span class="o">),</span> <span class="n">GAR</span> <span class="bp">=</span> <span class="n">G1</span> <span class="bp">+</span> <span class="n">GR</span><span class="o">)}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">add</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">add_pair</span><span class="o">,</span> <span class="n">rw</span> <span class="n">DGC_2.fix_eq</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">add_help</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">G0</span> <span class="bp">+</span> <span class="n">G0</span> <span class="bp">=</span> <span class="n">G0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">eq_LR</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">G0</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>(then I go on to prove facts on addition).<br>
The proofs can probably be considerably simplified...</p>



<a name="281190600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281190600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281190600">(May 04 2022 at 17:30)</a>:</h4>
<p>I don't believe defining games in terms of sets of games works in type theory</p>



<a name="281190695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281190695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281190695">(May 04 2022 at 17:31)</a>:</h4>
<p>Otherwise you could define a game whose left set is the set of all games</p>



<a name="281190723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281190723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281190723">(May 04 2022 at 17:31)</a>:</h4>
<p>And that's an absurd</p>



<a name="281190866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281190866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281190866">(May 04 2022 at 17:32)</a>:</h4>
<p>Mathlib already has pre-games, and it defines them via type indexed families of pre-games</p>



<a name="281190971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281190971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281190971">(May 04 2022 at 17:33)</a>:</h4>
<p>Crucially the indexing types must belong to universe <code>u</code>, while the type of pre-games is in universe <code>u+1</code>, which avoids the contradiction</p>



<a name="281191283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191283">(May 04 2022 at 17:34)</a>:</h4>
<p>This has the annoyance that pre-games with equal left and right sets of games can still be different if the indexing types or the indexing itself are different, but I'm currently defining tbe quotient of pre-games by extensionality to overcome this</p>



<a name="281191645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191645">(May 04 2022 at 17:37)</a>:</h4>
<p>In surreals you have an equivalence of recursive equivalence like "forall a, exists b, A_left a &lt;= B_left b" to deal with this, and pSet has something similar - <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv/src">src#pSet.equiv</a></p>



<a name="281191734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191734">(May 04 2022 at 17:37)</a>:</h4>
<p>Pre-games already have a notion of a relabelling</p>



<a name="281191843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191843">(May 04 2022 at 17:38)</a>:</h4>
<p>I assume relabelling is a bit too strict of an equivalence for games though</p>



<a name="281191852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191852">(May 04 2022 at 17:38)</a>:</h4>
<p>And existence of a relabelling almost corresponds to ZFC equality of pre-games</p>



<a name="281191889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191889">(May 04 2022 at 17:38)</a>:</h4>
<p>Not quite because it assumes that you have multisets instead of sets</p>



<a name="281191918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191918">(May 04 2022 at 17:38)</a>:</h4>
<p>Of course, it's too strict for games</p>



<a name="281191965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191965">(May 04 2022 at 17:39)</a>:</h4>
<p>That's a quotient by antisymmetry</p>



<a name="281191980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281191980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281191980">(May 04 2022 at 17:39)</a>:</h4>
<p>Not just structural equality</p>



<a name="281192014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192014">(May 04 2022 at 17:39)</a>:</h4>
<p>for pSet it's also not quite relabeling, because it needs to be relabeling where after the relabeling the elements are equivalent</p>



<a name="281192041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192041">(May 04 2022 at 17:39)</a>:</h4>
<p>or maybe that's part of relabeling</p>



<a name="281192176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192176">(May 04 2022 at 17:40)</a>:</h4>
<p>I suppose pre-games don't have any quotient on them?</p>



<a name="281192187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192187">(May 04 2022 at 17:40)</a>:</h4>
<p>that's what makes them pre-games</p>



<a name="281192728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192728">(May 04 2022 at 17:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281190600">said</a>:</p>
<blockquote>
<p>I don't believe defining games in terms of sets of games works in type theory</p>
</blockquote>
<p>That's the problem I had; this is why I resorted to axioms and constants to describe the set-up in a way that was as close as possible to Conway's definition.<br>
Note that I wrote this code before I was aware that combinatorial games are present in mathlib. (And before I had any experience with Lean to speak of.)</p>



<a name="281192759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192759">(May 04 2022 at 17:44)</a>:</h4>
<p>Regarding <span class="user-mention" data-user-id="224323">@Junyan Xu</span> 's point about loopy games, I believe the correct approach is to use a coinductive type instead of an inductive type but otherwise with the same definition. Because we would want to consider the <code>A -&gt; A</code> and <code>B -&gt; B</code> and <code>A -&gt; B -&gt; A</code> all be equivalent loopy games (there is only one infinite line of play)</p>



<a name="281192948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281192948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281192948">(May 04 2022 at 17:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281106984">said</a>:</p>
<blockquote>
<p><del>Moreover, you should be able to get rid of all the <code>relabelling</code> stuff.</del>(maybe not)<br>
<a href="/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png">image.png</a></p>
</blockquote>
<p>I don't think that would get rid of the relabelling stuff. If you have a type of positions, then it stands that you can have two games that are exactly the same except they use a different type.</p>



<a name="281193086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281193086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281193086">(May 04 2022 at 17:47)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> using sets of games leads to the same paradoxes in set theory too. Well-foundedness is an essential component, and I believe Conway uses an informal description of transfinite induction in ONAG</p>



<a name="281193191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281193191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281193191">(May 04 2022 at 17:47)</a>:</h4>
<p>using inductive types is by far the easiest way to do this and get the right answer in CIC</p>



<a name="281193205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281193205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281193205">(May 04 2022 at 17:47)</a>:</h4>
<p>Doesn't set theory circumvent this by having games be a proper class?</p>



<a name="281193326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281193326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281193326">(May 04 2022 at 17:48)</a>:</h4>
<p>In a way, Conway defines games as sets with two kinds of elements.</p>



<a name="281193445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281193445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281193445">(May 04 2022 at 17:49)</a>:</h4>
<p>And well-foundedness is sort of built-in ("... all games arise in this way"); alternatively, it is equivalent to the induction principle for games.</p>



<a name="281193710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281193710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281193710">(May 04 2022 at 17:51)</a>:</h4>
<p>If one wants to build the theory within set theory, then the games are not a set, but a proper class (which is not a problem).</p>



<a name="281199763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281199763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281199763">(May 04 2022 at 18:32)</a>:</h4>
<p>An element of <code>set α</code> in Lean is actually a predicate, which may be an actual set or a proper class, if <code>α</code> is in a higher universe; for example when <code>α</code> is <code>pgame.{u} : Type (u+1)</code>, <code>s : set α</code> is small (an "actual set" in <code>Type u</code>) if <code>subtype s</code> is equipotent to some type in <code>Type u</code>, and a proper class otherwise.</p>
<p>Conway defines games/numbers like how you define the von Neumann universe or constructible universe in set theory, implicitly using transfinite induction; at each step you can only use games/numbers you already constructed. In Lean, this smallness is guaranteed by using indexing types in <code>Type u</code> for left and right options.</p>
<p>The point of my new definition is: if we have to use indexing types, why not use a single indexing type for all positions? It also makes some definitions simpler, e.g. negation, and impartial games would simply be those with L=R.</p>
<p>I don't think we need force isomorphic games be equal using coinductive types or something like Aczel's anti-foundation axiom; there are many different types of games as you can see in <em>Winning Ways</em> and it's easy to find coincidences where the games are CGT equivalent or even the game graphs are the same, but they don't have to be the same <code>pgame</code>; it would be enough to prove by induction that you can substitute one with the other without changing the CGT value (equivalence class) of the whole game.</p>



<a name="281200449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281200449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281200449">(May 04 2022 at 18:37)</a>:</h4>
<p>Describing what it means for a game to be well founded is approximately as complicated as defining <code>pgame</code> in the first place though</p>



<a name="281200504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281200504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281200504">(May 04 2022 at 18:37)</a>:</h4>
<p>you basically have to say that a game has a <code>pgame</code> that surjects onto it in a certain sense</p>



<a name="281200759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281200759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281200759">(May 04 2022 at 18:39)</a>:</h4>
<p>I think that your general concept of game-graphs are useful but distinct from either the inductive or coinductive concept of <code>pgame</code></p>



<a name="281201051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281201051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281201051">(May 04 2022 at 18:41)</a>:</h4>
<p>You need the coinductive analogue of <code>game</code> to provide the values of loopy games and game-graphs</p>



<a name="281201403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281201403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281201403">(May 04 2022 at 18:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281200449">said</a>:</p>
<blockquote>
<p>Describing what it means for a game to be well founded is approximately as complicated as defining <code>pgame</code> in the first place though</p>
</blockquote>
<p>Is this complicated, or problematic, or you mean something else?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">pgame</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">L</span> <span class="n">R</span> <span class="o">:</span> <span class="n">pos</span> <span class="bp">→</span> <span class="n">pos</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="c">/-</span><span class="cm"> L x y means x is a option at position y for left -/</span>
<span class="o">(</span><span class="n">wf</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">L</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">start</span> <span class="o">:</span> <span class="n">pos</span><span class="o">)</span>
</code></pre></div>



<a name="281201933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281201933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281201933">(May 04 2022 at 18:47)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pgame/src">src#pgame</a></p>



<a name="281201974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281201974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281201974">(May 04 2022 at 18:47)</a>:</h4>
<p>I think it's more complicated</p>



<a name="281202088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202088">(May 04 2022 at 18:48)</a>:</h4>
<p>the fact that you can't pattern match on it and have to carry <code>start</code> around seems like it will make proofs harder</p>



<a name="281202167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202167">(May 04 2022 at 18:48)</a>:</h4>
<p>for graphs you usually don't designate a start vertex in the structure itself</p>



<a name="281202261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202261">(May 04 2022 at 18:49)</a>:</h4>
<p>Also, you might not want to assume the whole type is well founded, only the elements under <code>start</code></p>



<a name="281202290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202290">(May 04 2022 at 18:49)</a>:</h4>
<p>that is <code>acc (λ x y, L x y ∨ R x y) start</code></p>



<a name="281202363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202363">(May 04 2022 at 18:50)</a>:</h4>
<p>You can remove unreachable elements and get an equivalent game.</p>



<a name="281202410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202410">(May 04 2022 at 18:50)</a>:</h4>
<p>sure, but those kinds of arguments are messy in lean</p>



<a name="281202417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202417">(May 04 2022 at 18:50)</a>:</h4>
<p>I'll definitely try to replicate current development in mathlib to see how easy my definition is to work with.</p>



<a name="281202548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281202548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281202548">(May 04 2022 at 18:51)</a>:</h4>
<p>You may try the two <code>sorry</code>s in my code posted above, I won't get to them until 6pm (~3 hours later).</p>



<a name="281203346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281203346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281203346">(May 04 2022 at 18:57)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/well_founded.well_founded_iff_has_min">docs#well_founded.well_founded_iff_has_min</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/set.well_founded_on_iff_no_descending_seq">docs#set.well_founded_on_iff_no_descending_seq</a> will be handy. (The second uses dependent choice but mathlib is fine with it.)</p>



<a name="281209882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281209882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281209882">(May 04 2022 at 19:46)</a>:</h4>
<p>I find that Lean generally makes it so that it's harder to use that characterization of well foundedness</p>



<a name="281209926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281209926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281209926">(May 04 2022 at 19:46)</a>:</h4>
<p>Usually, if everything is setup right, you can do bare induction and get what you want more easily</p>



<a name="281209992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281209992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281209992">(May 04 2022 at 19:47)</a>:</h4>
<p>This is just my opinion though</p>



<a name="281256112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281256112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281256112">(May 05 2022 at 06:04)</a>:</h4>
<p>I've defined ≤ and showed it's reflexive using the new definition and I'll call it a day; more to come!<br>
<a href="https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621">https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621</a></p>



<a name="281302368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281302368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281302368">(May 05 2022 at 13:58)</a>:</h4>
<p>Are you planning for this to replace the current definition in <code>mathlib</code>? Or is this just a side thing?</p>



<a name="281302398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281302398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281302398">(May 05 2022 at 13:59)</a>:</h4>
<p>What you're doing seems nice but I feel like refactoring <code>pgame</code> with this would be a ton of work with little (if any) benefit</p>



<a name="281315721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281315721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281315721">(May 05 2022 at 15:34)</a>:</h4>
<p>I believe my definition is the most natural when dealing with concrete games (that are described by which moves are possible at each position) and loopy games, and realizing addition as juxtaposition of games is really nice. Currently it's in exploration phase, and if the mathlib definition turns out to be superior for some purposes we may work on providing some glues between the two.</p>



<a name="281337320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281337320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281337320">(May 05 2022 at 18:09)</a>:</h4>
<p>How would multiplication work? Don't you need well foundedness to define that?</p>



<a name="281337344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281337344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281337344">(May 05 2022 at 18:09)</a>:</h4>
<p>Which wouldn't quite work on loopy games</p>



<a name="281343512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281343512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281343512">(May 05 2022 at 18:58)</a>:</h4>
<p>Yeah, I don't think multiplication is well-behaved even for well-founded games (and there are at least two definitions of ≤  as the loopy games slides show, and there is the misère play convention (first player without move wins) where there isn't a nice notion of ≤). Multiplication won't respect equivalence unless restricted to surreals. I expect <code>of_L_R</code> in <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281148141">my earlier post</a> will be required to define multiplication. I haven't thought about surreals much, but I have done some computations in <code>On₂</code>, the (algebraically closed, etc.) field of characteristic two formed by all ordinals by considering them as impartial games, where multiplication is defined like in the surreal case. I think <em>Winning Ways</em> also defined multiplication for more general games that's well-behaved under certain conditions, but I have to look them up.</p>



<a name="281379720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281379720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281379720">(May 06 2022 at 01:25)</a>:</h4>
<p>I think it would be fine to have an alternative definition in parallel, if there is appropriate glue.</p>



<a name="281380407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281380407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281380407">(May 06 2022 at 01:40)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.state">docs#pgame.state</a> already looks pretty similar</p>



<a name="281381358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281381358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281381358">(May 06 2022 at 02:01)</a>:</h4>
<p>I'd forgotten about that one, even though the domineering example I built uses it.</p>



<a name="281381491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281381491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281381491">(May 06 2022 at 02:03)</a>:</h4>
<p>For lots of concrete games the turn bound is easy and convenient, and in practice how you might be proving well-foundedness anyway.</p>



<a name="281381705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281381705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281381705">(May 06 2022 at 02:07)</a>:</h4>
<p>I think it would be great to have more actual concrete games! Hex, dots-and-boxes, and go would all be lovely (some amount of fitting square pegs in round holes to treat these all as Conway style games, but they could be described other ways, too).</p>



<a name="281399288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281399288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281399288">(May 06 2022 at 06:35)</a>:</h4>
<p>My paper on dots and boxes describes how at a professional level it has little to do with combinatorial game theory, but strings and coins (:= dots and boxes with the normal play rule rather than "most boxes is the winner") would be lovely :-)</p>



<a name="281563382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281563382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281563382">(May 07 2022 at 22:16)</a>:</h4>
<p>Update: I've shown <code>game</code> is a <code>ordered_add_comm_group</code> under the new definition within 374 lines: <a href="https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621">https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621</a></p>



<a name="281909238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281909238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281909238">(May 11 2022 at 01:58)</a>:</h4>
<p>Updates: I have been able to show the well-foundedness of the game constructed from left/right options (formerly called <code>of_L_R</code> and now simply called <code>of</code>); see the end of <a href="https://gist.github.com/alreadydone/93e25ccda07b0c9c1ef2b40efedf3339">https://gist.github.com/alreadydone/93e25ccda07b0c9c1ef2b40efedf3339</a>. However, at the same time I came up with an explicit construction of a type of positions for the product of two games (has anyone written about it before?) and plan to use it instead of <code>of</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="n">pgame</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g₁</span> <span class="n">g₂</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">pos</span> <span class="o">:=</span> <span class="n">tree3</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">g₁.pos</span> <span class="bp">×</span> <span class="n">g₂.pos</span><span class="o">),</span>
    <span class="c">/-</span><span class="cm"> could also potentially be `multiset (bool × g₁.pos × g₂.pos)`; each element</span>
<span class="cm">       of the multiset is seen as an expression of the form +x*y or -x*y, where x is a position in g₁ and y a position in g₂. -/</span>
    <span class="n">L</span> <span class="o">:=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">mul_rel</span> <span class="n">tt</span> <span class="n">g₁.L</span> <span class="n">g₂.L</span> <span class="bp">∪</span> <span class="n">mul_rel</span> <span class="n">ff</span> <span class="n">g₁.L</span> <span class="n">g₂.R</span> <span class="bp">∪</span>
                  <span class="n">mul_rel</span> <span class="n">ff</span> <span class="n">g₁.R</span> <span class="n">g₂.L</span> <span class="bp">∪</span> <span class="n">mul_rel</span> <span class="n">tt</span> <span class="n">g₁.R</span> <span class="n">g₂.R</span><span class="o">),</span>
    <span class="n">R</span> <span class="o">:=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">mul_rel</span> <span class="n">ff</span> <span class="n">g₁.L</span> <span class="n">g₂.L</span> <span class="bp">∪</span> <span class="n">mul_rel</span> <span class="n">tt</span> <span class="n">g₁.L</span> <span class="n">g₂.R</span> <span class="bp">∪</span>
                  <span class="n">mul_rel</span> <span class="n">tt</span> <span class="n">g₁.R</span> <span class="n">g₂.L</span> <span class="bp">∪</span> <span class="n">mul_rel</span> <span class="n">ff</span> <span class="n">g₁.R</span> <span class="n">g₂.R</span><span class="o">),</span>
    <span class="n">wf</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">start</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tt</span><span class="o">,</span> <span class="n">g₁.start</span><span class="o">,</span> <span class="n">g₂.start</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>
<p>See the beginning of the gist above for the full code.</p>
<p>I like the symmetric form of the definition of L and R fields. It works for surreal multiplication, but presumably not for multiplying a positive game with an arbitrary game, which I'll worry about later. (I'm currently experimenting with <code>jux : (fin 3 → tree3) → tree3</code> instead of <code>jux : tree3 → tree3 → tree3 → tree3</code>.)</p>
<p>To fill in the <code>sorry</code> above, I basically need to prove the termination of a version of the hydra game; basically, the options of the product of two games are each a sum of three products, that is to say if you cut a head of the hydra, it grows back three heads at some lower levels ("less than" the original product w.r.t. the &lt; relation that is the transitive closure of (sgn, xL/xR, y), (sgn, x, yL/yR)  &lt; (sgn', x, y)). I realized I need some form of Kőnig's lemma and Googled with the keywords "Kőnig hydra", and <a href="https://mathoverflow.net/questions/192297/a-well-founded-relation-on-lists">this MO problem</a> came up. After browsing the answers, I found that <span class="user-mention" data-user-id="285970">@Peter LeFanu Lumsdaine</span> 's approach seems simpler than setting up the stage to apply Kőnig's lemma, so that's what I'm gonna formalize now. The statement is as below (with multiset instead of list); it doesn't seem to show up when defining multiplication via Conway induction as done in mathlib.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.multiset.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="sd">/-- Cut one head `a` of a hydra `s`, and it grows back an arbitrary finite number of</span>
<span class="sd">  heads at "lower levels" than the head cut. -/</span>
<span class="kd">inductive</span> <span class="n">cut_rel</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a'</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">cut_rel</span> <span class="o">(</span><span class="n">s.erase</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">t</span><span class="o">)</span> <span class="n">s</span>

<span class="kd">theorem</span> <span class="n">well_founded.cut_rel</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="o">(</span><span class="n">cut_rel</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Since the line count is growing large, I'll probably split this project into multiple files and create a folder (like <code>set_theory/game_new</code>) in mathlib to contain it and create a branch on github. If people find it easier to work with this new definition, we may continue to add materials to that folder and gradually deprecate the old one.</p>



<a name="281914452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281914452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281914452">(May 11 2022 at 03:33)</a>:</h4>
<p>I'm still really iffy on this. The way I see it, your approach has the following pros and cons:</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Allows a natural extension to loopy games.</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>The induction arguments become considerably harder.</li>
<li>Much worse definitional equalities (since you force a game and all subsequent moves to be part of the same graph).</li>
<li>The notion of "relabellings" becomes much more complicated.</li>
<li>The refactor would take a large amount of work, and to me it's not even clear that everything would work out nicely.</li>
<li>This deviates from Conway's approach even more radically than our current approach (and supposedly, that's what we're trying to formalize).</li>
</ul>
<p>Call it force of habit, but I'd rather stick to what we have unless there's other substantial reasons to switch, or unless there's a substantial theory on loopy games that we can formalize using your definition.</p>



<a name="281914719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281914719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281914719">(May 11 2022 at 03:38)</a>:</h4>
<p>To give a basic example of something that would break in a way that's hard to fix: <code>ordinal.to_pgame</code>. Currently, a lot of the results about it induct on the ordinal, which is possible because left moves of <code>o.to_pgame</code> are <strong>exactly</strong> <code>a.to_pgame</code> for <code>a &lt; o</code>. With your definition, this wouldn't be the case, so you'd need to consider relabellings in pretty much all of the proofs.</p>



<a name="281914727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281914727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281914727">(May 11 2022 at 03:38)</a>:</h4>
<p>Pretty much this same reasoning extends to <code>nim</code>.</p>



<a name="281918056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281918056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281918056">(May 11 2022 at 04:44)</a>:</h4>
<p>set_theory.game.ordinal is a short file. Would it convince you it's a viable approach if I reproduce the results therein? Your "relabelling" is basically my <code>iso</code>, which I showed preserves <code>Rlose</code> (i.e. 0 ≤ g) in <code>map_iso_Rlose_iff</code>, and use it in the following lemmas to show commutativity, associativity, etc. I later defined a structure <code>iso</code> which is quite simple:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">iso</span> <span class="o">(</span><span class="n">g</span> <span class="n">g'</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="n">g.pos</span> <span class="bp">≃</span> <span class="n">g'.pos</span><span class="o">)</span>
<span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">inv_image</span> <span class="n">g'.L</span> <span class="n">pos</span> <span class="bp">=</span> <span class="n">g.L</span><span class="o">)</span>
<span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">inv_image</span> <span class="n">g'.R</span> <span class="n">pos</span> <span class="bp">=</span> <span class="n">g.R</span><span class="o">)</span>
</code></pre></div>
<p>I'm puzzled by your comment that "induction arguments become considerably harder" and "much worse  definitional equalities". Can you elaborate and maybe give an example in my code, or have I not got to the point where they'll be problematic? My experience has been that induction/recursion <strong>becomes unnecessary</strong> in many places with my approach. It's a one-off thing to prove well-foundedness in various constructions, and I wouldn't call them hard except for multiplication. Contrary to your comment, I think one advantage of my approach is that addition, negation, multiplication, and impartial games now have totally non-inductive definitions (is_numeric can also be defined by quantifying over all positions using the inductively defined Lwin); when defining Rlose/Lwin, I used induction on positions instead of games. </p>
<p>I agree it's a deviation from Conway's approach but I'd argue using indexing types for left/right options is also a deviation, and necessitates relabelling which makes things inelegant (though using a ordinal-indexed union of games born by birthday x would be more inelegant). As I said before, the initial motivation of my definition is : "if we have to use indexing types, why not use a single one?" In general, I think we should choose what works best (like the filter approach to topology, or is_localization in mathlib), which can only be found out through experimentation. It would be great if more people like you are interested to join the effort. I think I currently have all the essential results in game.pgame and game.basic except for <code>mul</code> and <code>inv</code>, and those are my ongoing work. My plan is to gradually work through all files under <code>game</code> and <code>surreal</code>, which seem to contain everything about CGT in mathlib and don't seem that massive, though I think I probably don't have the energy to complete a refactor without other people's interest and help. So I think it's a sensible approach to add another folder, so people can choose whichever approach that suits their purpose when they develop CGT and/or contribute to mathlib. I'd like to keep the same <code>pgame</code>, <code>game</code> etc. namespace (which shouldn't be a problem if you don't import files from both development), but I expect some linters may complain.</p>



<a name="281920280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281920280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281920280">(May 11 2022 at 05:25)</a>:</h4>
<p>For ordinals or nimbers, we can actually realize them simply as different starting positions in the "same" game, with all ordinals in the universe as positions, L = (&lt;), and R = (&lt;) for nimbers and empty for ordinals; just the <code>start</code> needs to be changed to the ordinal. This is at the expense of elevating the game from <code>pgame.{u}</code> to <code>pgame.{u+1}</code> though. The larger ordinals are unreachable in the game, but this is the flexibility offered by my approach and not a bug (e.g. the extraneous positions also occur in my definition of multiplication).</p>



<a name="281923172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281923172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281923172">(May 11 2022 at 06:21)</a>:</h4>
<p>I would be interested in seeing a concrete game translated to this formalism, too, e.g. domineering.</p>



<a name="281926010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281926010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281926010">(May 11 2022 at 07:05)</a>:</h4>
<p>I think that this approach makes more sense without the <code>wf</code>field</p>



<a name="281926098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281926098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281926098">(May 11 2022 at 07:06)</a>:</h4>
<p>The fact that you have to universe-bump is a pretty fundamental difference</p>



<a name="281930595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281930595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281930595">(May 11 2022 at 08:03)</a>:</h4>
<p>You only have to universe bump if you want to fit all ordinals in, don't you? There'll be some <code>u</code>-small ordinals trick otherwise?</p>



<a name="281930911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281930911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281930911">(May 11 2022 at 08:07)</a>:</h4>
<p>The current approach <a href="https://github.com/leanprover-community/mathlib/blob/df9683ca3c237d11920a3de8dfab2cc9dc2f8214/src/set_theory/game/ordinal.lean#L33">uses <code>o.out.α</code></a> (invokes choice) which seems to be the only option to lower the universe.</p>



<a name="281936113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281936113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281936113">(May 11 2022 at 09:00)</a>:</h4>
<p>note that <code>ordinal</code> is rampantly choice-assuming. It would need a very significant rewrite in order to make it not need choice and many theorems would not hold</p>



<a name="281936204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281936204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281936204">(May 11 2022 at 09:01)</a>:</h4>
<p>It's usually possible to avoid using <code>o.out</code> but there isn't much gain to be had in doing so because choice already appears ten times in the dependencies</p>



<a name="281937088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281937088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281937088">(May 11 2022 at 09:10)</a>:</h4>
<p>Note that the definition of <code>to_pgame</code> is actually computable; the reason for the <code>noncomputable!</code> is because one of the auxiliary definitions lean creates is unexpectedly noncomputable and it causes a weird error message</p>



<a name="281938131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281938131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281938131">(May 11 2022 at 09:20)</a>:</h4>
<p>Here's a definition that avoids <code>noncomputable!</code></p>



<a name="281938137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281938137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281938137">(May 11 2022 at 09:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Converts a well order into the corresponding pre-game. -/</span>
<span class="kd">def</span> <span class="n">well_order_to_pgame</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">has_well_founded</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">⟨{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">has_well_founded.r</span> <span class="n">x</span> <span class="n">a</span><span class="o">},</span> <span class="n">pempty</span><span class="o">,</span>
  <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">have</span> <span class="n">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">y.2</span><span class="o">,</span> <span class="n">well_order_to_pgame</span> <span class="n">y.1</span><span class="o">,</span> <span class="n">pempty.elim</span><span class="o">⟩</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">dec_tac</span> <span class="o">:=</span> <span class="n">tactic.assumption</span> <span class="o">}</span>

<span class="sd">/-- Converts an ordinal into the corresponding pre-game. -/</span>
<span class="kd">def</span> <span class="n">to_pgame</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">o.out.α</span><span class="o">,</span> <span class="n">pempty</span><span class="o">,</span> <span class="n">well_order_to_pgame</span><span class="o">,</span> <span class="n">pempty.elim</span><span class="o">⟩</span>
</code></pre></div>



<a name="281975537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281975537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281975537">(May 11 2022 at 14:41)</a>:</h4>
<p>Note that you can define loopy games in the same style as <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame">docs#pgame</a> by writing a coinductive definition instead of an inductive one. Here's a sketch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pfunctor.univariate.M</span>
<span class="kn">import</span> <span class="n">set_theory.game.pgame</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">def</span> <span class="n">loopy_game</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pfunctor.M</span> <span class="o">⟨</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">×</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">ulift.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">p.fst</span> <span class="bp">⊕</span> <span class="n">p.snd</span><span class="o">)⟩</span>

<span class="kd">def</span> <span class="n">pgame.loopy_game</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">loopy_game.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">pfunctor.M.corec</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">G.left_moves</span><span class="o">,</span> <span class="n">G.right_moves</span><span class="o">),</span>
                          <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">sum.elim</span> <span class="n">G.move_left</span> <span class="n">G.move_right</span> <span class="n">p.down</span><span class="o">⟩</span>

<span class="kn">namespace</span> <span class="n">loopy_game</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">loopy_game.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>

<span class="kd">def</span> <span class="n">left_moves</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">G.head.fst</span>
<span class="kd">def</span> <span class="n">right_moves</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">G.head.snd</span>
<span class="kd">def</span> <span class="n">move_left</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">left_moves</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">loopy_game</span> <span class="o">:=</span> <span class="n">G.children</span> <span class="o">(</span><span class="n">ulift.up</span> <span class="o">(</span><span class="n">sum.inl</span> <span class="n">x</span><span class="o">))</span>
<span class="kd">def</span> <span class="n">move_right</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">right_moves</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">loopy_game</span> <span class="o">:=</span> <span class="n">G.children</span> <span class="o">(</span><span class="n">ulift.up</span> <span class="o">(</span><span class="n">sum.inr</span> <span class="n">y</span><span class="o">))</span>

<span class="kd">inductive</span> <span class="n">is_wf</span> <span class="o">:</span> <span class="n">loopy_game.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">sup</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">loopy_game</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G.left_moves</span><span class="o">,</span> <span class="n">is_wf</span> <span class="o">(</span><span class="n">G.move_left</span> <span class="n">x</span><span class="o">))</span> <span class="bp">→</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G.right_moves</span><span class="o">,</span> <span class="n">is_wf</span> <span class="o">(</span><span class="n">G.move_right</span> <span class="n">y</span><span class="o">))</span> <span class="bp">→</span>
  <span class="n">is_wf</span> <span class="n">G</span>

<span class="kd">def</span> <span class="n">is_wf.pgame</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_wf</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">pgame</span> <span class="o">:=</span> <span class="n">h.rec</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ls</span> <span class="n">rs</span><span class="o">,</span> <span class="n">pgame.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ls</span> <span class="n">rs</span>

<span class="kd">end</span> <span class="n">loopy_game</span>
</code></pre></div>
<p>Probably you could go further and show that <code>pgame</code> is equivalent to the subtype of well-founded loopy games in this language</p>
<p>The code above essentially defines <code>loopy_game</code> to be a terminal coalgebra for a certain polynomial functor. Junyan's definition instead looks at the type of <em>all</em> (well-founded) pointed coalgebras. This makes a lot of sense if we want to construct explicit elements of <code>loopy_game</code> -- normally we define elements of a coinductive type by corecursion, i.e. by constructing explicit coalgebras. (Actually this is analogous to how we deal with bisimulation in mathlib: instead of defining an indexed coinductive prop of bisimulations, we take a bisimulation to be some coalgebra for the same functor.)</p>
<p>I think it's not clear which of these two approaches to loopy games is the best, but for well-founded games I don't understand what the problem with <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame">docs#pgame</a> is (other than it being difficult to construct concrete games, but this problem seems to be solved by <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.state">docs#pgame.state</a>)</p>



<a name="281996099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/281996099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#281996099">(May 11 2022 at 16:59)</a>:</h4>
<p>Thanks but I'm yet to read more about pfunctor and coinduction. From my limited understanding about bisimulation, it seems to be a better and more general notion of strong equivalence between games than relabelling. Here strong equivalence means it guarantees substitutability (in sums and as options) in any (loopy or wf) game under both the normal and misere play convention. (If you want to see more theory about loopy and misere games, there are whole chapters in Aaron Siegel's <em>Combinatorial Game Theory</em>.</p>
<p>As evidence of better defeq with my approach, see <a href="https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621">lines 135-137</a>: <code>neg_zero</code> and <code>neg_neg</code> are propositional equalities in mathlib; with my approach the former is defeq in Lean 3, and the latter (I think) is defeq in Lean 4 due to structure eta being defeq. <code>neg_add</code> is only true up to relabelling in mathlib; with my approach it's also defeq (which is "abused" in <code>add_le_add_iff_Rlose</code>, for example).</p>



<a name="282054150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282054150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282054150">(May 12 2022 at 03:15)</a>:</h4>
<p>A bunch of equalities in <code>pgame</code> might become def-eq in Lean 4, but I'm unsure to what extent that will help.</p>



<a name="282054730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282054730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282054730">(May 12 2022 at 03:29)</a>:</h4>
<p>It's very interesting that you're able to avoid induction in many circumstances. It's also interesting that you get better definitional equalities in these basic definitions. That speaks to some mathematical elegance in your approach. That said, there are a lot of induction proofs scattered throughout, some quite hard and involved, and I'm still not convinced that your approach can avoid all of them. And there's still the problem of definitional equalities in inductively defined families of games like <code>ordinal.to_pgame</code> and <code>nim</code>.</p>
<p>I very strongly disagree with your approach of bumping the universe of <code>ordinal.to_pgame</code>. This sort of universe bumping can lead to very hard to solve problems later down the line. I'm interested in seeing how the <code>ordinal.lean</code> file would work with your approach without said universe bumping.</p>
<p>I could help with your new definition, but I've yet to see benefits large enough to justify all the work that would be needed for this refactoring. If you only want loopy games, then the coinductive approach seems to be by far the smoothest alternative given the current state of the library.</p>



<a name="282054832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282054832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282054832">(May 12 2022 at 03:31)</a>:</h4>
<p>I really don't want to come off as mean, because I can imagine that you've been working for hours on this, and I don't want to give the impression that said work is worthless or uninteresting. I'd just like to more carefully evaluate what's better for mathlib in the short and long run.</p>



<a name="282054935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282054935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282054935">(May 12 2022 at 03:34)</a>:</h4>
<p>Also, I'm quite biased given my recent heavy involvement on the mathlib pgame code base. So I'd like to hear opinions from others too.</p>



<a name="282370552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282370552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282370552">(May 14 2022 at 20:25)</a>:</h4>
<p>After this <code>&lt;</code> refactor, there's another pretty big refactor I want to do</p>



<a name="282370598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282370598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282370598">(May 14 2022 at 20:26)</a>:</h4>
<p>We currently have a lot of <code>congr</code> lemmas for the different relations, and even then, proving inequalities is a total hassle</p>



<a name="282370606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282370606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282370606">(May 14 2022 at 20:26)</a>:</h4>
<p>This could be made way easier if we defined <code>game</code> earlier</p>



<a name="282370634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282370634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282370634">(May 14 2022 at 20:27)</a>:</h4>
<p>Then, to prove an inequality on <code>pgame</code>, we could simply <code>change</code> it into the def-eq inequality on <code>game</code>, and use a few <code>rw</code>s</p>



<a name="282379832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282379832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282379832">(May 15 2022 at 00:24)</a>:</h4>
<p>My latest thoughts: although I can provide an explicit model for the positions in the multiplication of two games, it doesn't seem to simplify any proofs, unlike in the addition case, so I probably won't open a PR for this approach in the near future. I will continue to explore the approach for concrete games, loopy games, and ordinals, when I have the leisure. I have yet to understand the coinductive approach to loopy games; for example, how would I construct a <code>loopy_game</code> from my <code>pos, L, R</code> and vice versa?</p>
<p>I might soon PR some work related to well-foundedness that has arisen from this endeavour, including the termination of the hydra game, which provides one way to show the well-foundedness of the induction for properties of surreal multiplication in the notes of Schleicher--Stoll; namely, if you consider the arguments of P1(x,y), P2(x1,x2,y) and P4(x,y1,y2) as multisets {x,y}, {x1,x2,y}, and {x,y1,y2}, then each of P1, P2, P4 is deduced from P1, P2, P4 with smaller argument multisets under the <code>cut_expand</code> relation. The proof of termination is actually pretty elegant using <code>acc</code>; interestingly it uses the <code>add_rel</code> for game addition.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">cut_expand</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a'</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">s'</span> <span class="bp">=</span> <span class="n">s.erase</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">t</span>
</code></pre></div>



<a name="282382506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282382506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282382506">(May 15 2022 at 01:39)</a>:</h4>
<p>If your <code>cut_expand</code> approach works, that would be super elegant</p>



<a name="282382829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282382829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282382829">(May 15 2022 at 01:49)</a>:</h4>
<p>Well, it might be a bit inconvenient to set up, since P1, P2, P4 are meant to have a fixed amount of arguments</p>



<a name="282382848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282382848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282382848">(May 15 2022 at 01:49)</a>:</h4>
<p>So you might need to induct on a generic multiset <code>s</code> and make the inductive hypotheses "if <code>{x, y}</code> is less than <code>s</code> then <code>P1</code>,  ..."</p>



<a name="282387707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387707">(May 15 2022 at 04:02)</a>:</h4>
<p>On the topic of relabellings and extensionality</p>



<a name="282387711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387711">(May 15 2022 at 04:02)</a>:</h4>
<p>I wonder if relabellings are even useful to begin with</p>



<a name="282387722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387722">(May 15 2022 at 04:03)</a>:</h4>
<p>Just from reading the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv">docs#pSet.equiv</a>, it seems like the same amount of work to prove two games are relabellings and to prove they're extensionally equal</p>



<a name="282387755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387755">(May 15 2022 at 04:03)</a>:</h4>
<p>If this is the case, then surely we don't need <code>relabelling</code>s at all?</p>



<a name="282387925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387925">(May 15 2022 at 04:07)</a>:</h4>
<p>On an unrelated note, I hadn't ever noticed just how similar <code>pgame</code> and <code>pSet</code> are</p>



<a name="282387966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387966">(May 15 2022 at 04:08)</a>:</h4>
<p><code>pSet</code> can very well be called the unary version of <code>pgame</code></p>



<a name="282387968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282387968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282387968">(May 15 2022 at 04:08)</a>:</h4>
<p>Which I guess is to be expected, ZFC games are constructed almost the same way as ZFC sets, just twice</p>



<a name="282388582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388582">(May 15 2022 at 04:28)</a>:</h4>
<p>I'm going to try to get rid of <code>relabelling</code> in favor of <code>identical</code>, which actually describes extensionality</p>



<a name="282388584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388584">(May 15 2022 at 04:28)</a>:</h4>
<p>If proofs become no more complicated than they were before, then to me that suggests that there's no need for <code>relabelling</code> at all</p>



<a name="282388738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388738">(May 15 2022 at 04:33)</a>:</h4>
<p>This is my idea:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">`identical x y` says that `x` and `y` are extensionally the same game. Specifically, for every move</span>
<span class="sd">in `x` there's an inductively `identical` move for `y`, and viceversa. Compare to `pSet.equiv`.</span>

<span class="sd">In ZFC, identical games would indeed be the same games.</span>
<span class="sd">-/</span>
<span class="kd">inductive</span> <span class="n">identical</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">}</span> <span class="o">(</span><span class="n">Lxy</span> <span class="o">:</span> <span class="n">x.left_moves</span> <span class="bp">→</span> <span class="n">y.left_moves</span><span class="o">)</span> <span class="o">(</span><span class="n">Lyx</span> <span class="o">:</span> <span class="n">y.left_moves</span> <span class="bp">→</span> <span class="n">x.left_moves</span><span class="o">)</span>
         <span class="o">(</span><span class="n">Rxy</span> <span class="o">:</span> <span class="n">x.right_moves</span> <span class="bp">→</span> <span class="n">y.right_moves</span><span class="o">)</span> <span class="o">(</span><span class="n">Ryx</span> <span class="o">:</span> <span class="n">y.right_moves</span> <span class="bp">→</span> <span class="n">x.right_moves</span><span class="o">),</span>
         <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">identical</span> <span class="o">(</span><span class="n">x.move_left</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">y.move_left</span> <span class="o">(</span><span class="n">Lxy</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">→</span>
         <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">identical</span> <span class="o">(</span><span class="n">y.move_left</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">x.move_left</span> <span class="o">(</span><span class="n">Lyx</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">→</span>
         <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">identical</span> <span class="o">(</span><span class="n">x.move_right</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">y.move_right</span> <span class="o">(</span><span class="n">Rxy</span> <span class="n">j</span><span class="o">)))</span> <span class="bp">→</span>
         <span class="o">(</span><span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">identical</span> <span class="o">(</span><span class="n">y.move_right</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">x.move_right</span> <span class="o">(</span><span class="n">Ryx</span> <span class="n">j</span><span class="o">)))</span> <span class="bp">→</span>
       <span class="n">identical</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="282388876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388876">(May 15 2022 at 04:37)</a>:</h4>
<p>isn't that the <code>game</code> equivalence relation?</p>



<a name="282388922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388922">(May 15 2022 at 04:38)</a>:</h4>
<p><code>game</code> is to <code>pgame</code> as <code>Set</code> is to <code>pSet</code></p>



<a name="282388928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388928">(May 15 2022 at 04:38)</a>:</h4>
<p>(the similarity is not a coincidence, <code>pgame</code> was mostly a copy-paste-paste job)</p>



<a name="282388932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282388932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282388932">(May 15 2022 at 04:38)</a>:</h4>
<blockquote>
<p>isn't that the game equivalence relation?</p>
</blockquote>
<p>Certainly not. g + -g, which can be arbitrarily complicated, is equivalent to 0 in <code>game</code></p>



<a name="282389022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282389022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282389022">(May 15 2022 at 04:40)</a>:</h4>
<blockquote>
<p>pSet can very well be called the unary version of pgame<br>
Which I guess is to be expected, ZFC games are constructed almost the same way as ZFC sets, just twice</p>
</blockquote>
<p>Yes, that's why I drew a parallel between Conway's construction of games and the von Neumann universe. The axiom of regularity/foundation says the von Neumann universe contains all the sets.</p>



<a name="282389025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282389025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282389025">(May 15 2022 at 04:41)</a>:</h4>
<p><code>pSet.equiv</code> is a <code>Prop</code> though, are you sure you want to keep the data in <code>identical</code>?</p>



<a name="282389032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282389032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282389032">(May 15 2022 at 04:41)</a>:</h4>
<p>it's also defined by recursion not induction</p>



<a name="282389073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282389073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282389073">(May 15 2022 at 04:42)</a>:</h4>
<p>I think this is the difference between <a href="https://leanprover-community.github.io/mathlib_docs/find/function.bijective">docs#function.bijective</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv">docs#equiv</a>; I wouldn't be surprised if both notions are useful</p>



<a name="282389284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282389284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282389284">(May 15 2022 at 04:49)</a>:</h4>
<blockquote>
<p>Then, to prove an inequality on pgame, we could simply change it into the def-eq inequality on game, and use a few rws</p>
</blockquote>
<p>As mentioned in <a href="https://github.com/leanprover-community/mathlib/pull/13925#issuecomment-1126850423">#13925</a>, I wonder whether this would be a nice application of the <code>norm_cast</code> (specifically <code>rw_mod_cast</code>) tactic. If that's the case, I think <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> can probably provide some guidance on how to write an "extension" or something for that tactic to apply to <code>pgame</code>s.</p>



<a name="282389436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282389436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282389436">(May 15 2022 at 04:52)</a>:</h4>
<p>I don't think you need to write an extension or anything; you just mark the relevant theorems with the <code>@[norm_cast]</code> attribute</p>



<a name="282390319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282390319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282390319">(May 15 2022 at 05:16)</a>:</h4>
<p>What exactly is <code>restricted</code> supposed to mean?</p>



<a name="282390325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282390325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282390325">(May 15 2022 at 05:16)</a>:</h4>
<p>My new definition of <code>identical</code> really resembles it</p>



<a name="282390327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282390327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282390327">(May 15 2022 at 05:16)</a>:</h4>
<p>But I don't quite understand the docstring</p>



<a name="282390505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282390505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282390505">(May 15 2022 at 05:20)</a>:</h4>
<p>Also, is <code>≡</code> in use in mathlib? I want to use that for <code>identical</code></p>



<a name="282390693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282390693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282390693">(May 15 2022 at 05:26)</a>:</h4>
<p>It means what the docstring says: x has no more left moves and no less right moves than y. If you have fewer moves you are more likely to lose, so it implies x ≤ y: x is worse or equal for left than y.<br>
It's different from your definition because the maps are single sided: (L : x.left_moves → y.left_moves), not the other way around, (R : y.right_moves → x.right_moves), not the other way around.</p>



<a name="282391038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282391038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282391038">(May 15 2022 at 05:37)</a>:</h4>
<p>From my reading of the paper, to utilize <code>rw_mod_cast</code> for <code>pgame</code>, it seems we need to do the following:</p>
<ul>
<li>Introduce a has_coe instance from pgame to game (seems necessary).</li>
<li>write the <code>move</code> lemmas and mark them with <code>@[norm_cast]</code>: the quotient map (the cast) pgame → game respects add/neg/sub/zero</li>
<li>write and mark the <code>elim</code> lemmas: &lt; ≤ ⧏ are preserved by the cast, plus <code>↑a = ↑b ↔ a ≈ b</code></li>
<li><code>squash</code> lemmas should only be necessary when we have the casts pgame → pgame-mod-identical → game (maybe also for {x // x.numeric} → surreal → game and {x // x.numeric} → pgame → game?)</li>
</ul>



<a name="282391267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282391267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282391267">(May 15 2022 at 05:44)</a>:</h4>
<p>I proved that <code>x ≡ y</code> implies <code>restricted x y</code> (and of course, <code>restricted y x</code>)</p>



<a name="282391271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282391271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282391271">(May 15 2022 at 05:44)</a>:</h4>
<p>I wonder if the converse is true?</p>



<a name="282391274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282391274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282391274">(May 15 2022 at 05:44)</a>:</h4>
<p>That is, <code>restricted x y</code> and <code>restricted y x</code> imply <code>x ≡ y</code></p>



<a name="282392255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282392255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282392255">(May 15 2022 at 06:08)</a>:</h4>
<p>I have just produced one of the goofiest proofs ever</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- If `w` is identical to `x` and `y` is identical to `z`, then `w + y` is identical to `x + z`. -/</span>
<span class="kd">theorem</span> <span class="n">identical.add_congr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">w</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">}},</span> <span class="n">w</span> <span class="bp">≡</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≡</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">w</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">≡</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">z</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">wl</span><span class="o">,</span> <span class="n">wr</span><span class="o">,</span> <span class="n">wL</span><span class="o">,</span> <span class="n">wR</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">xl</span><span class="o">,</span> <span class="n">xr</span><span class="o">,</span> <span class="n">xL</span><span class="o">,</span> <span class="n">xR</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">yl</span><span class="o">,</span> <span class="n">yr</span><span class="o">,</span> <span class="n">yL</span><span class="o">,</span> <span class="n">yR</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">zl</span><span class="o">,</span> <span class="n">zr</span><span class="o">,</span> <span class="n">zL</span><span class="o">,</span> <span class="n">zR</span><span class="o">⟩</span>
  <span class="o">⟨</span><span class="n">Lwx</span><span class="o">,</span> <span class="n">Lxw</span><span class="o">,</span> <span class="n">Rwx</span><span class="o">,</span> <span class="n">Rxw</span><span class="o">,</span> <span class="n">HLwx</span><span class="o">,</span> <span class="n">HLxw</span><span class="o">,</span> <span class="n">HRwx</span><span class="o">,</span> <span class="n">HRxw</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Lyz</span><span class="o">,</span> <span class="n">Lzy</span><span class="o">,</span> <span class="n">Ryz</span><span class="o">,</span> <span class="n">Rzy</span><span class="o">,</span> <span class="n">HLyz</span><span class="o">,</span> <span class="n">HLzy</span><span class="o">,</span> <span class="n">HRyz</span><span class="o">,</span> <span class="n">HRzy</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">Hwx</span> <span class="o">:</span> <span class="o">⟨</span><span class="n">wl</span><span class="o">,</span> <span class="n">wr</span><span class="o">,</span> <span class="n">wL</span><span class="o">,</span> <span class="n">wR</span><span class="o">⟩</span> <span class="bp">≡</span> <span class="o">⟨</span><span class="n">xl</span><span class="o">,</span> <span class="n">xr</span><span class="o">,</span> <span class="n">xL</span><span class="o">,</span> <span class="n">xR</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Lwx</span><span class="o">,</span> <span class="n">Lxw</span><span class="o">,</span> <span class="n">Rwx</span><span class="o">,</span> <span class="n">Rxw</span><span class="o">,</span> <span class="n">HLwx</span><span class="o">,</span> <span class="n">HLxw</span><span class="o">,</span> <span class="n">HRwx</span><span class="o">,</span> <span class="n">HRxw</span><span class="o">⟩,</span>
  <span class="k">let</span> <span class="n">Hyz</span> <span class="o">:</span> <span class="o">⟨</span><span class="n">yl</span><span class="o">,</span> <span class="n">yr</span><span class="o">,</span> <span class="n">yL</span><span class="o">,</span> <span class="n">yR</span><span class="o">⟩</span> <span class="bp">≡</span> <span class="o">⟨</span><span class="n">zl</span><span class="o">,</span> <span class="n">zr</span><span class="o">,</span> <span class="n">zL</span><span class="o">,</span> <span class="n">zR</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Lyz</span><span class="o">,</span> <span class="n">Lzy</span><span class="o">,</span> <span class="n">Ryz</span><span class="o">,</span> <span class="n">Rzy</span><span class="o">,</span> <span class="n">HLyz</span><span class="o">,</span> <span class="n">HLzy</span><span class="o">,</span> <span class="n">HRyz</span><span class="o">,</span> <span class="n">HRzy</span><span class="o">⟩,</span>
  <span class="n">fsplit</span><span class="bp">;</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">i</span> <span class="bp">|</span> <span class="n">i</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inl</span> <span class="o">(</span><span class="n">Lwx</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inr</span> <span class="o">(</span><span class="n">Lyz</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inl</span> <span class="o">(</span><span class="n">Lxw</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inr</span> <span class="o">(</span><span class="n">Lzy</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inl</span> <span class="o">(</span><span class="n">Rwx</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inr</span> <span class="o">(</span><span class="n">Ryz</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inl</span> <span class="o">(</span><span class="n">Rxw</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">sum.inr</span> <span class="o">(</span><span class="n">Rzy</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span><span class="n">dsimp</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">HLwx</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">add_congr</span> <span class="n">Hyz</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">Hwx.add_congr</span> <span class="o">(</span><span class="n">HLyz</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">HLxw</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">add_congr</span> <span class="n">Hyz</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">Hwx.add_congr</span> <span class="o">(</span><span class="n">HLzy</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">HRwx</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">add_congr</span> <span class="n">Hyz</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">Hwx.add_congr</span> <span class="o">(</span><span class="n">HRyz</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">HRxw</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">add_congr</span> <span class="n">Hyz</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">Hwx.add_congr</span> <span class="o">(</span><span class="n">HRzy</span> <span class="n">i</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">dec_tac</span> <span class="o">:=</span> <span class="n">pgame_wf_tac</span> <span class="o">}</span>
</code></pre></div>



<a name="282392310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282392310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282392310">(May 15 2022 at 06:10)</a>:</h4>
<p>This is the only proof so far that has been somewhat longer than the previous proof about <code>relabelling</code>, and even then, I'd argue this proof is clearer than the original one</p>



<a name="282392346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282392346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282392346">(May 15 2022 at 06:11)</a>:</h4>
<p>(btw, I reordered some arguments in <code>identical</code> which made some proofs quite easier)</p>



<a name="282392827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282392827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282392827">(May 15 2022 at 06:24)</a>:</h4>
<p>Yeah, I think I was right! Proving that things are identical is pretty much as easy / hard as proving they're relabellings</p>



<a name="282392832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282392832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282392832">(May 15 2022 at 06:25)</a>:</h4>
<p>And in fact, I was even able to golf a bunch of proofs</p>



<a name="282392882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282392882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282392882">(May 15 2022 at 06:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282391274">said</a>:</p>
<blockquote>
<p>That is, <code>restricted x y</code> and <code>restricted y x</code> imply <code>x ≡ y</code></p>
</blockquote>
<p>It seems <code>x = {1,0| }, y = {1| }</code> is a counterexample.</p>



<a name="282394325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394325">(May 15 2022 at 07:06)</a>:</h4>
<p>Hmm... it seems like there is one theorem in mathlib that is no longer true with <code>identical</code> but was with <code>relabelling</code></p>



<a name="282394326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394326">(May 15 2022 at 07:06)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.short_of_relabelling">docs#pgame.short_of_relabelling</a></p>



<a name="282394330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394330">(May 15 2022 at 07:06)</a>:</h4>
<p>This isn't currently used anywhere, though</p>



<a name="282394419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394419">(May 15 2022 at 07:09)</a>:</h4>
<p>What should be done here?</p>



<a name="282394430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394430">(May 15 2022 at 07:09)</a>:</h4>
<p>I do think that there's little case in keeping <code>relabelling</code> around if we're going to have <code>identical</code>... but maybe there's <em>some</em> case</p>



<a name="282394668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394668">(May 15 2022 at 07:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282394330">said</a>:</p>
<blockquote>
<p>This isn't currently used anywhere, though</p>
</blockquote>
<p>Oh, it's actually used somewhere</p>



<a name="282394715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394715">(May 15 2022 at 07:16)</a>:</h4>
<p>Hmm</p>



<a name="282394729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394729">(May 15 2022 at 07:17)</a>:</h4>
<p>Being a relabelling is a strictly stronger notion than being identical, so maybe what we should have is a theorem showing one implies the other</p>



<a name="282394937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394937">(May 15 2022 at 07:21)</a>:</h4>
<p>Would be nice to have another symbol for the relabelling relation</p>



<a name="282394999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282394999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282394999">(May 15 2022 at 07:23)</a>:</h4>
<p>Maybe <code>≡r</code>?</p>



<a name="282395319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282395319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282395319">(May 15 2022 at 07:32)</a>:</h4>
<p>Is it used to show <code>domineering</code> is a short game? I forget.</p>



<a name="282395468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282395468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282395468">(May 15 2022 at 07:37)</a>:</h4>
<p>It's used in some theorems about short games, yeah</p>



<a name="282395471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282395471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282395471">(May 15 2022 at 07:37)</a>:</h4>
<p>I guess that for those, it's important to provide an actual bijection between moves</p>



<a name="282396443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396443">(May 15 2022 at 08:00)</a>:</h4>
<p>One way to recover that theorem is to define something like "essentially short" which means that from each position there are a finite number of equivalence classes up to <code>identical</code></p>



<a name="282396537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396537">(May 15 2022 at 08:03)</a>:</h4>
<p>note that a game is essentially short iff it is identical to a short game, and if you take that as the definition then the theorem becomes almost tautologically true</p>



<a name="282396689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396689">(May 15 2022 at 08:06)</a>:</h4>
<p>I think the question we should be asking is: should something like <code>{0, 0, 0, ... | }</code>with infinitely many zeros be short?</p>



<a name="282396700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396700">(May 15 2022 at 08:07)</a>:</h4>
<p>it is essentially short by my definition</p>



<a name="282396716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396716">(May 15 2022 at 08:07)</a>:</h4>
<p>This would probably break all of the computability on short games, though</p>



<a name="282396723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396723">(May 15 2022 at 08:07)</a>:</h4>
<p>how so</p>



<a name="282396768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396768">(May 15 2022 at 08:08)</a>:</h4>
<p>especially if essentially short came with an actual finset of equivalence class representatives</p>



<a name="282396778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396778">(May 15 2022 at 08:08)</a>:</h4>
<p>actually make that a list or multiset, there is no point in distinctness here</p>



<a name="282396808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396808">(May 15 2022 at 08:09)</a>:</h4>
<p>Hmm, that might work</p>



<a name="282396858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396858">(May 15 2022 at 08:10)</a>:</h4>
<p>So, to be clear, we do want to replace <code>relabelling</code> by <code>identical</code>, right?</p>



<a name="282396935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396935">(May 15 2022 at 08:12)</a>:</h4>
<p>I don't see why not have both, but making <code>identical</code> be the load bearing one seems good to me</p>



<a name="282396953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396953">(May 15 2022 at 08:13)</a>:</h4>
<p>...yeah, actually, it might be a better idea to just have both</p>



<a name="282396996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282396996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282396996">(May 15 2022 at 08:14)</a>:</h4>
<p>I do think we would need to mix them in the API, though</p>



<a name="282397000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397000">(May 15 2022 at 08:14)</a>:</h4>
<p>When possible, have <code>identical</code> in the hypotheses, and <code>relabelling</code> in the conclusions</p>



<a name="282397008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397008">(May 15 2022 at 08:14)</a>:</h4>
<p>well one implies the other so that seems fine</p>



<a name="282397132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397132">(May 15 2022 at 08:19)</a>:</h4>
<p>I now have another problem</p>



<a name="282397136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397136">(May 15 2022 at 08:19)</a>:</h4>
<p>I attempted to make <code>relabelling</code> into a <code>Prop</code></p>



<a name="282397143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397143">(May 15 2022 at 08:19)</a>:</h4>
<p>When making API for <code>nnreal</code> it's certainly handy to have <code>a \ne 0</code> in the hypotheses and <code>0 &lt; a</code> in the conclusions because of dot notation and <a href="https://leanprover-community.github.io/mathlib_docs/find/has_lt.lt.ne'">docs#has_lt.lt.ne'</a> , one could play the same trick here</p>



<a name="282397197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397197">(May 15 2022 at 08:20)</a>:</h4>
<p>Which to me makes a lot of sense: <code>relabelling</code> should be an equivalence relation, and it's not like we ever use the data</p>



<a name="282397204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397204">(May 15 2022 at 08:21)</a>:</h4>
<p>...except, we actually do use the data</p>



<a name="282397223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397223">(May 15 2022 at 08:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.short_of_relabelling">docs#pgame.short_of_relabelling</a></p>



<a name="282397224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397224">(May 15 2022 at 08:21)</a>:</h4>
<p>you said something about computability? I think we do use the data</p>



<a name="282397281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397281">(May 15 2022 at 08:22)</a>:</h4>
<p>There's no way to avoid this, is there? Unless we were to make short games noncomputable</p>



<a name="282397284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397284">(May 15 2022 at 08:22)</a>:</h4>
<p>certainly if <code>identical</code> is data and you have <code>identical_of_relabelling</code> you will need the data</p>



<a name="282397295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397295">(May 15 2022 at 08:22)</a>:</h4>
<p>I didn't mean for <code>identical</code> to be data either</p>



<a name="282397303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397303">(May 15 2022 at 08:22)</a>:</h4>
<p>like I said earlier this is like equiv vs bijective</p>



<a name="282397310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397310">(May 15 2022 at 08:22)</a>:</h4>
<p>guess which one sees more use in mathlib?</p>



<a name="282397329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397329">(May 15 2022 at 08:23)</a>:</h4>
<p>I don't think this is quite the same situation</p>



<a name="282397332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397332">(May 15 2022 at 08:23)</a>:</h4>
<p>Under normal circumstances, we really don't have any use for the data in a <code>relabelling</code></p>



<a name="282397335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397335">(May 15 2022 at 08:23)</a>:</h4>
<p>We can't "apply" a relabelling like we can an equivalence</p>



<a name="282397377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397377">(May 15 2022 at 08:24)</a>:</h4>
<p>why not?</p>



<a name="282397384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397384">(May 15 2022 at 08:24)</a>:</h4>
<p>you can take a strategy for one game and make a strategy for the other, or other things like that</p>



<a name="282397397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397397">(May 15 2022 at 08:24)</a>:</h4>
<p>That's just the relabelling itself</p>



<a name="282397400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397400">(May 15 2022 at 08:24)</a>:</h4>
<p>You're not applying it to anything</p>



<a name="282397409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397409">(May 15 2022 at 08:25)</a>:</h4>
<p>You might suppose you can apply a relabelling between <code>a</code> and <code>b</code> to a subsequent game of <code>a</code>, but even if this is possible we have no API whatsoever for this</p>



<a name="282397412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397412">(May 15 2022 at 08:25)</a>:</h4>
<p>if you have a play sequence on one game you can apply it to get a play sequence on the other</p>



<a name="282397451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397451">(May 15 2022 at 08:26)</a>:</h4>
<p>I think just about any data "about" a game can be remapped across the relabelling</p>



<a name="282397454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397454">(May 15 2022 at 08:26)</a>:</h4>
<p>so it really does look like equiv to me</p>



<a name="282397456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397456">(May 15 2022 at 08:26)</a>:</h4>
<p>Hmm... you're right</p>



<a name="282397459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397459">(May 15 2022 at 08:26)</a>:</h4>
<p>We currently have no API for this at all, but it's certainly something that could at some point be worked on</p>



<a name="282397461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397461">(May 15 2022 at 08:26)</a>:</h4>
<p>that all mostly applies to <code>identical</code> as well</p>



<a name="282397491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397491">(May 15 2022 at 08:27)</a>:</h4>
<p>Alright, I see why this should be data</p>



<a name="282397883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282397883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282397883">(May 15 2022 at 08:36)</a>:</h4>
<p>Before trying to do any of the <code>identical</code> stuff, I've opened <a href="https://github.com/leanprover-community/mathlib/pull/14155">#14155</a> to add the <code>≡r</code>notation for relabellings and clean up some proofs</p>



<a name="282398677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282398677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282398677">(May 15 2022 at 08:57)</a>:</h4>
<p>I should probably outline what I'm getting at with all this</p>



<a name="282398837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282398837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282398837">(May 15 2022 at 09:00)</a>:</h4>
<p>The idea is to first define this identical relation. Then, we define the quotient of games by this relation and prove that negation, addition, and multiplication (?) can be lifted to this quotient. This should save us from the pain of <code>congr</code> lemmas when proving identities or relabellings.</p>



<a name="282398867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282398867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282398867">(May 15 2022 at 09:01)</a>:</h4>
<p>Note that <code>game</code> can't do this, as the relabelling relation doesn't lift to it</p>



<a name="282399098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282399098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282399098">(May 15 2022 at 09:07)</a>:</h4>
<p>Hmmm... wait. If I really want to do this, then I actually need to define two quotients, one for relabelings and one for identical games</p>



<a name="282399168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282399168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282399168">(May 15 2022 at 09:08)</a>:</h4>
<p>This feels excessive and redundant, but it also seems like the easiest way to work with these two relations</p>



<a name="282425919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282425919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282425919">(May 15 2022 at 19:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282382848">said</a>:</p>
<blockquote>
<p>So you might need to induct on a generic multiset <code>s</code> and make the inductive hypotheses "if <code>{x, y}</code> is less than <code>s</code> then <code>P1</code>,  ..."</p>
</blockquote>
<p>I'm currently using your <code>mul_args</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">cut_expand</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a'</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">s'</span> <span class="bp">=</span> <span class="n">s.erase</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">t</span>

<span class="kd">inductive</span> <span class="n">mul_args</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">P1</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">mul_args</span>
<span class="bp">|</span> <span class="n">P24</span> <span class="o">(</span><span class="n">x₁</span> <span class="n">x₂</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">mul_args</span>

<span class="kd">def</span> <span class="n">to_multiset</span> <span class="o">:</span> <span class="n">mul_args</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">pgame</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mul_args.P1</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mul_args.P24</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x₁</span><span class="o">,</span> <span class="n">x₂</span><span class="o">,</span> <span class="n">y</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">hyp</span> <span class="o">:</span> <span class="n">mul_args</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mul_args.P1</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">numeric</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">numeric</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">numeric</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mul_args.P24</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">numeric</span> <span class="n">x₁</span> <span class="bp">→</span> <span class="n">numeric</span> <span class="n">x₂</span> <span class="bp">→</span> <span class="n">numeric</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">P24</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">ces</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">inv_image</span> <span class="o">(</span><span class="n">cut_expand</span> <span class="n">subsequent</span><span class="o">)</span> <span class="n">to_multiset</span>

<span class="kd">theorem</span> <span class="n">P1_of_P24</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a'</span><span class="o">,</span> <span class="n">ces</span> <span class="n">a'</span> <span class="o">(</span><span class="n">mul_args.P1</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">hyp</span> <span class="n">a'</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x.numeric</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y.numeric</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">numeric</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>seems to be working fine!</p>



<a name="282427973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282427973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282427973">(May 15 2022 at 20:40)</a>:</h4>
<p>That's pretty amazing</p>



<a name="282427978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282427978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282427978">(May 15 2022 at 20:40)</a>:</h4>
<p>Do you have a proof sketch for the hydra game ending?</p>



<a name="282428048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282428048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282428048">(May 15 2022 at 20:42)</a>:</h4>
<p>I think that warrants its own separate PR</p>



<a name="282428372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282428372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282428372">(May 15 2022 at 20:50)</a>:</h4>
<p>And I'd be glad to help if possible</p>



<a name="282428602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282428602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282428602">(May 15 2022 at 20:57)</a>:</h4>
<p><a href="https://gist.github.com/alreadydone/9eea203363bb76e5306c35a75550b836">This is a full proof in under 100 lines</a>.</p>



<a name="282428872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282428872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282428872">(May 15 2022 at 21:02)</a>:</h4>
<p>Yeah, I believe this is an interesting enough result to maybe even have its own file</p>



<a name="282428877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282428877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282428877">(May 15 2022 at 21:03)</a>:</h4>
<p>Obviously the PR wouldn't be stated in terms of games, though</p>



<a name="282428937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282428937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282428937">(May 15 2022 at 21:04)</a>:</h4>
<p>Note: the proof of <code>le_trans</code> could be stated in terms of this, though I don't think it's large enough that this would be able to golf it</p>



<a name="282429017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429017">(May 15 2022 at 21:06)</a>:</h4>
<p>Since it's just 100 lines I think it could go to the end of <a href="https://leanprover-community.github.io/mathlib_docs/logic/relation.html">https://leanprover-community.github.io/mathlib_docs/logic/relation.html</a> instead of having its own file.</p>
<p>I'd like to PR it, but maybe I'll wait until I fill in more details in the Theorem 3.8 proof to convince that this well-foundedness result is the only thing left to make the proof work.</p>



<a name="282429034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429034">(May 15 2022 at 21:07)</a>:</h4>
<p>Wait, you're working on that independently?</p>



<a name="282429083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429083">(May 15 2022 at 21:08)</a>:</h4>
<p>I have looked at your code</p>



<a name="282429098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429098">(May 15 2022 at 21:09)</a>:</h4>
<p>but instead of doing it in one stretch I try to extract lemmas that apply to multiple cases</p>



<a name="282429183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429183">(May 15 2022 at 21:11)</a>:</h4>
<p>That's what I've attempted too, but all of these lemmas seem to depend on the same induction hypotheses</p>



<a name="282429249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429249">(May 15 2022 at 21:13)</a>:</h4>
<p>your <code>surreal_mul</code> branch hasn't been updated for almost 2 weeks, is there any new progress? I see that you are busy with other PRs.</p>
<p>I think I really just started to write code about Theorem 3.8 today, after the &lt; correction was merged. I've shown one of the four cases of P1 follows from the induction hypothesis, and is now hoping the same lemmas that solved this case would also solve the other cases.</p>



<a name="282429287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429287">(May 15 2022 at 21:14)</a>:</h4>
<p>I just merged with master :P</p>



<a name="282429290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429290">(May 15 2022 at 21:14)</a>:</h4>
<p>Yeah, I've been busy with other PRs</p>



<a name="282429298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429298">(May 15 2022 at 21:14)</a>:</h4>
<p>I wanted a certain lemma on birthdays, which necessitated a certain lemma on ordinals, and that led me down a rabbit hole of fixing some glaring holes in that API</p>



<a name="282429302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429302">(May 15 2022 at 21:14)</a>:</h4>
<p>I still haven't even added that darned lemma</p>



<a name="282429308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429308">(May 15 2022 at 21:15)</a>:</h4>
<p>But it wouldn't be necessary with your new approach</p>



<a name="282429314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429314">(May 15 2022 at 21:15)</a>:</h4>
<p>I'll see if I can continue work on the proof within the next few days</p>



<a name="282429386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429386">(May 15 2022 at 21:16)</a>:</h4>
<p>And you know, the sheer work you've put into your new framework for games is starting to convince me that it might be worth it, but I have no idea how I would pitch this to everyone else</p>



<a name="282429403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429403">(May 15 2022 at 21:17)</a>:</h4>
<p>Still a bit worried about e.g. the ordinal and nim API though</p>



<a name="282429587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282429587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282429587">(May 15 2022 at 21:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282429298">said</a>:</p>
<blockquote>
<p>I wanted a certain lemma on birthdays, which necessitated a certain lemma on ordinals, and that led me down a rabbit hole of fixing some glaring holes in that API</p>
</blockquote>
<p>I find it strange to see the <code>birthday (x + y)</code> stuff in your code. Why not express it in terms of <code>birthday x</code> and <code>birthday y</code>?  Seems that <code>(x + y)</code> doesn't appear in the options of the product of two games?</p>



<a name="282430414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282430414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282430414">(May 15 2022 at 21:42)</a>:</h4>
<p>As far as I know (and I don't know that many things) there isn't any nice form for the birthday of the sum of two games</p>



<a name="282430425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282430425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282430425">(May 15 2022 at 21:42)</a>:</h4>
<p>(deleted)</p>



<a name="282430426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282430426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282430426">(May 15 2022 at 21:42)</a>:</h4>
<p>However, this value does have the property that it decreases when you replace either game by a subsequent one</p>



<a name="282430498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282430498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282430498">(May 15 2022 at 21:44)</a>:</h4>
<p>Further, if the birthday of y is less than the birthday of z, the birthday of x + y is less than the birthday of x + z</p>



<a name="282431436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282431436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282431436">(May 15 2022 at 22:06)</a>:</h4>
<p>I think that's now called something like <code>covariant_class (+) (&lt;)</code> or something</p>



<a name="282432346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282432346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282432346">(May 15 2022 at 22:31)</a>:</h4>
<p>We don't have any named relation for "the birthday of x is less than the birthday of y" though</p>



<a name="282432347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282432347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282432347">(May 15 2022 at 22:31)</a>:</h4>
<p>I don't think we need it either</p>



<a name="282434161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282434161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282434161">(May 15 2022 at 23:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282430498">said</a>:</p>
<blockquote>
<p>Further, if the birthday of y is less than the birthday of z, the birthday of x + y is less than the birthday of x + z</p>
</blockquote>
<p>Note, I'm only 99% sure of this</p>



<a name="282434187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282434187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282434187">(May 15 2022 at 23:18)</a>:</h4>
<p>I wanted to prove it in Lean, but for that I needed a lemma <code>lsub_sum</code>, which would be a consequence of <code>sup_sum</code>, which would be a consequence of <code>csup_sum</code>, which I had no idea where to put because <code>conditionally_complete_lattice.lean</code> and <code>complete_lattice.lean</code> are very different files despite most of the same theorems being true... you get my point</p>



<a name="282435007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435007">(May 15 2022 at 23:36)</a>:</h4>
<p>Predictably, this <code>lf</code> refactor broke what I had of the surreal multiplication proof</p>



<a name="282435024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435024">(May 15 2022 at 23:37)</a>:</h4>
<p>I'll try to fix it later today</p>



<a name="282435327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435327">(May 15 2022 at 23:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282434161">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282430498">said</a>:</p>
<blockquote>
<p>Further, if the birthday of y is less than the birthday of z, the birthday of x + y is less than the birthday of x + z</p>
</blockquote>
<p>Note, I'm only 99% sure of this</p>
</blockquote>
<p>That sounds false, at least with strict less than</p>



<a name="282435411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435411">(May 15 2022 at 23:46)</a>:</h4>
<p>I think if the birthday of <code>x</code> is large then it will dominate and the birthday of <code>x + y</code> will be the same as <code>x</code> or maybe one more</p>



<a name="282435489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435489">(May 15 2022 at 23:48)</a>:</h4>
<p>(at least, I am taking it as analogous to the claim that <code>rank y &lt; rank z -&gt; rank (x ⊔ y) &lt; rank (x ⊔ z)</code> in zfc)</p>



<a name="282435579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435579">(May 15 2022 at 23:50)</a>:</h4>
<p>Oh no wait I remember now, this is the <a href="https://en.wikipedia.org/wiki/Ordinal_arithmetic#Natural_operations">natural sum</a> operation on ordinals</p>



<a name="282435591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435591">(May 15 2022 at 23:51)</a>:</h4>
<p>which we don't have any API for</p>



<a name="282435658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282435658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282435658">(May 15 2022 at 23:52)</a>:</h4>
<p>That is, I claim that <code>birthday (x + y) = birthday x # birthday y</code></p>



<a name="282436111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436111">(May 16 2022 at 00:02)</a>:</h4>
<p>Let me sketch a proof of that claim:</p>
<p>We first prove that <code>birthday y ≤ birthday z → birthday (x + y) ≤ birthday (x + z)</code> by Conway induction. Separate each birthday as the <code>max</code> of four <code>lsub</code>s. By the inductive hypotheses, these are less-or-equal respectively.</p>
<p>Then, if <code>birthday y &lt; birthday z</code>, there exists some option<code>z'</code> of <code>z</code> with <code>birthday y ≤ birthday z'</code>, so that <code>birthday (x + y) ≤ birthday (x + z') &lt; birthday (x + z)</code>.</p>



<a name="282436131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436131">(May 16 2022 at 00:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282435579">said</a>:</p>
<blockquote>
<p>Oh no wait I remember now, this is the <a href="https://en.wikipedia.org/wiki/Ordinal_arithmetic#Natural_operations">natural sum</a> operation on ordinals</p>
</blockquote>
<p>Nice! Yet another thing I can do with ordinals!</p>



<a name="282436140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436140">(May 16 2022 at 00:03)</a>:</h4>
<p>And yes, I believe that <code>y &lt; z -&gt; x # y &lt; x # z</code></p>



<a name="282436265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436265">(May 16 2022 at 00:06)</a>:</h4>
<p>the theory of natural sum/product is pretty darn similar to the theory of birthdays of surreals though, it might not be worth the rephrasing</p>



<a name="282436285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436285">(May 16 2022 at 00:07)</a>:</h4>
<p>there is one novelty you get with the ordinal formulation though, which is the concrete definition of natural sum given by lining up the cantor normal forms and adding things pointwise</p>



<a name="282436360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436360">(May 16 2022 at 00:08)</a>:</h4>
<p>Whoa, that works?</p>



<a name="282436361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436361">(May 16 2022 at 00:08)</a>:</h4>
<p>That's really cool</p>



<a name="282436379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436379">(May 16 2022 at 00:09)</a>:</h4>
<p>We don't need to "rephrase" ordinal birthdays in terms of the natural sum and product. But we could define the natural sum and product on ordinals, prove all the necessary theorems, then simply transfer them to surreal birthdays</p>



<a name="282436446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436446">(May 16 2022 at 00:11)</a>:</h4>
<p>yup, it's mentioned at the end of that wikipedia section</p>



<a name="282436705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282436705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282436705">(May 16 2022 at 00:17)</a>:</h4>
<p>The easiest way to prove it probably goes via the observation that the natural sum is the greatest order type of a total order extending the disjoint union of types with order types <code>x</code> and <code>y</code> respectively. It is easy to see that the pointwise sum of cantor orderings is <em>a</em> way to order that disjoint union: you take all the A stuff and then all the B stuff in each coordinate, which proves that the cantor formula is <code>&lt;= x # y</code>. For the reverse I think you can use ordinal induction, although it looks messy</p>



<a name="282437359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282437359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282437359">(May 16 2022 at 00:31)</a>:</h4>
<p>I think we'll need quite a lot more API for Cantor normal forms to get this to work</p>



<a name="282451874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282451874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282451874">(May 16 2022 at 05:56)</a>:</h4>
<p>It's not immediate to fix my progress on the multiplication proof</p>



<a name="282451878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282451878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282451878">(May 16 2022 at 05:56)</a>:</h4>
<p>I had taken a few shortcuts that just don't work anymore</p>



<a name="282451893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282451893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282451893">(May 16 2022 at 05:57)</a>:</h4>
<p>Which leads to the question of whether I was actually simplifying the proof by using <code>lf</code> instead of <code>lt</code>, or if my approach was flawed and I just hadn't realized it</p>



<a name="282451961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282451961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282451961">(May 16 2022 at 05:58)</a>:</h4>
<p>I'm going to have to go over the proof again with what I now know and evaluate this, and I am currently too tired to do so</p>



<a name="282451964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282451964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282451964">(May 16 2022 at 05:58)</a>:</h4>
<p>So maybe tomorrow</p>



<a name="282453301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282453301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282453301">(May 16 2022 at 06:20)</a>:</h4>
<p>On an unrelated note</p>



<a name="282453312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282453312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282453312">(May 16 2022 at 06:20)</a>:</h4>
<p>We have a consensus on <code>\&lt;|</code> and <code>\lf</code> being useful shortcuts, right?</p>



<a name="282455163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455163">(May 16 2022 at 06:49)</a>:</h4>
<p>I lied, I'm looking at the proof right now :P</p>



<a name="282455184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455184">(May 16 2022 at 06:49)</a>:</h4>
<p><a href="/user_uploads/3121/sGiOP5BkK_05bpjqS33lJX_5/image.png">image.png</a> This right here is an iff, if <code>z₁</code> and <code>z₂</code> are numeric</p>
<div class="message_inline_image"><a href="/user_uploads/3121/sGiOP5BkK_05bpjqS33lJX_5/image.png" title="image.png"><img src="/user_uploads/3121/sGiOP5BkK_05bpjqS33lJX_5/image.png"></a></div>



<a name="282455210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455210">(May 16 2022 at 06:49)</a>:</h4>
<p>This is an immediate consequence of <code>le_def_lt</code>, the numeric counterpart to <code>le_def_lf</code> (which I have already PR'd)</p>



<a name="282455275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455275">(May 16 2022 at 06:50)</a>:</h4>
<p>I wonder, can we get away with the if direction without assuming that these are numeric?</p>



<a name="282455307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455307">(May 16 2022 at 06:50)</a>:</h4>
<p>It isn't really a problem, this dependency still satisfies the hydra relation, but it's a dependency I hadn't accounted for before</p>



<a name="282455655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455655">(May 16 2022 at 06:55)</a>:</h4>
<p><code>pgame.le_def_lf</code> doesn't assume numeric, and we are proving <code>lt</code>, which implies <code>lf</code> unconditionally, so I don't see any additional dependency.</p>



<a name="282455819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282455819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282455819">(May 16 2022 at 06:57)</a>:</h4>
<p>Oh, you're right</p>



<a name="282456060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282456060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282456060">(May 16 2022 at 07:00)</a>:</h4>
<p>So, it seems like we can prove P2 by using a weaker form of P4 using <code>lf</code> instead of <code>lt</code></p>



<a name="282456134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282456134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282456134">(May 16 2022 at 07:01)</a>:</h4>
<p>Here's the question: can we perhaps do the rest of the proof from this weaker P4'?</p>



<a name="282456147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282456147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282456147">(May 16 2022 at 07:01)</a>:</h4>
<p>If so then we've found a way to simplify the argument</p>



<a name="282456302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282456302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282456302">(May 16 2022 at 07:03)</a>:</h4>
<p>I'm a bit skeptical of this working though, since <code>add_lf_add</code> isn't actually true</p>



<a name="282456380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282456380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282456380">(May 16 2022 at 07:04)</a>:</h4>
<p>Hmm... in fact, this would have doomed my proof if I hadn't realized we had <code>lt</code> and <code>lf</code> swapped</p>



<a name="282459275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282459275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282459275">(May 16 2022 at 07:39)</a>:</h4>
<p>Alright, I got the proof working again... or rather, what I had written of it</p>



<a name="282459286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282459286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282459286">(May 16 2022 at 07:39)</a>:</h4>
<p>There's little missing now, other than the proof of well-foundedness</p>



<a name="282459298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282459298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282459298">(May 16 2022 at 07:39)</a>:</h4>
<p>I think I can finish the skeleton tonight</p>



<a name="282465447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282465447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282465447">(May 16 2022 at 08:42)</a>:</h4>
<p>Yeah actually no</p>



<a name="282465529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282465529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282465529">(May 16 2022 at 08:42)</a>:</h4>
<p>I am way past my bedtime and I only finished one of eight (?) remaining cases</p>



<a name="282508293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282508293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282508293">(May 16 2022 at 15:01)</a>:</h4>
<p>I got this as the output of <code>abel</code></p>



<a name="282508295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282508295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282508295">(May 16 2022 at 15:01)</a>:</h4>
<p><a href="/user_uploads/3121/G4ZBmgY0dsKmuUgnARqlCEJX/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/G4ZBmgY0dsKmuUgnARqlCEJX/image.png" title="image.png"><img src="/user_uploads/3121/G4ZBmgY0dsKmuUgnARqlCEJX/image.png"></a></div>



<a name="282508348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282508348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282508348">(May 16 2022 at 15:01)</a>:</h4>
<p>Note that <code>⟦x₁R jx₁ * mk yl yr yL yR⟧</code> appears on both sides of the inequality</p>



<a name="282508461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282508461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282508461">(May 16 2022 at 15:02)</a>:</h4>
<p>Is there some easy way to make <code>abel</code> realize this and cancel them out? Or some other tactic that does the job better?</p>



<a name="282508529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282508529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282508529">(May 16 2022 at 15:02)</a>:</h4>
<p>Note: the original expression was even more complicated, and <code>abel</code> did successfully cancel out one of two pairs of common terms</p>



<a name="282508796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282508796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282508796">(May 16 2022 at 15:04)</a>:</h4>
<p>"cancelling out" means "applying a monotonicity lemma", so I think it's out of scope for <code>abel</code>.</p>



<a name="282509788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282509788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282509788">(May 16 2022 at 15:11)</a>:</h4>
<p>Is there any other tactic that can deal with this?</p>



<a name="282509888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282509888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282509888">(May 16 2022 at 15:12)</a>:</h4>
<p>For full context: here's my hypothesis and my goal <a href="/user_uploads/3121/ekF6zvgKCSDOwFfr5LfF-Q4n/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/ekF6zvgKCSDOwFfr5LfF-Q4n/image.png" title="image.png"><img src="/user_uploads/3121/ekF6zvgKCSDOwFfr5LfF-Q4n/image.png"></a></div>



<a name="282509940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282509940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282509940">(May 16 2022 at 15:12)</a>:</h4>
<p><code>x₁</code> is def-eq to <code>mk x₁l x₁r x₁L xᵣ</code> btw, same goes for <code>x₂</code></p>



<a name="282510044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282510044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282510044">(May 16 2022 at 15:13)</a>:</h4>
<p>Actually, there might be some syntactic equality troubles that prevent a single tactic from closing the goal, but simplifying <code>H₃</code> enough that I can just use one or two <code>rw add_comm</code> and <code>exact</code> would be amazing</p>



<a name="282511100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282511100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282511100">(May 16 2022 at 15:21)</a>:</h4>
<p>Use some lemma to rewrite H3 to the form <code>0 &lt; _</code> and then try <code>abel</code>?</p>



<a name="282511412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282511412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282511412">(May 16 2022 at 15:23)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#monotonicity">tactic#monotonicity</a></p>



<a name="282514590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282514590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282514590">(May 16 2022 at 15:46)</a>:</h4>
<p>You mean <code>mono</code>?</p>



<a name="282514603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282514603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282514603">(May 16 2022 at 15:46)</a>:</h4>
<p><code>mono at H₃</code> doesn't seem to work</p>



<a name="282514813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282514813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282514813">(May 16 2022 at 15:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282511100">said</a>:</p>
<blockquote>
<p>Use some lemma to rewrite H3 to the form <code>0 &lt; _</code> and then try <code>abel</code>?</p>
</blockquote>
<p>This might work, maybe <code>apply_rules</code> could do this?</p>



<a name="282524865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282524865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282524865">(May 16 2022 at 16:56)</a>:</h4>
<p>I have proven four out of eight goals in the very last stretch of the skeleton of the proof!</p>



<a name="282524874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282524874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282524874">(May 16 2022 at 16:56)</a>:</h4>
<p>The skeleton will be ready really soon</p>



<a name="282524901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282524901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282524901">(May 16 2022 at 16:56)</a>:</h4>
<p>(today in messages that are funnier without context)</p>



<a name="282537301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282537301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282537301">(May 16 2022 at 18:05)</a>:</h4>
<p>Six out of eight!</p>



<a name="282538196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282538196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282538196">(May 16 2022 at 18:11)</a>:</h4>
<p>Eight out of eight!!!!!!</p>



<a name="282538208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282538208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282538208">(May 16 2022 at 18:11)</a>:</h4>
<p>Alright, the skeleton of the proof is done</p>



<a name="282538319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282538319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282538319">(May 16 2022 at 18:12)</a>:</h4>
<p>This is almost 300 lines of code for a single proof (which I presume is some sort of mathlib record?)</p>



<a name="282538333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282538333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282538333">(May 16 2022 at 18:12)</a>:</h4>
<p>There's definitely room for golfing though</p>



<a name="282538875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282538875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282538875">(May 16 2022 at 18:16)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span></p>



<a name="282538975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282538975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282538975">(May 16 2022 at 18:17)</a>:</h4>
<p>I tried to make the induction step easier to prove by deduplicating applications of the induction hypothesis</p>



<a name="282539082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282539082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282539082">(May 16 2022 at 18:18)</a>:</h4>
<p>Even then, there are a whopping 36 applications we need to prove well-founded</p>



<a name="282541710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282541710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282541710">(May 16 2022 at 18:36)</a>:</h4>
<p>I'm going through each of them and verifying they satisfy the <code>cut_expand</code> relation</p>



<a name="282541758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282541758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282541758">(May 16 2022 at 18:36)</a>:</h4>
<p>Not formally, yet</p>



<a name="282542138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542138">(May 16 2022 at 18:39)</a>:</h4>
<p>Actually, the <code>cut_expand</code> relation is a wee bit too weak</p>



<a name="282542161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542161">(May 16 2022 at 18:39)</a>:</h4>
<p>It seems like we need its transitive closure</p>



<a name="282542178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542178">(May 16 2022 at 18:39)</a>:</h4>
<p>Fortunately I proved not too long ago that the transitive closure of a well-founded relation is well-founded</p>



<a name="282542632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542632">(May 16 2022 at 18:42)</a>:</h4>
<p>Now, here's the kicker</p>



<a name="282542752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542752">(May 16 2022 at 18:43)</a>:</h4>
<p>What's a succint way to prove two multisets satisfy the <code>cut_expand</code> relation?</p>



<a name="282542771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542771">(May 16 2022 at 18:43)</a>:</h4>
<p><a href="/user_uploads/3121/wW5JrWsEEUKZwsvi6pESlI_w/image.png">image.png</a> If we provide <code>t</code>, are the other proofs <code>rfl</code>?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/wW5JrWsEEUKZwsvi6pESlI_w/image.png" title="image.png"><img src="/user_uploads/3121/wW5JrWsEEUKZwsvi6pESlI_w/image.png"></a></div>



<a name="282542901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542901">(May 16 2022 at 18:44)</a>:</h4>
<p>It's great that you finished the proof! I'll hopefully PR my part tonight. I'll probably change <code>s' = s.erase a + t</code> to <code>s' + {a} = s + t</code> in <code>cut_expand</code>, as it avoids <code>decidable_eq</code> and it's probably easier to show concrete multisets satisfy the relation with <code>+</code> instead of <code>erase</code>.</p>
<p>And I think I'll also define an <code>inductive</code> relation on <code>mul_args</code> that is a subrelation of <code>inv_image (trans_gen $ cut_expand is_option)</code> (so well-founded and we can have the <code>has_well_founded</code> instance on <code>mul_args</code>) and covers all cases we need, and then we can define a wf tactic that use <code>solve_by_elim</code> with the constructors of the relation to fulfill the wf obligations.</p>



<a name="282542968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282542968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282542968">(May 16 2022 at 18:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282542752">said</a>:</p>
<blockquote>
<p>What's a succint way to prove two multisets satisfy the <code>cut_expand</code> relation?</p>
</blockquote>
<p>The docs for <code>fin_cases</code>appears like that it could solve these, but actually not.</p>



<a name="282543025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282543025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282543025">(May 16 2022 at 18:45)</a>:</h4>
<p>The most systematic way I can think of now is to use <code>add_singleton</code> to expand it to sum of singletons, then use commutativity, associativity etc. (Notice that <code>{a,b,c}</code> is something like <code>({a}.cons b).cons c</code> under the hood.)</p>



<a name="282543331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282543331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282543331">(May 16 2022 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282542901">said</a>:</p>
<blockquote>
<p>And I think I'll also define an <code>inductive</code> relation on <code>mul_args</code> that is a subrelation of <code>inv_image (trans_gen $ cut_expand is_option)</code> (so well-founded and we can have the <code>has_well_founded</code> instance on <code>mul_args</code>) and covers all cases we need, and then we can define a wf tactic that use <code>solve_by_elim</code> with the constructors of the relation to fulfill the wf obligations.</p>
</blockquote>
<p>Already on it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_lt</span> <span class="n">mul_args</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">inv_image</span> <span class="o">(</span><span class="n">relation.trans_gen</span> <span class="bp">$</span> <span class="n">cut_expand</span> <span class="n">subsequent</span><span class="o">)</span> <span class="n">to_multiset</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_well_founded</span> <span class="n">mul_args</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">),</span>
  <span class="n">wf</span> <span class="o">:=</span> <span class="n">inv_image.wf</span> <span class="n">_</span> <span class="o">(</span><span class="n">cut_expand.wf</span> <span class="n">wf_subsequent</span><span class="o">)</span><span class="bp">.</span><span class="n">trans_gen</span> <span class="o">}</span>
</code></pre></div>



<a name="282543561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282543561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282543561">(May 16 2022 at 18:50)</a>:</h4>
<p>I'm writing down the sorries for the well-foundedness proofs</p>



<a name="282545237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282545237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282545237">(May 16 2022 at 19:00)</a>:</h4>
<p>There! I've sorried all 36 of them</p>



<a name="282545253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282545253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282545253">(May 16 2022 at 19:00)</a>:</h4>
<p>And they should all be true</p>



<a name="282545863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282545863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282545863">(May 16 2022 at 19:04)</a>:</h4>
<p>How does your new definition for <code>cut_expand</code> look like?</p>



<a name="282545874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282545874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282545874">(May 16 2022 at 19:04)</a>:</h4>
<p>I want to try some things out with it</p>



<a name="282546495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282546495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282546495">(May 16 2022 at 19:08)</a>:</h4>
<p>I presume it's this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">cut_expand</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">s'</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a'</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">r</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">s'</span> <span class="bp">+</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">=</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">t</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">cut_expand</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">}</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="mi">3</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">fin_cases</span> <span class="n">h</span><span class="bp">;</span>
    <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dec_trivial</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282546887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282546887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282546887">(May 16 2022 at 19:11)</a>:</h4>
<p>Interesting, changing <code>erase</code> to <code>+</code> makes it decidable and fin_cases applicable?</p>



<a name="282546981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282546981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282546981">(May 16 2022 at 19:12)</a>:</h4>
<p>At least for naturals</p>



<a name="282547012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282547012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282547012">(May 16 2022 at 19:12)</a>:</h4>
<p>Oh yes, pgame doesn't have decidable_eq</p>



<a name="282547117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282547117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282547117">(May 16 2022 at 19:13)</a>:</h4>
<p>Is there any way to prove goals like <code>x₁ ∈ {x₁, x₂, x₃}</code> easily without <code>decidable_eq</code>?</p>



<a name="282547279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282547279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282547279">(May 16 2022 at 19:15)</a>:</h4>
<p>Or god forbid, something like this <a href="/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png" title="image.png"><img src="/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png"></a></div>



<a name="282552267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282552267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282552267">(May 16 2022 at 19:59)</a>:</h4>
<p>I've started filling out the sorries</p>



<a name="282552350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282552350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282552350">(May 16 2022 at 20:00)</a>:</h4>
<p>The one that I'm going to leave open is the one for <code>cut_expand.wf</code></p>



<a name="282552369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282552369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282552369">(May 16 2022 at 20:00)</a>:</h4>
<p>That's all yours</p>



<a name="282552506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282552506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282552506">(May 16 2022 at 20:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282547117">said</a>:</p>
<blockquote>
<p>Is there any way to prove goals like <code>x₁ ∈ {x₁, x₂, x₃}</code> easily without <code>decidable_eq</code>?</p>
</blockquote>
<p>Maybe <code>simp only [multiset.mem_cons]</code> then use <code>rfl</code> with some <code>or.inl</code>, <code>or.inr</code>.</p>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282547279">said</a>:</p>
<blockquote>
<p>Or god forbid, something like this <a href="/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png">image.png</a></p>
</blockquote>
<p>maybe <code>simp only [&lt;- multiset.singleton_add], abel</code></p>



<a name="282552931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282552931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282552931">(May 16 2022 at 20:04)</a>:</h4>
<p>I filled in some simple lemmas for <code>P1 x' y' &lt; P1 x y</code>, we're already down to 26 sorries</p>



<a name="282553095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282553095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282553095">(May 16 2022 at 20:05)</a>:</h4>
<p>Actually I want to remove the <code>a ∈ s</code> condition, which is unnecessary for irreflexive relation <code>r</code>.</p>



<a name="282557697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282557697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282557697">(May 16 2022 at 20:42)</a>:</h4>
<p>Every well-founded relation is irreflexive</p>



<a name="282557711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282557711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282557711">(May 16 2022 at 20:42)</a>:</h4>
<p>So yeah, you should remove that</p>



<a name="282583125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282583125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282583125">(May 17 2022 at 01:45)</a>:</h4>
<p>I'm having a bit of trouble</p>



<a name="282583128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282583128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282583128">(May 17 2022 at 01:45)</a>:</h4>
<p>Not with the proofs themselves</p>



<a name="282583150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282583150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282583150">(May 17 2022 at 01:45)</a>:</h4>
<p>But rather, giving names to like 10 auxiliary lemmas for that relation is not really working out haha</p>



<a name="282585400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282585400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282585400">(May 17 2022 at 02:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282552506">said</a>:</p>
<blockquote>
<p>maybe <code>simp only [&lt;- multiset.singleton_add], abel</code></p>
</blockquote>
<p>Just need an additional <code>rw multiset.has_insert</code> to make it work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.multiset.basic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">}</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">multiset.has_insert</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.singleton_add</span><span class="o">],</span> <span class="n">abel</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282585419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282585419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282585419">(May 17 2022 at 02:27)</a>:</h4>
<p>However it's still cumbersome. Maybe wrap it into a single local tactic? I think Lean can't come up with <code>t</code> (=<code>s' + {a} - s</code>) automatically because <code>multiset.has_sub</code> uses decidable_eq.</p>



<a name="282586471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282586471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282586471">(May 17 2022 at 02:49)</a>:</h4>
<p>On second thought, I'm not sure this will help</p>



<a name="282586505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282586505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282586505">(May 17 2022 at 02:50)</a>:</h4>
<p>I've been able to produce relatively short proofs for the theorems I've needed, without relying on things like these</p>



<a name="282593953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282593953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282593953">(May 17 2022 at 05:16)</a>:</h4>
<p>I think if you adopt my approach and define (&lt;) on mul_args as an <code>inductive</code> relation, then you can replace the ~10 auxiliary lemmas with ~10 constructors; you can prove it's a subrelation of the <code>inv_image</code> in a single lemma, and use <code>subrelation.wf</code> to show it's well-founded. And here's a way to name the constructors systematically; for example, the constructor that produces <code>mul_args.P1 y x₂L &lt; mul_args.P24 x₁ x₂ y</code> may be named <code>eyo₂</code>, meaning that the first argument is equal to y and the second is an option of x₂. Similarly, the constructor that produces <code>mul_args.P24 yL yR x &lt; mul_args.P1 x y</code> may be named <code>oyoyex</code>.</p>



<a name="282606680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282606680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282606680">(May 17 2022 at 08:22)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14190">#14190</a></p>



<a name="282673266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282673266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282673266">(May 17 2022 at 17:03)</a>:</h4>
<p>I decided against defining <code>&lt;</code> on <code>mul_args</code> directly, instead opting to define a relation on <code>multiset</code>s themselves. That way, I'm able to directly apply lemmas like <code>{x, y} = {y, x}</code>without having to use <code>change</code> or <code>unfold</code></p>



<a name="282675959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282675959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282675959">(May 17 2022 at 17:21)</a>:</h4>
<p>But yeah, your approach still works</p>



<a name="282676227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282676227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282676227">(May 17 2022 at 17:23)</a>:</h4>
<p>There's some auxiliary lemmas on <code>cut_expand</code> I'll still need, but I'll PR those after your PR is merged</p>



<a name="282808699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282808699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282808699">(May 18 2022 at 15:54)</a>:</h4>
<p>I just realized</p>



<a name="282808767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282808767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282808767">(May 18 2022 at 15:54)</a>:</h4>
<p>I think you can prove equality of multisets like <code>{x₁, x₂, x₃} = {x₂, x₂, x₁, x₃}</code> by <code>ext, tauto</code></p>



<a name="282809689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282809689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282809689">(May 18 2022 at 16:01)</a>:</h4>
<p><code>ext, simp</code> should also work</p>



<a name="282849796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282849796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282849796">(May 18 2022 at 21:09)</a>:</h4>
<p>I've always held that if <code>ext, simp</code> <em>fails</em> to prove a "these things are the same because they are made out of the same ingredients" goal, then you are obligated to go write the missing <code>@[ext]</code> and <code>@[simp]</code> lemmas before proceeding!</p>



<a name="282850179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282850179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282850179">(May 18 2022 at 21:12)</a>:</h4>
<p>In that case I'm not sure this holds, because there can be arbitrarily many <code>or_comm</code> required to prove the goal.</p>



<a name="282994100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282994100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282994100">(May 19 2022 at 21:25)</a>:</h4>
<p>We got <code>\lf</code>, <code>\&lt;|</code>, and <code>\fuzzy</code> added to vscode-lean!</p>



<a name="282994912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282994912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282994912">(May 19 2022 at 21:33)</a>:</h4>
<p>Did you add them to the other extensions as well?</p>



<a name="282995062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282995062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282995062">(May 19 2022 at 21:35)</a>:</h4>
<p>Uhhhhh no</p>



<a name="282995085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282995085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282995085">(May 19 2022 at 21:35)</a>:</h4>
<p>I probably should do that</p>



<a name="282995096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/282995096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#282995096">(May 19 2022 at 21:35)</a>:</h4>
<p>What other extensions are there?</p>



<a name="283001443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283001443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283001443">(May 19 2022 at 22:42)</a>:</h4>
<p>(I pull in changes every so often to neovim, so I pulled yours in already. There's emacs too but I think Sebastian does the same every so often. Probably some day we'll have a shared location that doesn't involve copy pasting, but for now I think you're good)</p>



<a name="283003363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283003363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283003363">(May 19 2022 at 23:03)</a>:</h4>
<p>There's also <span class="user-mention" data-user-id="451983">@Arthur Paulino</span>'s Chrome extension</p>



<a name="283161371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283161371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283161371">(May 21 2022 at 08:21)</a>:</h4>
<p>I only just learnt to use \lf and \rf to type <code>⌊</code> and <code>⌋</code>  :(</p>



<a name="283161425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283161425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283161425">(May 21 2022 at 08:22)</a>:</h4>
<p>Aaah, no that was one of my favorite shortcuts <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="283161442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283161442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283161442">(May 21 2022 at 08:23)</a>:</h4>
<p>What does "lf" stand for in the pgame world?</p>



<a name="283161452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283161452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283161452">(May 21 2022 at 08:23)</a>:</h4>
<p>"<strong>l</strong>ess than or <strong>f</strong>uzzy to"</p>



<a name="283162835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283162835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283162835">(May 21 2022 at 08:56)</a>:</h4>
<p><code>ltf</code> might be a reasonable compromise then, although I don't remember what the rules are for resolving ambiguity of abbreviations</p>



<a name="283162847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283162847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283162847">(May 21 2022 at 08:57)</a>:</h4>
<p>Maybe adding <code>\floor</code> for <code> ⌊$CURSOR⌋</code> is a better solution anyway</p>



<a name="283163589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283163589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283163589">(May 21 2022 at 09:16)</a>:</h4>
<p>Or both?</p>



<a name="283163821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283163821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283163821">(May 21 2022 at 09:23)</a>:</h4>
<p>It would be great if we could move the management of these aliases to within mathlib itself</p>



<a name="283163860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283163860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283163860">(May 21 2022 at 09:24)</a>:</h4>
<p>But that's probably a conversation for a new thread</p>



<a name="283198574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283198574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283198574">(May 21 2022 at 23:31)</a>:</h4>
<p>I decided to go ahead and PR natural addition: <a href="https://github.com/leanprover-community/mathlib/pull/14291">#14291</a></p>



<a name="283198612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283198612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283198612">(May 21 2022 at 23:32)</a>:</h4>
<p>This is relevant to games in two ways (that I know of!)</p>



<a name="283198623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283198623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283198623">(May 21 2022 at 23:32)</a>:</h4>
<p><code>a.to_pgame + b.to_pgame ≈ (of_nat_ordinal (to_nat_ordinal a + to_nat_ordinal b)).to_pgame</code></p>



<a name="283198630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283198630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283198630">(May 21 2022 at 23:32)</a>:</h4>
<p>(i.e. natural addition is the addition on ordinal games)</p>



<a name="283198636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283198636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283198636">(May 21 2022 at 23:33)</a>:</h4>
<p>And <code>birthday (a + b) = of_nat_ordinal (to_nat_ordinal (birthday a) + to_nat_ordinal (birthday b))</code></p>



<a name="283198697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283198697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283198697">(May 21 2022 at 23:34)</a>:</h4>
<p>This <code>of</code> and <code>to</code> notation totally sucks, but natural addition and multiplication have a ton of algebraic properties, so it was worth making into a type alias so that we could provide all the appropriate instances</p>



<a name="283199261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283199261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283199261">(May 21 2022 at 23:51)</a>:</h4>
<p>maybe add some notation for <code>of/to</code>? localised maybe?</p>



<a name="283199820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283199820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283199820">(May 22 2022 at 00:05)</a>:</h4>
<p>Any suggestions?</p>



<a name="283199858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283199858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283199858">(May 22 2022 at 00:06)</a>:</h4>
<p>I'm guessing such a notation would look something like <code>ᵒᵈ</code> and friends</p>



<a name="283208500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283208500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283208500">(May 22 2022 at 03:47)</a>:</h4>
<p>Or just put them in a namespace so by <code>open</code>ing the namespace you can just write <code>to</code> and <code>from</code>? I think this might be too specialized to warrant notation.</p>



<a name="283213584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283213584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283213584">(May 22 2022 at 05:39)</a>:</h4>
<p>That's clever</p>



<a name="283214896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283214896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283214896">(May 22 2022 at 06:07)</a>:</h4>
<p><code>to_nat_ordinal</code> and <code>of_nat_ordinal</code> are both already in a <code>nat_ordinal</code> namespace. Should I just rename them to <code>to</code> and <code>of</code>?</p>



<a name="283216622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216622">(May 22 2022 at 06:48)</a>:</h4>
<p>Wikipedia <a href="https://en.wikipedia.org/wiki/Ordinal_arithmetic#Natural_operations">uses the notations ⊕ and ⊗</a> which I think are standard. The ⊕ notation is also common for <a href="https://en.wikipedia.org/wiki/Nim#Mathematical_theory">Nim sum</a> / xor, and nim sum/product also have tons of algebraic properties (forming an algebraically closed field On₂, see <a href="http://www.neverendingbooks.org/on2-conways-nim-arithmetics">Lieven le Bruyn's blog posts</a>), but we may use <code>⊕₂</code> <code>⊗₂</code> to signify both their binary nature and their similarity to natural sum/product.</p>
<p>By the way, well partial orders is spelt <a href="https://leanprover-community.github.io/mathlib_docs/find/set.is_pwo">docs#set.is_pwo</a> in mathlib, and it would be nice to connect them to natural sums/products as explained in the first Wikipedia page.</p>



<a name="283216654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216654">(May 22 2022 at 06:49)</a>:</h4>
<p><code>⊕</code> is definitely a no-go, since it's used for type sums</p>



<a name="283216713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216713">(May 22 2022 at 06:50)</a>:</h4>
<p>Also, the decision to make a new type in order to use <code>+</code> and <code>*</code> was quite intentional. These natural operations have a lot of algebraic structure to them, and we'd be missing out on tons of instances if we just made them operations on <code>ordinal</code> itself</p>



<a name="283216722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216722">(May 22 2022 at 06:50)</a>:</h4>
<p>They're commutative, associative, preserve order, are cancellative, and distributive</p>



<a name="283216740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216740">(May 22 2022 at 06:51)</a>:</h4>
<p>And they have the usual <code>0</code> and <code>1</code> from ordinals</p>



<a name="283216863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216863">(May 22 2022 at 06:54)</a>:</h4>
<p>Ok yes, a lot of nice properties seem impossible to state without the had_add has_mul instances, and those would conflict with the original ones, so a type synonym seems necessary.</p>



<a name="283216956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283216956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283216956">(May 22 2022 at 06:56)</a>:</h4>
<p>In an ideal world we'd have <code>group (+)</code> instead of <code>add_group</code> and such, but this isn't that world <span aria-label="sob" class="emoji emoji-1f62d" role="img" title="sob">:sob:</span></p>



<a name="283217351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283217351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283217351">(May 22 2022 at 07:05)</a>:</h4>
<p>Maybe what we want is <code>a ⊗ b = of_nat_ordinal (to_nat_ordinal a * to_nat_ordinal b)</code> and the alike.</p>
<p>Here's how people solve the notation conflict with type sum in <a href="https://leanprover-community.github.io/mathlib_docs/category_theory/limits/shapes/biproducts.html#notation">biproducts</a> ("direct sum") in the categorical setting; in concrete categories its underlying type is usually exactly the type sum. I wonder if it makes sense and easy to make the ⊕ notation localized.</p>
<p>By the way, anyone knows why <code>lf</code> and <code>equiv</code> are displayed <a href="https://leanprover-community.github.io/mathlib_docs/set_theory/game/pgame.html">in the docs</a> instead of their notations?</p>



<a name="283218288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218288">(May 22 2022 at 07:31)</a>:</h4>
<p>It's because the notation is local</p>



<a name="283218411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218411">(May 22 2022 at 07:34)</a>:</h4>
<p>Notations still give you syntactic equality, right? If so, that's definitely the right approach</p>



<a name="283218420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218420">(May 22 2022 at 07:35)</a>:</h4>
<p>Still, I wouldn't use <code>⊕</code>, since that's also used for nimber addition</p>



<a name="283218467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218467">(May 22 2022 at 07:36)</a>:</h4>
<p>Wikipedia also suggests the # ⨳ notations.</p>



<a name="283218471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218471">(May 22 2022 at 07:36)</a>:</h4>
<p>Yeah, I'd rather go with that</p>



<a name="283218485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218485">(May 22 2022 at 07:36)</a>:</h4>
<p><code>#</code> could potentially clash with the notation for cardinality, but I find it unlikely we'll ever involve the two at the same time</p>



<a name="283218975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218975">(May 22 2022 at 07:50)</a>:</h4>
<p>Hmm... actually, I'm not so sure about the local notation anymore</p>



<a name="283218979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218979">(May 22 2022 at 07:50)</a>:</h4>
<p>Because, the theorems about <code>nat_ordinal</code> are most naturally stated in terms of <code>nat_ordinal</code>, of course</p>



<a name="283218980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218980">(May 22 2022 at 07:50)</a>:</h4>
<p>But the <code>#</code> notation requires us to state our theorems as theorems about <code>ordinal</code> instead</p>



<a name="283218983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218983">(May 22 2022 at 07:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/283218485">said</a>:</p>
<blockquote>
<p><code>#</code> could potentially clash with the notation for cardinality, but I find it unlikely we'll ever involve the two at the same time</p>
</blockquote>
<p>umm... cardinal and ordinal are very often used together</p>



<a name="283218989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218989">(May 22 2022 at 07:50)</a>:</h4>
<p>Hmm.... true</p>



<a name="283218998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283218998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283218998">(May 22 2022 at 07:51)</a>:</h4>
<p>I think it doesn't need a symbol beyond what it gets via <code>nat_ordinal</code></p>



<a name="283219054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219054">(May 22 2022 at 07:52)</a>:</h4>
<p><code>a.nadd b</code> / <code>a.nmul b</code>?</p>



<a name="283219077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219077">(May 22 2022 at 07:53)</a>:</h4>
<p>If <code>a</code> <code>b</code> are <code>nat_ordinal</code> then these are just <code>a + b</code> <code>a * b</code>.</p>



<a name="283219079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219079">(May 22 2022 at 07:53)</a>:</h4>
<p>I mean for the <code>ordinal</code> ops</p>



<a name="283219085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219085">(May 22 2022 at 07:54)</a>:</h4>
<p>Oh yes</p>



<a name="283219125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219125">(May 22 2022 at 07:54)</a>:</h4>
<p><code>nat_ordinal</code> would wrap those ops and give them notation</p>



<a name="283219159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219159">(May 22 2022 at 07:55)</a>:</h4>
<p>Yes <code>nadd</code> <code>nmul</code> look short enough. Though I just looked into Unicode just for fun:</p>
<p>The official name for ⨳ <code>⨳</code> is "smash product", and in the <a href="http://shapecatcher.com/unicode/block/Supplemental_Mathematical_Operators">same block</a> there are also ⩩ <code>⩩</code> and ⩨ <code>⩨</code>, but ⌗ <code>⌗</code> is in a different block (0x2317, Miscellaneous Technical). This vertical version looks better than the slanted # <code>#</code>, and also avoids conflict.<br>
There is also<br>
Vai syllable pu: ꖛ <code>ꖛ</code><br>
Unicode hexadecimal: 0xa59b<br>
In block: Vai (a language in Liberia and Sierra Leone)</p>



<a name="283219161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219161">(May 22 2022 at 07:55)</a>:</h4>
<p>I'm worried that by wrapping around <code>+</code> and <code>*</code>, we either</p>
<ul>
<li>lose a lot of flexibility due to not having typeclasses</li>
<li>have to prove a lot of lemmas twice</li>
</ul>



<a name="283219202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219202">(May 22 2022 at 07:56)</a>:</h4>
<p>? <code>nat_ordinal</code> would have typeclasses</p>



<a name="283219222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219222">(May 22 2022 at 07:57)</a>:</h4>
<p>you could use <code>nat_ordinal</code> to prove theorems about <code>nadd</code> and <code>nmul</code> by wrapping, but I don't think there will be a huge number of such lemmas</p>



<a name="283219223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219223">(May 22 2022 at 07:57)</a>:</h4>
<p>Yeah, but we wouldn't have, say <code>nadd_assoc</code> or <code>nadd_comm</code>, or <code>nadd_lt_nadd_left</code>, ... unless we went ahead and wrote every single one of them out</p>



<a name="283219227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219227">(May 22 2022 at 07:57)</a>:</h4>
<p>you will definitely have <code>nadd_assoc</code> and <code>nadd_comm</code></p>



<a name="283219230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219230">(May 22 2022 at 07:57)</a>:</h4>
<p>because you have to prove those</p>



<a name="283219276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219276">(May 22 2022 at 07:58)</a>:</h4>
<p>My point is that we have those for <code>+</code> on <code>nat_ordinal</code> rather than for <code>nadd</code></p>



<a name="283219284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219284">(May 22 2022 at 07:58)</a>:</h4>
<p>I guess it's not <em>that</em> much boilerplate we'd need to add, but still</p>



<a name="283219287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219287">(May 22 2022 at 07:58)</a>:</h4>
<p>you will have them on nat_ordinal by wrapping <code>nadd_assoc</code></p>



<a name="283219300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219300">(May 22 2022 at 07:58)</a>:</h4>
<p>calling the operation <code>+</code> doesn't magically prove it is commutative and associative</p>



<a name="283219317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219317">(May 22 2022 at 07:59)</a>:</h4>
<p>there are some "theorems for free" but that is not one of them</p>



<a name="283219423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219423">(May 22 2022 at 08:00)</a>:</h4>
<p>like <code>nadd_left_assoc</code>, okay you might want to defer to group lemmas (although the proof is so trivial it might be more work to prove by reflecting to <code>nat_ordinal</code> than directly)</p>



<a name="283219471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219471">(May 22 2022 at 08:01)</a>:</h4>
<p>No, I rather mean</p>



<a name="283219478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219478">(May 22 2022 at 08:01)</a>:</h4>
<p>If we were to wrap around <code>+</code> by using <code>nadd</code>, we'd need to prove a bunch of boilerplate like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">nadd_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">nadd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">nadd</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">add_comm</span> <span class="n">nat_ordinal</span> <span class="n">_</span>
<span class="kd">theorem</span> <span class="n">nadd_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">nadd</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">nadd</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">nadd</span> <span class="n">a</span> <span class="o">(</span><span class="n">nadd</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">add_assoc</span> <span class="n">nat_ordinal</span> <span class="n">_</span>
</code></pre></div>
<p>and so on</p>



<a name="283219524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219524">(May 22 2022 at 08:02)</a>:</h4>
<p>But I guess it's not that much boilerplate anyways</p>



<a name="283219528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219528">(May 22 2022 at 08:02)</a>:</h4>
<p>I'm saying that those lemmas would have substantive proofs</p>



<a name="283219534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219534">(May 22 2022 at 08:02)</a>:</h4>
<p>Sure, they'd have the proofs from <code>nat_ordinal</code></p>



<a name="283219537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219537">(May 22 2022 at 08:02)</a>:</h4>
<p>and they would be referenced in the <code>instance : add_comm_group nat_ordinal</code></p>



<a name="283219543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219543">(May 22 2022 at 08:02)</a>:</h4>
<p>Oh yeah, I'm aware of that</p>



<a name="283219545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219545">(May 22 2022 at 08:03)</a>:</h4>
<p>It seems another occasion where we'd like to <code>norm_cast</code> into <code>nat_ordinal</code> when we want to prove something about nat sum/prod, in order for instances on <code>nat_ordinal</code> to fire. Maybe just a little bit of boilerplate would make that work? I haven't tried it with pgame-&gt;game.</p>



<a name="283219611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219611">(May 22 2022 at 08:04)</a>:</h4>
<p>Personally I think <code>nat_ordinal</code> and <code>nadd</code> will not get much use beyond the few pgame lemmas you are working on right now</p>



<a name="283219632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219632">(May 22 2022 at 08:04)</a>:</h4>
<p>they are pretty much only ever brought up in connection with surreals / combinatorial games</p>



<a name="283219646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283219646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283219646">(May 22 2022 at 08:05)</a>:</h4>
<p>which is why I think having a couple definitions and no notation is fine</p>



<a name="283220417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220417">(May 22 2022 at 08:25)</a>:</h4>
<p>I went ahead and defined <code>nadd</code> on <code>ordinal</code>. As expected, there were a lot of boilerplate lemmas to transfer over, though they're almost all def-eq so that's no issue. I think this is a good price to pay for much simpler notation.</p>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14291/commits/f5c5e1e710c92089b88f7f329626f45959785b97">https://github.com/leanprover-community/mathlib/pull/14291/commits/f5c5e1e710c92089b88f7f329626f45959785b97</a></p>



<a name="283220482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220482">(May 22 2022 at 08:27)</a>:</h4>
<p>And yeah, I guess that what I'm ultimately doing is pretty niche. But that doesn't mean we can't make it look pretty!</p>



<a name="283220505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220505">(May 22 2022 at 08:28)</a>:</h4>
<p>It looks like <code>nat_ordinal</code> has a ton of boilerplate going in the opposite direction</p>



<a name="283220511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220511">(May 22 2022 at 08:28)</a>:</h4>
<p>my suggesion is to steal the definition of <code>nat_ordinal.add</code> and paste it in <code>ordinal.nadd</code></p>



<a name="283220517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220517">(May 22 2022 at 08:28)</a>:</h4>
<p>and then prove <code>ordinal.nadd_assoc</code> directly</p>



<a name="283220530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220530">(May 22 2022 at 08:29)</a>:</h4>
<p>and then <code>nat_ordinal</code> will only be boilerplate lemmas</p>



<a name="283220613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220613">(May 22 2022 at 08:30)</a>:</h4>
<p>I don't think this will entirely work out, since a few of the boilerplate lemmas (the <code>nadd_lt_nadd</code> ones) are generated from the covariant and contravariant instances</p>



<a name="283220619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220619">(May 22 2022 at 08:31)</a>:</h4>
<p>So at the very least, those have to be proven in <code>nat_ordinal</code> first</p>



<a name="283220632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220632">(May 22 2022 at 08:31)</a>:</h4>
<p>Aren't those instances true on ordinal too?</p>



<a name="283220685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220685">(May 22 2022 at 08:32)</a>:</h4>
<p>Not all of them, and even if they were, they wouldn't be on the same operation!</p>



<a name="283220692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220692">(May 22 2022 at 08:32)</a>:</h4>
<p>of course, <code>s/+/nadd/</code></p>



<a name="283220697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220697">(May 22 2022 at 08:32)</a>:</h4>
<p>and if they aren't instances, just call them <code>nadd_lt_nadd</code></p>



<a name="283220709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220709">(May 22 2022 at 08:33)</a>:</h4>
<p>The instances automatically generate the <code>iff</code> and <code>cancel</code> lemmas though</p>



<a name="283220716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220716">(May 22 2022 at 08:33)</a>:</h4>
<p>If I proved these theorems on <code>ordinal</code> first, I'd need to manually prove those lemmas</p>



<a name="283220765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220765">(May 22 2022 at 08:34)</a>:</h4>
<p>which instance are you talking about specifically?</p>



<a name="283220772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220772">(May 22 2022 at 08:34)</a>:</h4>
<p>all the ones I see apply to ordinal too</p>



<a name="283220777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220777">(May 22 2022 at 08:34)</a>:</h4>
<p>I'm talking about <code>add_covariant_class_lt</code> and the seven other similar ones</p>



<a name="283220787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220787">(May 22 2022 at 08:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">add_covariant_class_lt</span> <span class="o">:</span>
  <span class="n">covariant_class</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">nadd</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>et al</p>



<a name="283220859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220859">(May 22 2022 at 08:36)</a>:</h4>
<p>Unfortunately, those instances don't have support for any operations other than <code>+</code>,<code>*</code>, or their swapped counterparts (and relations other than <code>&lt;</code> and <code>≤</code>)</p>



<a name="283220871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220871">(May 22 2022 at 08:36)</a>:</h4>
<p>So doing this wouldn't autogenerate the lemmas</p>



<a name="283220883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220883">(May 22 2022 at 08:37)</a>:</h4>
<p>In fact, it wouldn't even give us access to the <code>add_lt_add_left</code> and such lemmas</p>



<a name="283220899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220899">(May 22 2022 at 08:37)</a>:</h4>
<p>Since they require a <code>has_add</code> instance specifically</p>



<a name="283220972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283220972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283220972">(May 22 2022 at 08:38)</a>:</h4>
<p>do you want <code>rel_iff_cov</code>?</p>



<a name="283221009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221009">(May 22 2022 at 08:39)</a>:</h4>
<p>poking around in the relevant files I see several generic lemmas, they have generic names of course</p>



<a name="283221091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221091">(May 22 2022 at 08:41)</a>:</h4>
<p>I think if the instances are expressible they should definitely be stated on <code>ordinal</code>, possibly in addition to <code>nat_ordinal</code></p>



<a name="283221131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221131">(May 22 2022 at 08:42)</a>:</h4>
<p>My understanding is that there's little to no support for these custom covariant and contravariant classes</p>



<a name="283221133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221133">(May 22 2022 at 08:42)</a>:</h4>
<p>It's the reason I didn't implement them for <code>lf</code> on <code>pgame</code></p>



<a name="283221137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221137">(May 22 2022 at 08:42)</a>:</h4>
<p>Maybe someone else can confirm</p>



<a name="283221209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221209">(May 22 2022 at 08:44)</a>:</h4>
<p>I'm wondering what kind of nontrivial thing you are even getting out of these classes. We have it stated in a bunch of different ways that x &lt; y -&gt; f x &lt; f y implies f is injective and strictly increasing and iff-preserves lt and le</p>



<a name="283221230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221230">(May 22 2022 at 08:45)</a>:</h4>
<p>but not having the lemmas doesn't seem like a good reason to not have the instances</p>



<a name="283221339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221339">(May 22 2022 at 08:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">nadd_lt_nadd_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">♯</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">♯</span> <span class="n">c</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">add_lt_add_left</span> <span class="n">nat_ordinal</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">theorem</span> <span class="n">lt_of_nadd_lt_nadd_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">♯</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">♯</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">lt_of_add_lt_add_left</span> <span class="n">nat_ordinal</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">theorem</span> <span class="n">nadd_lt_nadd_iff_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">♯</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">♯</span> <span class="n">c</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">add_lt_add_iff_left</span> <span class="n">nat_ordinal</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>
<p>We don't need all three of these, the last one is plenty</p>



<a name="283221359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221359">(May 22 2022 at 08:49)</a>:</h4>
<p>Well, we get all three almost for free on <code>nat_ordinal</code></p>



<a name="283221402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221402">(May 22 2022 at 08:50)</a>:</h4>
<p>I know, but we get all three for free just from <code>nadd_lt_nadd_iff_left</code></p>



<a name="283221412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221412">(May 22 2022 at 08:50)</a>:</h4>
<p>in fact, you could probably prove the first two even shorter by using the last one</p>



<a name="283221424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221424">(May 22 2022 at 08:51)</a>:</h4>
<p>but I would just drop them, we try to discourage the one way version of iff lemmas unless they are <em>really</em> heavily used</p>



<a name="283221467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221467">(May 22 2022 at 08:52)</a>:</h4>
<p>it's more compositional that way</p>



<a name="283221502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221502">(May 22 2022 at 08:53)</a>:</h4>
<p>The way I see it, if we're going to write down boilerplate, we might as well be thorough</p>



<a name="283221542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221542">(May 22 2022 at 08:54)</a>:</h4>
<p>I wouldn't mourn the loss of the one-sided theorems though</p>



<a name="283221558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221558">(May 22 2022 at 08:55)</a>:</h4>
<p>well it's a lot less boilerplate if you do it the other way around (I contest)</p>



<a name="283221582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221582">(May 22 2022 at 08:55)</a>:</h4>
<p>like <code>nat_ordinal.blsub</code> doesn't need to exist at all</p>



<a name="283221669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221669">(May 22 2022 at 08:57)</a>:</h4>
<p>also ditto on what eric said, instead of <code>a + b ≤ of_nat_ordinal (to_nat_ordinal a + to_nat_ordinal b)</code> you should use only one of the two functions at a time, <code>to_nat_ordinal (a + b) ≤ to_nat_ordinal a + to_nat_ordinal b</code></p>



<a name="283221714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221714">(May 22 2022 at 08:58)</a>:</h4>
<p>The advantage of having it is that for <code>n : nat_ordinal</code>, <code>n.blsub</code> doesn't resolve to something with a messy type</p>



<a name="283221728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221728">(May 22 2022 at 08:58)</a>:</h4>
<p>I don't think you should ever need to write <code>n.blsub</code></p>



<a name="283221835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221835">(May 22 2022 at 09:00)</a>:</h4>
<p>if all the substantive proof is over <code>ordinal</code> and <code>nadd</code> then the only thing that <code>nat_ordinal</code> needs to do is lift the ring ops</p>



<a name="283221843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221843">(May 22 2022 at 09:01)</a>:</h4>
<p><code>nat_ordinal.blsub</code> was actually Eric's suggestion, haha</p>



<a name="283221871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221871">(May 22 2022 at 09:01)</a>:</h4>
<p>It really only makes things easier to look at</p>



<a name="283221874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221874">(May 22 2022 at 09:02)</a>:</h4>
<p>I could remove it and save a few rewrites</p>



<a name="283221921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221921">(May 22 2022 at 09:02)</a>:</h4>
<p>I'm saying that blsub of a nat_ordinal is not a thing that should be happening</p>



<a name="283221934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221934">(May 22 2022 at 09:02)</a>:</h4>
<p>regardless of how it is written</p>



<a name="283221935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221935">(May 22 2022 at 09:03)</a>:</h4>
<p>From a mathematical perspective, you mean?</p>



<a name="283221939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221939">(May 22 2022 at 09:03)</a>:</h4>
<p>yes</p>



<a name="283221957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283221957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283221957">(May 22 2022 at 09:03)</a>:</h4>
<p>it's used inside the definition of <code>nat_ordinal.add</code> but if that is defined directly on <code>ordinal</code> then I think you won't ever need it elsewhere</p>



<a name="283222001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222001">(May 22 2022 at 09:04)</a>:</h4>
<p>Surely from a mathematical perspective, <code>nat_ordinal</code> wouldn't need to exist?</p>



<a name="283222009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222009">(May 22 2022 at 09:04)</a>:</h4>
<p>It only exists because Lean doesn't allow us to define more than one addition for a type</p>



<a name="283222013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222013">(May 22 2022 at 09:04)</a>:</h4>
<p>Mathematicians have no issue with that</p>



<a name="283222023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222023">(May 22 2022 at 09:05)</a>:</h4>
<p>sure, so do your best to not use it at all and see how far you can get</p>



<a name="283222031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222031">(May 22 2022 at 09:05)</a>:</h4>
<p>(that's not sarcasm)</p>



<a name="283222117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222117">(May 22 2022 at 09:06)</a>:</h4>
<p>I can believe that there are some theorems that currently are only stated for plus-like things so you need to transfer stuff to nat_ordinal, but just use it to get the theorem and then go back to <code>ordinal</code> to finish the proof</p>



<a name="283222146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283222146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283222146">(May 22 2022 at 09:08)</a>:</h4>
<p>(and don't forget that you can switch between <code>nat_ordinal</code> and <code>ordinal</code> namespaces multiple times)</p>



<a name="283223695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283223695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283223695">(May 22 2022 at 09:50)</a>:</h4>
<p>I just realised, another option is to make notation that does all the casting stuff for you, and then you should be able to do many <code>rw</code>s and stuff as if the notation was a real +/*</p>



<a name="283243421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283243421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283243421">(May 22 2022 at 17:47)</a>:</h4>
<p>I think I get your point: we have <code>nat_ordinal</code> for the instances, and nothing more, right?</p>



<a name="283243910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283243910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283243910">(May 22 2022 at 17:59)</a>:</h4>
<p>I like that design better</p>



<a name="283243920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283243920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283243920">(May 22 2022 at 17:59)</a>:</h4>
<p>It should avoid most if not all of the annoying casting we currently have</p>



<a name="283243926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283243926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283243926">(May 22 2022 at 17:59)</a>:</h4>
<p>And if we ever need some theorem that's available through an instance on <code>nat_ordinal</code>, we can simply def-eq cast it</p>



<a name="283246160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283246160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283246160">(May 22 2022 at 18:55)</a>:</h4>
<p>What precedences should I set for <code>♯</code> and <code>⨳</code>?</p>



<a name="283246165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283246165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283246165">(May 22 2022 at 18:55)</a>:</h4>
<p>I'm still not using the latter, but still</p>



<a name="283247912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283247912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283247912">(May 22 2022 at 19:37)</a>:</h4>
<p>For this application, it makes sense to make them the same as + and * respectively</p>



<a name="283248059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283248059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283248059">(May 22 2022 at 19:40)</a>:</h4>
<p>And what would those precedences be?</p>



<a name="283248061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283248061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283248061">(May 22 2022 at 19:40)</a>:</h4>
<p>I don't know where to find them</p>



<a name="283248228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283248228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283248228">(May 22 2022 at 19:44)</a>:</h4>
<p>By the way, I did the refactor Mario suggested, and the lemmas look much nicer!</p>



<a name="283248998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283248998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283248998">(May 22 2022 at 20:01)</a>:</h4>
<p><code>#print +</code></p>



<a name="283249004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283249004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283249004">(May 22 2022 at 20:01)</a>:</h4>
<p>I think it is 65</p>



<a name="283266585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283266585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283266585">(May 23 2022 at 03:02)</a>:</h4>
<p>Currently having a go at defining natural multiplication and I'm already at a roadblock with distributivity</p>



<a name="283266592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283266592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283266592">(May 23 2022 at 03:02)</a>:</h4>
<p><a href="/user_uploads/3121/OJ2aKNZiSNg5vo6pUm6p3ffW/image.png">image.png</a> Other than a stupidly long <code>rw</code> chain, how can I prove this?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/OJ2aKNZiSNg5vo6pUm6p3ffW/image.png" title="image.png"><img src="/user_uploads/3121/OJ2aKNZiSNg5vo6pUm6p3ffW/image.png"></a></div>



<a name="283266599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283266599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283266599">(May 23 2022 at 03:02)</a>:</h4>
<p>(note that the terms <code>a' ⨳ b'</code> and <code>a ⨳ b'</code> in <code>this</code> cancel out, giving the result)</p>



<a name="283266679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283266679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283266679">(May 23 2022 at 03:04)</a>:</h4>
<p>I could cast this into a (huge) expression in <code>nat_ordinal</code>, but afaik there's no tactic that can finish the goal even then</p>



<a name="283267798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283267798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283267798">(May 23 2022 at 03:30)</a>:</h4>
<p>A calc block is probably the clearest way</p>



<a name="283267830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283267830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283267830">(May 23 2022 at 03:31)</a>:</h4>
<p>you should be able to normalize it using <code>simp [comm, left_comm, assoc]</code></p>



<a name="283267886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283267886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283267886">(May 23 2022 at 03:32)</a>:</h4>
<p>Is there any way I can normalize it, while specifying the order of the terms?</p>



<a name="283267887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283267887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283267887">(May 23 2022 at 03:32)</a>:</h4>
<p>That would be extremely useful if possible</p>



<a name="283268156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283268156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283268156">(May 23 2022 at 03:39)</a>:</h4>
<p>one hack is to choose fortuitous variable names</p>



<a name="283268234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283268234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283268234">(May 23 2022 at 03:40)</a>:</h4>
<p>otherwise, you are probably better off using <code>rw [left_comm]</code> to bring something to the front</p>



<a name="283268343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283268343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283268343">(May 23 2022 at 03:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/left_comm">docs#left_comm</a></p>



<a name="283268398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283268398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283268398">(May 23 2022 at 03:44)</a>:</h4>
<p>This?</p>



<a name="283268547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283268547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283268547">(May 23 2022 at 03:48)</a>:</h4>
<p><code>nadd_left_comm</code> probably</p>



<a name="283269319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283269319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283269319">(May 23 2022 at 04:05)</a>:</h4>
<p>Oh, I see!</p>



<a name="283269326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283269326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283269326">(May 23 2022 at 04:05)</a>:</h4>
<p>Once you <code>simp [assoc]</code> you can use <code>nadd_left_comm</code> to move terms as you will</p>



<a name="283269328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283269328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283269328">(May 23 2022 at 04:05)</a>:</h4>
<p>Clever!</p>



<a name="283269428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283269428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283269428">(May 23 2022 at 04:07)</a>:</h4>
<p>I did it! I managed to prove this!</p>



<a name="283269431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283269431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283269431">(May 23 2022 at 04:07)</a>:</h4>
<p>And it only took like 10 <code>rw</code>s!</p>



<a name="283270984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283270984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283270984">(May 23 2022 at 04:46)</a>:</h4>
<p>On a just vaguely related note: if you had <em>actual</em> <code>has_add.add</code>, the proposed tactic <code>move_add</code> gives you the option of specifying which terms in a sum should be first/last at will.  You can also of course pass the full permutation, if you so wish!</p>
<p>I'm simply bringing this up since it is the second time that I see a place where <code>move_add</code> would have been wanted "in the wild".  Also, adding support for operations other than <code>+</code> would be fairly easy.</p>



<a name="283271003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283271003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283271003">(May 23 2022 at 04:47)</a>:</h4>
<p>you would still need to know that the new operation is comm/assoc</p>



<a name="283271054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283271054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283271054">(May 23 2022 at 04:48)</a>:</h4>
<p>Yes, you would need the analogues of add_assoc, add_comm and add_left_comm.</p>



<a name="283271068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283271068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283271068">(May 23 2022 at 04:49)</a>:</h4>
<p>These are the three "external" inputs to the tactic, everything else is moving exprs around.</p>



<a name="283271285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283271285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283271285">(May 23 2022 at 04:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/283270984">said</a>:</p>
<blockquote>
<p>I'm simply bringing this up since it is the second time that I see a place where <code>move_add</code> would have been wanted "in the wild".  Also, adding support for operations other than <code>+</code> would be fairly easy.</p>
</blockquote>
<p>Make that a third! I would have benefited a lot from that in the surreal multiplication proof</p>



<a name="283271287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283271287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283271287">(May 23 2022 at 04:53)</a>:</h4>
<p>I have some huge <code>rw</code> blocks over there too</p>



<a name="283271478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283271478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283271478">(May 23 2022 at 04:56)</a>:</h4>
<p>Ok, I'll leave the current PR as is, since it has already gone through some revisions.  But I will add a second PR allowing "custom" operations.</p>
<p>I was thinking of just <code>+</code> and <code>*</code> support, but I might try to see if I can get a "generic" tactic that takes also an operation as input.  It might be tricky to specify the comm/assoc lemmas to use in this case, though.</p>



<a name="283272248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283272248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283272248">(May 23 2022 at 05:12)</a>:</h4>
<p>We wouldn't need this if there were some easy way to convert a lemma on <code>ordinal</code> and natural operations to the corresponding one on <code>nat_ordinal</code></p>



<a name="283272253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283272253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283272253">(May 23 2022 at 05:13)</a>:</h4>
<p>I've heard people say <code>norm_cast</code> could help but I don't really know how that works</p>



<a name="283272526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283272526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283272526">(May 23 2022 at 05:19)</a>:</h4>
<p>I do not know neither the maths, nor the mathlib side of this story, so I'll leave this to someone else!</p>
<p>My naïve view is that <code>norm_cast</code> would take care of dealing with seen and unseen coercions and uniformize everything.  Thus, if there were a coe between <code>nat_ordinal</code> and <code>pgames</code> (or <code>games</code>, I really don't know), then <code>norm_cast</code> could convert expressions where one appear into expressions where the other appears.</p>



<a name="283272590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283272590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283272590">(May 23 2022 at 05:20)</a>:</h4>
<p>I think that you might have to tag the relevant lemmas with a <code>norm_cast</code> attribute, but this is something that I have never done and might be wrong about.</p>



<a name="283277596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283277596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283277596">(May 23 2022 at 06:49)</a>:</h4>
<p>I managed to prove the basic properties of natural multiplication and wow were they painful</p>



<a name="283277662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283277662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283277662">(May 23 2022 at 06:50)</a>:</h4>
<p>At least now I'm almost sure I have the correct definition</p>



<a name="283277677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283277677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283277677">(May 23 2022 at 06:50)</a>:</h4>
<p>I had to extrapolate a bit since every source I looked at just gave the Cantor form definition instead of the recursive one</p>



<a name="283279933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283279933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283279933">(May 23 2022 at 07:20)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> hydra PR got merged! I got a bit distracted as of late with the whole natural operations schtick, but I'll PR some auxiliary lemmas on <code>cut_expand</code> shortly and hopefully finish the proof with them</p>



<a name="283290042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283290042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283290042">(May 23 2022 at 09:10)</a>:</h4>
<p>A few days ago I experimented with the idea of exploiting symmetry to reduce the number of cases in the surreal multiplication proof; e.g. there are 2x2x3=12 cases to show P1 (that x*y is numeric), but I can <a href="https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R566-R581">almost reduce it to just 3 cases</a> using <a href="https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R340"><code>P24_neg</code></a>, <code>P24_neg'</code>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_mul_neg">docs#pgame.quot_mul_neg</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_mul_comm">docs#pgame.quot_mul_comm</a> etc. (The 3 cases are used to show <code>left_lt_right</code>, and lines 566-581 use <code>left_lt_right</code> to show all 2x2=4 cases. Line 582 onwards are old proofs.) It seems the <code>&lt;</code> and <code>&gt;</code> cases could also follow from one another. However, using symmetry introduces additional obligations to prove identities and handle induction hypotheses (?), so I'm not sure the proofs will end up shorter. I only thought carefully about proving P1, but I expect to exploit symmetry when proving P2 and P4, you'd still apply the symmetries to P2 and P4 instead of P1.</p>
<p>The code is obviously very disorganized so I wouldn't be surprised if it ends up being unhelpful ... However <br>
I am at a conference and don't expect to be able to work on this in the next few days, and since you are getting back to this, I decided to push it in the hope that it could be somewhat inspirational.</p>



<a name="283311962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283311962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283311962">(May 23 2022 at 12:36)</a>:</h4>
<p>(deleted)</p>



<a name="283312318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283312318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283312318">(May 23 2022 at 12:39)</a>:</h4>
<p>By the way, as for a tactic to solve numeric obligations</p>



<a name="283312446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283312446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283312446">(May 23 2022 at 12:40)</a>:</h4>
<p>You can often use <code>solve_by_elim [numeric.move_left, numeric.move_right]</code></p>



<a name="283379624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283379624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283379624">(May 23 2022 at 21:44)</a>:</h4>
<p>I'm wondering</p>



<a name="283379693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283379693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283379693">(May 23 2022 at 21:45)</a>:</h4>
<p>Given that the order relations on games are much, much nicer to work with than those on games, should we have a simp lemma converting between them? Or is that dangerous?</p>



<a name="283379730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283379730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283379730">(May 23 2022 at 21:45)</a>:</h4>
<p>And if making it a simp lemma isn't the best idea, could it be made norm_cast? I don't know how that works really</p>



<a name="283380306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283380306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283380306">(May 23 2022 at 21:51)</a>:</h4>
<p>At the very least we should have the lemmas for rewriting</p>



<a name="283381002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283381002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283381002">(May 23 2022 at 21:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/283379693">said</a>:</p>
<blockquote>
<p>Given that the order relations on games are much, much nicer to work with than those on games, should we have a simp lemma converting between them? Or is that dangerous?</p>
</blockquote>
<p>one of these should be pgames and I guess it's the first one</p>



<a name="283672195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283672195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283672195">(May 23 2022 at 22:15)</a>:</h4>
<p>Oh sorry</p>



<a name="283672204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283672204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283672204">(May 23 2022 at 22:15)</a>:</h4>
<p>It's the second one</p>



<a name="283672318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/283672318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#283672318">(May 23 2022 at 22:16)</a>:</h4>
<p>lost the 5050 ;b</p>



<a name="284078645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284078645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284078645">(May 27 2022 at 00:30)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> I have some time to look into this again</p>



<a name="284078658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284078658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284078658">(May 27 2022 at 00:30)</a>:</h4>
<p>What's the general idea in your simplification? I'm having a bit of a hard time following it</p>



<a name="284081895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284081895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284081895">(May 27 2022 at 01:27)</a>:</h4>
<p>I agree with some of your ideas, like separating <code>P1</code> and such into definitions and proving comm lemmas and the like. This should make the proof shorter and easier to follow.</p>



<a name="284081992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284081992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284081992">(May 27 2022 at 01:29)</a>:</h4>
<p>I do disagree with various of your ideas here. <code>mul_args</code> should have only two constructors. That way, you get a stronger induction hypothesis for less work (instead of trying to prove that P1 implies both P2 and P4 for the same set of values).</p>



<a name="284082012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284082012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284082012">(May 27 2022 at 01:29)</a>:</h4>
<p>Further, defining an ad-hoc relation on <code>mul_args</code> and proving it well founded wouldn't really lead to less work, since we'd still have to prove exactly the same things we're currently proving to prove that it's a subrelation of <code>cut_expand</code>.</p>



<a name="284082121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284082121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284082121">(May 27 2022 at 01:31)</a>:</h4>
<p>And totally disagree on defining <code>move_left</code> on <code>{x // numeric x}</code>. There's absolutely no reason we should be working directly with these subtypes. Just separate <code>x</code> and <code>numeric x</code>.</p>



<a name="284082451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284082451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284082451">(May 27 2022 at 01:37)</a>:</h4>
<p>Btw I PR'd the lemmas to cast inequalities from <code>pgame</code> to <code>game</code>, and the lemma that relabellings preserve being numeric</p>



<a name="284083347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284083347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284083347">(May 27 2022 at 01:52)</a>:</h4>
<p>Oh and also, I don't think that tactic to prove games numeric would be all that useful, since almost always you just apply <code>numeric.move_left</code> and <code>numeric.move_right</code> once or twice</p>



<a name="284235236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284235236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284235236">(May 28 2022 at 15:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/284082121">said</a>:</p>
<blockquote>
<p>And totally disagree on defining <code>move_left</code> on <code>{x // numeric x}</code>. There's absolutely no reason we should be working directly with these subtypes. Just separate <code>x</code> and <code>numeric x</code>.</p>
</blockquote>
<p>Those are just some random ideas that are not necessarily good. However it seems nice to change <code>numeric</code> from a predicate to <code>set</code>, which allows us to write <code>x : numeric</code> through coercion instead of <code>x : {x // numeric x}</code>: <a href="https://github.com/leanprover-community/mathlib/compare/surreal_set?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67L58">https://github.com/leanprover-community/mathlib/compare/surreal_set?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67L58</a></p>
<p>I am back from the conference and can probably flesh out and clean up more of my plan in <a href="https://github.com/leanprover-community/mathlib/tree/surreal_mul_symm">branch#surreal_mul_symm</a> this weekend; I'll keep you posted.</p>



<a name="284258759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284258759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284258759">(May 29 2022 at 01:52)</a>:</h4>
<p>Would that still allow for dot notation? If so that might be a good idea</p>



<a name="284259569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284259569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284259569">(May 29 2022 at 02:15)</a>:</h4>
<p>From your code it seems like the answer is yes</p>



<a name="284259572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284259572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284259572">(May 29 2022 at 02:15)</a>:</h4>
<p>Yeah, this looks like a good idea</p>



<a name="284570576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284570576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284570576">(Jun 01 2022 at 06:09)</a>:</h4>
<p>I've finished the proof of P1 with my symmetry approach at <a href="https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318">https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318</a><br>
I'll leave P2 and P4 to tomorrow.</p>



<a name="284653626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/284653626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#284653626">(Jun 01 2022 at 18:47)</a>:</h4>
<p>Oh nice! I haven't been nearly as free as I thought I'd be, but I'll check your code thoroughly as soon as I can</p>



<a name="285611510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611510">(Jun 10 2022 at 00:19)</a>:</h4>
<p>Should the type equality lemmas like <code>x.left_moves = y</code> be <code>simp</code>?</p>



<a name="285611522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611522">(Jun 10 2022 at 00:19)</a>:</h4>
<p>I've been told previously that they shouldn't be, but it seems like all over the code this decision has already been taken as a "yes"</p>



<a name="285611577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611577">(Jun 10 2022 at 00:20)</a>:</h4>
<p>Consider for instance <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.zero_left_moves">docs#pgame.zero_left_moves</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.one_left_moves">docs#pgame.one_left_moves</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.pow_half_left_moves">docs#pgame.pow_half_left_moves</a></p>



<a name="285611606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611606">(Jun 10 2022 at 00:20)</a>:</h4>
<p>Moreover, <code>zero_left_moves</code> is actually used a few times in some <code>dsimp</code>s</p>



<a name="285611795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611795">(Jun 10 2022 at 00:24)</a>:</h4>
<p>The rationale I got for not making them <code>simp</code> is that type equality is finicky and that this could break things. But surely <code>simp</code> will just not work in those instances?</p>



<a name="285611844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611844">(Jun 10 2022 at 00:24)</a>:</h4>
<p>Moreover, there's a few <code>simp</code> lemmas on types like <code>pempty</code> and <code>punit</code> that aren't available on general empty / unique types</p>



<a name="285611884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285611884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285611884">(Jun 10 2022 at 00:25)</a>:</h4>
<p>Like <code>∀ x : pempty, p x</code> and <code>(∀ x : punit, p x) ↔ p punit.star</code></p>



<a name="285616277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285616277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285616277">(Jun 10 2022 at 01:05)</a>:</h4>
<p>Well, I guess something that should be done anyways is generalizing <code>forall_pempty</code> and <code>exists_pempty</code> to empty types</p>



<a name="285623567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285623567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285623567">(Jun 10 2022 at 02:44)</a>:</h4>
<p>I made an attempt to redefine <code>pSet</code> and <code>pgame</code> such that they have the correct notion of equality (namely "identity") out of the box, where type equality is replaced by set equality, but Lean does not accept it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">indexed_set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">indexed_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span> <span class="n">set.range</span> <span class="n">s₁.f</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="n">s₂.f</span><span class="o">,</span>
  <span class="n">iseqv</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">eq.symm</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">eq.trans</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">inductive</span> <span class="n">pSet</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">quotient</span> <span class="bp">$</span> <span class="n">indexed_set.setoid</span> <span class="n">pSet</span><span class="o">)</span> <span class="o">:</span> <span class="n">pSet</span>

<span class="kd">inductive</span> <span class="n">pgame</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">L</span> <span class="n">R</span> <span class="o">:</span> <span class="n">quotient</span> <span class="bp">$</span> <span class="n">indexed_set.setoid</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">:</span> <span class="n">pgame</span>
<span class="c">/-</span><span class="cm">inductive type being declared can only be nested</span>
<span class="cm">inside the parameters of other inductive types -/</span>
</code></pre></div>
<p>I then immediately found <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20type.20nesting.html">this thread</a> confirming that <code>quotient</code> is forbidden, so we're out of luck.</p>



<a name="285624903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285624903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285624903">(Jun 10 2022 at 03:06)</a>:</h4>
<p>It seems to me that allowing <code>quotient</code> won't lead to paradoxes that arise when allowing <code>set</code>, but am not sure whether there are other technical problems.</p>
<p>Personally, I am fine with making type equalities <code>simp</code> lemmas in the situation of <code>pgame</code>s.</p>



<a name="285626043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285626043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285626043">(Jun 10 2022 at 03:24)</a>:</h4>
<p>But, the philosophy is that we care about the underlying set and not the indexing type, so maybe this and the right/existential versions are more benign lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">left_moves_induction</span> <span class="o">{</span><span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pgame</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span><span class="bp">.</span><span class="n">left_moves</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">move_left</span> <span class="n">_</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">xl</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">xL</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
</code></pre></div>



<a name="285626185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285626185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285626185">(Jun 10 2022 at 03:27)</a>:</h4>
<p>Sure, but those won't fire whenever the game in question isn't <code>reducible</code></p>



<a name="285626318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285626318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285626318">(Jun 10 2022 at 03:29)</a>:</h4>
<p>Also, there's a few rare situations in which we do care about the types, though granted, they arise only because of our specific design. That's when we're proving equalities (not equivalences or relabellings) between pre-games.</p>



<a name="285626334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285626334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285626334">(Jun 10 2022 at 03:29)</a>:</h4>
<p>Or when we're showing that the move sets for some game are <code>empty</code> or <code>unique</code></p>



<a name="285626449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285626449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285626449">(Jun 10 2022 at 03:31)</a>:</h4>
<p>Most of the time you can just use <code>pempty.is_empty</code> or <code>punit.unique</code> for these proofs, but if the definition is irreducible, then you need to do some type rewriting</p>



<a name="285626458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285626458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285626458">(Jun 10 2022 at 03:31)</a>:</h4>
<p>Something like that happens in the <code>ordinal.lean</code> file</p>



<a name="285628691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285628691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285628691">(Jun 10 2022 at 04:09)</a>:</h4>
<p>Whether the type is reducible, you should be able to do <code>apply (left_moves_induction _).2</code>.</p>



<a name="285628902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285628902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285628902">(Jun 10 2022 at 04:13)</a>:</h4>
<p>That wouldn't work either</p>



<a name="285628908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285628908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285628908">(Jun 10 2022 at 04:13)</a>:</h4>
<p>I'm talking about games that aren't definitionally equal to anything of the form <code>mk xl xr xL xR</code></p>



<a name="285629051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629051">(Jun 10 2022 at 04:15)</a>:</h4>
<blockquote>
<p>I'm talking about games that aren't definitionally equal to anything of the form mk xl xr xL xR</p>
</blockquote>
<p>For example?</p>



<a name="285629149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629149">(Jun 10 2022 at 04:17)</a>:</h4>
<p>The simp lemmas you want are for explicit pgames, right? The examples you gave were zero, one, and pow_half n. And <code>mk</code> is the only constructor...</p>



<a name="285629573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629573">(Jun 10 2022 at 04:25)</a>:</h4>
<p><code>ordinal.to_pgame</code></p>



<a name="285629594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629594">(Jun 10 2022 at 04:25)</a>:</h4>
<p>Since it's defined via the equation compiler, you need to use <code>rw to_pgame</code> to prove the equality with <code>mk _ _ _ _</code></p>



<a name="285629595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629595">(Jun 10 2022 at 04:25)</a>:</h4>
<p>Which is definitely odd, but that's how it goes</p>



<a name="285629644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629644">(Jun 10 2022 at 04:26)</a>:</h4>
<p>Another example might be a pre-game retrieved from an <code>exists</code></p>



<a name="285629655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629655">(Jun 10 2022 at 04:26)</a>:</h4>
<p>It's not going to be def-eq to any specific <code>mk _ _ _ _</code></p>



<a name="285629677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285629677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285629677">(Jun 10 2022 at 04:26)</a>:</h4>
<p>Although of course you can case on it</p>



<a name="285630089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285630089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285630089">(Jun 10 2022 at 04:35)</a>:</h4>
<blockquote>
<p>Another example might be a pre-game retrieved from an exists</p>
</blockquote>
<p>I don't think you can simp its moves though because you don't know what they are ...</p>



<a name="285630137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285630137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285630137">(Jun 10 2022 at 04:36)</a>:</h4>
<p>For <code>ordinal.to_pgame</code>, yes if you <code>#print</code> it you see it's <code>well_founded.fix</code> under the hood:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ordinal.to_pgame._main._pack</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span> <span class="n">pgame</span><span class="o">)</span> <span class="n">_x</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span>
  <span class="n">has_well_founded.wf.fix</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span>
       <span class="n">id_rhs</span> <span class="o">((</span><span class="bp">Π</span> <span class="o">(</span><span class="n">_y</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span> <span class="n">has_well_founded.r</span> <span class="n">_y</span> <span class="n">_x</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">)</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_F</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">_y</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">),</span> <span class="n">has_well_founded.r</span> <span class="n">_y</span> <span class="n">_x</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">),</span>
            <span class="n">mk</span> <span class="o">(</span><span class="n">quotient.out</span> <span class="n">_x</span><span class="o">)</span><span class="bp">.</span><span class="n">α</span> <span class="n">pempty</span>
              <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">quotient.out</span> <span class="n">_x</span><span class="o">)</span><span class="bp">.</span><span class="n">α</span><span class="o">),</span> <span class="k">let</span> <span class="n">hwf</span> <span class="o">:</span> <span class="n">typein</span> <span class="n">has_lt.lt</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">_x</span> <span class="o">:=</span> <span class="n">_</span> <span class="k">in</span> <span class="n">_F</span> <span class="o">(</span><span class="n">typein</span> <span class="n">has_lt.lt</span> <span class="n">x</span><span class="o">)</span> <span class="n">hwf</span><span class="o">)</span>
              <span class="n">pempty.elim</span><span class="o">))</span>
    <span class="n">_x</span>
</code></pre></div>



<a name="285631169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285631169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285631169">(Jun 10 2022 at 04:55)</a>:</h4>
<p>But in this case <code>to_pgame_left_moves</code> etc. aren't defeq, so they won't fire with <code>dsimp</code> and rewriting by them will cause problems, right? Seems a situation where induction principles would be more useful.</p>



<a name="285635147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285635147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285635147">(Jun 10 2022 at 06:08)</a>:</h4>
<p>Would this be more convenient?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">to_pgame_move_left</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">o.to_pgame.move_left</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">o.out.α</span><span class="o">,</span> <span class="o">(</span><span class="n">typein</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_pgame</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">to_pgame</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>
<p>together with lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">I₁</span> <span class="n">I₂</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">I₁</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f₂</span> <span class="o">:</span> <span class="n">I₂</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">range_eq_iff_forall_exists</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">f₁</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="n">f₂</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i₁</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">f₂</span> <span class="n">i₂</span> <span class="bp">=</span> <span class="n">f₁</span> <span class="n">i₁</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i₂</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i₁</span><span class="o">,</span> <span class="n">f₁</span> <span class="n">i₁</span> <span class="bp">=</span> <span class="n">f₂</span> <span class="n">i₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">i₁</span><span class="o">,</span> <span class="n">h.subst</span> <span class="o">(</span><span class="n">set.mem_range_self</span> <span class="n">i₁</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">h.substr</span> <span class="o">(</span><span class="n">set.mem_range_self</span> <span class="n">i₂</span><span class="o">)⟩,</span>
 <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">set.ext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">i₁</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="n">hx</span> <span class="bp">▸</span> <span class="n">h.1</span> <span class="n">i₁</span><span class="o">,</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i₂</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="n">hx</span> <span class="bp">▸</span> <span class="n">h.2</span> <span class="n">i₂</span><span class="o">⟩⟩</span>

<span class="kd">lemma</span> <span class="n">range_eq_iff_forall_iff</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">f₁</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="n">f₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">f₁</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">f₂</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">P</span><span class="o">,</span> <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">set.forall_range_iff</span> <span class="o">},</span> <span class="n">rw</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span><span class="o">,</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">revert</span> <span class="n">x</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">set.forall_range_iff</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">exacts</span> <span class="o">[(</span><span class="n">h</span> <span class="bp">$</span> <span class="n">set.range</span> <span class="n">f₂</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">$</span> <span class="n">set.range</span> <span class="n">f₁</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="n">i</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">range_eq_iff_exists_iff</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">f₁</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="n">f₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">f₁</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">f₂</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">not_forall_not</span><span class="o">,</span> <span class="n">not_iff_not</span><span class="o">],</span> <span class="n">rw</span> <span class="n">range_eq_iff_forall_iff</span> <span class="n">f₁</span> <span class="n">f₂</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">P</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">P</span><span class="o">,</span> <span class="n">convert</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span><span class="n">P</span> <span class="n">x</span><span class="o">)</span><span class="bp">;</span> <span class="n">simp_rw</span> <span class="n">not_not</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="285636089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285636089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285636089">(Jun 10 2022 at 06:24)</a>:</h4>
<p>More convenient than what? I think the current API works pretty well already</p>



<a name="285636196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285636196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285636196">(Jun 10 2022 at 06:25)</a>:</h4>
<p><code>to_left_moves_to_pgame</code> together with its small API are really all you need</p>



<a name="285636527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285636527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285636527">(Jun 10 2022 at 06:31)</a>:</h4>
<p>My point is that in general when the pgame is defined recursively and not defeq to some <code>mk</code>, you may prove an equality between <code>set.range</code> and automatically unlock the forall/exists lemmas.</p>
<p>More generally, if you want to change the indexing type, you may show one of the four conditions and automatically get the other three.</p>
<p>It doesn't seem to me that the APIs around <code>ordinal.to_pgame</code> are completely satisfactory; I think we should strive to eliminate heq lemmas if possible.</p>



<a name="285636704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285636704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285636704">(Jun 10 2022 at 06:33)</a>:</h4>
<p>That approach certainly works, though I still prefer the current one. Building the equivalence between <code>set.Iio o</code> and <code>o.to_pgame.left_moves</code> just makes it really convenient to build a given move, or to reason about an arbitrary one.</p>



<a name="285636773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285636773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285636773">(Jun 10 2022 at 06:34)</a>:</h4>
<p>There is a <code>heq</code> lemma, but it's used only once and never again. If we wanted to, we could make it <code>private</code> and it wouldn't break anything. The API doesn't really depend on it.</p>



<a name="285637166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285637166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285637166">(Jun 10 2022 at 06:41)</a>:</h4>
<p>Moreover, the current aprroach allows you to explicitly build a move that leads to a certain position, instead of just declaring it exists</p>



<a name="285637187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285637187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285637187">(Jun 10 2022 at 06:41)</a>:</h4>
<p>This pattern of building equivalences between left/right moves of games and simpler types is one I've replicated throughout the whole game API, and it's worked very well</p>



<a name="285639158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285639158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285639158">(Jun 10 2022 at 07:10)</a>:</h4>
<p>I think my approach still allows you to build move if desired; it only forgets the equivalence (or weaker correspondences) that goes between the two indexing types, but still remembers the two indexing functions. For example, with this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">o.to_pgame.move_left</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">set.Iio</span> <span class="n">o</span><span class="o">,</span> <span class="n">to_pgame</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">symmetry</span><span class="o">,</span> <span class="n">rw</span> <span class="n">to_pgame</span><span class="o">,</span> <span class="n">convert</span> <span class="n">function.surjective.range_comp</span> <span class="o">(</span><span class="n">enum_iso_out</span> <span class="n">o</span><span class="o">)</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">subtype.ext_iff.1</span> <span class="o">((</span><span class="n">enum_iso_out</span> <span class="n">o</span><span class="o">)</span><span class="bp">.</span><span class="n">symm_apply_apply</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>you can choose to build the move using <code>o.to_pgame.move_left</code> or using <code>to_pgame</code>.</p>



<a name="285639642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285639642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285639642">(Jun 10 2022 at 07:17)</a>:</h4>
<p>What I mean is, say you want a move <code>i</code> such that <code>(to_pgame 2).move_left i = to_pgame 1</code>. With your approach, you need to show <code>to_pgame 1 ∈ set.range (λ x : set.Iio 2, to_pgame x)</code> (which is pretty easy, granted), then rewrite into <code>to_pgame 1 ∈ set.range o.to_pgame.move_left</code>, and that still only tells you that there exists some move with the property you want. You need to use <code>cases</code> to actually retrieve the move. </p>
<p>If you're building data, you'll instead need to call <code>classical.some</code>.</p>
<p>With my approach, you can explicitly build said move as <code>to_left_moves_to_pgame ⟨1, one_lt_two⟩</code>, and <code>simp</code> will do the rest.</p>



<a name="285639908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285639908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285639908">(Jun 10 2022 at 07:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.to_pgame_lf">docs#ordinal.to_pgame_lf</a> is a very good example of this in action.</p>



<a name="285641458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285641458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285641458">(Jun 10 2022 at 07:42)</a>:</h4>
<p>With my approach the proof for <code>to_pgame_lf</code> would be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">range_move_left_eq_range_to_pgame</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">o.to_pgame.move_left</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">set.Iio</span> <span class="n">o</span><span class="o">,</span> <span class="n">to_pgame</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span> <span class="c">/-</span><span class="cm"> see earlier post -/</span>

<span class="kd">lemma</span> <span class="n">range_eq_iff_forall_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">I₁</span> <span class="n">I₂</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f₁</span> <span class="o">:</span> <span class="n">I₁</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f₂</span> <span class="o">:</span> <span class="n">I₂</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set.range</span> <span class="n">f₁</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="n">f₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">f₁</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">P</span> <span class="bp">$</span> <span class="n">f₂</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span> <span class="c">/-</span><span class="cm"> see earlier post -/</span>

<span class="kd">theorem</span> <span class="n">to_pgame_lf</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a.to_pgame</span> <span class="bp">⧏</span> <span class="n">b.to_pgame</span> <span class="o">:=</span>
<span class="o">((</span><span class="n">range_eq_iff_forall_iff</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">range_move_left_eq_range_to_pgame</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">function.swap</span> <span class="n">lf</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">move_left_lf</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
</code></pre></div>



<a name="285641682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285641682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285641682">(Jun 10 2022 at 07:45)</a>:</h4>
<p>Yeah, I feel like my approach is simpler both conceptually and in terms of the final code</p>



<a name="285641711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285641711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285641711">(Jun 10 2022 at 07:45)</a>:</h4>
<p>Seems odd having to use a clever induction principle for something like this</p>



<a name="285641785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285641785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285641785">(Jun 10 2022 at 07:46)</a>:</h4>
<p>Especially when the pencil and paper proof of this theorem is just "since <code>a &lt; b</code>, there's a left move from <code>b.to_pgame</code> to <code>a.to_pgame</code>, Q.E.D"</p>



<a name="285685119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285685119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285685119">(Jun 10 2022 at 14:42)</a>:</h4>
<p>The following might everything more convenient and will make simp lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.zero_left_moves">docs#pgame.zero_left_moves</a> obsolete, but may need a large refactor: namely, for each concrete pgame, register two instances <code>has_left_moves</code> and <code>has_right_moves</code>; for example, for <code>ordinal.to_pgame</code>we register the instance <code>has_left_moves (o.to_pgame)</code> which holds the data of an indexing type <code>set.Iio o</code> (which lies in a higher universe but is more convenient), the indexing function <code>λ x, to_pgame x</code>, and a proof that the range of the indexing function is equal to the range of <code>x.move_left</code>. For the theorems that mentions <code>left_moves</code> and <code>move_left</code>, make a version that takes an additional typeclass argument <code>has_left_moves x</code>, and use the indexing type as <code>left_moves</code> and the indexing function as <code>move_left</code> instead; the new version would be proved from the old using my <code>range_eq_iff_forall_iff</code> and <code>range_eq_iff_exists_iff</code>. This way, I think we can forget about <code>left_moves</code> and always directly work with the desired indexing function.</p>



<a name="285701233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285701233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285701233">(Jun 10 2022 at 16:34)</a>:</h4>
<p>I'm going to oppose this on grounds that it's just too clever</p>



<a name="285701284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285701284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285701284">(Jun 10 2022 at 16:34)</a>:</h4>
<p>I've worked with large and rapidly changing codebases before, and being too clever is what ultimately led to their downfall</p>



<a name="285701538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285701538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285701538">(Jun 10 2022 at 16:36)</a>:</h4>
<p>And really, I don't want to forget about the concrete types. They're a quirk of our design choices, sure, but they're quirks that make sense and are convenient within type theory, which is what we're working with.</p>



<a name="285707316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285707316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285707316">(Jun 10 2022 at 17:21)</a>:</h4>
<p>Well, I'm just trying my best to address your original question about simp lemmas, but it seems you are not open enough to new ideas :( I think in mathlib we are not afraid of doing large refactors, not to mention that the current combinatorial game library is only an isolated small corner of mathlib.</p>
<p>As a rule of thumb, I think in the case of non-defeq indexing types, the indexing type and the indexing function should be bundled and rewritten together, and equality between <code>set.range</code> is the condition that allows you to rewrite between two such bundled functions.</p>
<p>My approach doesn't forget about "concrete types", instead it designate a preferred indexing type via typeclass resolution. In the case of <code>ordinal.pgame</code>, <code>Iio</code> is arguably the indexing type we want, but it lives in a higher universe, so we must complete the construction using <code>o.out.α</code> first and change the indexing type later. Once we have our desired indexing type and function and know it's equivalent to the original via <code>set.range</code>, I do think we can forget the original indexing type and the transition functions between the indexing types. After all combinatorial game theory talks about <em>sets</em> of left and right options, so if there's anything that depends on the particular indexing type, that doesn't belong to CGT and it would be nice if our API hides it.</p>



<a name="285708822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285708822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285708822">(Jun 10 2022 at 17:32)</a>:</h4>
<p>Don't get me wrong, I'm open to new ideas, but hiding implementation details via an ad-hoc typeclass just doesn't seem like a good one. Once again, the current approach achieves the same thing, and I argue that it achieves it more clearly and easily.</p>



<a name="285709017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285709017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285709017">(Jun 10 2022 at 17:34)</a>:</h4>
<p>And even if we went with your approach, I'm not sure how that answers the question about simp lemmas. We might need them less often, sure, but there's still the possibility.</p>



<a name="285709500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285709500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285709500">(Jun 10 2022 at 17:38)</a>:</h4>
<p>In fact, even if we went with your approach, why would using <code>set.range</code> be preferable to the equivalence approach? And if it isn't, and we went with the equivalence approach, surely the only thing we'd accomplish is hiding the equivalence behind a typeclass, which doesn't seem like a good idea?</p>



<a name="285711451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285711451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285711451">(Jun 10 2022 at 17:55)</a>:</h4>
<p><code>set.range</code> is convenient as there is a large amount of APIs around it, for example <a href="https://leanprover-community.github.io/mathlib_docs/find/function.surjective.range_comp">docs#function.surjective.range_comp</a> allows you to reindex by the domain of a surjective function to the original indexing type; an equivalence is in particular surjective.</p>
<p>Notice that since I aim to forget the original indexing type, there is no way I can keep the equivalence (which I referred to more generally as the "transition function"), so it has to be forgotten as well. Of course, if you reindex using <code>g ∘ f</code> instead of <code>g</code>, then the transition function <code>f</code> is effectively still there. In the <code>ordinal.to_pgame</code> case however, we have another preferred indexing function <code>h = to_pgame</code> with domain <code>Iio o</code>, and after <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/285639158">proving that <code>h = g ∘ f</code></a>, we indeed forget about <code>f</code> and <code>g</code>, which is good IMO.</p>



<a name="285720511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285720511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285720511">(Jun 10 2022 at 19:11)</a>:</h4>
<p>There is a lot of API around equivalences too</p>



<a name="285720707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285720707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285720707">(Jun 10 2022 at 19:13)</a>:</h4>
<p>Another grounds on which I disagree with this refactor is that in Lean, types and functions are simply much more convenient than sets, no matter how you put it. Rephrasing traditionally set-theoretic concepts in terms of types is something mathlib doesn't shy away from, and I don't think we should either unless there's a clear benefit.</p>



<a name="285721738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285721738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285721738">(Jun 10 2022 at 19:22)</a>:</h4>
<p>Let me repeat: I never propose to throw away the indexing type anywhere above. Even in the <code>quotient indexed_set.setoid</code> approach which gives you a type of small sets (as opposed to proper classes), you still construct a small set from an indexing type/function. What I said is results in CGT should be independent of the indexing type/function, so you are free to change to any equivalent indexing type/function, and <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/285635147">this post</a> contains the essential APIs to work with the equivalence. <code>set.range</code> is just the simplest way (among the four equivalent ways) of stating the most general condition (more general than equivalences) for two indexing types/functions to be considered equivalent. Typeclass mechanism can be used to automatically come up with the preferred indexing type/function.</p>



<a name="285722568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285722568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285722568">(Jun 10 2022 at 19:30)</a>:</h4>
<p>I see, so your approach is strictly more general</p>



<a name="285722762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285722762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285722762">(Jun 10 2022 at 19:32)</a>:</h4>
<p>I don't think there's any current circumstance where we need to deduplicate moves, and I can't think of a possible scenario for this</p>



<a name="285751870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285751870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285751870">(Jun 11 2022 at 02:19)</a>:</h4>
<p>The intention of my current proposal is not to deduplicate move or to define the identity relation on pgames (that would require a condition more general than equality of ranges, as some options may be identical but not equal), but merely to freely switch the original move indexing type/function to our preferred one.</p>
<p>I think in your original examples zero, one, and pow_half, where the desired indexing type/function is defeq to the original, my proposal isn't of much use and <code>dsimp</code> would be good enough; the <code>ordinal.to_pgame</code> example that you raised later is a situation my proposal is aimed at: we want to change to a indexing type that is not only not defeq to the original, but actually live in a higher universe.</p>
<p>In the meantime, I've come up with another situation where my proposal would be useful, namely <code>(-x).left_moves</code>, which is equal to <code>x.right_moves</code> but not defeq, which necessitates <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.to_left_moves_neg">docs#pgame.to_left_moves_neg</a> and 8 lemmas following it. If we make <code>x.right_moves</code> the default indexing type for <code>(-x).left_moves</code>, we should be able to reduce the number of lemmas and simplify the development. I think the same holds true for addition (<a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.to_left_moves_add">docs#pgame.to_left_moves_add</a>) and multiplication as well, and other cases of non-defeq-ness due to the use of <code>well_founded.fix</code> (feel free to add examples!).</p>



<a name="285759652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285759652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285759652">(Jun 11 2022 at 05:09)</a>:</h4>
<p>Ah, I can see the appeal now</p>



<a name="285759670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285759670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285759670">(Jun 11 2022 at 05:09)</a>:</h4>
<p>I think there's an alternate solution that's a bit easier, though</p>



<a name="285759673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285759673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285759673">(Jun 11 2022 at 05:09)</a>:</h4>
<p>We can do induction lemmas</p>



<a name="285759712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285759712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285759712">(Jun 11 2022 at 05:10)</a>:</h4>
<p>"if a proposition holds true for any left move of <code>x</code>, it holds for any right move of <code>-x</code>"</p>



<a name="285759717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/285759717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#285759717">(Jun 11 2022 at 05:10)</a>:</h4>
<p>I think this would achieve the same goal more easily</p>



<a name="286111642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286111642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286111642">(Jun 14 2022 at 18:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="224323">@Junyan Xu</span> I think <code>impartial</code> shouldn't be a typeclass</p>



<a name="286111754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286111754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286111754">(Jun 14 2022 at 18:09)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/3974">#3974</a>, which is where it was made into a typeclass, gives two justifications:</p>
<ul>
<li>it means you don't have to use lemmas like <code>impartial_add</code> all the time</li>
<li><code>grundy_value</code> doesn't have this annoying extra argument</li>
</ul>



<a name="286111851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286111851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286111851">(Jun 14 2022 at 18:10)</a>:</h4>
<p>The second reasoning is now obsolete, since I removed the <code>impartial</code> argument from <code>grundy_value</code> a while back<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.grundy_value">docs#pgame.grundy_value</a></p>



<a name="286111898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286111898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286111898">(Jun 14 2022 at 18:10)</a>:</h4>
<p>Although the theorems need it, the definition itself doesn't</p>



<a name="286111977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286111977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286111977">(Jun 14 2022 at 18:11)</a>:</h4>
<p>The first argument seems like not a very compelling reason on its own</p>



<a name="286112031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286112031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286112031">(Jun 14 2022 at 18:11)</a>:</h4>
<p>The major con of this decision is that it goes against the general design style that typeclasses are meant for types, with rare exceptions</p>



<a name="286112261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286112261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286112261">(Jun 14 2022 at 18:13)</a>:</h4>
<p>And of course, there's the issues of using <code>unfreezingI</code></p>



<a name="286112291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286112291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286112291">(Jun 14 2022 at 18:13)</a>:</h4>
<p>I wonder what Scott's reasoning for being against this was</p>



<a name="286118299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286118299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286118299">(Jun 14 2022 at 19:03)</a>:</h4>
<p>(deleted)</p>



<a name="286299860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286299860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286299860">(Jun 16 2022 at 02:37)</a>:</h4>
<p>One advantage of making it an typeclass is that we can introduce instance like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">impartial_mk</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">pgame.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">impartial</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">impartial</span> <span class="o">(</span><span class="n">pgame.mk</span> <span class="n">α</span> <span class="n">α</span> <span class="n">f</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and for new impartial pgames you define, you can use <code>@[derive impartial]</code> to automatically generate the instance. I don't know how good Lean is at inferring instances like <code>∀ a, impartial (f a)</code>, though.<br>
This is more suitable for the "actual" impartial games, requiring the left options to be the same as the right options. It's not so suitable for the current mathlib definition, because the G ≈ -G condition can be nontrivial to verify and is not a typeclass.</p>
<p>Similarly, we might introduce</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">dicotic_mk_nonempty</span> <span class="o">(</span><span class="n">xl</span> <span class="n">xr</span><span class="o">)</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">xl</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">xr</span><span class="o">]</span>
  <span class="o">(</span><span class="n">xL</span> <span class="o">:</span> <span class="n">xl</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">(</span><span class="n">xR</span> <span class="o">:</span> <span class="n">xr</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">dicotic</span> <span class="o">(</span><span class="n">xL</span> <span class="n">i</span><span class="o">)]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">dicotic</span> <span class="o">(</span><span class="n">xR</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">dicotic</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="n">dicotic_mk_empty</span> <span class="o">(</span><span class="n">xl</span> <span class="n">xr</span><span class="o">)</span> <span class="o">[</span><span class="n">is_empty</span> <span class="n">xl</span><span class="o">]</span> <span class="o">[</span><span class="n">is_empty</span> <span class="n">xr</span><span class="o">]</span> <span class="o">(</span><span class="n">xL</span> <span class="o">:</span> <span class="n">xl</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">(</span><span class="n">xR</span> <span class="o">:</span> <span class="n">xr</span> <span class="bp">→</span> <span class="n">pgame</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">dicotic</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c">/-</span><span class="cm"> relabelling of the zero game, not of much use; `zero_dicotic` plus the above should suffice. -/</span>
<span class="c">/-</span><span class="cm"> basically the same as `dicotic_of_is_empty_moves`. -/</span>
</code></pre></div>
<p>If Lean has trouble inferring the forall instances, we might introduce</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">dicotic_mk_const</span> <span class="o">(</span><span class="n">xl</span> <span class="n">xr</span> <span class="n">xL</span> <span class="n">xR</span><span class="o">)</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">xl</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">xr</span><span class="o">]</span> <span class="o">[</span><span class="n">dicotic</span> <span class="n">xL</span><span class="o">]</span> <span class="o">[</span><span class="n">dicotic</span> <span class="n">xR</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">dicotic</span> <span class="o">(</span><span class="n">mk</span> <span class="n">xl</span> <span class="n">xr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">xL</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">xR</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>which covers the case where <code>xl</code> and <code>xr</code> are <code>punit</code>.</p>



<a name="286301185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286301185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286301185">(Jun 16 2022 at 03:06)</a>:</h4>
<p>I'm still not sure if this justifies the typeclass approach. Sure, it's more convenient in some ways, but we aren't making every definition into a typeclass and I'm interested in knowing why</p>



<a name="286306049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286306049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286306049">(Jun 16 2022 at 04:52)</a>:</h4>
<blockquote>
<p>The major con of this decision is that it goes against the general design style that typeclasses are meant for types, with rare exceptions</p>
</blockquote>
<p>Indeed not many examples of typeclasses come to mind that are not for types; typeclasses in <a href="https://tqft.net/mathlib/order/rel_classes">file#order/rel_classes</a>, <a href="https://tqft.net/mathlib/algebra/covariant_and_contravariant">file#algebra/covariant_and_contravariant</a>, <a href="https://leanprover-community.github.io/mathlib_docs/init/algebra/classes.html">core/init/algebra/classes</a> are mostly not classes on types but maybe they're meant for some canonical operations/relations on types.</p>
<p>In this particular case, since pgames are constructed in a hierarchical way, I think it makes sense to introduce classes on elements of <code>pgame</code>: deriving a property of a <code>pgame</code> from similar properties of its constituents is akin to deriving structure on / property of a more complicated type constructed from a simpler type, from the structure on / property of the simpler type, like <a href="https://leanprover-community.github.io/mathlib_docs/find/witt_vector.comm_ring">docs#witt_vector.comm_ring</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.unique_factorization_monoid">docs#mv_polynomial.unique_factorization_monoid</a>. When we can automate derivation of a structure/property simply by pattern matching, and if it will be used a lot, then I think it's worth being made a typeclass and declare the patterns as instances.</p>



<a name="286311270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286311270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286311270">(Jun 16 2022 at 06:27)</a>:</h4>
<p>Well in that case, it's probably worth making <code>numeric</code> into a typeclass too</p>



<a name="286311275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286311275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286311275">(Jun 16 2022 at 06:27)</a>:</h4>
<p>I wonder what the maintainers think</p>



<a name="286312120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286312120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286312120">(Jun 16 2022 at 06:35)</a>:</h4>
<p>For <code>numeric</code>, the left_lt_right condition isn't usually trivial to check, and lt isn't a typeclass. Of course, if one of the left/right move set is empty, then the condition is vacuously true, and this case could be made an instance.</p>



<a name="286378625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286378625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286378625">(Jun 16 2022 at 16:30)</a>:</h4>
<p>But why a typeclass? We already have a theorem that does the same thing</p>



<a name="286378724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286378724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286378724">(Jun 16 2022 at 16:31)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.numeric_of_is_empty_left_moves">docs#pgame.numeric_of_is_empty_left_moves</a></p>



<a name="286378909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286378909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286378909">(Jun 16 2022 at 16:33)</a>:</h4>
<p>Also, I've been told that an alternate and simpler approach is to do the thing you suggested a while back, a tactic to solve <code>numeric</code> goals</p>



<a name="286378971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286378971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286378971">(Jun 16 2022 at 16:33)</a>:</h4>
<p>This does have a precedent in mathlib, with tactics like <code>monotonicity</code> and <code>continuity</code></p>



<a name="286379058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286379058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286379058">(Jun 16 2022 at 16:34)</a>:</h4>
<p>That said, I still haven't gotten any specific reason against the typeclass pattern, other than various people finding it annoying and little use throughout mathlib</p>



<a name="286383840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286383840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286383840">(Jun 16 2022 at 17:12)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> just told me that the main reason is to avoid overuse of typeclass inference</p>



<a name="286384036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286384036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286384036">(Jun 16 2022 at 17:13)</a>:</h4>
<p>So now the question is, how do we make these <code>numericity</code> and <code>impartiality</code> and whatnot tactics?</p>



<a name="286396406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286396406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286396406">(Jun 16 2022 at 18:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/286383840">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> just told me that the main reason is to avoid overuse of typeclass inference</p>
</blockquote>
<p>At least, that's what I think the reason is - there could well be a better reason!</p>



<a name="286412101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286412101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286412101">(Jun 16 2022 at 20:54)</a>:</h4>
<p>Instead of replacing typeclass, <a href="https://github.com/leanprover-community/mathlib/pull/13417/files#diff-c562213980884826feaaa85563a2f8634c703d4f6c59bb27c8941d1296dac0f2R38">the <code>coherence</code> tactic</a> instead <strong>introduced</strong> two typeclasses, so I doesn't seem to be a universal pattern to replace typeclasses by tactics. And after all, <code>apply_instance</code> is also a tactic and it solves goals if you set up the instances right.</p>
<p>A key difference between numeric/impartial/dicotic and continuity/measurability/monotonicity is that the latter are used widely across mathlib, so overusing typeclasses may cause performance issues, especially when there are many instances of the typeclasses. For the relatively secluded theory of combinatorial games, it seems need not worry much about performance issues. Here (as in the case of <code>coherence</code>) I consider typeclass inference just as a domain-specific way to automate by pattern matching. (I think the typeclasses for the <code>coherence</code> are more secluded and only used in the tactic though.)</p>



<a name="286413019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286413019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286413019">(Jun 16 2022 at 21:01)</a>:</h4>
<p>I'm on board with you, but I still want to hear a maintainer's opinion</p>



<a name="286413304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286413304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286413304">(Jun 16 2022 at 21:03)</a>:</h4>
<p>Maybe let us hear from <span class="user-mention" data-user-id="110087">@Scott Morrison</span> since he authored both the first coherence tactic <a href="https://github.com/leanprover-community/mathlib/pull/13125">#13125</a> and part of the game library.</p>



<a name="286467225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286467225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286467225">(Jun 17 2022 at 09:39)</a>:</h4>
<p>In my experience, typeclasses work well if nearly all instances can be inferred using only a set of theorems of the form <code>P1 (f x) → P2 (g y) → ... → Q x y ... z</code>, where <code>f x</code> and <code>g y</code> are stated literally and don't do any computation, and there's never theorems <code>P → P</code>, or both <code>P → Q</code> and <code>Q → P</code> at the same time. As soon as you have to deal with equalities (your instance is on <code>fx'</code> and <code>fx' = f x</code> but not literally the same expression), or there is the possibility of looping, you're going to get a bad time.</p>



<a name="286467531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286467531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286467531">(Jun 17 2022 at 09:42)</a>:</h4>
<p>In this case, if there is a nontrivial equality on <code>pgame</code> (i.e. two <code>pgames</code> can be definitionally or propositionally equal without literally being written the same), I suspect typeclasses can't keep up.</p>



<a name="286467724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286467724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286467724">(Jun 17 2022 at 09:44)</a>:</h4>
<p>I actually suspect the inference speed is not a huge issue in this case, in my experience the real slowdown comes from checking definitional equality of instances in types that have instances that have types etc.</p>



<a name="286467958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286467958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286467958">(Jun 17 2022 at 09:47)</a>:</h4>
<p>One approach you could consider is to define a tactic <code>meta def impartial_tac := apply_instance</code> and use this as a <a href="https://leanprover-community.github.io/mathlib_docs/find/auto_param">docs#auto_param</a>: instead of <code>[impartial p]</code> you write <code>(h : impartial p . impartial_tac)</code> and you basically get the same semantics at the moment, and when instances don't scale you replace the code of <code>impartial_tac</code> with something smarter.</p>



<a name="286468090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286468090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286468090">(Jun 17 2022 at 09:49)</a>:</h4>
<p>Drawback is that instance implicits like <code>[impartial p]</code> are much more common than auto_params so there's the possiblity that some tactics (or some parts of the elaborator) can't handle auto_param well.</p>



<a name="286468174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286468174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286468174">(Jun 17 2022 at 09:50)</a>:</h4>
<p>Which is why you should first try using <code>apply_instance</code> as definition for the <code>auto_param</code>, then you can be sure that nothing breaks before you upgrade the tactic.</p>



<a name="286475414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286475414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286475414">(Jun 17 2022 at 11:15)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> I really love the insights you give to this community <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span> Thank you.</p>



<a name="286630118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286630118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286630118">(Jun 18 2022 at 05:16)</a>:</h4>
<p>Do we have any consensus on keeping/refactoring <code>impartial</code>?</p>



<a name="286630211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286630211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286630211">(Jun 18 2022 at 05:18)</a>:</h4>
<p>It seems like the general consensus isn't a good design pattern even though it's slightly useful sometimes</p>



<a name="286630213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286630213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286630213">(Jun 18 2022 at 05:18)</a>:</h4>
<p>So, not really a strong argument either way</p>



<a name="286630585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286630585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286630585">(Jun 18 2022 at 05:26)</a>:</h4>
<p>There might be a sort of "death by a thousand cuts" argument against having it as a class</p>



<a name="286631050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286631050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286631050">(Jun 18 2022 at 05:36)</a>:</h4>
<p>Actually, let me list out pros and cons</p>
<p>Pros:</p>
<ul>
<li>theorems like <code>impartial_add</code>, <code>impartial_neg</code>, <code>impartial_sub</code>, <code>impartial_zero</code> can be omitted</li>
<li>we might be able to <code>derive</code> the class in some common circumstances</li>
</ul>
<p>Cons:</p>
<ul>
<li>we have <code>resetI</code> issues when we want to manipulate an impartial pre-game, like e.g. doing induction on it or unfolding the definition</li>
<li>pre-game equality is really finicky and rarely definitional (due to the inductive definitions), so instances aren't super effective</li>
<li>typeclasses seem to be somewhat of an antipattern in this situation (there's limited precedent)</li>
<li><code>grundy_value</code> no longer depends on the typeclass parameter, this was one of the original reasons for the typeclass</li>
<li>a tactic could do both of the pros</li>
</ul>



<a name="286631282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286631282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286631282">(Jun 18 2022 at 05:41)</a>:</h4>
<p>I'd also argue that the pros are barely anything to write home about. It's super simple to just call these theorems explicitly.</p>



<a name="286631289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286631289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286631289">(Jun 18 2022 at 05:41)</a>:</h4>
<p>So, even if there's not a strong argument either way, there seem to be much more weak arguments in favor of ditching the class</p>



<a name="286631388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286631388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286631388">(Jun 18 2022 at 05:43)</a>:</h4>
<p>Oh, and one last con: if we keep <code>impartial</code> as a class, then it stands to reason we should do the same for other definitions that are closed under basic operations, like <code>numeric</code> games, or <code>small</code> games, or <code>dicotic</code> games, so the cons scale up</p>



<a name="286641798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286641798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286641798">(Jun 18 2022 at 09:44)</a>:</h4>
<p>I think we're missing some basic machinery mathlib-wide for propositions closed under operations</p>



<a name="286641821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/286641821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#286641821">(Jun 18 2022 at 09:45)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid_class">docs#submonoid_class</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/is_submonoid">docs#is_submonoid</a> come close, but neither seems to be used much for this type of thing</p>



<a name="287412958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287412958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287412958">(Jun 25 2022 at 05:05)</a>:</h4>
<p>As you may have noticed, I've been a bit busy tying up what I consider to be loose ends with the game API</p>



<a name="287413094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287413094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287413094">(Jun 25 2022 at 05:07)</a>:</h4>
<p>Nothing incredibly important, but still, a lot of things that are breaking changes</p>



<a name="287413164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287413164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287413164">(Jun 25 2022 at 05:08)</a>:</h4>
<p>Once I'm done with all that, I'll be free to clean up the multiplication proof and hopefully PR it</p>



<a name="287417372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287417372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287417372">(Jun 25 2022 at 06:26)</a>:</h4>
<p>Unrelated but what's up with <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.restricted">docs#pgame.restricted</a>?</p>



<a name="287417377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287417377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287417377">(Jun 25 2022 at 06:27)</a>:</h4>
<p>Might have asked before but I'm thinking about this again and I'm confused</p>



<a name="287417383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287417383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287417383">(Jun 25 2022 at 06:27)</a>:</h4>
<p>The description would be accurate if L and R were injective, but they aren't</p>



<a name="287417407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287417407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287417407">(Jun 25 2022 at 06:28)</a>:</h4>
<p>And I can't think of any natural examples of a game being a restriction of another, except for the case of relabellings</p>



<a name="287417449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287417449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287417449">(Jun 25 2022 at 06:28)</a>:</h4>
<p>So this really just seems like an auxiliary definition of sorts</p>



<a name="287417628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287417628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287417628">(Jun 25 2022 at 06:32)</a>:</h4>
<p>Maybe the idea was to define it in terms of injective functions and prove x &lt;= y from that, but then someone realized you didn't need the injective hypothesis</p>



<a name="287418609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287418609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287418609">(Jun 25 2022 at 06:50)</a>:</h4>
<p>I don't think the definition is worthless, it's certainly an... interesting way to show an inequality. But maybe it should be renamed, and at the very least the docstring should be changed</p>



<a name="287445069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287445069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287445069">(Jun 25 2022 at 17:00)</a>:</h4>
<p>Another question, what's up with <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.equiv.has_coe">docs#pgame.equiv.has_coe</a>?</p>



<a name="287445078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287445078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287445078">(Jun 25 2022 at 17:00)</a>:</h4>
<p>I don't think it's currently used anywhere</p>



<a name="287445099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287445099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287445099">(Jun 25 2022 at 17:01)</a>:</h4>
<p>Is there any precedent for using casts for proofs?</p>



<a name="287465305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287465305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287465305">(Jun 26 2022 at 01:31)</a>:</h4>
<p>I just had this idea that, in retrospect, is something <span class="user-mention" data-user-id="125393">@Junyan Xu</span> had suggested</p>



<a name="287465352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287465352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287465352">(Jun 26 2022 at 01:32)</a>:</h4>
<p>We should make a comparison function for games, that outputs one of four outcomes</p>



<a name="287465359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287465359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287465359">(Jun 26 2022 at 01:33)</a>:</h4>
<p>Less, equivalent, greater, fuzzy</p>



<a name="287465365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287465365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287465365">(Jun 26 2022 at 01:33)</a>:</h4>
<p>There's a lot we could do with such a function</p>



<a name="287465459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287465459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287465459">(Jun 26 2022 at 01:36)</a>:</h4>
<p>Of particular interest to me are the fact this function can be lifted to games and surreals, and that its value is the same when you add a game to both sides</p>



<a name="287465524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287465524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287465524">(Jun 26 2022 at 01:37)</a>:</h4>
<p>By proving this, we could get a lot of lemmas currently either taking a lot of API space or missing, almost for free</p>



<a name="287466439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287466439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287466439">(Jun 26 2022 at 02:01)</a>:</h4>
<p>For instance, to prove <code>cmp w x = cmp y z</code> it suffices to prove <code>w \le x \iff y \le z</code> and <code>x \le w \iff z \le y</code>, which in many cases can be reduced to just the <code>\le</code> case by symmetry</p>



<a name="287466488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287466488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287466488">(Jun 26 2022 at 02:02)</a>:</h4>
<p>But that gives you <code>r w x \iff r y z</code> for <code>\le</code> and <code>&lt;</code> and <code>\equiv</code> and <code>\fuzzy</code> for free which is super cool</p>



<a name="287466657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287466657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287466657">(Jun 26 2022 at 02:07)</a>:</h4>
<p>I'll prove some basic theorems about this comparison function</p>



<a name="287466661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287466661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287466661">(Jun 26 2022 at 02:07)</a>:</h4>
<p>I can't do a lot since I currently have like three sweeping changes on the same files PR'd</p>



<a name="287466865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287466865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287466865">(Jun 26 2022 at 02:13)</a>:</h4>
<p>Speaking of which, if so done could review my "comparison API review" and my refactor on relabellings that would be awesome</p>



<a name="287476177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287476177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287476177">(Jun 26 2022 at 06:34)</a>:</h4>
<p>Oh wow</p>



<a name="287476189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287476189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287476189">(Jun 26 2022 at 06:35)</a>:</h4>
<p>This new API on comparison is so overpowered I was able to comfortably prove pretty much every single variant of the covariant and contravariant theorems on pre-games without ever even appealing to the <code>game</code> structure</p>



<a name="287476629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287476629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287476629">(Jun 26 2022 at 06:46)</a>:</h4>
<p>It's extremely boilerplatey, but that's what peak performance looks like ;)</p>



<a name="287511587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287511587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287511587">(Jun 26 2022 at 20:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287466439">said</a>:</p>
<blockquote>
<p>For instance, to prove <code>cmp w x = cmp y z</code> it suffices to prove <code>w ≤ x ↔ y ≤ z</code> and <code>x ≤ w ↔ z ≤ y</code>, which in many cases can be reduced to just the `≤ case by symmetry</p>
</blockquote>
<p>Do you know about <a href="https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le'">docs#lt_iff_lt_of_le_iff_le'</a>?</p>



<a name="287515722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287515722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287515722">(Jun 26 2022 at 21:47)</a>:</h4>
<p>Should we introduce fuzzy and lf for any preorder? And equiv (≈), which is already there if we use <a href="https://leanprover-community.github.io/mathlib_docs/find/antisymm_rel.setoid">docs#antisymm_rel.setoid</a>.</p>



<a name="287515847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287515847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287515847">(Jun 26 2022 at 21:50)</a>:</h4>
<p>I think this cmp function can be defined on all preorders without trouble.</p>



<a name="287515870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287515870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287515870">(Jun 26 2022 at 21:51)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/cmp">docs#cmp</a> is already a thing, but it has linear orders in mind.</p>



<a name="287516683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516683">(Jun 26 2022 at 22:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287511587">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287466439">said</a>:</p>
<blockquote>
<p>For instance, to prove <code>cmp w x = cmp y z</code> it suffices to prove <code>w ≤ x ↔ y ≤ z</code> and <code>x ≤ w ↔ z ≤ y</code>, which in many cases can be reduced to just the `≤ case by symmetry</p>
</blockquote>
<p>Do you know about <a href="https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le'">docs#lt_iff_lt_of_le_iff_le'</a>?</p>
</blockquote>
<p>Yep, these aren't quite the same lemmas though</p>



<a name="287516708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516708">(Jun 26 2022 at 22:10)</a>:</h4>
<p>Sure, you also need <a href="https://leanprover-community.github.io/mathlib_docs/find/iff.not">docs#iff.not</a>. But my point is that those two are enough.</p>



<a name="287516734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516734">(Jun 26 2022 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287515722">said</a>:</p>
<blockquote>
<p>Should we introduce fuzzy and lf for any preorder? And equiv (≈), which is already there if we use <a href="https://leanprover-community.github.io/mathlib_docs/find/antisymm_rel.setoid">docs#antisymm_rel.setoid</a>.</p>
</blockquote>
<p>We discussed this back when I introduced <code>lf</code>. Our conclusion was basically that yes, we could define this on all partial orders, but it wouldn't be very useful, since we couldn't think of any other example where the relation <code>¬ x ≤ y</code>had any particular importance.</p>



<a name="287516807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516807">(Jun 26 2022 at 22:13)</a>:</h4>
<p>Further, if we just defined it in the obvious way, <code>¬ x ≤ y</code>, we'd mess up the def-eqs on pre-games. We'd need to take the approach of <code>lt</code>, where it's defined as a field of the <code>preorder</code> class, and that just seems awkward.</p>



<a name="287516814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516814">(Jun 26 2022 at 22:13)</a>:</h4>
<p>Not to mention, the name <code>lf</code> wouldn't make sense at all outside of games</p>



<a name="287516884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516884">(Jun 26 2022 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287516708">said</a>:</p>
<blockquote>
<p>Sure, you also need <a href="https://leanprover-community.github.io/mathlib_docs/find/iff.not">docs#iff.not</a>. But my point is that those two are enough.</p>
</blockquote>
<p>I'm talking about a partial order here though, not a linear order</p>



<a name="287516895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516895">(Jun 26 2022 at 22:14)</a>:</h4>
<p>Now as for a general <code>cmp</code> function on preorders, we could totally do that</p>



<a name="287516910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516910">(Jun 26 2022 at 22:15)</a>:</h4>
<p>We should have the fields <code>lt</code>, <code>gt</code>, <code>equiv</code>, and <code>incomp</code></p>



<a name="287516924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516924">(Jun 26 2022 at 22:15)</a>:</h4>
<p>We can even provide some API for converting between these values and those given by <code>cmp</code> on linear orders</p>



<a name="287516975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516975">(Jun 26 2022 at 22:16)</a>:</h4>
<p>Who talked about linear orders? <a href="https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le">docs#lt_iff_lt_of_le_iff_le</a> is for linear_orders, but <a href="https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le'">docs#lt_iff_lt_of_le_iff_le'</a> is for any preorder.</p>



<a name="287516994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516994">(Jun 26 2022 at 22:17)</a>:</h4>
<p>Oh I see! I read the wrong theorem</p>



<a name="287516998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287516998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287516998">(Jun 26 2022 at 22:18)</a>:</h4>
<p>Yeah, what I basically did was prove this but for all the other relations on games</p>



<a name="287517286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287517286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287517286">(Jun 26 2022 at 22:24)</a>:</h4>
<p>Yeah I think that's the play here</p>



<a name="287517290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287517290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287517290">(Jun 26 2022 at 22:24)</a>:</h4>
<p>I'll add the comparison function on preorders, then use it to prove results about pre-games</p>



<a name="287531824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287531824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287531824">(Jun 27 2022 at 04:23)</a>:</h4>
<p>I think I just deciphered what <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.restricted">docs#pgame.restricted</a> really "means"</p>



<a name="287531829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287531829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287531829">(Jun 27 2022 at 04:23)</a>:</h4>
<p>And it's... disappointing</p>



<a name="287531882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287531882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287531882">(Jun 27 2022 at 04:24)</a>:</h4>
<p>Replacr the functions L and R and the hypotheses by existence lemmas</p>



<a name="287531910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287531910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287531910">(Jun 27 2022 at 04:26)</a>:</h4>
<p>And you literally just get a weaker version of the converse of <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.le_def">docs#pgame.le_def</a></p>



<a name="287531982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287531982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287531982">(Jun 27 2022 at 04:27)</a>:</h4>
<p>So really, any inequality <code>x \le y</code> you can prove by building a restriction, can be proven by just using <code>le_def</code></p>



<a name="287532001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/287532001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#287532001">(Jun 27 2022 at 04:27)</a>:</h4>
<p>I think that settles it, this needs to go</p>



<a name="289207964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/289207964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#289207964">(Jul 11 2022 at 15:29)</a>:</h4>
<p>I'm back!</p>



<a name="289208165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/289208165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#289208165">(Jul 11 2022 at 15:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/284570576">said</a>:</p>
<blockquote>
<p>I've finished the proof of P1 with my symmetry approach at <a href="https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318">https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318</a><br>
I'll leave P2 and P4 to tomorrow.</p>
</blockquote>
<p>I'll try and merge this with what we have.</p>



<a name="289208374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/289208374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#289208374">(Jul 11 2022 at 15:32)</a>:</h4>
<p>I hadn't noticed your comments on <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_mul_comm">docs#pgame.quot_mul_comm</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_neg_mul">docs#pgame.quot_neg_mul</a>, that seems like a nice thing to do on the side</p>



<a name="290531736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290531736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290531736">(Jul 22 2022 at 16:09)</a>:</h4>
<p>I want to try PR-ing the <code>mul_option</code> stuff, but <a href="https://github.com/leanprover-community/mathlib/pull/15252">#15252</a> is currerntly blocking that</p>



<a name="290531777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290531777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290531777">(Jul 22 2022 at 16:09)</a>:</h4>
<p>I think that's the last thing we would need before PRing the surreal multiplication proof</p>



<a name="290531950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290531950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290531950">(Jul 22 2022 at 16:10)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/15252">#15252</a> has a merge conflict now</p>



<a name="290532221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290532221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290532221">(Jul 22 2022 at 16:12)</a>:</h4>
<p>Ah true, it will conflict with my recent swapping of arguments on relabellings</p>



<a name="290532242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290532242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290532242">(Jul 22 2022 at 16:12)</a>:</h4>
<p>On that note, I've been thinking about relabellings again</p>



<a name="290532313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290532313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290532313">(Jul 22 2022 at 16:13)</a>:</h4>
<p>I think I might have brought this up before, but now I'm more convinced: we eventually need to ditch relabellings in favor of extensional equivalence</p>



<a name="290532372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290532372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290532372">(Jul 22 2022 at 16:13)</a>:</h4>
<p>Relabellings are just a consequence of our implementation of games, which doesn't coincide with the ZFC one</p>



<a name="290532632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290532632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290532632">(Jul 22 2022 at 16:16)</a>:</h4>
<p>The definition of extensional equivalence, e.g. being "identical" games, would be pretty much the same one as for <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv">docs#pSet.equiv</a>: <code>x ≡ y</code> when every left move of <code>x</code> is extensionally equivalent to some left move of <code>y</code>, and viceversa, and likewise for right moves</p>



<a name="290532871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290532871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290532871">(Jul 22 2022 at 16:17)</a>:</h4>
<p>We could then define the quotient of pre-games by extensional equivalence, which would correspond to the actual ZFC notion of pre-games</p>



<a name="290533038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290533038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290533038">(Jul 22 2022 at 16:18)</a>:</h4>
<p>It's definitely a confusing situation, since we would have <code>pgame</code> which is an implementation detail, then some other type (<code>igame</code>?) for ZFC pre-games (which they don't call pre-games, they just call them games), and then actually <code>game</code> corresponding to ZFC pre-games quotiented by antisymmetry</p>



<a name="290533054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290533054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290533054">(Jul 22 2022 at 16:19)</a>:</h4>
<p>And surreals of course</p>



<a name="290533105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290533105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290533105">(Jul 22 2022 at 16:19)</a>:</h4>
<p>The nice thing about <code>igame</code> is that you can define left and right moves of <code>igame</code> as <code>igame</code>s themselves, which is something you can't do with neither games nor surreals</p>



<a name="290533122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290533122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290533122">(Jul 22 2022 at 16:19)</a>:</h4>
<p>Which means we can define the birthday of an <code>igame</code> too</p>



<a name="290533227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290533227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290533227">(Jul 22 2022 at 16:20)</a>:</h4>
<p>And we can also correctly define short <code>igame</code>s as an <code>igame</code> with a finite left and right move set, and prove that an <code>igame</code> is short iff it has finite birthday, a result that isn't true on <code>pgame</code></p>



<a name="290533303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290533303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290533303">(Jul 22 2022 at 16:21)</a>:</h4>
<p>The philosophy here would be the same one as with <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet">docs#pSet</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/Set">docs#Set</a>: we treat the former as an implementation detail, only proving the necessary results, and move everything to the latter</p>



<a name="290535411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290535411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290535411">(Jul 22 2022 at 16:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/290532313">said</a>:</p>
<blockquote>
<p>I think I might have brought this up before, but now I'm more convinced: we eventually need to ditch relabellings in favor of extensional equivalence</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv">docs#pSet.equiv</a> is purely in terms of quantifiers, while <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.relabelling">docs#pgame.relabelling</a> has the equivalences/functions that go between the left/right moves of two equivalent games. I remember you previously said it's useful to have those functions; if that's true we may consider keeping relabelling instead of ditching it, but maybe the lesson from <a href="https://leanprover-community.github.io/mathlib_docs/find/pSet">docs#pSet</a> tells us we don't really need those functions.</p>



<a name="290536792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290536792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290536792">(Jul 22 2022 at 16:48)</a>:</h4>
<p>I previously said that we <em>use</em> those functions. The single place where they're used is in the definition of <code>short</code>, which as I've mentioned previously doesn't match mathematical usage.</p>



<a name="290536868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290536868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290536868">(Jul 22 2022 at 16:48)</a>:</h4>
<p>We could still define identical games in terms of functions, i.e. explicit maps from left moves of <code>x</code> to identical left moves of <code>y</code>, and all the others, instead of just having the quantifiers</p>



<a name="290536910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290536910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290536910">(Jul 22 2022 at 16:49)</a>:</h4>
<p>This might still enable the VM to play short games, though I don't know if that's a priority</p>



<a name="290537047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290537047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290537047">(Jul 22 2022 at 16:50)</a>:</h4>
<p>In any case, it's clear to me that relabellings are a quirk of Lean's type theory, rather that something mathematicians would care much about.</p>



<a name="290540312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290540312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290540312">(Jul 22 2022 at 17:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> was the one who made the code for <code>short</code> so I'd like to hear his opinion.</p>



<a name="290692617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290692617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290692617">(Jul 24 2022 at 18:06)</a>:</h4>
<p>I'm wondering</p>



<a name="290692624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290692624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290692624">(Jul 24 2022 at 18:06)</a>:</h4>
<p>If <a href="https://github.com/leanprover-community/mathlib/pull/15289">#15289</a> is merged, <code>lf</code> will no longer have a weird inductive definition</p>



<a name="290692639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290692639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290692639">(Jul 24 2022 at 18:07)</a>:</h4>
<p>It will literally be defined as <code>(≥)ᶜ</code></p>



<a name="290692708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290692708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290692708">(Jul 24 2022 at 18:08)</a>:</h4>
<p>So, in order to be able to use this smoothly on both <code>pgame</code> and <code>game</code>, maybe we should make <code>⧏</code> notation for <code>(≥)ᶜ</code>?</p>



<a name="290692735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290692735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290692735">(Jul 24 2022 at 18:09)</a>:</h4>
<p>I also suggested <a href="#narrow/stream/116395-maths/topic/Comparison.20in.20preorders/near/290425782">here</a> that we could define more general notation <code>⋚</code> for "equal up to antisymmetry" and <code>∥</code> for incomparability</p>



<a name="290692786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290692786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290692786">(Jul 24 2022 at 18:10)</a>:</h4>
<p>So we wouldn't need specialized <code>pgame.equiv</code> and <code>pgame.fuzzy</code> predicates, nor their <code>game</code> counterparts, nor their <code>igame</code> counterparts if we ever do that</p>



<a name="290693785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290693785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290693785">(Jul 24 2022 at 18:37)</a>:</h4>
<p>Or you know what?</p>



<a name="290693787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290693787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290693787">(Jul 24 2022 at 18:37)</a>:</h4>
<p>Maybe we don't need <code>lf</code> anymore</p>



<a name="290693859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290693859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290693859">(Jul 24 2022 at 18:39)</a>:</h4>
<p>Which is probably somewhat of a hot take given the effort we put into making <code>lf</code> into what it is</p>



<a name="290693940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290693940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290693940">(Jul 24 2022 at 18:41)</a>:</h4>
<p>There was previously the argument that <code>lf</code> was useful because it provided a nice def-eq for <code>le</code>, but that no longer applies after the aforementioned refactor</p>



<a name="290694025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694025">(Jul 24 2022 at 18:43)</a>:</h4>
<p>In fact, changing the def-eq barely broke anything</p>



<a name="290694031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694031">(Jul 24 2022 at 18:43)</a>:</h4>
<p>What's that nice def-eq? I think one reason for keeping <code>lf</code> is it makes statements like <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.lf_of_le_of_lf/src">src#pgame.lf_of_le_of_lf</a> look natural.</p>



<a name="290694038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694038">(Jul 24 2022 at 18:43)</a>:</h4>
<p>and it's everywhere in the literature</p>



<a name="290694172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694172">(Jul 24 2022 at 18:46)</a>:</h4>
<p>The nice def-eqs in question are the ones given by <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.le_iff_forall_lf">docs#pgame.le_iff_forall_lf</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/pgame.lf_iff_exists_le">docs#pgame.lf_iff_exists_le</a></p>



<a name="290694183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694183">(Jul 24 2022 at 18:46)</a>:</h4>
<p>I guess they're not exactly def-eqs but they're really close</p>



<a name="290694269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694269">(Jul 24 2022 at 18:49)</a>:</h4>
<p>It's true that <code>lf</code> makes some statements look more natural. But I don't think the statements translated into preorders are particularly unclear either. We could just prove <code>not_le_of_le_of_not_le</code> and now we don't need to prove it separately for <code>pgame</code> and <code>game</code></p>



<a name="290694283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694283">(Jul 24 2022 at 18:49)</a>:</h4>
<p>Again, there's also the option of just making <code>lf</code> a notation on an arbitrary preorder, and make aliases for the theorems we want to port</p>



<a name="290694448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290694448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290694448">(Jul 24 2022 at 18:53)</a>:</h4>
<p>Ultimately what I want is to prove as few results on preorders as possible. All that should be done elsewhere, and we should strive not to duplicate that in the game theory files.</p>



<a name="290708840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290708840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290708840">(Jul 25 2022 at 00:57)</a>:</h4>
<p>I wonder if we could have a whole file <code>set_theory/game/lf.lean</code> where we introduce the notation and all relevant aliases</p>



<a name="290708911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290708911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290708911">(Jul 25 2022 at 00:58)</a>:</h4>
<p>That way, if we want to use <code>lf</code> notation on pre-games, games, surreals, or any future quotient or subtype we come up with, we can just open that namespace/locale and get it</p>



<a name="290708983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/290708983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#290708983">(Jul 25 2022 at 01:00)</a>:</h4>
<p>I'm still not sure if we need the aliases though, maybe we can keep the notation but still use <code>not_le</code> or <code>not_ge</code> in theorem names?</p>



<a name="296134971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Well-founded%20recursion%20for%20pgames/near/296134971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> FR <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames.html#296134971">(Aug 30 2022 at 14:31)</a>:</h4>
<p>Maybe a bit outdated, can we still get any convenient computable constructing functions if we use extensional equivalence? I recently found it hard to define something like <code>smallset Set → Set</code> (smallset is quotient of indexed set which is used for <code>pSet</code> and <code>pgame</code>) without giving up computability.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html">A function that is a sum of said function</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="301892656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/301892656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#301892656">(Oct 02 2022 at 05:01)</a>:</h4>
<p>The first step would be to change the statement to be in terms of the coefficients, which are equal to a sum of coefficients.<br>
The next step would be to use modular arithmetic to show that the sum of ite simplifies to a single ite.<br>
Here is my MWE (minimal working example):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.analytic.basic</span>
<span class="kn">import</span> <span class="n">analysis.complex.basic</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">formal_multilinear_series</span> <span class="n">finset</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">nnreal</span> <span class="n">ennreal</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nontrivially_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_add_comm_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">complete_space</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">formal_multilinear_series</span> <span class="bp">𝕜</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">𝕜</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="bp">𝕜</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ennreal</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">plain_old_series</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">nontrivially_normed_field</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">[</span><span class="n">normed_add_comm_group</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">formal_multilinear_series</span> <span class="bp">𝕜</span> <span class="bp">𝕜</span> <span class="n">E</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">continuous_multilinear_map.mk_pi_field</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">n</span><span class="o">)</span>

<span class="c1">------------------------</span>

<span class="kd">def</span> <span class="n">rues_coeff</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">((</span><span class="n">k</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">%</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">/</span> <span class="n">k.factorial</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">rues_series</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">plain_old_series</span> <span class="n">ℂ</span> <span class="o">(</span><span class="n">rues_coeff</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">ruesDiff</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rues_series</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span>

<span class="kd">lemma</span> <span class="n">ruesDiffTsumForm</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span><span class="o">:</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ruesDiff</span> <span class="n">n</span> <span class="n">m</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">tsum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">k</span><span class="o">:</span><span class="n">ℕ</span><span class="o">),</span> <span class="k">if</span> <span class="o">((</span><span class="n">k</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span><span class="bp">+</span><span class="n">m</span><span class="o">)</span><span class="bp">%</span><span class="n">n</span><span class="bp">=</span><span class="mi">0</span> <span class="k">then</span> <span class="n">z</span> <span class="bp">^</span> <span class="n">k</span> <span class="bp">/</span> <span class="n">k.factorial</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">--already proved, but here for reference</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">ruesDiffSumOfRuesDiff</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span><span class="o">:</span><span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="mi">0</span><span class="bp">&lt;</span><span class="n">n</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span><span class="o">:</span><span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ruesDiff</span> <span class="n">n</span> <span class="n">m</span> <span class="n">z</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k₀</span> <span class="k">in</span> <span class="n">range</span> <span class="n">k</span><span class="o">,</span> <span class="n">ruesDiff</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">*</span><span class="n">k₀</span><span class="bp">+</span><span class="n">m</span><span class="o">)</span> <span class="n">z</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">--what I need help proving</span>
<span class="kd">end</span>
</code></pre></div>



<a name="301898950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/301898950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#301898950">(Oct 02 2022 at 06:54)</a>:</h4>
<p>If anyone does not see motivation to proving this result, perhaps skimming <a href="https://github.com/Nazgand/nazgandMathBook/blob/master/RootOfUnityExponentialSumFunction.pdf">https://github.com/Nazgand/nazgandMathBook/blob/master/RootOfUnityExponentialSumFunction.pdf</a> and noting the lemma is a generalization of (5.3) would nerd-snipe someone into helping.</p>



<a name="302076111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302076111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302076111">(Oct 03 2022 at 14:34)</a>:</h4>
<p>It seems to me that the easiest way to prove the sum of ite is an ite is to use the Type <code>set Prop</code>.<br>
I have a rough draft of what this should look like. Please help. I don't even know how to define <code>andSet</code>, let alone how to properly define the output Type of <code>iteSumOfIte</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">all</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="c1">-- andSet claims that every Prop in props is true</span>
<span class="kd">def</span> <span class="n">andSet</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">andSetElem</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">p</span><span class="bp">∈</span><span class="n">props</span><span class="o">)</span> <span class="o">:</span> <span class="n">andSet</span> <span class="n">props</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">andSetAndAndSet</span> <span class="o">(</span><span class="n">props₀</span> <span class="n">props₁</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">andSet</span> <span class="n">props₀</span> <span class="bp">∧</span> <span class="n">andSet</span> <span class="n">props₁</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">andSet</span> <span class="o">(</span><span class="n">props₀</span> <span class="bp">∪</span> <span class="n">props₁</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- orSet claims that at least 1 Prop in props is true</span>
<span class="kd">def</span> <span class="n">orSet</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">orSetElem</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">p</span><span class="bp">∈</span><span class="n">props</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">orSet</span> <span class="n">props</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- mututallyExcusive claims that at most 1 Prop in props is true</span>
<span class="kd">def</span> <span class="n">mutuallyExcusive</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">--  andSet {¬(h₀ ∧ h₁) | {h₀,h₁} ⊆ props ∧ h₀≠h₁} -- something like this but with init.data.set.set_of</span>

<span class="c1">-- exactly1True claims that exactly 1 Prop in props is true</span>
<span class="kd">def</span> <span class="n">exactly1True</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">orSet</span> <span class="n">props</span> <span class="bp">∧</span> <span class="n">mutuallyExcusive</span> <span class="n">props</span>

<span class="c1">-- decidableSet claims every Prop in props is decidable</span>
<span class="kd">def</span> <span class="n">decidableSet</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c1">-- andSet {decidable p | p ∈ props} -- something like this but with init.data.set.set_of</span>

<span class="kd">noncomputable</span>
<span class="kd">lemma</span> <span class="n">decidableSetElem</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">p</span><span class="bp">∈</span><span class="n">props</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidableSet</span> <span class="n">props</span> <span class="bp">→</span> <span class="n">decidable</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">decidableSetSubset</span> <span class="o">(</span><span class="n">props₀</span> <span class="n">props₁</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span><span class="n">props₀</span> <span class="bp">⊆</span> <span class="n">props₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidableSet</span> <span class="n">props₁</span> <span class="bp">→</span> <span class="n">decidableSet</span> <span class="n">props₀</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">noncomputable</span>
<span class="kd">lemma</span> <span class="n">decidableSetAndSet</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidableSet</span> <span class="n">props</span> <span class="bp">→</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">andSet</span> <span class="n">props</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">noncomputable</span>
<span class="kd">lemma</span> <span class="n">decidableSetOrSet</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidableSet</span> <span class="n">props</span> <span class="bp">→</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">orSet</span> <span class="n">props</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- having difficulty defining this lemma because of decidability</span>
<span class="kd">lemma</span> <span class="n">iteSumOfIte</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">finset</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span><span class="o">:</span><span class="n">exactly1True</span> <span class="n">props</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span><span class="o">:</span><span class="n">decidableSet</span> <span class="n">props</span><span class="o">)</span> <span class="o">:</span> <span class="n">ite</span> <span class="o">(</span><span class="n">orSet</span> <span class="n">props</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">p</span> <span class="k">in</span> <span class="n">props</span><span class="o">,</span> <span class="n">ite</span> <span class="n">p</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- this is the needed proof</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302077903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302077903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302077903">(Oct 03 2022 at 14:43)</a>:</h4>
<p>Your <code>andSetAndAndSet</code> looks suspiciously like <a href="https://leanprover-community.github.io/mathlib_docs/find/Inf_union">docs#Inf_union</a> :-) have a look at <a href="https://leanprover-community.github.io/mathlib_docs/find/inf_Prop_eq">docs#inf_Prop_eq</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/Inf_Prop_eq">docs#Inf_Prop_eq</a></p>



<a name="302085539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302085539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302085539">(Oct 03 2022 at 15:19)</a>:</h4>
<p>Any idea why iteSumOfIte is not accepted by the interpreter? It shows an error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">props</span> <span class="o">:</span> <span class="n">finset</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h₀</span> <span class="o">:</span> <span class="n">mutuallyExcusive</span> <span class="bp">↑</span><span class="n">props</span><span class="o">,</span>
<span class="n">h₁</span> <span class="o">:</span> <span class="n">decidableSet</span> <span class="bp">↑</span><span class="n">props</span>
<span class="bp">⊢</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">orSet</span> <span class="bp">↑</span><span class="n">props</span><span class="o">)</span>
</code></pre></div>



<a name="302086913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302086913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302086913">(Oct 03 2022 at 15:26)</a>:</h4>
<p>it's trying to show that this is <code>decidable</code>, but can't find the type class instance (probably because it doesn't exist). Without really looking at any of this, but knowing that you have been working on things related to power series, my bet would be that you should just <code>open classical</code> at the top of the file, because I doubt you care about actual computability here. This will make everything decidable for you.</p>



<a name="302092804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302092804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302092804">(Oct 03 2022 at 15:57)</a>:</h4>
<p>Thanks. I'll need to remember that. Edited. Next, <code>mutuallyExcusive</code> needs to be defined.</p>



<a name="302096641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302096641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302096641">(Oct 03 2022 at 16:15)</a>:</h4>
<p>how about:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mutuallyExcusive</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">∈</span> <span class="n">props</span><span class="o">,</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span>
</code></pre></div>
<p>Note: I have <em>not</em> tried to understand why you are doing any of these <code>set Prop</code> manipulations, I'm just answering your questions briefly because I don't have much time. I suspect that for whatever you are trying to do, there is likely a much nicer way.</p>



<a name="302097036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302097036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302097036">(Oct 03 2022 at 16:17)</a>:</h4>
<p><code>mutuallyExclusive</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/set.pairwise_disjoint">docs#set.pairwise_disjoint</a></p>



<a name="302098926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302098926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302098926">(Oct 03 2022 at 16:26)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  Sorry, how is that exactly? What is the <code>inf</code> of two propositions?</p>



<a name="302099150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302099150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302099150">(Oct 03 2022 at 16:28)</a>:</h4>
<p>I suppose it should be conjunction, but does Lean know that?</p>



<a name="302099256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302099256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302099256">(Oct 03 2022 at 16:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/Prop.distrib_lattice/src">src#Prop.distrib_lattice</a></p>



<a name="302099914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302099914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302099914">(Oct 03 2022 at 16:31)</a>:</h4>
<p>And <code>orSet</code> is of course just <code>Sup</code>.</p>



<a name="302100202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302100202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302100202">(Oct 03 2022 at 16:32)</a>:</h4>
<p>I think once you replace your adhoc constructions with the mathlib ones and generalize the <code>1</code> to anything, it's a fine lemma to have, if not a bit constricted.</p>



<a name="302101554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302101554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302101554">(Oct 03 2022 at 16:39)</a>:</h4>
<p>You can also prove the "dual" with <code>Inf</code> and <code>prod</code>, and write the multiplicative version.</p>



<a name="302102913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302102913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302102913">(Oct 03 2022 at 16:46)</a>:</h4>
<p>I don't see any other way to prove the original problem without the lemma <code>iteSumOfIte</code>.<br>
<code>set.pairwise_disjoint</code> asks for a function, though. Does the identity function work?<br>
Is this right, <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>? I am not sure what you meant.<br>
Also, I have been wondering how to prove <code>iteSumOfIte</code>. Induction on the set size seems like it might work, but I am unsure.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>
<span class="kn">import</span> <span class="n">order.complete_lattice</span>
<span class="kn">import</span> <span class="n">data.set.pairwise</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="c1">-- mututallyExclusive claims that at most 1 Prop in props is true</span>
<span class="kd">def</span> <span class="n">mutuallyExclusive</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">set</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">set.pairwise_disjoint</span> <span class="n">props</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">iteSumOfIte</span> <span class="o">(</span><span class="n">props</span><span class="o">:</span><span class="n">finset</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span><span class="o">:</span><span class="n">mutuallyExclusive</span> <span class="n">props</span><span class="o">)</span> <span class="o">:</span> <span class="n">ite</span> <span class="o">(</span><span class="n">Sup</span> <span class="n">props</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">p</span> <span class="k">in</span> <span class="n">props</span><span class="o">,</span> <span class="n">ite</span> <span class="n">p</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- this is the needed proof</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302105602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302105602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302105602">(Oct 03 2022 at 16:58)</a>:</h4>
<p><span class="user-mention" data-user-id="385848">@Mark Andrew Gerads</span>, I'd strongly recommend dropping your <code>camelCase</code> naming convention and using the <code>snake_case</code> one prescribed by <a href="https://leanprover-community.github.io/contribute/naming.html">#naming</a>. A powerful tool for working with mathlib is working out what the name of the result you want would be, and finding out if that name or similar already exists.</p>



<a name="302105709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302105709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302105709">(Oct 03 2022 at 16:59)</a>:</h4>
<p>If you use your own naming scheme, you will never be told by Lean that the thing you're proving already exists!</p>



<a name="302105844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302105844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302105844">(Oct 03 2022 at 17:00)</a>:</h4>
<p>For the "at most one is true" you could build a function that counts how many of the props are true, using <code>sum</code>, so going from <code>set Prop</code> to nat (or enat if your sets can be infinite) and then state that this number is at most one.</p>



<a name="302106247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302106247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302106247">(Oct 03 2022 at 17:01)</a>:</h4>
<p>Although I agree that this feels quite contrived for what you want to do - but I am not completely sure that I understand what you want to do</p>



<a name="302107240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302107240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302107240">(Oct 03 2022 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> my main goal in this thread is to prove <code>ruesDiffSumOfRuesDiff</code> in the first post of this thread. Because the coefficients use an <code>ite</code>, this ultimately seems to require <code>iteSumOfIte</code> in my last post.</p>



<a name="302107954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302107954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302107954">(Oct 03 2022 at 17:10)</a>:</h4>
<p>Ah ok. There might be some case of <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> here but I think I see what you are looking for.</p>



<a name="302108542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302108542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302108542">(Oct 03 2022 at 17:13)</a>:</h4>
<p>The lemma that has to be in mathlib is that the sum of a non empty collection of nonnegative terms is at least equal to the largest term, and if you phrase "at least one" in terms of the sum on your this, which feels reasonable to me, then I would look in this direction</p>



<a name="302108730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302108730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302108730">(Oct 03 2022 at 17:14)</a>:</h4>
<p>Maybe something similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.supr_le_sum">docs#cardinal.supr_le_sum</a> ?</p>



<a name="302110474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302110474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302110474">(Oct 03 2022 at 17:24)</a>:</h4>
<p>For your initial question, can you perhaps use <a href="https://leanprover-community.github.io/mathlib_docs/find/tsum_sum">docs#tsum_sum</a> ?</p>



<a name="302129418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302129418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302129418">(Oct 03 2022 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="385848">@Mark Andrew Gerads</span>, yes <code>set.pairwise_disjoint</code> takes in an indexed family. In fact you could generalize your lemma to indexed families as well.</p>



<a name="302129775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302129775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302129775">(Oct 03 2022 at 19:06)</a>:</h4>
<p>Something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">\</span><span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">pairwise_disjoint</span> <span class="n">f</span> <span class="bp">-&gt;</span> <span class="n">ite</span> <span class="o">(</span><span class="bp">\</span><span class="n">supr</span> <span class="n">i</span> <span class="bp">\</span><span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">sum</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="n">a</span> <span class="mi">0</span>
</code></pre></div>
<p>This allows you to apply it when you have several times <code>false</code> in the sum.</p>



<a name="302413158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302413158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302413158">(Oct 05 2022 at 08:49)</a>:</h4>
<p>I just noticed a problem. Because sets can only contain 1 element once, and every Prop is either <code>true</code> or <code>false</code>, this means that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>s</mi><mo>⊆</mo><mo stretchy="false">{</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">props \subseteq \{true,false\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mclose">}</span></span></span></span>. props having at most 1 true statement  is tautological.<br>
I think I need props to be a list of Prop instead, so I need to read about lists in mathlib.</p>



<a name="302413285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302413285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302413285">(Oct 05 2022 at 08:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function/near/302129775">said</a>:</p>
<blockquote>
<p>This allows you to apply it when you have several times <code>false</code> in the sum.</p>
</blockquote>
<p><span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span></p>



<a name="302414020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302414020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302414020">(Oct 05 2022 at 08:56)</a>:</h4>
<p>To be explicit, you don't need lists, you need <em>indexed families</em>, which are a function <code>ι → α</code> along with a range of values you're interested in <code>finset ι</code>.</p>



<a name="302440882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302440882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302440882">(Oct 05 2022 at 11:59)</a>:</h4>
<p>Okay, now I think I am asking for the right lemma. <code>library_search</code> failed. I have been thinking that if this is proved for n=2, that can be used for an inductive step. (<code>n&gt;0</code> and <code>mutually_exclusive (range n:set ℕ) p</code>) implies <code>mutually_exclusive (range (n-1):set ℕ) p</code>.<br>
Also, <code>∃ k ∈ range n, p k</code>=<code>(p (n-1) or ∃ k ∈ range (n-1), p k)</code>, which is why I believe induction could work. I will think more about it later.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kn">open</span> <span class="n">finset</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="c1">-- mutually_exclusive claims that at most 1 Prop is true in the indexed family I,p</span>
<span class="kd">def</span> <span class="n">mutually_exclusive</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span><span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">I</span><span class="o">:</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">i₀</span> <span class="n">i₁</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="n">p</span> <span class="n">i₀</span> <span class="bp">∧</span> <span class="n">p</span> <span class="n">i₁</span> <span class="bp">→</span> <span class="n">i₀</span> <span class="bp">=</span> <span class="n">i₁</span>

<span class="kd">lemma</span> <span class="n">ite_sum_of_ite</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span><span class="o">:</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h₀</span><span class="o">:</span><span class="n">mutually_exclusive</span> <span class="o">(</span><span class="n">range</span> <span class="n">n</span><span class="o">:</span><span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">ite</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span> <span class="bp">∈</span> <span class="n">range</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">k</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">range</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">p</span> <span class="n">k</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- this is the needed proof</span>
<span class="kd">end</span>
</code></pre></div>



<a name="302549449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302549449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302549449">(Oct 05 2022 at 21:38)</a>:</h4>
<p>Read <a href="#narrow/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function/near/302129775">my messages</a> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="302549763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302549763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302549763">(Oct 05 2022 at 21:40)</a>:</h4>
<p>The reason<code>library_search</code> failed is that you didn't teach it enough. Firstly, it doesn't know <em>anything</em> about <code>mutually_exclusive</code> so you can't expect it to do anything with that. Second it would only find exact matches, which we ruled out as the lemma doesn't exist in the library.</p>



<a name="302549778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302549778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302549778">(Oct 05 2022 at 21:40)</a>:</h4>
<p>Anyway, here is your lemma <a href="https://github.com/leanprover-community/mathlib/pull/16825">#16825</a></p>



<a name="302552733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302552733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302552733">(Oct 05 2022 at 22:02)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16825">#16825</a>?</p>



<a name="302552845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302552845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302552845">(Oct 05 2022 at 22:03)</a>:</h4>
<p>Yep, sorry. Keyboard should go to bed.</p>



<a name="302563960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302563960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302563960">(Oct 06 2022 at 00:01)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Thank you very much for the lemma. It is quite helpful.</p>



<a name="302566153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302566153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302566153">(Oct 06 2022 at 00:19)</a>:</h4>
<p>I'm not sure the lemma is actually that useful; you can immediately simplify the RHS with <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_filter">docs#finset.prod_filter</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod_const">docs#finset.prod_const</a></p>



<a name="302566272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302566272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302566272">(Oct 06 2022 at 00:21)</a>:</h4>
<p>Then we find that the actual lemma that is missing is that <code>s.filter f = {a}</code> when <code>a ∈ s</code> and <code>pairwise s f</code></p>



<a name="302876590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/302876590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mark Andrew Gerads <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#302876590">(Oct 07 2022 at 15:22)</a>:</h4>
<p>I don't care about the finer details too much; my main goal right now is ruesDiffSumOfRuesDiff.<br>
I am waiting on the PR now though, so please decide whatever needs to be decided to pull the PR. If the suggested filter version is pulled, I'll just need to learn to use filters.</p>



<a name="303044851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/A%20function%20that%20is%20a%20sum%20of%20said%20function/near/303044851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function.html#303044851">(Oct 08 2022 at 17:23)</a>:</h4>
<p>Note that <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.filter">docs#finset.filter</a> is not related to "filters" (<a href="https://leanprover-community.github.io/mathlib_docs/find/filter">docs#filter</a>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/graph.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html">graph theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245143605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245143605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245143605">(Jul 07 2021 at 08:06)</a>:</h4>
<p>Have there been any useful attempts to make a good library on graph theory? Any students of yours, <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> ? There's a student here who's considering formalising some planar graph theory as part of their bachelor's thesis.</p>



<a name="245143874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245143874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245143874">(Jul 07 2021 at 08:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110789">@Jakob von Raumer</span> There's a <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a> stream!</p>



<a name="245143980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245143980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245143980">(Jul 07 2021 at 08:10)</a>:</h4>
<p>There's been quite some activity in fact, see also <a href="https://github.com/leanprover-community/mathlib/tree/master/src/combinatorics">https://github.com/leanprover-community/mathlib/tree/master/src/combinatorics</a></p>



<a name="245144125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245144125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245144125">(Jul 07 2021 at 08:11)</a>:</h4>
<p>funnily enough I was thinking about this yesterday, and basically I have no idea what "good" means. It seems to me that graph theory is taught very early on to CS students, with applications to networks, algorithms etc. We don't have a graph theory course in the maths department at Imperial, and the one I sat through as an UG in Cambridge comprised a hotch-potch of unrelated results like Hall's Marriage theorem and the 5 colour theorem (and even the 7 colour theorem for maps on a torus) with no underlying story and no other courses relying on the results (mathematically, this is often the case in combinatorics-based courses, they tend to teach general principles as opposed to important theorems like the fundamental theorem of Galois theory which is used everywhere). So I am probably not the best person to ask! <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> what does a "good" graph theory library contain?</p>



<a name="245144461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245144461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245144461">(Jul 07 2021 at 08:15)</a>:</h4>
<p>Ah, thank you! Forgot to check the list of streams :)</p>



<a name="245144607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245144607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245144607">(Jul 07 2021 at 08:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> The graph theory course at KIT at the math dept contains, if my memory serves me right, a lot of Ramsey theory style results</p>



<a name="245144678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245144678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245144678">(Jul 07 2021 at 08:17)</a>:</h4>
<p>I think we probably had one lecture on "R(3,3)=6, proof by induction that R(m,n) is finite" and that was it for Ramsey theory.</p>



<a name="245179890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245179890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245179890">(Jul 07 2021 at 13:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/245144125">said</a>:</p>
<blockquote>
<p>funnily enough I was thinking about this yesterday, and basically I have no idea what "good" means. It seems to me that graph theory is taught very early on to CS students, with applications to networks, algorithms etc. We don't have a graph theory course in the maths department at Imperial, and the one I sat through as an UG in Cambridge comprised a hotch-potch of unrelated results like Hall's Marriage theorem and the 5 colour theorem (and even the 7 colour theorem for maps on a torus) with no underlying story and no other courses relying on the results (mathematically, this is often the case in combinatorics-based courses, they tend to teach general principles as opposed to important theorems like the fundamental theorem of Galois theory which is used everywhere). So I am probably not the best person to ask! <span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> what does a "good" graph theory library contain?</p>
</blockquote>
<p>I agree it's a tricky question. The two main things I'd like to see in a "good" library are definitions (of course with API) of all the basic concepts of graphs: planarity, colouring, extremal number, diameter etc with the standard results about them eg Brooks' theorem, Hall's theorem; and a collection of <em>tools</em> in order to make proving new results easy, for example results like Erdos-Stone, Szemeredi's regularity lemma and a clean API for probabilistic graph theory and expander graphs.</p>



<a name="245180186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245180186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245180186">(Jul 07 2021 at 13:35)</a>:</h4>
<p>Some of these are much harder than others, but I think the resulting library has the same goal as any other maths library: to provide enough definitions and results to make proving "actual" graph theory results (ie active research things) convenient.</p>



<a name="245181207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245181207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245181207">(Jul 07 2021 at 13:41)</a>:</h4>
<p>As for the existing Cambridge graph theory courses, my undergrad graph theory notes are here: <a href="https://github.com/b-mehta/maths-notes/blob/master/ii/mich/graph_theory.pdf">https://github.com/b-mehta/maths-notes/blob/master/ii/mich/graph_theory.pdf</a>, you can basically see a summary from the contents page. The Ramsey theory covered was basically what Kevin says, plus a proof of multicolour and infinite Ramsey; but there was also a Part III (MSc-level) Ramsey theory course <a href="https://www.maths.cam.ac.uk/postgrad/part-iii/files/misc/2020-21%20Guide/Combinatorics/Ramsey%20Theory.pdf">syllabus here</a> which went into more detail, <span class="user-mention" data-user-id="130377">@David Wärn</span> is proving some of the combinatorial results from it eg Hales-Jewett and Rado's theorem. There was also a Part III Extremal Graph Theory course which was more in-depth, there are some notes from a 2017 version of this course here: <a href="https://dec41.user.srcf.net/notes/III_M/extremal_graph_theory.pdf">https://dec41.user.srcf.net/notes/III_M/extremal_graph_theory.pdf</a></p>



<a name="245187192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245187192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245187192">(Jul 07 2021 at 14:19)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> do you mind if I update your Ramsey Theory files to the latest mathlib and submit?</p>



<a name="245187733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245187733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245187733">(Jul 07 2021 at 14:22)</a>:</h4>
<p>Feel free to make the PRs, but the main reason I haven't is that I'm not certain they're ready for PR yet, there's the whole crec business and it's pretty ugly... That said, the actual result is (I think) formulated nicely so maybe it's not hugely important that the proof is ugly</p>



<a name="245192496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/245192496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#245192496">(Jul 07 2021 at 14:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/245144125">said</a>:</p>
<blockquote>
<p>We don't have a graph theory course in the maths department at Imperial, and the one I sat through as an UG in Cambridge comprised a hotch-potch of unrelated results like Hall's Marriage theorem and the 5 colour theorem (and even the 7 colour theorem for maps on a torus) with no underlying story and no other courses relying on the results (mathematically, this is often the case in combinatorics-based courses, they tend to teach general principles as opposed to important theorems like the fundamental theorem of Galois theory which is used everywhere). </p>
</blockquote>
<p>In France a standard undergrad math curriculum features no graph theory at all. This is why graph theory doesn't appear at all on our <a href="https://leanprover-community.github.io/undergrad.html">undergrad math page</a>. Some students may still encounter graphs in some random optional first year course on recreational mathematics.</p>



<a name="258978056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/258978056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#258978056">(Oct 25 2021 at 15:43)</a>:</h4>
<p>Question: why is <a href="https://leanprover-community.github.io/mathlib_docs/combinatorics/simple_graph/basic.html#simple_graph"><code>simple_graph</code></a> under <code>combinatorics</code>? Would it fit better under <code>data</code>? </p>
<p>Idea: <code>data</code> &gt; <code>graph</code> &gt; [<code>simple_graph</code>, <code>directed_graph</code>, <code>weighted_graph</code> etc]</p>
<p>What do you think?</p>



<a name="258988088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/258988088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#258988088">(Oct 25 2021 at 16:55)</a>:</h4>
<p>normally speaking, "graphs" of "data (science)" are rather different from graphs as combinatorial structures.</p>



<a name="258988312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/258988312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#258988312">(Oct 25 2021 at 16:57)</a>:</h4>
<p>It would make me even sadder that there's so little under <code>combinatorics</code> <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="259026960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259026960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259026960">(Oct 25 2021 at 22:08)</a>:</h4>
<p>The <code>data</code> is more of a historical hodge podge of things people didn't find better homes for at the time. :-) I think in the long term we would like to rearrange things so <code>data</code> comes to mean "data structures" in the programming sense. I would encourage moving anything "mathmetical" out of <code>data</code>, rather than the reverse.</p>



<a name="259027025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259027025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259027025">(Oct 25 2021 at 22:09)</a>:</h4>
<p>Indeed, after the transition to Lean4 I think we're hoping for a separate "standard library" that comes before mathlib, and perhaps we will actually aspire to emptying the <code>data</code> directory: everything about data structures per se will be in the standard library, and whatever remains can be categorised by mathematical topic in mathlib.</p>



<a name="259027162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259027162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259027162">(Oct 25 2021 at 22:10)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> thanks for the return! I think we can move on to this thread now</p>



<a name="259027707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259027707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259027707">(Oct 25 2021 at 22:16)</a>:</h4>
<p>Looking at how far that branch already is, I thought of the following subareas:</p>
<ul>
<li>shortest path theorems</li>
<li>minimum cut</li>
<li>maximum flow</li>
<li>arriving at minimum cut and maximum flow duality</li>
</ul>
<p>Of course, you might have a clearer idea on the next steps since you've been doing such a fine job on this branch for quite a while already. I want to try something but I'm all ears.</p>



<a name="259027860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259027860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259027860">(Oct 25 2021 at 22:17)</a>:</h4>
<p>Regarding the location of graphs in the library -- given your topic about complexity theory, maybe you're interested in formalizing algorithms about graphs? I sort of think about the <code>combinatorics</code> graphs as being like the abstract interface (in the Java sense), where they don't have a concrete implementation.  The data of a <code>simple_graph</code> is just a relation without any promise of computability (unless you have <code>[decidable_rel G.adj]</code>).  You'd probably want reasonably efficient ways to represent a <code>simple_graph</code> for questions about complexity, and those might more on the <code>data</code> side of things.</p>



<a name="259028817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259028817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259028817">(Oct 25 2021 at 22:24)</a>:</h4>
<p>Hm, I guess I'd like to follow the flow of proving theorems with definitions without having to implement the mechanics of the algorithms just yet. Where do you see the <code>simple_graph</code> project moving towards?</p>



<a name="259028868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259028868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259028868">(Oct 25 2021 at 22:25)</a>:</h4>
<p>Those all seem like interesting things to work on! Maybe for now feel free to use the <code>walks_and_trees</code> branch, adding some new files.</p>



<a name="259029050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259029050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259029050">(Oct 25 2021 at 22:28)</a>:</h4>
<p>Alright, just wanted to know. I will try a few things locally first before requesting the permission to write on branches. I wanna make sure I can lift some weights beforehand.</p>



<a name="259029188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259029188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259029188">(Oct 25 2021 at 22:29)</a>:</h4>
<p>For <code>simple_graph</code>, one goal has been trying to implement all the basic stuff from the first few pages of Bollobas's textbook on graph theory, and trying to do so with an eye toward avoiding too much code duplication between, for example, simple graphs, multigraphs, labeled multigraphs, etc.</p>



<a name="259029881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259029881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259029881">(Oct 25 2021 at 22:36)</a>:</h4>
<p>For flows of a simple graph, this might be a reasonable starting definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">preflow</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_neg</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj_of_nonzero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">neg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">-</span><span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">weight</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>
<p>This supports having <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-flows for any abelian group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.  It's just missing conditions about what <code>∑ (w : V), weight v w</code> is.</p>



<a name="259030262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259030262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259030262">(Oct 25 2021 at 22:40)</a>:</h4>
<p>Hm, maybe talking about shortest paths wrt non-weighted graphs would be a closer next step?</p>



<a name="259030350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259030350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259030350">(Oct 25 2021 at 22:41)</a>:</h4>
<p>Not sure if such theorems are very (re)usable tho.</p>



<a name="259030905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259030905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259030905">(Oct 25 2021 at 22:48)</a>:</h4>
<p>Maybe directed graphs would be better for things about flows, but here's a definition for flows in an undirected graph:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">structure</span> <span class="n">flow</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">cap</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj_of_ne</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">neg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">-</span><span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">weight</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">conserve</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">cap_constraint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">weight</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">cap</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">)</span>
</code></pre></div>
<p>Each edge has a capacity, and the flow for that edge can go in either direction so long as it's within the capacity.</p>
<p>This is also an option, allowing the capacity to be different for flows in each direction:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">flow</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">cap</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">for_edges</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">neg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">-</span><span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">weight</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">conserve</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">cap_constraint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≤</span> <span class="n">cap</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
</code></pre></div>



<a name="259030954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259030954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259030954">(Oct 25 2021 at 22:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259030350">said</a>:</p>
<blockquote>
<p>Not sure if such theorems are very (re)usable tho.</p>
</blockquote>
<p>If anything, you'd probably create useful supporting lemmas along the way.</p>



<a name="259031101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259031101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259031101">(Oct 25 2021 at 22:51)</a>:</h4>
<p>Now I understood what you meant by "avoiding too much code duplication". You're using the <code>simple_graph</code> structure to extend onto other structures</p>



<a name="259031698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259031698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259031698">(Oct 25 2021 at 22:59)</a>:</h4>
<p>I will let you know of any updates <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="259034081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259034081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259034081">(Oct 25 2021 at 23:29)</a>:</h4>
<p>It might also be nice splitting up the definition into the "relative 1-cycle" part (i.e., the part having to do with Kirkhoff's law for currents where certain nodes are allowed to be current sources/sinks) and the capacity part. This can also be generalized to infinite graphs, so long as every vertex has only finitely many neighbors (i.e., it's locally finite).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A relative 1-cycle with coefficients in an abelian group. -/</span>
<span class="kd">structure</span> <span class="n">rel_cycle</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">G.locally_finite</span><span class="o">]</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj_if</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">neg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">-</span><span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">weight</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">conserve</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="bp">¬</span><span class="n">v</span> <span class="bp">∈</span> <span class="n">W</span> <span class="bp">→</span> <span class="bp">∑</span> <span class="n">w</span> <span class="k">in</span> <span class="n">G.neighbor_finset</span> <span class="n">v</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="sd">/-- A real-valued relative 1-cycle with bounded weights with only two boundary vertices. -/</span>
<span class="kd">structure</span> <span class="n">flow</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">G.locally_finite</span><span class="o">]</span>
  <span class="o">(</span><span class="n">cap</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">rel_cycle</span> <span class="n">G</span> <span class="o">{</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">}</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cap_constraint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≤</span> <span class="n">cap</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
</code></pre></div>



<a name="259034272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259034272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259034272">(Oct 25 2021 at 23:32)</a>:</h4>
<p>1-cycles themselves form an abelian group, the rank of which is an important invariant for graphs (it's the minimum number of edges you have to remove to get a forest).</p>



<a name="259086300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259086300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259086300">(Oct 26 2021 at 12:08)</a>:</h4>
<p>Also, just because git status says your branch is up to date doesn't mean you don't have changes. By that I mean unsaved changes. Edited unsaved files earlier in the import tree still cause recompilation of themselves and dependent files.</p>



<a name="259086363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259086363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259086363">(Oct 26 2021 at 12:08)</a>:</h4>
<p>If they are open in your vscode and your extension settings are the default ones.</p>



<a name="259097725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259097725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259097725">(Oct 26 2021 at 13:42)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Lean is not accepting <code>append_support''</code> nor <code>append_support'</code> on my machine (<code>connectivity.lean</code> lines 462 to 488).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">append_support''</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p'</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">p.append</span> <span class="n">p'</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">+</span> <span class="n">p.support.tail</span> <span class="bp">+</span> <span class="n">p'.support.tail</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">append_support</span><span class="o">,</span> <span class="bp">←</span><span class="n">multiset.coe_add</span><span class="o">],</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.singleton_eq_singleton</span><span class="o">,</span> <span class="n">multiset.cons_coe</span><span class="o">,</span>
    <span class="n">zero_add</span><span class="o">,</span> <span class="n">multiset.coe_eq_coe</span><span class="o">,</span> <span class="n">multiset.cons_add</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">support_eq</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">append_support'</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p'</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">p.append</span> <span class="n">p'</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p.support</span> <span class="bp">+</span> <span class="n">p'.support</span> <span class="bp">-</span> <span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">append_support</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nil_support</span><span class="o">,</span> <span class="n">list.tail_cons</span><span class="o">,</span> <span class="n">list.append_nil</span><span class="o">],</span>
    <span class="n">convert_to</span> <span class="n">_</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p.support</span> <span class="bp">+</span> <span class="o">([</span><span class="n">v</span><span class="o">]</span> <span class="bp">-</span> <span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">V</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">erw</span> <span class="n">multiset.add_sub_cancel</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="bp">←</span><span class="n">add_zero</span> <span class="o">(</span><span class="n">p.support</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">V</span><span class="o">),</span>
      <span class="n">rw</span> <span class="n">add_left_cancel_iff</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">cons_support</span><span class="o">,</span> <span class="n">list.tail_cons</span><span class="o">,</span> <span class="bp">←</span><span class="n">multiset.cons_coe</span><span class="o">,</span> <span class="bp">←</span><span class="n">multiset.singleton_add</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span>
    <span class="n">erw</span> <span class="n">multiset.add_sub_cancel</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">multiset.coe_add</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>On the former, it's failing to apply <code>simp</code> and on the later the second <code>simp</code> ends up with unsolved goals. Was this under your radar?</p>



<a name="259120904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259120904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259120904">(Oct 26 2021 at 16:12)</a>:</h4>
<p>Okay I fixed a few things. I wanna push to a different branch before merging so you can see my modifications first because these are my first changes to mathlib files.</p>



<a name="259123770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259123770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259123770">(Oct 26 2021 at 16:33)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/9983">https://github.com/leanprover-community/mathlib/pull/9983</a> A PR to merge my branch into yours.<br>
You said that I could push commits directly to your branch if I added new files. But in this case I made changes to files that you wrote so I'm more comfortable opening a PR into your branch this time around (I don't want to mess things up).</p>



<a name="259125740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259125740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259125740">(Oct 26 2021 at 16:46)</a>:</h4>
<p>For those kinds of changes (fixing proofs, changing names, and the like), feel free to commit straight to the branch. (And thanks for finding a way to simplify one of the proofs! I wouldn't mind if you did that for more of the proofs; many still have things like <a href="https://leanprover-community.github.io/extras/simp.html#non-terminal-codesimpcodes">non-terminal simps</a>.)</p>
<p>I haven't seen using PRs targeting non-master branches before for mathlib, and I'm not sure how it will interact with the existing PR due to my lack of experience. Will squash-and-merge effectively just add a single commit to the <code>walks_and_trees</code> branch?</p>



<a name="259125931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259125931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259125931">(Oct 26 2021 at 16:47)</a>:</h4>
<p>Yeah, such PR are fine but pretty rare. People usually rather go through a PR-like process behind the scenes.</p>



<a name="259126603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259126603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259126603">(Oct 26 2021 at 16:51)</a>:</h4>
<p>Okay since you've already reviewed the changes and approved them (on this chat), I'm gonna accept the PR and merge my branch into yours</p>



<a name="259133995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259133995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259133995">(Oct 26 2021 at 17:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259125740">said</a>:</p>
<blockquote>
<p>I haven't seen using PRs targeting non-master branches before for mathlib, and I'm not sure how it will interact with the existing PR due to my lack of experience. Will squash-and-merge effectively just add a single commit to the <code>walks_and_trees</code> branch?</p>
</blockquote>
<p>Yeah that's precisely it. It's just a way of coordinating collaboration so you know exactly what I'm changing instead of having to read it on a tight <code>git diff</code> terminal interface</p>



<a name="259134319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259134319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259134319">(Oct 26 2021 at 17:45)</a>:</h4>
<p>But sure, I can be more straightforward and commit directly on your branch <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="259134720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259134720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259134720">(Oct 26 2021 at 17:47)</a>:</h4>
<p>(I don't mind reviewing your changes if you prefer PRing.)</p>



<a name="259138300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259138300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259138300">(Oct 26 2021 at 18:13)</a>:</h4>
<p>Interesting, I've just found out about this GitHub feature: <code>compare</code>.<br>
If you go to <a href="https://github.com/leanprover-community/mathlib/compare">https://github.com/leanprover-community/mathlib/compare</a> you can pick two branches as if you wanted to merge one into the other and the diff will be shown in a PR-styled way. Example: comparing <code>walks_and_trees</code> with <code>master</code>:<br>
<a href="https://github.com/leanprover-community/mathlib/compare/master...walks_and_trees">https://github.com/leanprover-community/mathlib/compare/master...walks_and_trees</a></p>
<p>But it doesn't allow commentaries etc, which make sense</p>



<a name="259138435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259138435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259138435">(Oct 26 2021 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259134720">said</a>:</p>
<blockquote>
<p>(I don't mind reviewing your changes if you prefer PRing.)</p>
</blockquote>
<p>Thanks <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> <br>
Yeah I feel safer that way</p>



<a name="259173202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259173202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259173202">(Oct 26 2021 at 22:52)</a>:</h4>
<p>According to this definition, trees and spanning trees are the same for us, right?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A *tree* is a connected acyclic graph. -/</span>
<span class="kd">def</span> <span class="n">is_tree</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">G.connected</span> <span class="bp">∧</span> <span class="n">G.is_acyclic</span>
</code></pre></div>



<a name="259174061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259174061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259174061">(Oct 26 2021 at 23:02)</a>:</h4>
<p>A spanning tree is a <code>G' : subgraph G</code> that satisfies <code>G'.is_spanning</code> and <code>G'.coe.is_tree</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.coe">docs#simple_graph.subgraph.coe</a> to turn the subgraph into a graph.)  It's probably more convenient to use <code>G'.spanning_coe.is_tree</code>, which doesn't introduce a subtype for the vertices.</p>
<p>Another way to formalize spanning trees, probably even more convenient, is as a <code>G' : simple_graph V</code> such that <code>G' ≤ G</code> and <code>G'.is_tree</code>.  The type <code>simple_graph V</code> has a boolean algebra structure from comparing edge sets, and <code>G' ≤ G</code> means <code>G'</code> is a spanning subgraph of <code>G</code>.</p>



<a name="259175202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259175202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259175202">(Oct 26 2021 at 23:16)</a>:</h4>
<p>Ah, wait, I got confused. The concept of "Spanning tree" is that we can compute the spanning tree of a connected graph</p>



<a name="259175657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259175657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259175657">(Oct 26 2021 at 23:23)</a>:</h4>
<p>This (or some variation on it) would be nice to have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">exists_spanning_tree</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.connected</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">G'</span><span class="o">,</span> <span class="n">G'</span> <span class="bp">≤</span> <span class="n">G</span> <span class="bp">∧</span> <span class="n">G'.is_tree</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="259175841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259175841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259175841">(Oct 26 2021 at 23:25)</a>:</h4>
<p>This is a noncomputable version, allowing for <code>V</code> to be infinite. The argument that comes to mind uses Zorn's lemma applied to acyclic graphs <code>G' ≤ G</code>.</p>



<a name="259175922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259175922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259175922">(Oct 26 2021 at 23:27)</a>:</h4>
<p>Nice. I'm trying to figure out a way to state that the number of edges of a finite tree is equal to the number of vertices minus 1</p>



<a name="259176025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176025">(Oct 26 2021 at 23:28)</a>:</h4>
<p>But I'm not even being able to write it as a lemma and have Lean accept it</p>



<a name="259176139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176139">(Oct 26 2021 at 23:30)</a>:</h4>
<p>This is not the right lemma, but I'm getting an error.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">asd</span> <span class="o">:</span> <span class="n">G.is_tree</span> <span class="bp">→</span> <span class="n">G.edge_finset.card</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>The error is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">V</span><span class="o">,</span>
<span class="n">ᾰ</span> <span class="o">:</span> <span class="n">G.is_tree</span>
<span class="bp">⊢</span> <span class="n">fintype</span> <span class="n">V</span>
</code></pre></div>



<a name="259176164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176164">(Oct 26 2021 at 23:30)</a>:</h4>
<p>That's saying you don't have the assumption that <code>V</code> is finite.  Add <code>[fintype V]</code> as an argument to <code>asd</code>.</p>



<a name="259176307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176307">(Oct 26 2021 at 23:32)</a>:</h4>
<p>I guess you need <code>[decidable_eq V] [fintype V] [decidable_rel G.adj]</code> to use <code>G.edge_finset</code>.</p>



<a name="259176445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176445">(Oct 26 2021 at 23:34)</a>:</h4>
<p>(This should be changed actually. <code>G.edge_finset</code> should just need <code>[fintype G.edge_set]</code>.  Or maybe it should be removed, since all it does is make it a little easier to write <code>G.edge_set.to_finset</code>.)</p>



<a name="259176579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176579">(Oct 26 2021 at 23:36)</a>:</h4>
<p><code>[fintype V] [decidable_rel G.adj]</code> did the job, thanks!</p>
<p>Question: I see that some proofs use assumptions introduced with <code>{...}</code> and others use <code>[...]</code>. What's the difference?</p>



<a name="259176649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176649">(Oct 26 2021 at 23:37)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/set.2Efinite.2Efintype/near/249577393">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/set.2Efinite.2Efintype/near/249577393</a></p>



<a name="259176731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176731">(Oct 26 2021 at 23:38)</a>:</h4>
<p><a href="https://leanprover.github.io/reference/expressions.html#implicit-arguments">https://leanprover.github.io/reference/expressions.html#implicit-arguments</a></p>



<a name="259176746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176746">(Oct 26 2021 at 23:39)</a>:</h4>
<p>Chapter 10 of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a> is a good reference on how type classes (related to the square brackets) work in Lean 3.</p>



<a name="259176881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176881">(Oct 26 2021 at 23:41)</a>:</h4>
<p><code>lemma asd [fintype G.edge_set]: G.is_tree → G.edge_set.to_finset.card = 1 := sorry</code> is accepted <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="259176986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259176986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259176986">(Oct 26 2021 at 23:42)</a>:</h4>
<p>I will get back to the introduction of spanning trees once I figure this one out. Now I need to express the cardinality of <code>V</code>. Let me struggle a little</p>



<a name="259177081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259177081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259177081">(Oct 26 2021 at 23:44)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<p>That's <code>fintype.card V</code> if you've got <code>[fintype V]</code></p>
</div></div>



<a name="259177090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259177090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259177090">(Oct 26 2021 at 23:44)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<p>(it's common to add an <code>open fintype</code> line so you can just write <code>card V</code>)</p>
</div></div>



<a name="259184594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259184594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259184594">(Oct 27 2021 at 01:53)</a>:</h4>
<p>Is this too astray?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">fintype</span>

<span class="kd">lemma</span> <span class="n">is_tree_then_card_edges_le_card_vertices</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">G.is_tree</span> <span class="bp">→</span> <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">&lt;</span> <span class="n">card</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_tree_then_not_card_edges_le_card_vertices_minus_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]:</span> <span class="n">G.is_tree</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">&lt;</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">the strategy is to use the lemmas above and nat.eq_of_lt_succ_of_not_lt in order to</span>
<span class="cm">achieve equality</span>
<span class="cm">-/</span>
<span class="kd">lemma</span> <span class="n">is_tree_then_card_edges_eq_card_vertices_minus_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">G.is_tree</span> <span class="bp">→</span> <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hle</span> <span class="o">:=</span> <span class="n">is_tree_then_card_edges_le_card_vertices</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hnle</span> <span class="o">:=</span> <span class="n">is_tree_then_not_card_edges_le_card_vertices_minus_one</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259184714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259184714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259184714">(Oct 27 2021 at 01:55)</a>:</h4>
<p>Maybe an induction on the number of vertices works better</p>



<a name="259186042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259186042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259186042">(Oct 27 2021 at 02:23)</a>:</h4>
<p>It would be possible to prove it using an induction principle for trees (though I'm not sure exactly how I'd want to formulate it).</p>
<p>Another option is more direct.  Given a tree, choose an arbitrary root <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>.  Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>V</mi><mo>∖</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">W=V\setminus v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>.  For every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">w\in W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>, there is a unique path from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> (see <code>tree_path</code>); let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> denote the first edge in this path.  This function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> is surjective (given an edge, you should be able to use <code>is_rootward_antisymm</code> to show it's the image of one of its endpoints) and it is injective (same lemma or thereabouts).  Since this is a bijection, we get an equality of the cardinalities of the edge set and of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>.</p>



<a name="259186297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259186297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259186297">(Oct 27 2021 at 02:28)</a>:</h4>
<p>Will take a closer look at your approach tomorrow. I'm feeling a bit fried after some hours trying to translate my thoughts into Lean.</p>
<p>I've started this draft PR, also including some adjustments you requested on the previous PR that I couldn't see in time:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/9993">https://github.com/leanprover-community/mathlib/pull/9993</a></p>



<a name="259191326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259191326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259191326">(Oct 27 2021 at 04:16)</a>:</h4>
<p>The coercions here are a bit hairy, but maybe you can try filling in the sorries (assuming I set things up right):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">next_edge</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hvw</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">is_tree_then_card_edges_eq_card_vertices_minus_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">root</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">set.card_ne_eq</span> <span class="n">root</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">v</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span> <span class="bp">→</span> <span class="n">G.edge_set</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">next_edge</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="n">root</span> <span class="n">v.property</span> <span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">v</span> <span class="n">root</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">root</span><span class="o">),</span>
    <span class="c1">-- convert the term of incidence_set to an edge_set; there's probably a nicer way</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">a.property.1</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fprop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
    <span class="n">generalize</span> <span class="o">:</span> <span class="n">next_edge</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e.property</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">finj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">card_of_bijective</span> <span class="o">⟨</span><span class="n">finj</span><span class="o">,</span> <span class="n">fsurj</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>(Small warning: I'm not sure how much more code is needed to fill them in.)</p>



<a name="259225518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259225518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259225518">(Oct 27 2021 at 11:38)</a>:</h4>
<p>It's not accepting <code>v</code> as an input of <code>next_edge</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">next_edge</span> <span class="bp">↑</span><span class="n">v</span>
<span class="n">term</span>
  <span class="bp">↑</span><span class="n">v</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">simple_graph</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
</code></pre></div>



<a name="259225710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259225710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259225710">(Oct 27 2021 at 11:40)</a>:</h4>
<p>Do you need <code>next_edge _ v</code>? With an extra underscore?</p>



<a name="259225783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259225783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259225783">(Oct 27 2021 at 11:40)</a>:</h4>
<p>Maybe <code>simple_graph _</code> shouldn't be an explicit argument of <code>next_edge</code>?</p>



<a name="259226153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226153">(Oct 27 2021 at 11:44)</a>:</h4>
<p>The extra underscore before <code>v</code> worked, but I don't understand what you meant by <code>simple_graph _</code> being an argument of <code>next_edge</code></p>



<a name="259226174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226174">(Oct 27 2021 at 11:44)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> if you read the error message you can see it says "you know where you put v? I was expecting you to put a simple graph", and if you hover over <code>next_edge</code> you can see all the inputs it expects and in what order, so you can confirm that indeed the first input to that function is supposed to be a simple graph</p>



<a name="259226371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226371">(Oct 27 2021 at 11:46)</a>:</h4>
<p>Do you understand about () and {} inputs to functions? (Edit -- and [] inputs) That's what Johan is talking about</p>



<a name="259226425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226425">(Oct 27 2021 at 11:46)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> I guess you have <code>variables (foobar : simple_graph V)</code> somewhere above the definition of <code>next_edge</code>. I don't know much about the graph theory library, but maybe that should be <code>[simple_graph V]</code>.</p>



<a name="259226696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226696">(Oct 27 2021 at 11:49)</a>:</h4>
<p>I'm gonna do some reading on that subject</p>



<a name="259226706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226706">(Oct 27 2021 at 11:49)</a>:</h4>
<p>The _ means "Lean please work out yourself what this input should be"</p>



<a name="259226729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226729">(Oct 27 2021 at 11:49)</a>:</h4>
<p>But a more cunning choice of brackets will mean that you don't even need to put the _</p>



<a name="259226972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259226972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259226972">(Oct 27 2021 at 11:52)</a>:</h4>
<p>Inputs in () brackets are supplied by the user, unless the user gives lean _ which puts the ball back into its court. Inputs in {} brackets are supplied by lean's unification system so the user skips them, and inputs in [] brackets are supplied by lean's type class inference system so the user skips them too.</p>



<a name="259227049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259227049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259227049">(Oct 27 2021 at 11:53)</a>:</h4>
<p>Right now your error was giving lean a vertex when it wanted a simple graph, the suggested fix was to give it _ but another fix would be to change the type of bracket</p>



<a name="259228051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259228051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259228051">(Oct 27 2021 at 12:03)</a>:</h4>
<blockquote>
<p>Right now your error was giving lean a vertex when it wanted a simple graph</p>
</blockquote>
<p>If that's the error, then I think it's not just about the brackets. There's a logical error because we want <code>V</code> to be the vertices of a <code>simple_graph G</code>. So elements of <code>V</code>, such as <code>v</code>, shouldn't be of type <code>simple_graph</code></p>



<a name="259233713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259233713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259233713">(Oct 27 2021 at 12:56)</a>:</h4>
<p>You can read the error, and it is what it is. I am not suggesting that v should have type simple_graph! I am however suggesting that Lean wanted something of type simple_graph where you put a v, and this is of your own making (because of your choice of brackets).</p>



<a name="259233860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259233860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259233860">(Oct 27 2021 at 12:57)</a>:</h4>
<p>If you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> with the error I can try and explain my point more clearly (apart from the fact that I'm about to go to a meeting)</p>



<a name="259235478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259235478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259235478">(Oct 27 2021 at 13:09)</a>:</h4>
<p>Yeah I copied/pasted Kyle's code and now I'm trying to catch up with his line of thought <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>. I'm still crawling in Lean so I don't think I can spot a MWE that manifests this error.<br>
But you're not the first one that mentions the possibility of improving the way that the assumptions are denoted (implicitly/explicitly) so that's definitely something to take into consideration as an improvement.</p>



<a name="259240720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259240720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259240720">(Oct 27 2021 at 13:45)</a>:</h4>
<p>I'm asking if you could simply paste your fully (almost) working file with the error, so I don't have to go back over the entire thread and cut and paste all the parts together.</p>



<a name="259241708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259241708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259241708">(Oct 27 2021 at 13:51)</a>:</h4>
<p>Let me try</p>



<a name="259242244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259242244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259242244">(Oct 27 2021 at 13:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="sd">/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,</span>
<span class="sd">the type `walk u v` consists of all walks starting at `u` and ending at `v`.</span>

<span class="sd">We say that a walk *visits* the vertices it contains.  The set of vertices a</span>
<span class="sd">walk visits is `simple_graph.walk.support`. -/</span>
<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">walk</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">u</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">u</span> <span class="n">w</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="n">walk.nil</span>

<span class="kd">def</span> <span class="n">next_edge</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hvw</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">is_tree.card_edges_eq_card_vertices_sub_one'</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">root</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">set.card_ne_eq</span> <span class="n">root</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">v</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span> <span class="bp">→</span> <span class="n">G.edge_set</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">next_edge</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="n">root</span> <span class="n">v.property</span> <span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">v</span> <span class="n">root</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">root</span><span class="o">),</span>
    <span class="c1">-- convert the term of incidence_set to an edge_set; there's probably a nicer way</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">a.property.1</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fprop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
    <span class="n">generalize</span> <span class="o">:</span> <span class="n">next_edge</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e.property</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">finj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">card_of_bijective</span> <span class="o">⟨</span><span class="n">finj</span><span class="o">,</span> <span class="n">fsurj</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259242483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259242483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259242483">(Oct 27 2021 at 13:57)</a>:</h4>
<p>This file doesn't work for me.</p>



<a name="259242526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259242526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259242526">(Oct 27 2021 at 13:57)</a>:</h4>
<p>What branch of mathlib are you on? And there are universe issues.</p>



<a name="259242826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259242826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259242826">(Oct 27 2021 at 13:59)</a>:</h4>
<p>The branch is called <code>more_on_trees</code>. I've just pushed a commit. The file is <code>src/combinatorics/simple_graph/connectivity.lean</code></p>



<a name="259242885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259242885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259242885">(Oct 27 2021 at 13:59)</a>:</h4>
<p>The lemma starts at line 1251</p>



<a name="259243242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259243242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259243242">(Oct 27 2021 at 14:01)</a>:</h4>
<p>There are errors on that branch for me, in files imported by the file you're working on. This can cause unexpected issues.</p>



<a name="259243352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259243352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259243352">(Oct 27 2021 at 14:02)</a>:</h4>
<p>But despite these issues I think I've seen enough to be able to say something coherent.</p>



<a name="259243957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259243957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259243957">(Oct 27 2021 at 14:06)</a>:</h4>
<p>Unfortunately I can't get <code>next_edge</code> compiling either on your branch or on master.</p>



<a name="259244252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244252">(Oct 27 2021 at 14:08)</a>:</h4>
<p>But the definition mentions <code>G</code> and <code>G</code> is a variable which depends on <code>V</code>, so the actual type of <code>next_edge</code> will be something like <code>next_edge : \forall {V : Type u} (G : simple_graph V),  ∀ (v w : V) (h : v ≠ w) (p : G.walk v w), G.incidence_set </code></p>



<a name="259244258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244258">(Oct 27 2021 at 14:08)</a>:</h4>
<p>Yeah Kyle introduced the definition of <code>next_edge</code> just today, here on Zulip</p>



<a name="259244349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244349">(Oct 27 2021 at 14:09)</a>:</h4>
<p>And the reason that V is in {} brackets and G is in () brackets is because of the <code>variables {V : Type u} (G : simple_graph V)</code> line</p>



<a name="259244456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244456">(Oct 27 2021 at 14:09)</a>:</h4>
<p>The brackets for the <code>next_edge</code> variables correspond to the brackets used in the <code>variables</code> command earlier.</p>



<a name="259244558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244558">(Oct 27 2021 at 14:10)</a>:</h4>
<p>So the first user-provided input for <code>next_edge</code> needs to be a term of type <code>simple_graph V</code></p>



<a name="259244619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244619">(Oct 27 2021 at 14:10)</a>:</h4>
<p>and then the second and third inputs are two terms of type V etc etc</p>



<a name="259244897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259244897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259244897">(Oct 27 2021 at 14:12)</a>:</h4>
<p>And so the error you get is correct, because of the choice of brackets in the <code>variables</code> line.</p>



<a name="259245221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259245221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259245221">(Oct 27 2021 at 14:14)</a>:</h4>
<p>Johan suggested making them <code>[]</code> but it seems that <code>simple_graph</code> is a structure not a class, which means that the designers have left open the possibility that you might want to consider more than one structure of a simple graph on a fixed vertex type <code>V</code>. As a result the type class inference system does not know about <code>simple_graph</code> so <code>[]</code> brackets won't work.</p>



<a name="259245923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259245923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259245923">(Oct 27 2021 at 14:19)</a>:</h4>
<p>The other possibility is that you change <code>(G : simple_graph V)</code> into <code>{G : simple_graph V}</code> and in this case you'll be asking the unification system to fill in the variable for you. This could well work, because now my guess for what <code>next_edge</code> will want to eat is first two elements v,w of V, then a proof that v!=w, and finally a term <code>p</code> of type <code>G.walk v w</code>, and once Lean sees this term it will be able to look at its type and guess what <code>G</code> was, as the term <code>G</code> is mentioned in the type of <code>p</code>, and this is exactly the sort of thing which the unification system does. So I suspect that changing <code>(G : simple_graph V)</code> to <code>{G : simple_graph V}</code> on the variables line (or, if this variables line is on line 10 of the code and you're looking at line 1000, writing a new line <code>variable {G}</code> just above the definition of <code>next_edge</code>) will be another way of fixing the error you were seeing (other than adding in the <code>_</code>).</p>



<a name="259248182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259248182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259248182">(Oct 27 2021 at 14:33)</a>:</h4>
<p>It worked :D<br>
I'm learning the syntax slowly. For instance, it's not clear to me why the first parameter of <code>next_edge</code> is a <code>simple_graph</code>.<br>
When I read</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">next_edge</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hvw</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>just by checking the matches I see four inputs (like <code>v w h walk.nil</code>)</p>



<a name="259248275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259248275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259248275">(Oct 27 2021 at 14:33)</a>:</h4>
<p>Yes but you also see V and G, right? Where are they coming from?</p>



<a name="259248338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259248338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259248338">(Oct 27 2021 at 14:33)</a>:</h4>
<p>That's what <code>variables</code> do for you -- they are automatically added as inputs to any function which mentions them by name.</p>



<a name="259248467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259248467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259248467">(Oct 27 2021 at 14:34)</a>:</h4>
<p>They're not there when the function is defined, but when you use the function you have to supply them</p>



<a name="259248609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259248609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259248609">(Oct 27 2021 at 14:35)</a>:</h4>
<p>The <code>|</code> magic is supplying them, but if you do <code>#check @next_edge</code> just after the definition, or hover over it in a place where it's used in a theorem, you'll see the extra inputs.</p>



<a name="259248975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259248975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259248975">(Oct 27 2021 at 14:37)</a>:</h4>
<p>Will Lean4 work like this too?</p>



<a name="259249040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259249040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259249040">(Oct 27 2021 at 14:38)</a>:</h4>
<p>Yup</p>



<a name="259249462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259249462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259249462">(Oct 27 2021 at 14:40)</a>:</h4>
<p>Okay then I better get used to it. I think it's a bit hard on the reader but I see how it speeds up writing</p>



<a name="259266955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259266955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259266955">(Oct 27 2021 at 16:32)</a>:</h4>
<p>Sorry for the confusion I've seemed to cause with the code I posted. I had written it at the end of <code>src/combinatorics/simple_graph/connectivity.lean</code> in the <code>walks_and_trees</code> branch right before the final <code>end simple_graph</code>, so the full context was <code>variables {V : Type u} {G : simple_graph V} [decidable_eq V]</code> in the <code>simple_graph</code> namespace.</p>



<a name="259267922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259267922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259267922">(Oct 27 2021 at 16:38)</a>:</h4>
<p>It looks like errors in imports are from someone helpfully merging master to bring the branch up to date, but this introduced some small errors. (<span class="user-mention" data-user-id="451983">@Arthur Paulino</span> if you want to fix them, in <code>subgraph.lean</code> look for  the couple cases of <code>sym :=</code> and replace them with <code>symm :=</code>. I think that's it.)</p>



<a name="259270899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259270899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259270899">(Oct 27 2021 at 16:57)</a>:</h4>
<p>Nice. I had replaced some occurrences of <code>sym</code> by <code>symm</code> but I seem to have overlooked two of them</p>



<a name="259276244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259276244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anupam Nayak <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259276244">(Oct 27 2021 at 17:33)</a>:</h4>
<p>Declaring <code>variables</code> actually makes it easier for the reader too, if used properly. If you're working on something where you have 10 theorems, all about some 3 or 4 variables, then having to read the same arguments in each theorem is cumbersome. Separating out the common variables makes it clear to the reader that the next few theorems are all about these variables.</p>
<p>Even in maths we do this a lot when we say "let X, Y be topological spaces, f a continuous function from X to Y, yada yada, theorem 1... theorem n"</p>



<a name="259276882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259276882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259276882">(Oct 27 2021 at 17:37)</a>:</h4>
<p>That someone being me <span aria-label="exhausted" class="emoji emoji-1f625" role="img" title="exhausted">:exhausted:</span></p>



<a name="259289686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259289686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259289686">(Oct 27 2021 at 19:00)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I was also trying to make this definition a bit clearer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">next_edge</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hvw</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>Do you think it's worth the effort?</p>



<a name="259289855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259289855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259289855">(Oct 27 2021 at 19:01)</a>:</h4>
<p>What does <code>mem</code> stand for?</p>



<a name="259290606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259290606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259290606">(Oct 27 2021 at 19:06)</a>:</h4>
<p><code>next_edge</code> would be better if <code>G</code> were an explicit argument, but it doesn't make the definition clearer.  I'm not sure it could be made simpler.</p>
<p>By doubling the amount of code, you can split off the proof of incidence from the edge the function outputs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">next_edge</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">sym2</span> <span class="n">V</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span>

<span class="kd">lemma</span> <span class="n">next_edge_mem_incidence_set</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.next_edge</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259290679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259290679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259290679">(Oct 27 2021 at 19:07)</a>:</h4>
<p><code>mem</code> is used in a name for <code>∈</code></p>



<a name="259298750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259298750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259298750">(Oct 27 2021 at 20:05)</a>:</h4>
<p>this is the current diff: <a href="https://github.com/leanprover-community/mathlib/pull/9993/files">https://github.com/leanprover-community/mathlib/pull/9993/files</a></p>



<a name="259309569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259309569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259309569">(Oct 27 2021 at 21:31)</a>:</h4>
<p>If I have <code>e: ↥(G.edge_set)</code>, how to get the vertices that compose <code>e</code>?</p>



<a name="259310488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259310488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259310488">(Oct 27 2021 at 21:38)</a>:</h4>
<p><code>e.1</code> gives you an edge. From there it's a good exercise to define what you want. There are several ways to do it.</p>



<a name="259310568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259310568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259310568">(Oct 27 2021 at 21:39)</a>:</h4>
<p>I guess <code>e.val</code> will have type <code>sym2 V</code> so look at the API for <code>sym2</code> by right clicking on it</p>



<a name="259310749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259310749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259310749">(Oct 27 2021 at 21:41)</a>:</h4>
<p>oh hmm it's a quotient. You could use <code>quotient.out</code> I guess</p>



<a name="259310904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259310904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259310904">(Oct 27 2021 at 21:42)</a>:</h4>
<p>If you don't find what you want, don't worry but do tell us. The API for <code>sym2</code> is currently crap and we have plans to improve it.</p>



<a name="259311560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259311560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259311560">(Oct 27 2021 at 21:48)</a>:</h4>
<p>I think it's better to explain the strategy I'd apply if I were to prove it in a undergrad course, then I can use some help on translating my intent to Lean.</p>
<p>This is my current state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">V</span>
<span class="n">_inst_2</span><span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)</span>
<span class="n">_inst_3</span><span class="o">:</span> <span class="n">fintype</span> <span class="n">V</span>
<span class="n">_inst_4</span><span class="o">:</span> <span class="n">nonempty</span> <span class="n">V</span>
<span class="n">h</span><span class="o">:</span> <span class="n">G.is_tree</span>
<span class="n">root</span><span class="o">:</span> <span class="n">V</span>
<span class="n">f</span><span class="o">:</span> <span class="bp">↥</span><span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}),</span> <span class="o">⟨</span><span class="bp">↑</span><span class="o">(</span><span class="n">next_edge</span> <span class="bp">↑</span><span class="n">v</span> <span class="n">root</span> <span class="n">_</span> <span class="bp">↑</span><span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="bp">↑</span><span class="n">v</span> <span class="n">root</span><span class="o">)),</span> <span class="n">_</span><span class="o">⟩</span>
<span class="n">fprop</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="n">finj</span><span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span>
<span class="n">e</span><span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">G.edge_set</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span>
</code></pre></div>
<p>That is, I need to prove that given an edge <code>e</code> of a tree <code>G</code> and a root vertex <code>root</code>,  I can retrieve <code>a</code> as the furthest vertex that composes <code>e</code></p>



<a name="259311840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259311840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259311840">(Oct 27 2021 at 21:51)</a>:</h4>
<p><code>f</code> is a function that returns the last edge on a path from <code>root</code> to a given vertex</p>



<a name="259312370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259312370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259312370">(Oct 27 2021 at 21:57)</a>:</h4>
<p>My intuition is to take <code>e1</code> and <code>e2</code> as the vertices that compose <code>e</code> and apply <code>f</code> to them. Either <code>f(e1)</code> or <code>f(e2)</code> will result in <code>e</code></p>



<a name="259312797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259312797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259312797">(Oct 27 2021 at 22:00)</a>:</h4>
<p>The proof wouldn't be complete because I'd need to prove that last sentence. My struggle is to translate my thoughts into Lean</p>



<a name="259312822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259312822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259312822">(Oct 27 2021 at 22:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259310904">said</a>:</p>
<blockquote>
<p>The API for <code>sym2</code> is currently crap and we have plans to improve it.</p>
</blockquote>
<p>Where's this sentiment coming from? It certainly has everything necessary for this (though of course things can always be improved.)</p>



<a name="259312849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259312849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259312849">(Oct 27 2021 at 22:01)</a>:</h4>
<p>Doing SRL <span aria-label="stuck out tongue closed eyes" class="emoji emoji-1f61d" role="img" title="stuck out tongue closed eyes">:stuck_out_tongue_closed_eyes:</span></p>



<a name="259312986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259312986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259312986">(Oct 27 2021 at 22:02)</a>:</h4>
<p>Bhavik identified two stupid lemmas which made our life much easier. But we still ended up not using <code>sym2</code> anymore (well, except for the intrinsically <code>simple_graph</code>part).</p>



<a name="259313429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259313429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259313429">(Oct 27 2021 at 22:07)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> One way to do this is this incantation: <code>cases e with e he, refine quotient.ind (λ p, _) e, cases p with v w,</code></p>



<a name="259313500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259313500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259313500">(Oct 27 2021 at 22:07)</a>:</h4>
<p>Oh, wait, that doesn't generalize a variable correctly.</p>



<a name="259313599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259313599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259313599">(Oct 27 2021 at 22:08)</a>:</h4>
<p>Maybe <code>cases e with e he, induction e using quotient.ind, cases e with v w,</code></p>



<a name="259313765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259313765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259313765">(Oct 27 2021 at 22:10)</a>:</h4>
<p>I could have sworn there was a <code>sym2.ind</code> that we added, but I guess it was just <code>sym2.lift</code></p>



<a name="259313830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259313830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259313830">(Oct 27 2021 at 22:11)</a>:</h4>
<p>We have <code>sym2.ind</code> in <a href="https://github.com/leanprover-community/mathlib/tree/szemeredi">branch#szemeredi</a></p>



<a name="259315319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259315319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259315319">(Oct 27 2021 at 22:24)</a>:</h4>
<p>Now I need to take the furthest one (between <code>v</code> and <code>w</code>) from <code>root</code></p>



<a name="259316004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259316004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259316004">(Oct 27 2021 at 22:30)</a>:</h4>
<p>I'm gonna spend a few hours here: <a href="https://leanprover.github.io/reference/tactics.html">https://leanprover.github.io/reference/tactics.html</a></p>



<a name="259317725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259317725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259317725">(Oct 27 2021 at 22:49)</a>:</h4>
<p>Some info on that page might be out of date. I suspect you'd be better off reading the <a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html">corresponding chapter of TPiL</a> and referring to <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html">our tactic docs</a> as needed.</p>



<a name="259317906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259317906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259317906">(Oct 27 2021 at 22:51)</a>:</h4>
<p>Here's sort of what I was imagining for surjectivity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">next_edge</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hvw</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">nonempty_path_not_loop</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.path</span> <span class="n">v</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">walk.edges</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">v</span><span class="o">))</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">hp_support_nodup</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">≠</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hinc</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.path</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">edges</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.next_edge</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hne</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hinc</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hne</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hp_support_nodup</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">next_edge</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">simple_graph.walk.cons_edges</span><span class="o">,</span> <span class="n">sym2.eq_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">(⟨</span><span class="n">_</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩)</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">walk.mem_support_of_mem_edges</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">hp_support_nodup.1</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_tree_then_card_edges_eq_card_vertices_minus_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">root</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">set.card_ne_eq</span> <span class="n">root</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">v</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span> <span class="bp">→</span> <span class="n">G.edge_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span>
    <span class="o">⟨</span><span class="n">G.next_edge</span> <span class="n">v</span> <span class="n">root</span> <span class="n">v.property</span> <span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">v</span> <span class="n">root</span><span class="o">),</span>
     <span class="n">G.incidence_set_subset</span> <span class="n">_</span> <span class="o">(</span><span class="n">subtype.mem</span> <span class="n">_</span><span class="o">)⟩,</span>
  <span class="k">have</span> <span class="n">fprop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">subtype.mem</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">finj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">e</span> <span class="n">using</span> <span class="n">quotient.ind</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">is_rootward_or_reverse</span> <span class="n">h</span> <span class="n">root</span> <span class="n">he</span> <span class="k">with</span> <span class="n">hr</span> <span class="n">hr</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">v</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="c1">-- goal is equivalently v ≠ root; substitute v for root</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">hr.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
      <span class="n">erw</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">he</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">hr_right</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- do the same thing again. use wlog?</span>
    <span class="o">},</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">card_of_bijective</span> <span class="o">⟨</span><span class="n">finj</span><span class="o">,</span> <span class="n">fsurj</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259318021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259318021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259318021">(Oct 27 2021 at 22:52)</a>:</h4>
<p>With the right lemmas, this could be a lot cleaner.  I'm also not sure if going through <code>is_rootward_or_reverse</code> and using the definition of <code>is_rootward</code> is the best way, but at least it works.</p>



<a name="259318507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259318507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259318507">(Oct 27 2021 at 22:58)</a>:</h4>
<p><code>eq_next_edge_if_mem_path</code> is not being accepted</p>



<a name="259318561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259318561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259318561">(Oct 27 2021 at 22:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span> <span class="n">function</span> <span class="bp">'</span><span class="n">simple_graph.next_edge'</span> <span class="n">does</span> <span class="n">not</span> <span class="k">have</span> <span class="n">explicit</span> <span class="n">argument</span> <span class="k">with</span> <span class="n">type</span> <span class="o">(</span><span class="n">simple_graph</span> <span class="bp">...</span><span class="o">)</span>
</code></pre></div>



<a name="259318581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259318581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259318581">(Oct 27 2021 at 22:58)</a>:</h4>
<p>Note that I changed the definition of <code>next_edge</code> to include <code>G</code> as an explicit argument</p>



<a name="259318675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259318675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259318675">(Oct 27 2021 at 22:59)</a>:</h4>
<p>Oh, ok<br>
Now it failed to instantiate goal with <code>v</code> on the <code>use</code> tactic</p>



<a name="259318731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259318731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259318731">(Oct 27 2021 at 23:00)</a>:</h4>
<p>brb</p>



<a name="259325808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259325808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259325808">(Oct 28 2021 at 00:36)</a>:</h4>
<p>Alright, had to do some tweaks, but I was able to finish up surjection:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">next_edge</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">G.incidence_set</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">walk.nil</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">(</span><span class="bp">@</span><span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">u</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hvw</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">nonempty_path_not_loop</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.path</span> <span class="n">v</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">walk.edges</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">v</span><span class="o">))</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">hp_support_nodup</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hne</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">≠</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hinc</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.path</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">edges</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.next_edge</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hne</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">hinc</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hne</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hp_support_nodup</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">next_edge</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">simple_graph.walk.cons_edges</span><span class="o">,</span> <span class="n">sym2.eq_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">(⟨</span><span class="n">_</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩)</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">walk.mem_support_of_mem_edges</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">hp_support_nodup.1</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_tree.card_edges_eq_card_vertices_sub_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">root</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">set.card_ne_eq</span> <span class="n">root</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">v</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span> <span class="bp">→</span> <span class="n">G.edge_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span>
    <span class="o">⟨</span><span class="n">G.next_edge</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="n">root</span> <span class="n">v.property</span> <span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">v</span> <span class="n">root</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">root</span><span class="o">),</span>
     <span class="n">G.incidence_set_subset</span> <span class="n">_</span> <span class="o">(</span><span class="n">subtype.mem</span> <span class="n">_</span><span class="o">)⟩,</span>
  <span class="k">have</span> <span class="n">fprop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">subtype.mem</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">finj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">,</span>

    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">e</span> <span class="n">using</span> <span class="n">quotient.ind</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">is_rootward_or_reverse</span> <span class="n">h</span> <span class="n">root</span> <span class="n">he</span> <span class="k">with</span> <span class="n">hr</span> <span class="n">hr</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">e₁</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">hr.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hr</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hr_right</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
        <span class="n">erw</span> <span class="n">key</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">]},</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">]},</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">e₂</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">hr.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hr</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hr_right</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
        <span class="n">erw</span> <span class="n">key</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">],</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">he</span><span class="o">]},</span> <span class="o">},</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">card_of_bijective</span> <span class="o">⟨</span><span class="n">finj</span><span class="o">,</span> <span class="n">fsurj</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259326115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259326115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259326115">(Oct 28 2021 at 00:41)</a>:</h4>
<p>Nice. By the way, I modified my comment shortly after posting it with some minor proof simplifications in the surjection proof</p>



<a name="259326369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259326369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259326369">(Oct 28 2021 at 00:44)</a>:</h4>
<p>Any reason you changed it to <code>cases e with e₁ e₂</code>? This splits <code>e</code> into two vertices, so naming-wise either <code>v w</code> or <code>v₁ v₂</code> seem potentially better.</p>



<a name="259326479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259326479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259326479">(Oct 28 2021 at 00:46)</a>:</h4>
<p>hm, I wanted to use something different than <code>v</code>. Maybe <code>w</code> suits better</p>



<a name="259326508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259326508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259326508">(Oct 28 2021 at 00:46)</a>:</h4>
<p>or <code>u₁ u₂</code>?</p>



<a name="259326808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259326808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259326808">(Oct 28 2021 at 00:51)</a>:</h4>
<p>I'm gonna try to use your optimized solution to prove it for the other vertex</p>



<a name="259327206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259327206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259327206">(Oct 28 2021 at 00:56)</a>:</h4>
<p>There's also <code>wlog</code> since the two cases are basically the same except for permuting the vertices, but it gives a very slow proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">e</span> <span class="n">using</span> <span class="n">quotient.ind</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">u₁</span> <span class="n">u₂</span><span class="o">,</span>
    <span class="n">wlog</span> <span class="o">:=</span> <span class="n">is_rootward_or_reverse</span> <span class="n">h</span> <span class="n">root</span> <span class="n">he</span> <span class="n">using</span> <span class="o">[</span><span class="n">u₁</span> <span class="n">u₂</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">u₁</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">case</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">case.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">case</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
      <span class="n">erw</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">he</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">case_right</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">G.symm</span> <span class="n">he</span><span class="o">),</span>
    <span class="n">use</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">sym2.eq_swap</span><span class="o">],</span> <span class="o">},</span>
</code></pre></div>



<a name="259327271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259327271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259327271">(Oct 28 2021 at 00:57)</a>:</h4>
<p>Slow in terms of processing? Like it's more time consuming?</p>



<a name="259327881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259327881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259327881">(Oct 28 2021 at 01:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">e</span> <span class="n">using</span> <span class="n">quotient.ind</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">u₁</span> <span class="n">u₂</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">is_rootward_or_reverse</span> <span class="n">h</span> <span class="n">root</span> <span class="n">he</span> <span class="k">with</span> <span class="n">hr</span> <span class="n">hr</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">u₁</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">hr.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
      <span class="n">erw</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">he</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">hr_right</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">he</span><span class="o">]},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">u₂</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">hr.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hr</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
      <span class="n">erw</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">_</span> <span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">hr_right</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">he</span><span class="o">,</span> <span class="n">sym2.eq_swap</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
</code></pre></div>



<a name="259327945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259327945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259327945">(Oct 28 2021 at 01:06)</a>:</h4>
<p>okay I'm gonna push this version to my branch</p>



<a name="259377702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259377702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259377702">(Oct 28 2021 at 12:06)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I was thinking yesterday about the function <code>f</code> you defined inside the proof and I realized that <code>f</code> being (or not) surjective and injective is closely related with the definition of trees. That is, if <code>f</code> is not surjective then there's a pair of vertices that are not reachable from the root. And if <code>if</code> is not injective, then there is a cycle in <code>G</code>. Do you think this approach could be clearer?<br>
For the injection, at least, I'd want to try a proof by contradiction by finding a cycle. What do you think?</p>



<a name="259421711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259421711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259421711">(Oct 28 2021 at 17:12)</a>:</h4>
<p>Branch updated!<br>
<a href="https://github.com/leanprover-community/mathlib/pull/9993">https://github.com/leanprover-community/mathlib/pull/9993</a><br>
Please let me know what you think <span aria-label="rocket" class="emoji emoji-1f680" role="img" title="rocket">:rocket:</span></p>



<a name="259424078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259424078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259424078">(Oct 28 2021 at 17:29)</a>:</h4>
<p>That approach would definitely work (for non-injectivity, it would be nice if there were a way to construct a cycle from <code>f</code> somewhat directly, by iteratively applying it to the opposite vertex across the output edge, but that would take some more work to develop).</p>
<p>Something I forgot to mention is that <code>is_rootward_or_reverse</code> and <code>is_rootward_antisymm</code> do these kinds of cycle argument already, and I figured it might save some work to use them.  However, it would be a good exercise to not use them, for both you and for the library (to help see what's missing).</p>



<a name="259426315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259426315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259426315">(Oct 28 2021 at 17:47)</a>:</h4>
<p>Yeah I'm trying as hard as I can to translate the logic inside my mind into Lean. The proof by cycle construction seems to be going okay, unless I've set myself for some very hard intermediate proof that I can't see right now. From your perspective, do you see a trap like that in my code? I mean, is any of those <code>sorry</code>s that I inserted super hard for my current level?</p>



<a name="259428052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259428052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259428052">(Oct 28 2021 at 17:58)</a>:</h4>
<p>Okay, 1 <code>sorry</code> down. 1 <code>sorry</code> left</p>



<a name="259430750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259430750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259430750">(Oct 28 2021 at 18:19)</a>:</h4>
<p>What you're doing seems doable (if perhaps all a bit of a trial by fire <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> but you seem to be fine with that!).</p>
<p>I wanted to check my suggestion to use <code>is_rootward_antisymm</code> actually panned out, so I went ahead and proved injectivity with it. It'd be better if you kept going with your approach, so don't let this spoiler-tagged-code stop you.</p>
<p>Here's a utility lemma that may or may not be helpful to you:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">next_edge_mem_edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G.next_edge</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="n">p</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">p.edges</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">next_edge</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">walk.cons_edges</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,},</span>
<span class="kd">end</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_tree_then_card_edges_eq_card_vertices_minus_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">root</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">set.card_ne_eq</span> <span class="n">root</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">v</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">}</span> <span class="bp">→</span> <span class="n">G.edge_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span>
    <span class="o">⟨</span><span class="n">G.next_edge</span> <span class="n">v</span> <span class="n">root</span> <span class="n">v.property</span> <span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">v</span> <span class="n">root</span><span class="o">),</span>
     <span class="n">G.incidence_set_subset</span> <span class="n">_</span> <span class="o">(</span><span class="n">subtype.mem</span> <span class="n">_</span><span class="o">)⟩,</span>
  <span class="k">have</span> <span class="n">fprop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">root</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">∈</span> <span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">subtype.mem</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">finj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">u₁</span><span class="o">,</span> <span class="n">h₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">u₂</span><span class="o">,</span> <span class="n">h₂</span><span class="o">⟩,</span>
    <span class="n">by_cases</span> <span class="n">hne</span> <span class="o">:</span> <span class="n">u₁</span> <span class="bp">=</span> <span class="n">u₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">u₂</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">generalize</span> <span class="n">he₁</span> <span class="o">:</span> <span class="n">G.next_edge</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">e₁</span><span class="o">,</span>
    <span class="n">generalize</span> <span class="n">he₂</span> <span class="o">:</span> <span class="n">G.next_edge</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">e₂</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e₁</span> <span class="k">with</span> <span class="n">e₁</span> <span class="n">heu₁</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e₂</span> <span class="k">with</span> <span class="n">e₂</span> <span class="n">heu₂</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">heu₁</span> <span class="k">with</span> <span class="n">heu₁_edge</span> <span class="n">heu₁_adj</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">heu₂</span> <span class="k">with</span> <span class="n">heu₂_edge</span> <span class="n">heu₂_adj</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">heu₁_adj</span> <span class="n">heu₂_adj</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">e_is</span> <span class="o">:</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u₁</span><span class="o">,</span> <span class="n">u₂</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">induction</span> <span class="n">e₁</span> <span class="n">using</span> <span class="n">quotient.ind</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">e₁</span> <span class="k">with</span> <span class="n">v₁</span> <span class="n">w₁</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">sym2.mem_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">heu₁_adj</span> <span class="n">heu₂_adj</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">heu₁_adj</span><span class="bp">;</span>
      <span class="n">obtain</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">heu₂_adj</span><span class="bp">;</span>
      <span class="n">try</span> <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hne</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">}</span><span class="bp">;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">subst</span> <span class="n">e₁</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">is_rootward_antisymm</span> <span class="n">h</span> <span class="n">root</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">heu₂_edge</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">G.next_edge_mem_edges</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₁</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="n">erw</span> <span class="n">he₁</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">G.symm</span> <span class="n">heu₂_edge</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">G.next_edge_mem_edges</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h₂</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="n">erw</span> <span class="n">he₂</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">fsurj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">e</span> <span class="n">using</span> <span class="n">quotient.ind</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">u₁</span> <span class="n">u₂</span><span class="o">,</span>
    <span class="n">wlog</span> <span class="o">:=</span> <span class="n">is_rootward_or_reverse</span> <span class="n">h</span> <span class="n">root</span> <span class="n">he</span> <span class="n">using</span> <span class="o">[</span><span class="n">u₁</span> <span class="n">u₂</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">u₁</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_rootward</span><span class="o">]</span> <span class="n">at</span> <span class="n">case</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">nonempty_path_not_loop</span> <span class="n">_</span> <span class="n">case.2</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">case</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
      <span class="n">erw</span> <span class="n">eq_next_edge_if_mem_path</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">he</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">case_right</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">G.symm</span> <span class="n">he</span><span class="o">),</span>
    <span class="n">use</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">,</span> <span class="n">sym2.eq_swap</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">card_of_bijective</span> <span class="o">⟨</span><span class="n">finj</span><span class="o">,</span> <span class="n">fsurj</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="259431141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259431141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259431141">(Oct 28 2021 at 18:22)</a>:</h4>
<p>Now that <code>next_edge</code> exists, it would probably be better to redefine <code>next_edge</code> and <code>is_rootward</code> so there's less of an impedance mismatch. Too much of the proof seems to be moving data around to put things into or out of a form that works for the definition of <code>is_rootward</code>.</p>



<a name="259432018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259432018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259432018">(Oct 28 2021 at 18:29)</a>:</h4>
<p>(This part of the branch is much more experimental -- I'd wanted to see whether there was already enough stuff to be able to come up with <em>some</em> definition for <code>is_rootward</code> that satisfied lemmas <code>is_rootward_antisymm</code> and <code>is_rootward_or_reverse</code>.)</p>



<a name="259433075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259433075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259433075">(Oct 28 2021 at 18:36)</a>:</h4>
<p>Another way this argument could have been organized is to define two functions <code>parent child : G.edge_set -&gt; V</code> when given a root.  These functions give the structure of the rooted tree, and <code>e = ⟦(parent e, child e)⟧</code> for all e (modulo coercions).  Then you'd show that <code>child</code> is injective, and its image is the set of non-root vertices.  Taking cardinalities, you get the result.</p>



<a name="259449527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259449527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259449527">(Oct 28 2021 at 20:45)</a>:</h4>
<p>Hm, I got stuck on that part. I was able to build a circuit but I'm not seeing how I can prove that the graph is not acyclic</p>



<a name="259450869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259450869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259450869">(Oct 28 2021 at 20:57)</a>:</h4>
<p>Maybe the proof of <code>is_rootward_or_reverse</code> might have some hint.  <code>walk.to_path</code> is a way to turn a walk into a path, so that's a way to get a cycle from a circuit.</p>



<a name="259454009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259454009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259454009">(Oct 28 2021 at 21:22)</a>:</h4>
<p>I got the cycle but I don't know how to say "here's the cycle, G is not acyclic"</p>



<a name="259454222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259454222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259454222">(Oct 28 2021 at 21:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">has_cycle</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">G.is_acyclic</span><span class="o">,</span>
<span class="k">let</span> <span class="n">cycle</span> <span class="o">:=</span> <span class="o">(</span><span class="n">walk.to_path</span> <span class="n">circuit</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u₁</span> <span class="n">u₁</span><span class="o">),</span>
</code></pre></div>



<a name="259454535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259454535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259454535">(Oct 28 2021 at 21:28)</a>:</h4>
<p>Oh, I led you down a bad path, sorry.  That defines the empty path -- <code>walk.to_path</code> will delete everything since there's only one path from a vertex to itself.</p>



<a name="259454739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259454739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259454739">(Oct 28 2021 at 21:30)</a>:</h4>
<p>It might be easier applying <code>lemma is_acyclic_iff : G.is_acyclic ↔ ∀ (v w : V) (p q : G.path v w), p = q</code>.  If you <code>intro</code> your goal, you get a <code>G.is_acyclic</code> hypothesis, which you can rw with this lemma.</p>



<a name="259454775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259454775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259454775">(Oct 28 2021 at 21:31)</a>:</h4>
<p>Then you can <code>specialize</code> it to the two paths you built your circuit from.  I'm not sure if this is the best way, but you should be able to get that either u1 or u2 is equal to root, which is a contradiction.</p>



<a name="259466247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259466247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259466247">(Oct 28 2021 at 23:37)</a>:</h4>
<p>I'm not being able to break down <code>g</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">u₁_root_u₂</span><span class="o">:</span> <span class="n">G.walk</span> <span class="n">u₁</span> <span class="n">u₂</span> <span class="o">:=</span> <span class="bp">↑</span><span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">u₁</span> <span class="n">root</span><span class="o">)</span><span class="bp">.</span><span class="n">append</span> <span class="bp">↑</span><span class="o">(</span><span class="n">G.tree_path</span> <span class="n">h</span> <span class="n">u₂</span> <span class="n">root</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse</span>
<span class="n">u₁_u₂</span><span class="o">:</span> <span class="n">G.path</span> <span class="o">(</span><span class="n">u₁</span><span class="o">,</span> <span class="n">u₂</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span> <span class="o">(</span><span class="n">u₁</span><span class="o">,</span> <span class="n">u₂</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:=</span> <span class="n">path.singleton</span> <span class="n">e_prop</span>
<span class="n">u₂_u₁</span><span class="o">:</span> <span class="n">G.path</span> <span class="n">u₂</span> <span class="n">u₁</span>
<span class="n">circuit</span><span class="o">:</span> <span class="n">G.walk</span> <span class="n">u₁</span> <span class="n">u₁</span> <span class="o">:=</span> <span class="n">u₁_root_u₂.append</span> <span class="bp">↑</span><span class="n">u₂_u₁</span>
<span class="n">g</span><span class="o">:</span> <span class="n">u₁_root_u₂.to_path</span> <span class="bp">=</span> <span class="n">u₁_u₂</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="259466661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259466661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259466661">(Oct 28 2021 at 23:42)</a>:</h4>
<p>This is so close!</p>



<a name="259470404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259470404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259470404">(Oct 29 2021 at 00:34)</a>:</h4>
<p>Okay I need another cue <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> <br>
after this one I'm gonna go to the very basics. I'm sure I will understand a lot more</p>



<a name="259519854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259519854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259519854">(Oct 29 2021 at 12:57)</a>:</h4>
<p>Ah, I actually found an issue with my plan. Because of the way circuits are defined, a circuit can be something like <code>u -&gt; v -&gt; w -&gt; v -&gt; u</code></p>



<a name="259519880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259519880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259519880">(Oct 29 2021 at 12:57)</a>:</h4>
<p>Which doesn't even contain a cycle</p>



<a name="259520348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259520348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259520348">(Oct 29 2021 at 13:01)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> feel free to hit the merge button if you think everything is okay:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/9993/files">https://github.com/leanprover-community/mathlib/pull/9993/files</a></p>



<a name="259520370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259520370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259520370">(Oct 29 2021 at 13:01)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> feel free to hit the merge button if you think everything is okay:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/9993/files">https://github.com/leanprover-community/mathlib/pull/9993/files</a></p>



<a name="259551644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259551644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259551644">(Oct 29 2021 at 16:43)</a>:</h4>
<p>There's something strange about our branches. A lot of things break when I merge <code>master</code> into them <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="259552150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259552150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259552150">(Oct 29 2021 at 16:48)</a>:</h4>
<p>What kind of stuff? Some of it might might my fault.</p>



<a name="259552427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259552427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259552427">(Oct 29 2021 at 16:50)</a>:</h4>
<p>Hm, we can go slowly. First, <code>simple_graph/adj_matrix</code> is not working on <code>more_on_trees</code></p>



<a name="259553453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259553453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259553453">(Oct 29 2021 at 16:58)</a>:</h4>
<p>It doesn't work on <code>walks_and_trees</code> either. But this PR (<code>walks_and_trees</code> into <code>master</code>) is open and without broken tests:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/8737">https://github.com/leanprover-community/mathlib/pull/8737</a></p>



<a name="259553797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259553797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259553797">(Oct 29 2021 at 17:00)</a>:</h4>
<p><code>more_on_trees</code> contains fixes for <code>walks_and_trees</code>. So if we can get <code>more_on_trees</code> it to work, <a href="https://github.com/leanprover-community/mathlib/pull/9993">this PR</a> will fix <code>walks_and_trees</code></p>



<a name="259553890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259553890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259553890">(Oct 29 2021 at 17:01)</a>:</h4>
<p>Long story short, can you help me fix <code>more_on_walks</code>? <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="259553910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259553910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259553910">(Oct 29 2021 at 17:01)</a>:</h4>
<p>Let's have a look!</p>



<a name="259553978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259553978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259553978">(Oct 29 2021 at 17:01)</a>:</h4>
<p>Wait 10-15min, I'm onto something else right now.</p>



<a name="259554354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259554354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259554354">(Oct 29 2021 at 17:05)</a>:</h4>
<p>Np, I'm investigating these merges a little further</p>



<a name="259555150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259555150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259555150">(Oct 29 2021 at 17:11)</a>:</h4>
<p>2 months ago <a href="https://github.com/leanprover-community/mathlib/blame/walks_and_trees/src/combinatorics/simple_graph/adj_matrix.lean#L315">this line</a> was added. but nowadays, <code>R</code> cannot be found anymore</p>



<a name="259555470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259555470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259555470">(Oct 29 2021 at 17:14)</a>:</h4>
<p>Back then, <a href="https://github.com/leanprover-community/mathlib/blob/798b240b2e09a308b5f661fffcb16c7cf3edbc32/src/combinatorics/simple_graph/adj_matrix.lean#L28">this was the line</a> that introduced <code>R</code> (a <code>semiring</code>)</p>



<a name="259556020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259556020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259556020">(Oct 29 2021 at 17:18)</a>:</h4>
<p>Don't worry too much, this happens all the time. You write something, then someone comes along and changes the <code>variables</code> and bem your branch broke.</p>



<a name="259556092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259556092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259556092">(Oct 29 2021 at 17:19)</a>:</h4>
<p>But... how come can they merge something if their changes break other parts of the code?</p>



<a name="259556105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259556105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259556105">(Oct 29 2021 at 17:19)</a>:</h4>
<p>Shouldn't the build test fail?</p>



<a name="259556339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259556339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259556339">(Oct 29 2021 at 17:21)</a>:</h4>
<p>CI ensures that <code>master</code> branch still compiles. It doesn't care about other branches.</p>



<a name="259556520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259556520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259556520">(Oct 29 2021 at 17:22)</a>:</h4>
<p>So, if you work on a feature in a branch and merge master, then quite possibly your code will break.</p>



<a name="259556559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259556559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259556559">(Oct 29 2021 at 17:23)</a>:</h4>
<p>Ah, so it's really a matter of other branches becoming old/deprecated with time</p>



<a name="259560132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259560132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259560132">(Oct 29 2021 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span>, did you push all your changes? I can try to bump now.</p>



<a name="259560291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259560291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259560291">(Oct 29 2021 at 17:51)</a>:</h4>
<p>Yeap, <code>more_on_trees</code> is up to date on GitHub too</p>



<a name="259560434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259560434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259560434">(Oct 29 2021 at 17:52)</a>:</h4>
<p>after those fixes on <code>adj_matrix.lean</code> I'm gonna try to merge <code>master</code> into it</p>



<a name="259560540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259560540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259560540">(Oct 29 2021 at 17:53)</a>:</h4>
<p>I'm doing that now.</p>



<a name="259560576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259560576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259560576">(Oct 29 2021 at 17:53)</a>:</h4>
<p>Thanks!</p>



<a name="259561081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259561081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259561081">(Oct 29 2021 at 17:57)</a>:</h4>
<p>If the way the PR to another branch works is that it does a squash merge, won't that make it very difficult to see what Arthur's changes were? Maybe the destination branch should be updated to master, too?</p>



<a name="259561275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259561275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259561275">(Oct 29 2021 at 17:58)</a>:</h4>
<p>Yeah, the best thing would have been to fix those problems while in <code>walks_and_trees</code></p>



<a name="259561831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259561831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259561831">(Oct 29 2021 at 18:00)</a>:</h4>
<p>There's the "blame" visualization mode on GitHub. We can use that if we want to see who did what</p>



<a name="259561899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259561899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259561899">(Oct 29 2021 at 18:01)</a>:</h4>
<p>Since it's a squash, I think everything that changes from merging master will be blamed on you, Arthur</p>



<a name="259562072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562072">(Oct 29 2021 at 18:02)</a>:</h4>
<p>Oh, you mean on master</p>



<a name="259562157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562157">(Oct 29 2021 at 18:02)</a>:</h4>
<p>On master it's gonna be blamed on you because I opened a PR into your branch</p>



<a name="259562209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562209">(Oct 29 2021 at 18:03)</a>:</h4>
<p>I mean on <code>walks_and_trees</code>. I like having somewhat nice commit histories on branches so that I can track what's changed while working.</p>



<a name="259562399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562399">(Oct 29 2021 at 18:04)</a>:</h4>
<p>If your PR is what updates <code>walks_and_trees</code> to master, then there will be this massive commit that mixes what you did with everything that's happened to mathlib, and it will list you as the author.  (This doesn't matter for the history of <code>master</code>, since it will all be squashed again.)</p>



<a name="259562501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562501">(Oct 29 2021 at 18:05)</a>:</h4>
<p>Makes sense. I should have started doing those fixes on <code>walks_and_trees</code></p>



<a name="259562531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562531">(Oct 29 2021 at 18:05)</a>:</h4>
<p>I suspect all that needs to be done is to make sure to merge <code>master</code> on <code>walks_and_trees</code>, then merge <code>walks_and_trees</code> into <code>more_on_trees</code>, and then when the PR is merged, things will be OK.</p>



<a name="259562621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562621">(Oct 29 2021 at 18:06)</a>:</h4>
<p>I can cherry pick changes from Yael and make small pushes on your branch if he's already started the merging process</p>



<a name="259562753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562753">(Oct 29 2021 at 18:07)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> have you?</p>



<a name="259562759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562759">(Oct 29 2021 at 18:07)</a>:</h4>
<p>I don't think you need to do that -- this merging plan should be sufficient, and it shouldn't create any conflicts.</p>



<a name="259562799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562799">(Oct 29 2021 at 18:07)</a>:</h4>
<p>I'm doing exactly what Kyle just described.</p>



<a name="259562874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259562874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259562874">(Oct 29 2021 at 18:08)</a>:</h4>
<p>Perfect</p>



<a name="259563428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259563428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259563428">(Oct 29 2021 at 18:12)</a>:</h4>
<p>Next time I do fixes, I'm gonna do on the branch I branched out from and then merge it into mine afterwards</p>



<a name="259564191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259564191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259564191">(Oct 29 2021 at 18:19)</a>:</h4>
<p>Perhaps a surprising thing about git is that every commit is actually a complete snapshot of the entire repository (along with pointers to the commits it's based on).  All the diffs you see in the UI are just computed on the fly from these complete snapshots.  I'm just trying to make sure there's a commit on <code>walks_and_trees</code> that already has a post-merge-<code>master</code> state so that when <code>more_on_trees</code> is merged, the diff that git computes will make more sense.</p>



<a name="259564515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259564515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259564515">(Oct 29 2021 at 18:22)</a>:</h4>
<p>I've fixed <code>connectivity</code> and <code>adj_matrix</code>. Is there any file file you noticed that was broken?</p>



<a name="259565026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565026">(Oct 29 2021 at 18:27)</a>:</h4>
<p>All fixed!</p>



<a name="259565169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565169">(Oct 29 2021 at 18:28)</a>:</h4>
<p>You really threaded the needle there with all of your comma removal, somehow avoiding a merge conflict. <span aria-label="clap" class="emoji emoji-1f44f" role="img" title="clap">:clap:</span></p>



<a name="259565363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565363">(Oct 29 2021 at 18:30)</a>:</h4>
<p>Do you know why <code>adj_matrix_pow_apply_eq_card_walk</code> needs <code>semiring</code> now?</p>



<a name="259565405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565405">(Oct 29 2021 at 18:30)</a>:</h4>
<p>Yeah, I was expecting some horrendous thing going on!</p>



<a name="259565422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565422">(Oct 29 2021 at 18:30)</a>:</h4>
<p>What did it need before?</p>



<a name="259565482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565482">(Oct 29 2021 at 18:30)</a>:</h4>
<p>I suspect that what happened is that a <code>variables [semiring R]</code> got removed.</p>



<a name="259565501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259565501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259565501">(Oct 29 2021 at 18:31)</a>:</h4>
<p>Oh right, <code>adj_matrix</code> was generalized to <code>def adj_matrix [has_zero α] [has_one α]</code></p>



<a name="259566333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259566333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259566333">(Oct 29 2021 at 18:38)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> for getting this to happen</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_tree.card_edges_eq_card_vertices_sub_one</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">G.edge_set</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">G.edge_set</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span>
</code></pre></div>



<a name="259567210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259567210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259567210">(Oct 29 2021 at 18:44)</a>:</h4>
<p>I kicked it off, but you were the one actually paving the way :D</p>



<a name="259567305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259567305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259567305">(Oct 29 2021 at 18:45)</a>:</h4>
<p>Thanks a lot Yaël for the merges!</p>



<a name="259567428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259567428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259567428">(Oct 29 2021 at 18:46)</a>:</h4>
<p>Hopefully eventually we'll have the matrix-tree theorem, too, which at its core relates any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)\times(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> minor of the Laplacian matrix to the set of all tree-like functions <code>f : {v | v ≠ root} → G.edge_set</code>.</p>



<a name="259568160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568160">(Oct 29 2021 at 18:52)</a>:</h4>
<p>This sounds like it should say</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_tree.card_edges</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.edge_finset.card</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
</code></pre></div>



<a name="259568206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568206">(Oct 29 2021 at 18:53)</a>:</h4>
<p><code>[fintype G.edge_set]</code> should come from <code>[fintype V]</code> and <code>[nonempty V]</code> is useless.</p>



<a name="259568474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568474">(Oct 29 2021 at 18:55)</a>:</h4>
<p>I sort of want to abolish <code>G.edge_finset</code> since it's just <code>G.edge_set.to_finset</code>.</p>
<p>The reason <code>[fintype G.edge_set]</code> is there is because, while it is derived from <code>[fintype V]</code>, it's better to have it take an arbitrary proof of finiteness rather than requiring it to take the one derived from <code>[fintype V]</code>.</p>



<a name="259568543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568543">(Oct 29 2021 at 18:56)</a>:</h4>
<p>Ah yeah because it shows up in the statement.</p>



<a name="259568562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568562">(Oct 29 2021 at 18:56)</a>:</h4>
<p>It's true that <code>nonempty V</code> is not necessary because of truncating subtraction.</p>



<a name="259568569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568569">(Oct 29 2021 at 18:56)</a>:</h4>
<p>I strongly disagree to removing <code>edge_finset</code>. It's very useful but I think it could be redefined.</p>



<a name="259568775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568775">(Oct 29 2021 at 18:58)</a>:</h4>
<p>It's actually just a matter of changing<code>.to_finset</code> with <code>univ.filter</code> becaus you assume a fintype anyway.</p>



<a name="259568845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259568845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259568845">(Oct 29 2021 at 18:59)</a>:</h4>
<p><code>edge_finset</code> definitely should be redefined -- right now it requires <code>[fintype V]</code> which is very restrictive.  The definition is using the instance that says <code>[fintype G.edge_set]</code> from <code>[fintype V]</code>.</p>



<a name="259569170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569170">(Oct 29 2021 at 19:01)</a>:</h4>
<p>This line requires <code>[nonempty V]</code>, doesn't it?<br>
<code>have root := classical.arbitrary V,</code></p>



<a name="259569173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569173">(Oct 29 2021 at 19:02)</a>:</h4>
<p>In SRL, we talk a lot about <code>edge_finset</code> (even if to be fair it's hidden under one definition so never actually see it).</p>



<a name="259569313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569313">(Oct 29 2021 at 19:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259569170">said</a>:</p>
<blockquote>
<p>This line requires <code>[nonempty V]</code>, doesn't it?<br>
<code>have root := classical.arbitrary V,</code></p>
</blockquote>
<p>My point is that the final statement doesn't require it. so you can case-split on <code>is_empty V</code>/<code>nonempty V</code>, prove the trivial stuff in the first case, and go on with your existing proof in the second case.</p>



<a name="259569364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569364">(Oct 29 2021 at 19:03)</a>:</h4>
<p>And for SRGs, Alena definitely needed <code>edge_finset</code>.</p>



<a name="259569425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569425">(Oct 29 2021 at 19:04)</a>:</h4>
<p>I think the reason <code>edge_finset</code> exists is that we didn't realize we could write <code>G.edge_set.to_finset</code>, judging by its definition.  It also makes summations over the edge set look nicer, but it's mostly cosmetic.</p>



<a name="259569539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569539">(Oct 29 2021 at 19:04)</a>:</h4>
<p>Maybe we can change the assumptions to <code>[fintype (G.neighbors_set u)] [fintype (G.neighbors_set v)]</code>?</p>



<a name="259569643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569643">(Oct 29 2021 at 19:05)</a>:</h4>
<p>Here's a question: is the empty graph a tree? Right now the definition allows empty graphs to be trees, but that doesn't seem right.</p>



<a name="259569709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569709">(Oct 29 2021 at 19:06)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> A good exercise would be to remove the <code>[nonempty V]</code> assumption, if you want to do that.</p>



<a name="259569834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259569834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259569834">(Oct 29 2021 at 19:07)</a>:</h4>
<p>Sure I'm gonna try it</p>



<a name="259570019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259570019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259570019">(Oct 29 2021 at 19:09)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_empty_or_nonempty">docs#is_empty_or_nonempty</a></p>



<a name="259570200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259570200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259570200">(Oct 29 2021 at 19:10)</a>:</h4>
<p>Is there thing akin to <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.nontriviality">docs#tactic.nontriviality</a> which would automatically perform the cache update and the goal discharge?</p>



<a name="259570202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259570202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259570202">(Oct 29 2021 at 19:10)</a>:</h4>
<p>You'll also have to figure out how to show the cardinality of the edge set is 0 if <code>V</code> is empty.  Maybe write that as a separate lemma, like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">simple_graph.edge_set_empty_of_empty</span> <span class="o">[</span><span class="n">is_empty</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">G.edge_set.nonempty</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="259570680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259570680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259570680">(Oct 29 2021 at 19:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259570200">said</a>:</p>
<blockquote>
<p>Is there thing akin to <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.nontriviality">docs#tactic.nontriviality</a> which would automatically perform the cache update and the goal discharge?</p>
</blockquote>
<p>Do you mean this one? <a href="https://leanprover-community.github.io/mathlib_docs/logic/nontrivial.html#tactic.interactive.nontriviality">https://leanprover-community.github.io/mathlib_docs/logic/nontrivial.html#tactic.interactive.nontriviality</a></p>



<a name="259570684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259570684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259570684">(Oct 29 2021 at 19:14)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  I think <code>casesI</code> would work?</p>



<a name="259571191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259571191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259571191">(Oct 29 2021 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> do you agree with this name change?</p>
<blockquote>
<p>This sounds like it should say</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_tree.card_edges</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.is_tree</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.edge_finset.card</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
</code></pre></div>



<a name="259571381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259571381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259571381">(Oct 29 2021 at 19:20)</a>:</h4>
<p>To me it sounds more like the name of a function that would return the cardinality of the set of edges of a tree <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> <br>
But of course, my experience in this subject is super short</p>



<a name="259571543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259571543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259571543">(Oct 29 2021 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259569643">said</a>:</p>
<blockquote>
<p>Here's a question: is the empty graph a tree? Right now the definition allows empty graphs to be trees, but that doesn't seem right.</p>
</blockquote>
<p>Of course this is debatable, but typically <a href="https://ncatlab.org/nlab/show/empty+space">empty sets are not connected</a>. For the graph case, this means the empty graph is not a tree (but it is a forest with zero trees, of course).</p>



<a name="259572128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259572128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259572128">(Oct 29 2021 at 19:27)</a>:</h4>
<p>Within my (shallow) understanding, making use of a subtraction that truncates at zero to prove such lemma for empty trees sounds a bit hacky. Because, semantically, the right side of the equality (<code>n - 1</code>) doesn't make sense to me</p>



<a name="259573196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259573196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259573196">(Oct 29 2021 at 19:36)</a>:</h4>
<p>Unless, of course, we have a reason (besides pure generality) to make it true for empty trees as well</p>



<a name="259573858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259573858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259573858">(Oct 29 2021 at 19:42)</a>:</h4>
<p><code>is_tree.card_edge_finset</code> would be a better name than <code>is_tree.card_edges</code>.  I agree removing the <code>nonempty V</code> assumption is hacky, but if it's only a few extra lines in the proof it's nice when you can eliminate assumptions.</p>



<a name="259573970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259573970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259573970">(Oct 29 2021 at 19:43)</a>:</h4>
<p>It also might not be a hack if <code>G.is_tree</code> comes with the fact that <code>V</code> is nonempty, for instance by modifying <code>G.is_connected</code> to include this hypothesis.</p>



<a name="259574608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259574608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259574608">(Oct 29 2021 at 19:49)</a>:</h4>
<p>Okay that makes sense to me. I'm gonna try and see if I can do it</p>



<a name="259710140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259710140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259710140">(Oct 30 2021 at 04:36)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  It took longer than I expected, but I got it to work!<br>
<a href="https://github.com/leanprover-community/mathlib/pull/10053">https://github.com/leanprover-community/mathlib/pull/10053</a></p>



<a name="259710419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259710419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259710419">(Oct 30 2021 at 04:44)</a>:</h4>
<p>Also <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> <span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span></p>



<a name="259725394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259725394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259725394">(Oct 30 2021 at 11:21)</a>:</h4>
<p>Hey <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>, after your proposed changes this was the only proof I couldn't adjust:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_tree_iff</span> <span class="o">:</span> <span class="n">G.is_tree</span> <span class="bp">↔</span> <span class="n">nonempty</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="bp">∃!</span><span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">p.is_path</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_tree</span><span class="o">,</span> <span class="n">is_acyclic_iff</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hc</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hne</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">hne</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hc</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">some.to_path</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">path.path_is_path</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hu</span> <span class="n">v</span> <span class="n">w</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">hu</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hne</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">hne</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">p</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">v</span> <span class="n">w</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">q</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">hq</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">h</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259725450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259725450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259725450">(Oct 30 2021 at 11:22)</a>:</h4>
<p>It's failing to apply the very first <code>simp</code></p>



<a name="259726267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259726267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259726267">(Oct 30 2021 at 11:42)</a>:</h4>
<p>the issue is that is_tree is now a structure, so it's not definitionally equal to the ands from before</p>



<a name="259726425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259726425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259726425">(Oct 30 2021 at 11:47)</a>:</h4>
<p>here's a working version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_tree_iff</span> <span class="o">:</span> <span class="n">G.is_tree</span> <span class="bp">↔</span> <span class="n">nonempty</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="bp">∃!</span><span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">p.is_path</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hc</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hne</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">is_acyclic_iff</span> <span class="n">at</span> <span class="n">hu</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">hne</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hc</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">some.to_path</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_and</span><span class="o">,</span> <span class="n">path.path_is_path</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hu</span> <span class="n">v</span> <span class="n">w</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">hu</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hne</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">hne</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">p</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">is_acyclic_iff</span><span class="o">,</span>
      <span class="n">rintros</span> <span class="n">v</span> <span class="n">w</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">q</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">hq</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">h</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>note that I changed the <code>use/intros</code> into a <code>refine</code>, which is a very nice tactic. it's also strictly stronger than <code>split</code>! (although annoyingly, it gets confused when you try to do a <code>rintro</code> in it... so for example <code>refine ⟨λ ⟨hc, hu, hne⟩, _, λ ⟨hne, h⟩, _⟩</code> doesn't work, but if it did it'd be the sameas the <code>split</code> and the two <code>rintro</code>s you do after</p>



<a name="259726581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259726581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259726581">(Oct 30 2021 at 11:50)</a>:</h4>
<p>Thank you very much!</p>



<a name="259726657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259726657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259726657">(Oct 30 2021 at 11:52)</a>:</h4>
<p>Another thing... <a href="https://github.com/leanprover-community/mathlib/runs/4053485713?check_suite_focus=true">The lint tests are failing</a>. I tried to fix those but I couldn't figure it out.</p>



<a name="259727306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259727306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259727306">(Oct 30 2021 at 12:06)</a>:</h4>
<p>don't worry about them, they're not in your part of the code</p>



<a name="259727347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259727347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259727347">(Oct 30 2021 at 12:07)</a>:</h4>
<p>also, I know you've put in all this work on this, but it may be worth keeping the "weaker" empty option available (as mathematically boring as it is); I think this is common in mathlib, with things like <a href="https://leanprover-community.github.io/mathlib_docs/find/is_preconnected">docs#is_preconnected</a> (so maybe <code>is_pretree</code>?) because a lot of results end up holding for the weaker class anyways</p>



<a name="259741467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259741467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259741467">(Oct 30 2021 at 17:14)</a>:</h4>
<p>Hm, I'd rather leave it for later decisions since we're not sure whether we need that generalization starting from a definition of "preconnectedness" in the context of graphs</p>



<a name="259741806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259741806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259741806">(Oct 30 2021 at 17:23)</a>:</h4>
<p>I'd say time will tell. Let's see how the need evolves</p>



<a name="259742273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259742273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259742273">(Oct 30 2021 at 17:34)</a>:</h4>
<p>Plus I'm not so sure how I'd go about that generalization with the definition of "pretrees". I gave it a little go and I ended up having to redefine a lot of things in terms of "pretree", like <code>pretree_path</code> and <code>pretree_dist</code>, which seemed very odd to me <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="259798153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259798153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259798153">(Oct 31 2021 at 17:15)</a>:</h4>
<p>What if we just allow empty trees and add the nonempty restrictions on lemmas that require such? In other words, simply ignore my most recent PR?</p>



<a name="259812783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259812783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259812783">(Oct 31 2021 at 22:53)</a>:</h4>
<p>I think the idea of letting "pre-trees" be forests such that there's a path between any two vertices is fine, and then just define a tree to be a nonempty pretree.</p>



<a name="259812798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259812798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259812798">(Oct 31 2021 at 22:53)</a>:</h4>
<p>there are a bunch of standard theorems about primes which are true for preprimes (i.e. primes and 1), e.g. p divides ab implies p divides a or p divides b</p>



<a name="259813330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259813330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259813330">(Oct 31 2021 at 23:04)</a>:</h4>
<p>Right now, a forest is just an acyclic graph (and it has no definition of its own since <code>G.is_acyclic</code> exists), and a tree is a connected acyclic graph.  The definition of <code>G.is_connected</code> is that there's a walk between every pair of vertices.  If anything, it should be <code>G.is_connected</code> that should require that there be at least one vertex.</p>
<p>The way this probably should work is the definition of connected be changed to "there exists a vertex v such that for every vertex w there is a walk from v to w."</p>



<a name="259813365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259813365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259813365">(Oct 31 2021 at 23:05)</a>:</h4>
<p>This is the same as saying that the quotient of <code>V</code> by the <code>G.walk</code> relation is a singleton.</p>



<a name="259813992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259813992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259813992">(Oct 31 2021 at 23:21)</a>:</h4>
<p>But then how would we structure it? Have the definition of trees that requires connectivity and define a forest as an union of trees?</p>



<a name="259814078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259814078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259814078">(Oct 31 2021 at 23:23)</a>:</h4>
<p>I'm suggesting that the definition of connectivity be changed, and leave <code>is_tree</code> alone.  A forest is just an acyclic graph, so there's nothing to change there.</p>



<a name="259814147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259814147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259814147">(Oct 31 2021 at 23:25)</a>:</h4>
<p>Unfortunately, this makes the different theorems for what <code>G.is_tree</code> is equivalent to to be more awkward, but maybe they don't have to be equivalences.</p>



<a name="259814217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259814217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259814217">(Oct 31 2021 at 23:27)</a>:</h4>
<p>Today I merged master into <code>walks_and_trees</code> again and solved some lint errors</p>



<a name="259819290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259819290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259819290">(Nov 01 2021 at 01:39)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Is this what you mean?<br>
<a href="https://github.com/leanprover-community/mathlib/pull/10082">https://github.com/leanprover-community/mathlib/pull/10082</a></p>



<a name="259819355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259819355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259819355">(Nov 01 2021 at 01:41)</a>:</h4>
<p>Line 1244 is not working and I don't know how to proceed there. Probably related to what you've said about dropping the equivalence</p>



<a name="259819397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259819397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259819397">(Nov 01 2021 at 01:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259813330">said</a>:</p>
<blockquote>
<p>The way this probably should work is the definition of connected be changed to "there exists a vertex v such that for every vertex w there is a walk from v to w."</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">connected</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.reachable</span> <span class="n">u</span> <span class="n">v</span>
</code></pre></div>



<a name="259819467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259819467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259819467">(Nov 01 2021 at 01:45)</a>:</h4>
<p>and then something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">connected_iff_nonempty_and_pairwise_reachable</span> <span class="o">:</span>
  <span class="n">G.connected</span> <span class="bp">↔</span> <span class="n">nonempty</span> <span class="n">V</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.reachable</span> <span class="n">u</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259819672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259819672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259819672">(Nov 01 2021 at 01:50)</a>:</h4>
<p>I haven't given much thought to the effects of this, though.  The <code>nonempty V ∧ ∀ (u v : V), G.reachable u v</code> definition is potentially nicer (note that in the definition you gave, <code>nonempty V</code> is inside the forall).</p>



<a name="259820782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259820782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259820782">(Nov 01 2021 at 02:16)</a>:</h4>
<p>Oops, I better remove it from the forall.</p>



<a name="259821449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259821449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259821449">(Nov 01 2021 at 02:36)</a>:</h4>
<p>The definition I gave is more "symmetrical", I think</p>



<a name="259821452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259821452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259821452">(Nov 01 2021 at 02:36)</a>:</h4>
<p>And it changes less things</p>



<a name="259822168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259822168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259822168">(Nov 01 2021 at 02:59)</a>:</h4>
<p>Okay, I got some progress there</p>



<a name="259828364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259828364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259828364">(Nov 01 2021 at 05:25)</a>:</h4>
<p>I think we already have at least 2 or 3 pairs of definitions <code>is_preconnected</code> and <code>is_connected</code> in mathlib, where <code>is_connected</code> is just <code>is_preconnected + nonempty</code>. You should do that too!</p>



<a name="259855551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259855551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259855551">(Nov 01 2021 at 12:05)</a>:</h4>
<p>Got the definition of <code>preconnected</code> in <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> <br>
<span class="user-mention" data-user-id="306601">@Kyle Miller</span> I wasn't able to prove <code>connected_of_edge_connected</code> but everything else is working. Feel free to take over branch <code>change-connectivity-def</code> before accepting <a href="https://github.com/leanprover-community/mathlib/pull/10082">this PR</a> (which merges <code>change-connectivity-def</code> into yours)</p>



<a name="259856971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259856971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259856971">(Nov 01 2021 at 12:22)</a>:</h4>
<p>And I'm closing <a href="https://github.com/leanprover-community/mathlib/pull/10053">this PR</a> since we're going for the change of definition of <code>connected</code> instead</p>



<a name="259908071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908071">(Nov 01 2021 at 19:20)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I've updated <a href="https://github.com/leanprover-community/mathlib/pull/10082">https://github.com/leanprover-community/mathlib/pull/10082</a> with your ideas but I couldn't make <code>connected_of_edge_connected</code> work</p>



<a name="259908111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908111">(Nov 01 2021 at 19:21)</a>:</h4>
<p>(the proof is written in a way that I can't understand at the moment)</p>



<a name="259908314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908314">(Nov 01 2021 at 19:22)</a>:</h4>
<p>Do you remember what the definition of <code>connected</code> used to be before?</p>



<a name="259908398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908398">(Nov 01 2021 at 19:23)</a>:</h4>
<p>Yeah</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">connected</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.reachable</span> <span class="n">u</span> <span class="n">v</span>
</code></pre></div>



<a name="259908493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908493">(Nov 01 2021 at 19:24)</a>:</h4>
<p>It was an <code>and</code>. So I used <code>and.imp_right</code>, since <code>connected</code> was <code>preconnected AND nontrivial V</code> and <code>edge_connected _ _ _ _</code> was <code>connected _</code> , which was <code>_ AND nontrivial V</code>. So the right hand side of the assumption implies the right hand side of the goal. That's the <code>and.imp_right</code> shortcut.</p>



<a name="259908504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908504">(Nov 01 2021 at 19:24)</a>:</h4>
<p>Not exactly, that's what <code>preconnected</code> is.</p>



<a name="259908533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908533">(Nov 01 2021 at 19:25)</a>:</h4>
<p>Now that <code>connected</code> is a structure, and not a plain <code>and</code> conjunction, you can't use <code>and.elim_right</code> anymore.</p>



<a name="259908986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908986">(Nov 01 2021 at 19:29)</a>:</h4>
<p>With the new definition, here's a place to start:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">connected_of_edge_connected</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.connected</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">preconnected</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">nonempty</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="259908987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259908987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259908987">(Nov 01 2021 at 19:29)</a>:</h4>
<p>I see, but I think it's the writing style (I've very new to Lean). So far I've only been able to understand steps explicitly separated by commas</p>



<a name="259909477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259909477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259909477">(Nov 01 2021 at 19:33)</a>:</h4>
<p>I think the <code>and.imp_right</code> proof might be more obfuscated than just terse, so don't feel bad about not being able to follow it.</p>



<a name="259909778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259909778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259909778">(Nov 01 2021 at 19:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">preconnected</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">reachable</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>leaves me at </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">k</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">hk</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span>
<span class="n">h</span><span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span>
<span class="n">uv</span><span class="o">:</span> <span class="n">V</span>
<span class="bp">⊢</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">k</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">hk</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span>
<span class="n">h</span><span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span>
<span class="bp">⊢</span> <span class="n">nonempty</span> <span class="n">V</span>
</code></pre></div>



<a name="259909851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259909851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259909851">(Nov 01 2021 at 19:37)</a>:</h4>
<p>I'm having a hard time modifying the one-liner, but here's away to modify the original one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">preconnected_of_edge_connected</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.preconnected</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h</span> <span class="bp">∅</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hk</span><span class="o">]))</span><span class="bp">.</span><span class="n">preconnected</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.coe_empty</span><span class="o">,</span> <span class="n">subgraph.delete_edges_of_empty</span><span class="o">]</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">h'.map</span> <span class="o">(</span><span class="n">subgraph.map_spanning_top</span> <span class="n">_</span><span class="o">)⟩,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Have another lemma <code>nonempty_of_edge_connected</code>, then put them together for <code>connected_of_edge_connected</code>.</p>



<a name="259909907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259909907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259909907">(Nov 01 2021 at 19:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">connected_of_edge_connected</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.connected</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">C'</span> <span class="o">:=</span> <span class="n">h</span> <span class="bp">∅</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hk</span><span class="o">])</span> <span class="k">in</span>
<span class="o">{</span> <span class="n">preconnected</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">C'.preconnected</span><span class="o">,</span>
  <span class="n">nonempty</span> <span class="o">:=</span> <span class="n">C'.nonempty</span> <span class="o">}</span>
</code></pre></div>



<a name="259910052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259910052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259910052">(Nov 01 2021 at 19:38)</a>:</h4>
<p>If you want to reuse the old proof. Really, there should be a <code>connected.antimono</code> or however you name it, saying that if a "supergraph" is connected, so is an induced subgraph.</p>



<a name="259910223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259910223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259910223">(Nov 01 2021 at 19:40)</a>:</h4>
<p>The original proof was pretty terse too =), I just followed the style</p>



<a name="259910340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259910340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259910340">(Nov 01 2021 at 19:41)</a>:</h4>
<p>Alright, PR updated. I'm gonna spend a few hours tomorrow figuring out what you guys wrote. But feel free to merge it into <code>walks_and_trees</code> if you see fit <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> <br>
<a href="https://github.com/leanprover-community/mathlib/pull/10082">https://github.com/leanprover-community/mathlib/pull/10082</a></p>
<p>Or, of course, just push commits directly to <code>change-connectivity-def</code></p>



<a name="259910404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259910404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259910404">(Nov 01 2021 at 19:41)</a>:</h4>
<p>Right now I'm having issues extracting the <code>reachable</code> Prop out of the quot. I'm clumsy with that API. If I have the following state, what's the right <code>quot</code> API?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">unique</span> <span class="n">G.connected_component</span>
<span class="n">h</span><span class="o">:</span> <span class="n">nonempty</span> <span class="n">V</span>
<span class="n">v</span><span class="o">:</span> <span class="n">V</span>
<span class="n">w</span><span class="o">:</span> <span class="n">V</span>
<span class="n">this</span><span class="o">:</span> <span class="n">G.connected_component_of</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">G.connected_component_of</span> <span class="n">w</span>
<span class="bp">⊢</span> <span class="n">G.reachable</span> <span class="n">v</span> <span class="n">w</span>
</code></pre></div>



<a name="259910561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259910561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259910561">(Nov 01 2021 at 19:42)</a>:</h4>
<p>(<code>preconnected_of_edge_connected</code> is now unnecessary given Yakov's <code>connected_of_edge_connected</code>)</p>



<a name="259911023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259911023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259911023">(Nov 01 2021 at 19:47)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I'm not sure if you can apply it directly, but <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.eq">docs#quotient.eq</a> should be a way to do something with <code>this</code> given <code>reachable_is_equivalence</code>/<code>reachable_setoid</code></p>



<a name="259911263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259911263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259911263">(Nov 01 2021 at 19:49)</a>:</h4>
<p>Ah, something with <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.exact">docs#quot.exact</a> maybe?</p>



<a name="259911476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259911476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259911476">(Nov 01 2021 at 19:51)</a>:</h4>
<p>The nice thing about the <code>quotient</code> ones (like <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.exact">docs#quotient.exact</a>) is that they give it in terms of the original relation, rather than <code>eqv_gen</code>.  Maybe this is a hole in the <code>quot</code> api? having variants for when you can supply an explicit <code>setoid</code>?</p>



<a name="259911615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259911615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259911615">(Nov 01 2021 at 19:52)</a>:</h4>
<p>Right, but even <code>quotient.*</code> ask for the setoid to be an implicit arg</p>



<a name="259911720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259911720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259911720">(Nov 01 2021 at 19:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">[</span><span class="n">unique</span> <span class="n">G.connected_component</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">(</span><span class="n">this</span><span class="o">:</span> <span class="n">G.connected_component_of</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">G.connected_component_of</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.reachable</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">quotient.exact</span> <span class="n">_</span> <span class="n">G.reachable_setoid</span> <span class="n">_</span> <span class="n">_</span> <span class="n">this</span>
</code></pre></div>



<a name="259911817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259911817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259911817">(Nov 01 2021 at 19:53)</a>:</h4>
<p><code>quotient</code> seems to be designed around having a canonical setoid instance for a given type, but there are times when you want potentially many.</p>



<a name="259912012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259912012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259912012">(Nov 01 2021 at 19:54)</a>:</h4>
<p>It would be nice if there were a <code>quot.exact'</code> or something that explicitly took this <code>setoid</code> instance, and then <code>quotient.exact</code> could be defined in terms of it.</p>



<a name="259912171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259912171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259912171">(Nov 01 2021 at 19:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">equivalence.eqv_gen_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">eqv_gen</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">eqv_gen.rel</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">induction</span> <span class="n">H</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h.left</span> <span class="n">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h.right.left</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h.right.right</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">connected_component_of.reachable_congr</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.connected_component_of</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">G.connected_component_of</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.reachable</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">reachable_is_equivalence</span><span class="o">]</span> <span class="n">using</span> <span class="n">quot.exact</span> <span class="n">_</span> <span class="n">h</span>
</code></pre></div>



<a name="259912202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259912202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259912202">(Nov 01 2021 at 19:56)</a>:</h4>
<p><code>setoid</code> might not be right since it bundles the relation -- rather, if <code>quot.exact'</code> took an <code>equivalence</code> proof.</p>



<a name="259912429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259912429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259912429">(Nov 01 2021 at 19:58)</a>:</h4>
<p>Which gives the following too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">quot.is_empty</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_empty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_empty</span> <span class="o">(</span><span class="n">quot</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">quot.induction_on</span> <span class="n">a</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span><span class="o">,</span> <span class="n">is_empty_elim</span> <span class="n">a'</span><span class="o">)⟩</span>

<span class="kd">instance</span> <span class="n">connected_component.is_empty_of_is_empty</span> <span class="o">[</span><span class="n">is_empty</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_empty</span> <span class="n">G.connected_component</span> <span class="o">:=</span>
<span class="n">quot.is_empty</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">connected_of_unique</span> <span class="o">[</span><span class="n">unique</span> <span class="n">G.connected_component</span><span class="o">]</span> <span class="o">:</span> <span class="n">G.connected</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">casesI</span> <span class="n">is_empty_or_nonempty</span> <span class="n">V</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">is_empty_elim</span> <span class="o">(</span><span class="n">default</span> <span class="n">G.connected_component</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">connected_component_of.reachable_congr</span> <span class="o">(</span><span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">‹</span><span class="n">_</span><span class="o">›⟩</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259913156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259913156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259913156">(Nov 01 2021 at 20:03)</a>:</h4>
<p>If <code>eqv_gen</code> is really the best interface to <code>quot</code> given an equivalence relation, I'd suggest</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">_root_.eqv_gen.of_eqv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">eqv_gen</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="n">induction</span> <span class="n">H</span><span class="o">,</span>
 <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
 <span class="o">{</span> <span class="n">exact</span> <span class="n">h.left</span> <span class="n">_</span> <span class="o">},</span>
 <span class="o">{</span> <span class="n">exact</span> <span class="n">h.right.left</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">},</span>
 <span class="o">{</span> <span class="n">exact</span> <span class="n">h.right.right</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">connected_component_of.reachable_congr</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.connected_component_of</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">G.connected_component_of</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.reachable</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">quot.exact</span> <span class="n">_</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">of_eqv</span> <span class="n">G.reachable_is_equivalence</span>
</code></pre></div>
<p>If namespaces worked out, it would also be nice with flipped arguments, so that the proof is <code>G.reachable_is_equivalence.of_eqv_gen (quot.exact _ h)</code></p>



<a name="259913379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259913379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259913379">(Nov 01 2021 at 20:04)</a>:</h4>
<p><code>eqv_gen_iff</code> would be nice to have, too</p>



<a name="259926709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/259926709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#259926709">(Nov 01 2021 at 21:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/259909778">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">preconnected</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">reachable</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>leaves me at </p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">k</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">hk</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span>
<span class="n">h</span><span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span>
<span class="n">u</span> <span class="n">v</span><span class="o">:</span> <span class="n">V</span>
<span class="bp">⊢</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">k</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">hk</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span>
<span class="n">h</span><span class="o">:</span> <span class="n">G.edge_connected</span> <span class="n">k</span>
<span class="bp">⊢</span> <span class="n">nonempty</span> <span class="n">V</span>
</code></pre></div><br>
</p>
</blockquote>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> maybe you don't need this now, but here's how to do that <code>nonempty</code> goal from earlier: if you look at the definition of <code>nonempty</code> then you can see that the constructor is called <code>nonempty.intro</code>, so <code>exact nonempty.intro u</code> should do it.</p>



<a name="260003810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260003810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260003810">(Nov 02 2021 at 14:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> makes sense, thanks!</p>



<a name="260003897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260003897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260003897">(Nov 02 2021 at 14:37)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> do you think the PR needs more adjustments before merging?</p>



<a name="260077726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260077726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260077726">(Nov 03 2021 at 00:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The list of edges in a walk are all edges of the graph.</span>
<span class="sd">It is written in this form to avoid unsightly coercions. -/</span>
<span class="kd">lemma</span> <span class="n">edges_subset_edge_set</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">p.edges</span><span class="o">)</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span>
</code></pre></div>
<p>Hm, this isn't really what we mean, is it? Wouldn't it be more like "Every edge in a walk is an edge of the graph"?</p>



<a name="260078198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260078198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260078198">(Nov 03 2021 at 00:56)</a>:</h4>
<p>Are you talking about the comment? Less weird is "Every edge in a walk's edge list is an edge of the graph." The point of this comment is to remind the reader why it's not <code>p.edges ⊆ G.edge_set</code>, and that's because <code>p.edges : list (sym2 V)</code> rather than <code>set (sym2 V)</code>.</p>



<a name="260078240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260078240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260078240">(Nov 03 2021 at 00:57)</a>:</h4>
<p>Yeah, about the comment</p>



<a name="260078430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260078430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260078430">(Nov 03 2021 at 01:00)</a>:</h4>
<p>(Please feel free to clarify that comment in the source. You can delete it and start over.)</p>



<a name="260329772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260329772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260329772">(Nov 04 2021 at 20:28)</a>:</h4>
<p>Hi! I'm trying to prove the lemma that says that the existence of a perfect matching implies that the cardinality of the vertices set is even. I've come to this point:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">fintype</span> <span class="n">V</span>
<span class="n">M</span><span class="o">:</span> <span class="n">G.matching</span>
<span class="n">_inst_2</span><span class="o">:</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">M.edges</span><span class="o">)</span>
<span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">),</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">M.edges</span> <span class="bp">∧</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e</span>
<span class="bp">⊢</span> <span class="n">card</span> <span class="n">V</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">card</span> <span class="bp">↥</span><span class="o">(</span><span class="n">M.edges</span><span class="o">)</span>
</code></pre></div>



<a name="260330185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260330185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260330185">(Nov 04 2021 at 20:31)</a>:</h4>
<p>I'd advise you to go by double counting the finset <code>(univ : V × sym2 V).filter (λ ve, ve.1 ∈ ve.2)</code></p>



<a name="260330304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260330304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260330304">(Nov 04 2021 at 20:32)</a>:</h4>
<p>Can you define an equiv <code>V ≃ Σ e : M.edges, {v : V // v ∈ e}</code>?</p>



<a name="260330431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260330431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260330431">(Nov 04 2021 at 20:33)</a>:</h4>
<p>Yeah, that's another way. Not sure it goes smoothly, though.</p>



<a name="260330877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260330877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260330877">(Nov 04 2021 at 20:36)</a>:</h4>
<p>I thought about double counting too because a vertex is in exactly one edge and an edge has exactly two vertices ( verytypical informal proof)</p>



<a name="260331231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260331231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260331231">(Nov 04 2021 at 20:39)</a>:</h4>
<p>I suggest <code>choose e he1 he2 using h</code> as next tactic step.</p>



<a name="260331706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260331706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260331706">(Nov 04 2021 at 20:43)</a>:</h4>
<p>This should follow from the degree-sum formula, right? Perfect matchings are certain kinds of subgraphs (this coercion is not implemented) and then you apply <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.sum_degrees_eq_twice_card_edges">docs#simple_graph.sum_degrees_eq_twice_card_edges</a> and use the fact that all the degrees are 1 for this subgraph.</p>



<a name="260332050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260332050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260332050">(Nov 04 2021 at 20:45)</a>:</h4>
<p>If you want to do it yourself, I'd suggest using the map <code>V -&gt; sym2 V</code> for the perfect matching that gets the edge associated to a vertex, show the image is <code>M.edges</code>, and show the map is 2-1 onto each element of <code>M.edges</code>.</p>



<a name="260332249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260332249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260332249">(Nov 04 2021 at 20:47)</a>:</h4>
<p>(Somewhere I shared a link to a branch that contains more things about perfect matchings, when <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> asked very recently. I think it has this <code>V -&gt; sym2 V</code> map.)</p>



<a name="260332991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260332991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260332991">(Nov 04 2021 at 20:53)</a>:</h4>
<p>Matchings were added to mathlib before subgraphs were.  It might be reasonable to redesign them as a graph <code>M : simple_graph V</code> satisfying <code>M \leq G</code> such that whenever <code>M.adj v w</code> and <code>M.adj v w'</code> then <code>w = w'</code>.  We could define <code>simple_graph.support</code> of a graph to be <code>{v : V | \exists w, G.adj v w}</code>, and then a perfect matching is an <code>M</code> such that <code>M.support = set.univ</code>.</p>



<a name="260333101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260333101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260333101">(Nov 04 2021 at 20:54)</a>:</h4>
<p>Do you think we even want a standalone definition if we have k-factors?</p>



<a name="260333305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260333305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260333305">(Nov 04 2021 at 20:55)</a>:</h4>
<p>If there are k-factors, then it would be good to have an interface for 1-factors something like this</p>



<a name="260333432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260333432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260333432">(Nov 04 2021 at 20:56)</a>:</h4>
<p>though it would instead actually be terms of <code>G.subgraph</code> instead of terms of <code>simple_graph V</code> that are subgraphs.</p>



<a name="260333668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260333668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260333668">(Nov 04 2021 at 20:58)</a>:</h4>
<p>Maybe make sure k-factors work for non-locally-finite graphs; the definition of matchings I gave doesn't depend on that assumption.</p>



<a name="260335259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260335259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260335259">(Nov 04 2021 at 21:10)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> if you want a relatively small thing to try PRing to mathlib itself, it could be defining the support of a <code>simple_graph</code>, which I don't think exists already.  Maybe its definition could be <code>def simple_graph.support (G : simple_graph V) : set V := rel.image G.adj set.univ</code>, and then you'd have a simp lemma <code>simple_graph.mem_support</code> that says a vertex <code>v</code> is an element of <code>G.support</code> iff there exists a vertex <code>w</code> with <code>G.adj v w</code>.  One other useful lemma (a corollary) would be that if <code>G.adj v w</code> for <code>(v w : V)</code> then <code>v</code> is an element of <code>G.support</code>.</p>



<a name="260335699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260335699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260335699">(Nov 04 2021 at 21:14)</a>:</h4>
<p>Yeah, all of a sudden this matching lemma became a redesigning task which I'm not sure I can handle without bugging too many people <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="260335883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260335883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260335883">(Nov 04 2021 at 21:16)</a>:</h4>
<p>At least not yet</p>



<a name="260335893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260335893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260335893">(Nov 04 2021 at 21:16)</a>:</h4>
<p>What is left? That goal state that you posted above?</p>



<a name="260335916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260335916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260335916">(Nov 04 2021 at 21:16)</a>:</h4>
<p>That shouldn't require any redesigning.</p>



<a name="260336153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260336153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260336153">(Nov 04 2021 at 21:17)</a>:</h4>
<p>With that <code>choose</code> line that I posted, it should be quite straightforward to build the equiv.</p>



<a name="260336258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260336258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260336258">(Nov 04 2021 at 21:18)</a>:</h4>
<p>And then you can use <code>fintype.card_congr</code> and <code>fintype.card_sigma</code>. By then you should be in pretty good shape.</p>



<a name="260337620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260337620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260337620">(Nov 04 2021 at 21:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260335699">said</a>:</p>
<blockquote>
<p>Yeah, all of a sudden this matching lemma became a redesigning task which I'm not sure I can handle without bugging too many people <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>
</blockquote>
<p>Don't worry! I happen to need k-factors myself.</p>



<a name="260347072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347072">(Nov 04 2021 at 23:09)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I was able to prove the lemma with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_support</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">support</span><span class="o">,</span> <span class="n">rel.image</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">choose</span> <span class="n">w</span> <span class="n">h</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">adj_comm</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">choose</span> <span class="n">w</span> <span class="n">h</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>But I notice some repeated structure for each split. Is it possible to optimize this proof?</p>



<a name="260347535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347535">(Nov 04 2021 at 23:14)</a>:</h4>
<p>better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_support</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">support</span><span class="o">,</span> <span class="n">rel.image</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">choose</span> <span class="n">w</span> <span class="n">h</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">choose</span> <span class="n">w</span> <span class="n">h</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260347547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347547">(Nov 04 2021 at 23:14)</a>:</h4>
<p>I think you might be able to do it in one line with <code>rw [support, rel.mem_image, adj_comm]</code></p>



<a name="260347560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347560">(Nov 04 2021 at 23:14)</a>:</h4>
<p>(maybe <code>simp only</code> instead of <code>rw</code>)</p>



<a name="260347656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347656">(Nov 04 2021 at 23:15)</a>:</h4>
<p>Oh, you'll need <code>set.mem_univ</code> and maybe a couple others.</p>



<a name="260347850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347850">(Nov 04 2021 at 23:17)</a>:</h4>
<p>Is it slower to add many arguments to <code>simp only</code>?<br>
Another question, what's the difference between <code>simp [a, b, ...]</code> and <code>simp only [a, b, c, ...]</code>?</p>



<a name="260347994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260347994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260347994">(Nov 04 2021 at 23:19)</a>:</h4>
<p>Without <code>only</code>, it additionally uses all lemmas marked with the <code>@[simp]</code> attribute. <a href="https://leanprover-community.github.io/extras/simp.html">https://leanprover-community.github.io/extras/simp.html</a></p>



<a name="260348209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348209">(Nov 04 2021 at 23:21)</a>:</h4>
<p>About the redesign you mentioned, isn't it a bit strange to define a matching as a subgraph? I mean, it's a subgraph that always contain all the vertices of the full graph</p>



<a name="260348326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348326">(Nov 04 2021 at 23:23)</a>:</h4>
<p>I <em>think</em> it's more common in the literature to understand a matching as a subset of edges</p>



<a name="260348418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348418">(Nov 04 2021 at 23:24)</a>:</h4>
<p>This theorem, by the way, is strangely resisting <code>squeeze_simp</code> and <code>simp?</code></p>



<a name="260348550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348550">(Nov 04 2021 at 23:26)</a>:</h4>
<p>What do you mean?</p>



<a name="260348616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348616">(Nov 04 2021 at 23:28)</a>:</h4>
<p>And regarding formalization vs literature: combinatorics is a very intuitive subject, so things tend to be very informal because the gaps can be filled in easily.  But a computer needs everything to be represented very precisely.  It seems like many of the ways we might use matchings are very subgraph-like, so we may as well just represent them as subgraphs, without needing to create coercions back and forth between different representations.</p>
<p>Yael seems to be on it to define what k-factors are, and he was thinking of defining them as being subgraphs.</p>



<a name="260348716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348716">(Nov 04 2021 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260348550">said</a>:</p>
<blockquote>
<p>What do you mean?</p>
</blockquote>
<p>Ok:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_support</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">support</span><span class="o">,</span> <span class="n">rel.mem_image</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">,</span> <span class="n">set.mem_univ</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
<p>Replacing <code>simp</code> with <code>squeeze_simp</code> suggests this <code>simp only</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_support</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">support</span><span class="o">,</span> <span class="n">rel.mem_image</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">,</span> <span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">set.mem_univ</span><span class="o">,</span> <span class="n">iff_self</span><span class="o">,</span> <span class="n">exists_true_left</span><span class="o">],</span>
  <span class="c1">-- goal not closed</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260348729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348729">(Nov 04 2021 at 23:29)</a>:</h4>
<p>Yeah as soon as I said it, I realized that spanning trees also have this characteristic of containing all vertices of the bigger graph and we might as well define them as subgraphs</p>



<a name="260348837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348837">(Nov 04 2021 at 23:31)</a>:</h4>
<p>Wow that's indeed a 1-liner</p>



<a name="260348865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348865">(Nov 04 2021 at 23:31)</a>:</h4>
<p>There's a complexity already with simple graphs that there are two notions of a subgraph: <code>G.subgraph</code> for arbitrary ones and <code>simple_graph V</code> for spanning ones (where we take only those that are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span>).</p>



<a name="260348994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260348994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260348994">(Nov 04 2021 at 23:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_support</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">support</span><span class="o">,</span> <span class="n">rel.image</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">]</span>
</code></pre></div>
<p>closed the goal here</p>



<a name="260349107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349107">(Nov 04 2021 at 23:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.spanning_coe">docs#simple_graph.subgraph.spanning_coe</a> is an attempt to connect up with this latter notion, and I expect to use <code>G.support</code> at some point for restricting a graph to a <code>G.subgraph</code> by removing degree-0 vertices.</p>



<a name="260349250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349250">(Nov 04 2021 at 23:36)</a>:</h4>
<p>This would be a little better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_support</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">support</span><span class="o">,</span> <span class="n">rel.mem_image</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">]</span>
</code></pre></div>
<p>It's better to use the "API" for definitions rather than unfolding them.  The point of <code>mem_support</code> is to define the API for <code>G.support</code> so future users don't have to unfold it.</p>



<a name="260349318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349318">(Nov 04 2021 at 23:37)</a>:</h4>
<p>Actually, I'm not sure this should be a <code>@[simp]</code> lemma. It doesn't hurt, but it's unclear to me right now whether it will help simplify things. I guess leave it unless anyone has a reason it shouldn't be one.</p>



<a name="260349398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349398">(Nov 04 2021 at 23:38)</a>:</h4>
<p>I can add it without <code>@[simp]</code> and then you can make it so if you see fit later</p>



<a name="260349445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349445">(Nov 04 2021 at 23:39)</a>:</h4>
<p>You might have a <code>support_mono</code> lemma that says <code>G &lt;= G' -&gt; G.support &lt;= G'.support</code>, right?</p>



<a name="260349563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349563">(Nov 04 2021 at 23:41)</a>:</h4>
<p>lemme try to get that in</p>



<a name="260349699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349699">(Nov 04 2021 at 23:42)</a>:</h4>
<p>Something something forgetful functor to Set</p>



<a name="260349821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349821">(Nov 04 2021 at 23:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">G</span> <span class="bp">≤</span> <span class="n">G'</span>
<span class="n">term</span>
  <span class="n">G'</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">simple_graph</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
</code></pre></div>
<p><code>G'</code> wasn't defined as a subgraph of <code>G</code> here <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="260349909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260349909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260349909">(Nov 04 2021 at 23:45)</a>:</h4>
<p>This should go inside <code>subgraph</code> right?</p>



<a name="260351276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260351276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260351276">(Nov 05 2021 at 00:03)</a>:</h4>
<p>This would be for <code>(G G' : simple_graph V)</code></p>



<a name="260351298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260351298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260351298">(Nov 05 2021 at 00:03)</a>:</h4>
<p>There's an ordering on simple graphs with the same vertex type based on edge containment</p>



<a name="260352075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260352075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260352075">(Nov 05 2021 at 00:13)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> For your proof earlier, you don't need to use <code>choose</code>, but you can rather use <code>cases</code>, <code>rcases</code>, or <code>obtain</code> since the goal is a proposition.  <code>choose</code> is mainly useful for when you need to "actually" get a value out of an existential</p>



<a name="260352185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260352185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260352185">(Nov 05 2021 at 00:15)</a>:</h4>
<p>I would even add when you need to swap an exists and a forall.</p>



<a name="260353411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260353411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260353411">(Nov 05 2021 at 00:35)</a>:</h4>
<p>Got this one</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">support_mono</span> <span class="o">(</span><span class="n">H</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">≤</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">H.support</span> <span class="bp">≤</span> <span class="n">G.support</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">is_subgraph_eq_le</span><span class="o">,</span> <span class="n">is_subgraph</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_support</span> <span class="n">at</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">choose</span> <span class="n">w</span> <span class="n">hw</span> <span class="n">using</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hw</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260354160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354160">(Nov 05 2021 at 00:47)</a>:</h4>
<p>Two things, other than that looks good (though of course someone will golf it, it's inevitable): make sure to put a space after <code>H</code>, and please swap the roles of <code>H</code> and <code>G</code> in the lemma statement -- if you <code>#check @support_mono</code> you'll see that the arguments are <code>(G H : simple_graph V)</code>.  Another option is to edit your lemma so it says <code>(H G : simple_graph V)</code> since this will override the <code>variables</code></p>



<a name="260354243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354243">(Nov 05 2021 at 00:48)</a>:</h4>
<p>I forgot a third thing: put <code>(h : H ≤ G)</code> as an argument before the colon, since you're <code>intro</code>ing it anyway.</p>



<a name="260354429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354429">(Nov 05 2021 at 00:51)</a>:</h4>
<p>like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">support_mono</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">G'</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.support</span> <span class="bp">≤</span> <span class="n">G'.support</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">is_subgraph_eq_le</span><span class="o">,</span> <span class="n">is_subgraph</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_support</span> <span class="n">at</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hv</span> <span class="k">with</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hw</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">adj_comm</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260354543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354543">(Nov 05 2021 at 00:53)</a>:</h4>
<p>probably <code>G</code> and <code>G'</code> should be implicit</p>



<a name="260354618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354618">(Nov 05 2021 at 00:54)</a>:</h4>
<p>also space <del>before</del> after the <code>&lt;-</code> although enforcement on that rule is pretty low</p>



<a name="260354632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354632">(Nov 05 2021 at 00:54)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> so use <code>{G G' : simple_graph V}</code> as the argument instead</p>



<a name="260354653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354653">(Nov 05 2021 at 00:55)</a>:</h4>
<p>What rule's that about <code>&lt;-</code>?</p>



<a name="260354663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354663">(Nov 05 2021 at 00:55)</a>:</h4>
<p>i.e. <code>rw [← is_subgraph_eq_le, is_subgraph] at h,</code></p>



<a name="260354751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260354751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260354751">(Nov 05 2021 at 00:56)</a>:</h4>
<p>done: <a href="https://github.com/leanprover-community/mathlib/pull/10176">https://github.com/leanprover-community/mathlib/pull/10176</a></p>



<a name="260359964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260359964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260359964">(Nov 05 2021 at 02:31)</a>:</h4>
<p>PR updated <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="260429166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429166">(Nov 05 2021 at 16:30)</a>:</h4>
<p>I'm attempting to formalize vertex coloring. do you guys think this is a good design?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">vertex_coloring</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">color</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">vertex_colors</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.vertex_coloring</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="260429257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429257">(Nov 05 2021 at 16:30)</a>:</h4>
<p>We already thought about it quite a lot.</p>



<a name="260429274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429274">(Nov 05 2021 at 16:30)</a>:</h4>
<p>I would make the codomain of <code>color</code> a parameter</p>



<a name="260429360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429360">(Nov 05 2021 at 16:31)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> used them without explicitly defining them for <a href="https://leanprover-community.github.io/mathlib_docs/find/combinatorics.line.exists_mono_in_high_dimension">docs#combinatorics.line.exists_mono_in_high_dimension</a></p>



<a name="260429391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429391">(Nov 05 2021 at 16:31)</a>:</h4>
<p>and <span class="user-mention" data-user-id="303889">@Alena Gusakov</span> has a definition on a branch</p>



<a name="260429489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429489">(Nov 05 2021 at 16:32)</a>:</h4>
<p>Either way, you'll want to use <a href="https://leanprover-community.github.io/mathlib_docs/find/pairwise">docs#pairwise</a></p>



<a name="260429571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429571">(Nov 05 2021 at 16:32)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I don't think your example is a vertex coloring in <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> 's sense, Hales-jewett does not have any constraints on colors of adjacent vertices</p>



<a name="260429684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429684">(Nov 05 2021 at 16:33)</a>:</h4>
<p>No, it doesn't. This is more of a contextual idea.</p>



<a name="260429702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429702">(Nov 05 2021 at 16:33)</a>:</h4>
<p>it does reveal some ambiguity of the terminology though</p>



<a name="260429897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429897">(Nov 05 2021 at 16:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> do you mean like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">vertex_coloring</span> <span class="o">(</span><span class="n">color_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">color_type</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">color</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">vertex_colors</span> <span class="o">(</span><span class="n">color_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.vertex_coloring</span> <span class="n">color_type</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="260429934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260429934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260429934">(Nov 05 2021 at 16:35)</a>:</h4>
<p>yes</p>



<a name="260430047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430047">(Nov 05 2021 at 16:35)</a>:</h4>
<p>That was my first go but I found it a bit annoying to carry <code>color_type</code> everywhere. What can I do about it?</p>



<a name="260430126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430126">(Nov 05 2021 at 16:36)</a>:</h4>
<p>Call it <code>α</code> <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>



<a name="260430191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430191">(Nov 05 2021 at 16:36)</a>:</h4>
<p>Ah, then explain in a docstring</p>



<a name="260430247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430247">(Nov 05 2021 at 16:37)</a>:</h4>
<p>The docstring of <code>vertex_coloring</code> needs to explain it anyway</p>



<a name="260430371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430371">(Nov 05 2021 at 16:37)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> how do you mean about <code>pairwise</code>?</p>



<a name="260430373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430373">(Nov 05 2021 at 16:37)</a>:</h4>
<p>but it's also useful to be able to constrain the type to other things; even in the finite graph situation you might want to take the codomain to be <code>fin k</code> to get a k-coloring</p>



<a name="260430491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430491">(Nov 05 2021 at 16:38)</a>:</h4>
<p>and in the infinite graph situation you might want it to be some other cardinal</p>



<a name="260430609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430609">(Nov 05 2021 at 16:39)</a>:</h4>
<p>or even just use regular type operations on it like <code>A ⊕ B</code> when joining two graphs with disjoint colors</p>



<a name="260430775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430775">(Nov 05 2021 at 16:40)</a>:</h4>
<p>Eh, it doesn't turn out that great.</p>



<a name="260430882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260430882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260430882">(Nov 05 2021 at 16:41)</a>:</h4>
<p>I was thinking of something like <code>∀ a, is_antichain G.adj (color '⁻¹ {a})</code></p>



<a name="260431136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260431136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260431136">(Nov 05 2021 at 16:43)</a>:</h4>
<p>or your "colors" could be other mathematical objects relevant to an application. This is the reason why <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix">docs#matrix</a> lets you use arbitrary index types even though we usually just think of the <code>fin n</code> case</p>



<a name="260431751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260431751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260431751">(Nov 05 2021 at 16:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260429702">said</a>:</p>
<blockquote>
<p>it does reveal some ambiguity of the terminology though</p>
</blockquote>
<p>These tend to be called "proper" colorings when there can be confusion.</p>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> Another design is to consider homomorphisms to <code>complete_graph α</code>, which gives you a lot of power</p>



<a name="260431949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260431949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260431949">(Nov 05 2021 at 16:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>
</code></pre></div>



<a name="260432012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260432012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260432012">(Nov 05 2021 at 16:49)</a>:</h4>
<p>This is how <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> suggested doing it.</p>



<a name="260433101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260433101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260433101">(Nov 05 2021 at 16:57)</a>:</h4>
<p>I was thinking about defining <code>vertex_coloring</code> and <code>edge_coloring</code></p>



<a name="260433241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260433241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260433241">(Nov 05 2021 at 16:58)</a>:</h4>
<p>Do you think it would be okay to prove the homomorphism after having that pair of more bare-bones definitions?</p>



<a name="260434916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260434916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260434916">(Nov 05 2021 at 17:08)</a>:</h4>
<p>I think you should start with the homomorphism and turn the fields from the struct into a definition and a lemma.  The first is from applying the homomorphism, and the second is what it means to be a homomorphism, so it should be 2-4 lines total</p>



<a name="260435027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260435027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260435027">(Nov 05 2021 at 17:09)</a>:</h4>
<p>It takes a bit of definition unfolding to see it, but this homomorphism definition is basically identical to the struct you defined</p>



<a name="260435448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260435448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260435448">(Nov 05 2021 at 17:12)</a>:</h4>
<p>Alright, I'm gonna try to dig this approach</p>



<a name="260440921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260440921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260440921">(Nov 05 2021 at 17:52)</a>:</h4>
<p>(<span class="user-mention" data-user-id="387244">@Yaël Dillies</span> With your k-factors work, one thing to think about is how to go back and forth between edge colorings and coverings by disjoint maximal 1-factors (i.e., perfect matchings).)</p>



<a name="260446849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260446849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260446849">(Nov 05 2021 at 18:37)</a>:</h4>
<p>How do I say this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">proper_coloring_is_valid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
 <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">C.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="260446948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260446948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260446948">(Nov 05 2021 at 18:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span> <span class="bp">'</span><span class="n">adj'</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">valid</span> <span class="s2">"field"</span> <span class="n">because</span> <span class="n">environment</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="bp">'</span><span class="n">simple_graph.proper_coloring.adj'</span>
  <span class="n">C</span>
<span class="n">which</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">G.proper_coloring</span> <span class="n">α</span>
</code></pre></div>



<a name="260447206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260447206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260447206">(Nov 05 2021 at 18:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">proper_coloring.color</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">C</span> <span class="n">v</span>

<span class="kd">lemma</span> <span class="n">proper_coloring.valid</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C.color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">C.color</span> <span class="n">w</span> <span class="o">:=</span>
<span class="n">C.map_rel</span> <span class="n">h</span>
</code></pre></div>



<a name="260447500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260447500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260447500">(Nov 05 2021 at 18:43)</a>:</h4>
<p>Also,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.mk</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.proper_coloring</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="bp">@</span><span class="n">h</span><span class="o">⟩</span>
</code></pre></div>
<p>for a constructor that looks recognizable.</p>



<a name="260448646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260448646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260448646">(Nov 05 2021 at 18:50)</a>:</h4>
<p>One of the reasons for having this be a homomorphism is that if you have an injective map <code>a -&gt; b</code>, then there is an induced graph homomorphism <code>complete_graph a -&gt;g complete_graph b</code> (not written, but easy), which you can compose with a proper a-coloring to get a proper b-coloring (so you can extend the set of colors using already existing machinery).</p>



<a name="260448783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260448783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260448783">(Nov 05 2021 at 18:51)</a>:</h4>
<p>Or, if you have a graph homomorphism <code>G -&gt;g G'</code> and a proper a-coloring of <code>G'</code>, then you can compose the homomorphisms to get a proper a-coloring of <code>G</code>.  This can be used to show that subgraphs of a proper a-colorable graph are a-colorable.</p>



<a name="260450928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260450928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260450928">(Nov 05 2021 at 19:06)</a>:</h4>
<p>You can see a lot further than I can. I will do my best to catch up</p>



<a name="260451334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260451334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260451334">(Nov 05 2021 at 19:10)</a>:</h4>
<blockquote>
<p>(<span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> With your k-factors work, one thing to think about is how to go back and forth between edge colorings and coverings by disjoint maximal 1-factors (i.e., perfect matchings).)</p>
</blockquote>
<p>Does that mean you want k-factors to be subgraphs?</p>



<a name="260452323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260452323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260452323">(Nov 05 2021 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> Something I'm looking forward to is having the fact that if every finite subgraph of a graph has a proper a-coloring, then (noncomputably) the graph has a proper a-coloring.  This can be done using the idea for how <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective">docs#finset.all_card_le_bUnion_card_iff_exists_injective</a> is proved from <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective'">docs#finset.all_card_le_bUnion_card_iff_exists_injective'</a></p>
<p>I guess there's a more general result, which is if <code>G'</code> is a finite graph and if every finite subgraph of <code>G</code> has a homomorphism to <code>G'</code>, then there is a homomorphism from <code>G</code> to <code>G'</code>.</p>



<a name="260452679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260452679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260452679">(Nov 05 2021 at 19:22)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> How were you thinking about formalizing them?</p>



<a name="260453368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260453368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260453368">(Nov 05 2021 at 19:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260452323">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> Something I'm looking forward to is having the fact that if every finite subgraph of a graph has a proper a-coloring, then (noncomputably) the graph has a proper a-coloring.  This can be done using the idea for how <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective">docs#finset.all_card_le_bUnion_card_iff_exists_injective</a> is proved from <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective'">docs#finset.all_card_le_bUnion_card_iff_exists_injective'</a></p>
</blockquote>
<p>Isn't that kind of trivial from our current definition of subgraph since a graph can be a subgraph of itself?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">subgraph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">verts</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj_sub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_vert</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">verts</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>



<a name="260453691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260453691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260453691">(Nov 05 2021 at 19:31)</a>:</h4>
<p>The graph can be infinite!</p>



<a name="260453862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260453862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260453862">(Nov 05 2021 at 19:32)</a>:</h4>
<p>Oh okay then, now that's interesting <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="260454178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260454178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260454178">(Nov 05 2021 at 19:35)</a>:</h4>
<p>I'm still in the process of struggling a bit with syntax. I will be chewing the idea of <code>proper_coloring</code> that you suggested</p>



<a name="260454341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260454341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260454341">(Nov 05 2021 at 19:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.mk</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.proper_coloring</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="bp">@</span><span class="n">h</span><span class="o">⟩</span>
</code></pre></div>
<p>what does <code>@h</code> mean?</p>



<a name="260454378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260454378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260454378">(Nov 05 2021 at 19:37)</a>:</h4>
<p>it turns the {} brackets into () ones</p>



<a name="260454567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260454567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260454567">(Nov 05 2021 at 19:38)</a>:</h4>
<p>The problem is that with just <code>h</code>, lean will fill in the <code>v</code> and <code>w</code> arguments with metavariables that it tries to solve for, but the second slot for the constructor is expecting a function that still takes those as arguments.</p>



<a name="260454579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260454579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260454579">(Nov 05 2021 at 19:38)</a>:</h4>
<p>If you try it without the @ then presumably you get some error saying "I was expecting you to give me a function which starts by consuming two elements of V but this function h appears to start by eating a term of type <code>G.adj _ _</code>"</p>



<a name="260454800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260454800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260454800">(Nov 05 2021 at 19:40)</a>:</h4>
<p>I guess there's really not a need for these to be implicit arguments for this <code>h</code> argument -- I was just following the types for <code>rel_iso.mk</code>, which is what those angle brackets actually mean in this context.</p>



<a name="260455538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260455538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260455538">(Nov 05 2021 at 19:47)</a>:</h4>
<p>This is a kind of fun thing you can do with <code>proper_coloring.mk</code>, if you like pattern matching:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">@[pattern]</span>
<span class="kd">def</span> <span class="n">proper_coloring.mk</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.proper_coloring</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="bp">@</span><span class="n">h</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">proper_coloring.color</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">),</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">proper_coloring.mk</span> <span class="n">f</span> <span class="n">valid</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span>

<span class="kd">def</span> <span class="n">proper_coloring.valid</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">C.color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">C.color</span> <span class="n">w</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">proper_coloring.mk</span> <span class="n">f</span> <span class="n">valid</span><span class="o">)</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">valid</span> <span class="n">h</span>
</code></pre></div>
<p>(I'm not suggesting you implement <code>color</code> and <code>valid</code> this way. It's just an example of what <code>@[pattern]</code> can do and why it might be good to keep the arguments to<code>h</code> as implicit.)</p>



<a name="260457537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260457537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260457537">(Nov 05 2021 at 20:03)</a>:</h4>
<p>It's still not clear to me what <code>mk</code> is doing. It's a function that takes a coloring function and a hypothesis that this coloring function is a proper one and returns... what?</p>



<a name="260457726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260457726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260457726">(Nov 05 2021 at 20:04)</a>:</h4>
<p>It's returning an "actual" proper coloring</p>



<a name="260457754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260457754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260457754">(Nov 05 2021 at 20:05)</a>:</h4>
<p>which we defined to be a kind of graph homomorphism</p>



<a name="260457967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260457967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260457967">(Nov 05 2021 at 20:06)</a>:</h4>
<p>Try looking at <code>#check @vertex_coloring.mk</code> for your original definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">vertex_coloring</span> <span class="o">(</span><span class="n">color_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">color_type</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">color</span> <span class="n">w</span><span class="o">)</span>
</code></pre></div>
<p>Every structure defines a <code>.mk</code> function (unless you override what it's called), which is the constructor.</p>



<a name="260458700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260458700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260458700">(Nov 05 2021 at 20:13)</a>:</h4>
<p>An idea here is that what <code>structure</code> does is have Lean create a new type from scratch with all the desired properties -- all these properties are what the type <em>is</em>.  What we can instead do is take a pre-existing type and implementing the same properties, so this type now <em>is</em> the structure defined by <code>vertex_coloring</code>.  (There's one difference though, which is that record syntax doesn't work quite as well if you don't use <code>structure</code> directly.)</p>



<a name="260458809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260458809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260458809">(Nov 05 2021 at 20:14)</a>:</h4>
<p>The way dot notation works also helps keep up the illusion.  We can write <code>C.color</code> and it will look for <code>proper_coloring.color C</code> first.</p>



<a name="260468028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260468028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260468028">(Nov 05 2021 at 21:39)</a>:</h4>
<p>The question I asked <a href="#narrow/stream/113489-new-members/topic/cardinality.20of.20image.20set.20of.20a.20function/near/260466530">here</a> was because I'm trying to arrive at a definition of the chromatic number. I did this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">fintype</span>

<span class="kd">def</span> <span class="n">proper_coloring.colors</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">set.range</span> <span class="n">C.color</span>

<span class="kd">def</span> <span class="n">proper_coloring.card</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">C.colors</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">card</span> <span class="n">C.colors</span>
</code></pre></div>
<p>But I'm very unsure this will have good consequences</p>



<a name="260468214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260468214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260468214">(Nov 05 2021 at 21:41)</a>:</h4>
<p>Maybe I should focus on some lemmas first</p>



<a name="260468730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260468730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260468730">(Nov 05 2021 at 21:48)</a>:</h4>
<p>It's easier to just use <code>fintype.card α</code> here, then later use some idea of restricting a coloring.  It's ok if not all colors are used, since there's a smaller <code>α</code> where it does use all the colors.</p>



<a name="260469040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260469040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260469040">(Nov 05 2021 at 21:51)</a>:</h4>
<p>Maybe some trick similar to the <code>rel.image</code> from earlier?</p>



<a name="260469317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260469317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260469317">(Nov 05 2021 at 21:54)</a>:</h4>
<p>A TODO in <code>subgraph.lean</code> says "Images of graph homomorphisms as subgraphs."  If we had that implemented, then you could do <code>C.image</code> to get a subgraph, the vertex set of which is the set of used colors.</p>



<a name="260469401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260469401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260469401">(Nov 05 2021 at 21:55)</a>:</h4>
<p>(The edges in the images represent colors that show up on endpoints of some edge in the original graph.  If the image isn't a complete graph, you can merge colors whenever they're not adjacent, for example.)</p>



<a name="260476691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260476691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260476691">(Nov 05 2021 at 23:27)</a>:</h4>
<p>Got this so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">proper_coloring.color</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">C</span> <span class="n">v</span>

<span class="kd">lemma</span> <span class="n">proper_coloring.valid</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">C.color</span> <span class="n">w</span> <span class="o">:=</span>
  <span class="n">C.map_rel</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">proper_coloring.mk</span> <span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">color</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.proper_coloring</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">color</span><span class="o">,</span> <span class="bp">@</span><span class="n">h</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">proper_coloring.card</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">fintype.card</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">proper_coloring.is_minimal</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">C'</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">),</span> <span class="n">C.card</span> <span class="bp">≤</span> <span class="n">C'.card</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="260476961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260476961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260476961">(Nov 05 2021 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260452679">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> How were you thinking about formalizing them?</p>
</blockquote>
<p>I was thinking of defining them as graphs. But making them subgraphs does sound smart</p>



<a name="260479603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260479603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260479603">(Nov 06 2021 at 00:14)</a>:</h4>
<p>I found this: <a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean</a></p>



<a name="260479811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260479811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260479811">(Nov 06 2021 at 00:18)</a>:</h4>
<p>Maybe this would work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">data.nat.lattice</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">proper_coloring.color</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">C</span> <span class="n">v</span>

<span class="kd">lemma</span> <span class="n">proper_coloring.valid</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">C.color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">C.color</span> <span class="n">w</span> <span class="o">:=</span>
  <span class="n">C.map_rel</span> <span class="n">h</span>

<span class="kd">@[pattern]</span>
<span class="kd">def</span> <span class="n">proper_coloring.mk</span> <span class="o">(</span><span class="n">color</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">color</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">color</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.proper_coloring</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">color</span><span class="o">,</span> <span class="bp">@</span><span class="n">h</span><span class="o">⟩</span>

<span class="sd">/-- Whether a graph can be colored by at most `n` colors. -/</span>
<span class="kd">def</span> <span class="n">colorable</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">),</span>
<span class="kd">by</span> <span class="n">exactI</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">≤</span> <span class="n">n</span>  <span class="c1">-- the "by exactI" trick is a way to get Lean to notice the `fintype` instance</span>

<span class="sd">/-- If `G` isn't colorable with finitely many colors, this will be 0. -/</span>
<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">chromatic_number</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Inf</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="260479915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260479915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260479915">(Nov 06 2021 at 00:20)</a>:</h4>
<p>The definition of <code>colorable</code> is "There exists a finite color type of size at most <code>n</code> for which there is a proper coloring of <code>G</code>."  The <code>by exactI</code> is a bit unfortunate; try removing it to see the error it's avoiding.</p>



<a name="260480108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260480108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260480108">(Nov 06 2021 at 00:24)</a>:</h4>
<p>By the way, here's some code from a while back about graphs and colorings (from before mathlib had anything about simple graphs at all): <a href="https://github.com/kmill/lean-graphcoloring/blob/master/src/graph.lean">https://github.com/kmill/lean-graphcoloring/blob/master/src/graph.lean</a></p>



<a name="260480237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260480237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260480237">(Nov 06 2021 at 00:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260479603">said</a>:</p>
<blockquote>
<p>I found this: <a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean</a></p>
</blockquote>
<p>This is the one that got more developed: <a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/coloring.lean</a></p>
<p>It has stuff about homomorphisms, but colorings weren't homomorphisms themselves.</p>



<a name="260480340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260480340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260480340">(Nov 06 2021 at 00:28)</a>:</h4>
<p>It also has this interesting "dual" version of colorings, which an indexed family of subsets of vertices (one subset per color), which allows you to work with partial colorings since not every vertex needs a color:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- This is an indexed family of disjoint subsets of the vertex type of `G` such that vertices in</span>
<span class="sd">the same set are not adjacent.  This is similar to `subgraph.coloring`, however not every vertex</span>
<span class="sd">needs to be given a color. -/</span>
<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">coloring'</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">color_set</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">c'</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">c'</span> <span class="bp">→</span> <span class="n">color_set</span> <span class="n">c</span> <span class="bp">∩</span> <span class="n">color_set</span> <span class="n">c'</span> <span class="bp">=</span> <span class="bp">∅</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">v'</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">color_set</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">v'</span> <span class="bp">∈</span> <span class="n">color_set</span> <span class="n">c</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">G.adj</span> <span class="n">v</span> <span class="n">v'</span><span class="o">)</span>
</code></pre></div>



<a name="260481151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260481151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260481151">(Nov 06 2021 at 00:46)</a>:</h4>
<p>I found the idea of <code>β-colorable</code> (would be <code>α-colorable</code> in our case) pretty smart, which constrains the coloring by the elements of the codomain</p>



<a name="260483206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260483206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joanna Choules <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260483206">(Nov 06 2021 at 01:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/graph.20theory/near/260452323">said</a>:</p>
<blockquote>
<p>I guess there's a more general result, which is if <code>G'</code> is a finite graph and if every finite subgraph of <code>G</code> has a homomorphism to <code>G'</code>, then there is a homomorphism from <code>G</code> to <code>G'</code>.</p>
</blockquote>
<p>Do you happen to know if this is already being worked on currently? I thought I would try the proof myself out of curiosity, and I've been making reasonable headway, but I'm conscious of not duplicating effort.</p>



<a name="260483570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260483570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260483570">(Nov 06 2021 at 01:25)</a>:</h4>
<p><span class="user-mention" data-user-id="392901">@Joanna Choules</span> I'm not aware of anyone working on it.  (Are you using <a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system">docs#nonempty_sections_of_fintype_inverse_system</a>? or do you have another approach for the compactness argument?)</p>



<a name="260484381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260484381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260484381">(Nov 06 2021 at 01:40)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> This is a proof that that definition of colorability I gave is "reasonable" (in that it is equivalent to something that's more concrete):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Whether a graph can be colored by at most `n` colors. -/</span>
<span class="kd">def</span> <span class="n">colorable</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">),</span>
<span class="kd">by</span> <span class="n">exactI</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">≤</span> <span class="n">n</span>  <span class="c1">-- the "by exactI" trick is a way to get Lean to notice the `fintype` instance</span>

<span class="kd">def</span> <span class="n">complete_graph.of_embedding</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">↪</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">complete_graph</span> <span class="n">α</span> <span class="bp">↪</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">inj'</span> <span class="o">:=</span> <span class="n">f.inj'</span><span class="o">,</span>
  <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">colorable_if_nonempty_fin_coloring</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.colorable</span> <span class="n">n</span> <span class="bp">↔</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">G.proper_coloring</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="n">αf</span><span class="o">,</span> <span class="n">C</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="n">tactic.unfreeze_local_instances</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="n">fintype.equiv_fin</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding.trans</span> <span class="o">(</span><span class="n">fin.cast_le</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨(</span><span class="n">complete_graph.of_embedding</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">to_hom.comp</span> <span class="n">C</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">C</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">ulift</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span>
      <span class="o">(</span><span class="n">complete_graph.of_embedding</span> <span class="n">equiv.ulift.symm.to_embedding</span><span class="o">)</span><span class="bp">.</span><span class="n">to_hom.comp</span> <span class="n">C</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>There are some universe variable issues that the proof needs to deal with, and it needs <code>tactic.unfreeze_local_instances</code> to get Lean to notice the <code>fintype</code> instance, but other than these technicalities the proof amounts to composing some graph homomorphisms.</p>



<a name="260484511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260484511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260484511">(Nov 06 2021 at 01:44)</a>:</h4>
<p>it's not accepting this line: <code>let f := (fintype.equiv_fin α).to_embedding.trans (fin.cast_le h).to_embedding,</code></p>



<a name="260484556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260484556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260484556">(Nov 06 2021 at 01:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="o">(</span><span class="n">fintype.equiv_fin</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding.trans</span> <span class="o">(</span><span class="n">fin.cast_le</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span>
<span class="n">term</span>
  <span class="o">(</span><span class="n">fin.cast_le</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">fin</span> <span class="n">C.card</span> <span class="bp">↪</span> <span class="n">fin</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">fin</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↪</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="bp">?</span><span class="o">))</span>
</code></pre></div>



<a name="260484637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260484637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260484637">(Nov 06 2021 at 01:46)</a>:</h4>
<p>Something to do with this definition that I added:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.card</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">fintype.card</span> <span class="n">α</span>
</code></pre></div>



<a name="260484890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260484890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joanna Choules <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260484890">(Nov 06 2021 at 01:52)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I plan to use the inverse system approach, yeah. So far I've mainly been working on the scaffolding (establishing a <code>directed_order</code>, defining the system functor), but I think I know how I want the main thread of the proof to go through.</p>



<a name="260485172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485172">(Nov 06 2021 at 01:58)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> do you think this can be useful?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">chromatic_number_is_minimal</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">C.is_minimal</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">chromatic_number</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">C.card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260485189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485189">(Nov 06 2021 at 01:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.is_minimal</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">C'</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">),</span> <span class="n">C.card</span> <span class="bp">≤</span> <span class="n">C'.card</span>
</code></pre></div>



<a name="260485466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485466">(Nov 06 2021 at 02:03)</a>:</h4>
<p>Is <code>C.card</code> defined to be <code>card (set.range C.color)</code>? I thought I saw you define it to be <code>card α</code>, and this theorem wouldn't be true for that.  (Maybe name the set <code>C.support</code> and make the theorem be about <code>card C.support</code>?)  There will be some <code>decidable</code> complaints from lean, so maybe add <code>open_locale classical</code> to avoid this for now.</p>



<a name="260485524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485524">(Nov 06 2021 at 02:04)</a>:</h4>
<p>This is the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.card</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">fintype.card</span> <span class="n">α</span>
</code></pre></div>



<a name="260485649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485649">(Nov 06 2021 at 02:07)</a>:</h4>
<p>Yeah, that's giving you the number of colors, not the number of <em>used</em> colors.</p>



<a name="260485715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485715">(Nov 06 2021 at 02:08)</a>:</h4>
<p>Ah, right</p>



<a name="260485732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485732">(Nov 06 2021 at 02:09)</a>:</h4>
<p>I think these are true:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.chromatic_number_le</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.chromatic_number</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">proper_coloring.zero_le_chromatic_number</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">G.chromatic_number</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">proper_coloring.chromatic_number_minimal</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">C'</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">),</span> <span class="n">set.range</span> <span class="n">C'.color</span> <span class="bp">=</span> <span class="n">set.univ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.chromatic_number</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="260485847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260485847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260485847">(Nov 06 2021 at 02:11)</a>:</h4>
<p>Why do you use <code>def</code> for these instead?</p>



<a name="260486843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260486843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260486843">(Nov 06 2021 at 02:34)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I've uploaded everything to the branch <code>graph-coloring-homomorphism</code></p>



<a name="260486861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260486861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260486861">(Nov 06 2021 at 02:35)</a>:</h4>
<p>That was a mistake -- they were supposed to be <code>lemma</code>s</p>



<a name="260487133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260487133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260487133">(Nov 06 2021 at 02:42)</a>:</h4>
<p>This is potentially a useful variation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">colorable_if_nonempty_fin_coloring'</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.colorable</span> <span class="n">n</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">C.color</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">colorable_if_nonempty_fin_coloring</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">C</span><span class="o">⟩,</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">complete_graph.of_embedding</span> <span class="o">(</span><span class="n">fin.coe_embedding</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">to_embedding</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">f.to_hom.comp</span> <span class="n">C</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">C</span> <span class="k">with</span> <span class="n">color</span> <span class="n">valid</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fin.is_lt</span> <span class="o">(</span><span class="n">color</span> <span class="n">v</span><span class="o">),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">Cf</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">C.color</span> <span class="n">v</span><span class="o">,</span> <span class="n">Cf</span> <span class="n">v</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩⟩,</span>
    <span class="n">rintro</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hvw</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">complete_graph_eq_top</span><span class="o">,</span> <span class="n">top_adj</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">C.valid</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hvw</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260487149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260487149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260487149">(Nov 06 2021 at 02:43)</a>:</h4>
<p>I'm gonna include it in the branch too</p>



<a name="260487207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260487207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260487207">(Nov 06 2021 at 02:45)</a>:</h4>
<p>here: <a href="https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean</a></p>



<a name="260487224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260487224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260487224">(Nov 06 2021 at 02:45)</a>:</h4>
<p>I'm gonna try to pick up that other task to redesign matchings as subgraphs. I think it's simpler <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="260498729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260498729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260498729">(Nov 06 2021 at 07:43)</a>:</h4>
<p>I'm quite happy for this discussion to be going on here but isn't there an entire graph theory stream where you can sort your ideas into different threads which perhaps will be helpful for later reference? Perhaps <span class="user-mention" data-user-id="392901">@Joanna Choules</span> and <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> don't know about it -- it's hidden by default. It would be really great to see some more progress in this area, I think there's plenty to be done and I think we now understand basic design decisions (which held up graph theory for so long) much better so there's now a chance for the area to grow</p>



<a name="260503361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260503361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joanna Choules <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260503361">(Nov 06 2021 at 09:37)</a>:</h4>
<p>Yeah, I just wanted to do a quick status check before ploughing on. If I run into any implementation questions I'll thread them separately.</p>



<a name="260576733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260576733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260576733">(Nov 07 2021 at 14:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> How to create different threads inside a stream? Do you mean we can have the following hierarchy:<br>
<code>maths &gt; graph theory &gt; coloring</code>?</p>



<a name="260577070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260577070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260577070">(Nov 07 2021 at 14:29)</a>:</h4>
<p>There is a separate stream (same level as <code>maths</code>), see <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a></p>



<a name="260670972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/graph%20theory/near/260670972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/graph.20theory.html#260670972">(Nov 08 2021 at 15:20)</a>:</h4>
<p>Posting here too since not everyone has subscribed to <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a> <br>
It's open for reviews: <a href="https://github.com/leanprover-community/mathlib/pull/10210">https://github.com/leanprover-community/mathlib/pull/10210</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
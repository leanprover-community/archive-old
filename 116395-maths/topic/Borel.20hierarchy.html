---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Borel.20hierarchy.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html">Borel hierarchy</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="315011158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315011158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315011158">(Dec 10 2022 at 01:19)</a>:</h4>
<p>I'd like to present my first attempt at a contribution to mathlib. It is the definition of the <a href="https://en.wikipedia.org/wiki/Borel_hierarchy#Boldface_Borel_hierarchy">Borel hierarchy</a> plus some API around it. You can find it (with a bunch of nonsensical garbage in the repo history) <a href="https://github.com/sterraf/mylearninglean/blob/main/src/borel_hierarchy.lean">here</a>.</p>
<p>The linked theory may serve as a refactor of Gouëzel's formalization of the cardinality bound for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>-algebras <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_space.cardinal_generate_measurable_le/src">src#measurable_space.cardinal_generate_measurable_le</a> . I reproved the main theorems in this file using my definitions---from lines 450 onward statements and proofs follow that same file closely.  </p>
<p>One of the main differences is that I have used unions, suprema, etc., indexed by ordinals (as it is customary in the literature) instead of using representatives. Accordingly, the notation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\omega_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is introduced for the <em>ordinal</em> <code>(aleph 1).ord</code> and not for <code>(aleph 1).ord.out.α</code>.</p>
<p>A brief implementation note: I defined the <em>pair</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><msubsup><mi mathvariant="normal">Σ</mi><mi>α</mi><mn>0</mn></msubsup><mo separator="true">,</mo><msubsup><mi mathvariant="normal">Π</mi><mi>α</mi><mn>0</mn></msubsup><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle\Sigma^0_\alpha, \Pi^0_\alpha\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span> by recursion on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, as suggested by Kevin <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310503644">here</a>. I couldn't figure out how to use the more elegant inductive definitions suggested by <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310513474">Junyan Xu</a> in the same thread.</p>
<p>I'd like to hear any comments to enhance the code, in order to prepare a PR. Thanks to all for your help in the past weeks, in particular <span class="user-mention" data-user-id="464202">@Felix Weilacher</span> for some discussions about which were the possible directions the formalization of Descriptive Set Theory could go.</p>



<a name="315028571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315028571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315028571">(Dec 10 2022 at 05:56)</a>:</h4>
<p><span class="user-mention" data-user-id="327749">@Pedro Sánchez Terraf</span> Here's how you might define the Sigma and Pi hierarchies inductively and simultaneously (where <code>ff : bool</code> corresponds to your <code>S</code> and <code>tt</code> corresponds to <code>P</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal.continuum</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">sigma0_pi0_rec</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">basic</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">sigma0_pi0_rec</span> <span class="mi">0</span> <span class="n">u</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">sigma0_pi0_rec</span> <span class="mi">0</span> <span class="bp">∅</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">univ</span> <span class="o">:</span> <span class="n">sigma0_pi0_rec</span> <span class="mi">0</span> <span class="n">set.univ</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">compl</span> <span class="o">{</span><span class="n">i</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">sigma0_pi0_rec</span> <span class="n">i</span> <span class="n">u</span> <span class="n">ff</span> <span class="bp">→</span> <span class="n">sigma0_pi0_rec</span> <span class="n">i</span> <span class="n">u</span><span class="bp">ᶜ</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">union</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">sigma0_pi0_rec</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="n">tt</span><span class="o">)</span> <span class="bp">→</span> <span class="n">sigma0_pi0_rec</span> <span class="n">i</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="n">ff</span>
</code></pre></div>
<p>BTW, <code>nonempty_compl_equiv</code> can be proved using <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.set.image">docs#equiv.set.image</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/compl_injective">docs#compl_injective</a>.</p>



<a name="315057065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315057065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315057065">(Dec 10 2022 at 10:52)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.image">docs#equiv.image</a> combined with <del> <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.compl">docs#equiv.compl</a> </del> is a better spelling that's computable (edit: that doesn't seem to work)</p>



<a name="315057529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315057529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315057529">(Dec 10 2022 at 10:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315028571">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="327749">Pedro Sánchez Terraf</span> Here's how you might define the Sigma and Pi hierarchies inductively and simultaneously (where <code>ff : bool</code> corresponds to your <code>S</code> and <code>tt</code> corresponds to <code>P</code>):</p>
</blockquote>
<p>Thank you very much, I'll give it a try.</p>



<a name="315233441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315233441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315233441">(Dec 11 2022 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315028571">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="327749">Pedro Sánchez Terraf</span> Here's how you might define the Sigma and Pi hierarchies inductively and simultaneously <br>
[...]<br>
BTW, <code>nonempty_compl_equiv</code> can be proved using <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.set.image">docs#equiv.set.image</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/compl_injective">docs#compl_injective</a>.</p>
</blockquote>
<p>I did the second thing and recovered all the main theorems using this alternative definition. The results are <a href="https://github.com/sterraf/mylearninglean/blob/cbef1dac20e3cec8d763ae5868726d0b44d7ec1f/src/borel_hierarchy.lean">here</a>. Nevertheless, working with this alternative definition was more difficult for me, and the new proofs are much longer, having to use extensionality where there was no need before. Most surely I'm missing some tricks, or guidelines to set up an API to make my life easier.</p>
<p>For instance, I could not recover my lemma <a href="https://github.com/sterraf/mylearninglean/blob/cbef1dac20e3cec8d763ae5868726d0b44d7ec1f/src/borel_hierarchy.lean#L209">sigma0_one</a> (commented out in the file linked above). One particular problem I have is that working on this goal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">),</span>
<span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">sigma0_pi0_rec</span> <span class="mi">1</span> <span class="n">ff</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="bp">∅</span><span class="o">,</span> <span class="n">univ</span><span class="o">})),</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">y</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">z</span>
</code></pre></div>
<p>I can't use<code>cases h</code>. The culprit seems to be that the ordinal <code>1</code> does not appear in the inductive definition. The error reads:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">cases</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">unsupported</span> <span class="n">equality</span> <span class="n">between</span> <span class="n">type</span> <span class="n">and</span> <span class="n">constructor</span> <span class="n">indices</span>
<span class="o">(</span><span class="n">only</span> <span class="n">equalities</span> <span class="n">between</span> <span class="n">constructors</span> <span class="n">and</span><span class="bp">/</span><span class="n">or</span> <span class="kd">variables</span> <span class="n">are</span> <span class="n">supported</span><span class="o">,</span> <span class="n">try</span> <span class="n">cases</span> <span class="n">on</span> <span class="n">the</span> <span class="n">indices</span><span class="o">):</span>
<span class="n">quot.mk</span> <span class="n">setoid.r</span> <span class="o">{</span><span class="n">α</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">empty_relation</span> <span class="n">punit</span><span class="o">,</span> <span class="n">wo</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">=</span>
  <span class="n">quot.mk</span> <span class="n">setoid.r</span> <span class="o">{</span><span class="n">α</span> <span class="o">:=</span> <span class="n">pempty</span><span class="o">,</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">empty_relation</span> <span class="n">pempty</span><span class="o">,</span> <span class="n">wo</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>
<p>I'm unable to understand the hint of “trying cases on the indices”. I also tried to use the internal lemmas that arise from the inductive definition, like <code>pointclasses.sigma0_pi0_rec.cases_on</code>, which I can correctly check for type but I can not invoke it using <code>apply</code> inside the proof.</p>



<a name="315234936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315234936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315234936">(Dec 11 2022 at 17:23)</a>:</h4>
<p>Ah because the <code>1</code> is an <code>ordinal</code>.<br>
Probably you could use <code>generalizing</code> somehow to replace it by a variable, together with a hypothesis that it's equal to <code>1</code>, and then use a lemma to eliminate some impossible cases.</p>



<a name="315235133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315235133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315235133">(Dec 11 2022 at 17:25)</a>:</h4>
<p>Looks like another proof growing longer... I'll check it</p>



<a name="315235303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315235303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315235303">(Dec 11 2022 at 17:27)</a>:</h4>
<p>But, <span class="user-mention" data-user-id="110032">@Reid Barton</span> , <code>generalizing</code> is part of an <code>induction</code> tactic, isn't it? But here I have the inductive thing in my hyps, not in my target.</p>



<a name="315235331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315235331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315235331">(Dec 11 2022 at 17:27)</a>:</h4>
<p>Oh sorry, I meant <code>generalize</code></p>



<a name="315235978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315235978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315235978">(Dec 11 2022 at 17:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315235331">said</a>:</p>
<blockquote>
<p>Oh sorry, I meant <code>generalize</code></p>
</blockquote>
<p>Again, it seems that this tactic only operates on the target. It was <code>generalize_hyp</code> <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
<p>EDIT: ... that didn't work either since it forgets that the new variable has value <code>1</code>. I think there was a tactic that did exactly what you are suggesting, but I'm not sure. I'll do it by hand.</p>
<p>EDIT 2:... It was rather circuitous in the end:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set</span> <span class="n">o</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">)</span> <span class="k">with</span> <span class="n">ho</span><span class="o">,</span>
<span class="n">replace</span> <span class="n">h</span> <span class="o">:</span> <span class="n">sigma0_pi0_rec</span> <span class="n">o</span> <span class="n">ff</span> <span class="n">z</span><span class="o">,</span>
<span class="o">{</span> <span class="n">tauto</span> <span class="o">},</span>
<span class="n">clear_value</span> <span class="n">o</span><span class="o">,</span> <span class="c1">-- needed!</span>
</code></pre></div>
<p>Only then I could use <code>cases</code> . Surely there is a better way <span aria-label="cry" class="emoji emoji-1f622" role="img" title="cry">:cry:</span></p>



<a name="315241578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315241578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315241578">(Dec 11 2022 at 18:22)</a>:</h4>
<p><code>induction h</code> apparently works. Seems <code>cases</code> is trying to too many things at once.</p>



<a name="315242031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315242031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315242031">(Dec 11 2022 at 18:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315241578">said</a>:</p>
<blockquote>
<p><code>induction h</code> apparently works. Seems <code>cases</code> is trying to too many things at once.</p>
</blockquote>
<p>I'm <a href="https://github.com/sterraf/mylearninglean/blob/72a22e9799aeee19435bba4c14c8a18a7f25744a/src/borel_hierarchy.lean">done</a>, but I'll try that too. This is unexpected for me, since I thought that tactic was used only when have the inductive object on the target.</p>



<a name="315243464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315243464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315243464">(Dec 11 2022 at 18:39)</a>:</h4>
<p>It's an inductive predicate (inductive family of propositions), so if you do <code>induction</code> on it it will enumerate all possible ways to construct a term of type, i.e. a proof of the proposition, with appropriate inductive hypothesis added to the context (which <code>cases</code> doesn't do).</p>



<a name="315244118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315244118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315244118">(Dec 11 2022 at 18:45)</a>:</h4>
<p>Does it add a hypothesis like <code>0 = 1</code> for the first three cases?</p>



<a name="315244510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315244510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315244510">(Dec 11 2022 at 18:50)</a>:</h4>
<p>No.<br>
Actually, the application of <code>induction</code> succeeds here, but finally I'm stuck again because without the info that the argument was <code>1</code> is lost. Therefore, one of the proof obligations requires me to prove certain closure under complements that is not true (it would if I was proving something general,  but not in this case).</p>



<a name="315244857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315244857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315244857">(Dec 11 2022 at 18:53)</a>:</h4>
<p>To make things clear: What I've been trying is <code>induction h with ...</code>, but now I see there is a different <code>induction h : t</code> which I didn't check before.</p>



<a name="315246498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315246498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315246498">(Dec 11 2022 at 19:08)</a>:</h4>
<p>Yeah I was too optimistic when I said <code>induction</code> works. I can't seem to make it work nicely. <code>ordinal</code> isn't an inductive type so it's not good to do pattern matching on <code>0 : ordinal</code>, but even if I replace the constructors by <code>| empty (i = 0) : sigma0_pi0_rec i tt ∅</code>, <code>induction</code> still doesn't keep the original <code>1</code> but generalizes <code>1</code> to an arbitrary ordinal, which is bad. So the inductive definition apparently doesn't work as nicely as expected, and makes me wonder whether we should just fall back to your original definition by well-founded recursion.</p>



<a name="315247048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247048">(Dec 11 2022 at 19:14)</a>:</h4>
<p>Yeah, I've seen some other awful behavior, like an awkward expansion of the definition of <code>0</code>. Some of that can be seen in the last error message I pasted <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315233441">above</a>, but even in the Infoview at line <a href="https://github.com/sterraf/mylearninglean/blob/72a22e9799aeee19435bba4c14c8a18a7f25744a/src/borel_hierarchy.lean#L131">131 of the file</a>, hypothesis <code>glt</code> <span aria-label="puke" class="emoji emoji-1f92e" role="img" title="puke">:puke:</span></p>



<a name="315247113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247113">(Dec 11 2022 at 19:15)</a>:</h4>
<p>Maybe worth trying <code>induction'</code> as well?</p>



<a name="315247294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247294">(Dec 11 2022 at 19:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315246498">said</a>:</p>
<blockquote>
<p>So the inductive definition apparently doesn't work as nicely as expected, and makes me wonder whether we should just fall back to your original definition by well-founded recursion.</p>
</blockquote>
<p>Haha none of the options work smoothly for me, but the original was apparently more amenable to the standard tactits (at least the ones I remember of the top of my head). Anyway, I did this at another branch, so the original is still alive and kicking.</p>



<a name="315247369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247369">(Dec 11 2022 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247113">said</a>:</p>
<blockquote>
<p>Maybe worth trying <code>induction'</code> as well?</p>
</blockquote>
<p>Is that Lean4?</p>



<a name="315247459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247459">(Dec 11 2022 at 19:18)</a>:</h4>
<p>Or something from the last 3 months? Didn't update mathlib3 since then.</p>



<a name="315247599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247599">(Dec 11 2022 at 19:20)</a>:</h4>
<p>Maybe I can rescue the inductive approach by proving the desired induction principle separately and use that instead of the <code>induction</code> tactic ...</p>



<a name="315247669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247669">(Dec 11 2022 at 19:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#induction'">tactic#induction'</a></p>



<a name="315247731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247731">(Dec 11 2022 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247599">said</a>:</p>
<blockquote>
<p>Maybe I can rescue the inductive approach by proving the desired induction principle separately and use that instead of the <code>induction</code> tactic ...</p>
</blockquote>
<p>I thought a bit about the shape of such an inductive principle, which is obvious in the case of <a href="https://leanprover-community.github.io/mathlib_docs/find/measurable_space.generate_measurable">docs#measurable_space.generate_measurable</a>, but having the ordinal argument confused me.</p>



<a name="315247773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247773">(Dec 11 2022 at 19:22)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean</a></p>



<a name="315247828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315247828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315247828">(Dec 11 2022 at 19:23)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean#L1331">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean#L1331</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">-</span> <span class="n">If</span> <span class="n">the</span> <span class="n">major</span> <span class="n">premise</span> <span class="o">(</span><span class="n">the</span> <span class="n">hypothesis</span> <span class="n">we</span> <span class="n">are</span> <span class="n">performing</span> <span class="n">induction</span> <span class="n">on</span><span class="o">)</span> <span class="n">has</span>
  <span class="n">complex</span> <span class="n">indices</span><span class="o">,</span> <span class="bp">`</span><span class="n">induction'</span><span class="bp">`</span> <span class="bp">'</span><span class="n">remembers'</span> <span class="n">them.</span> <span class="n">A</span> <span class="n">complex</span> <span class="n">expression</span> <span class="n">is</span> <span class="n">any</span>
  <span class="n">expression</span> <span class="n">that</span> <span class="n">is</span> <span class="n">not</span> <span class="n">merely</span> <span class="n">a</span> <span class="kn">local</span> <span class="n">hypothesis.</span> <span class="n">A</span> <span class="n">major</span> <span class="n">premise</span>
  <span class="bp">`</span><span class="n">h</span> <span class="o">:</span> <span class="n">I</span> <span class="n">p₁</span> <span class="bp">...</span> <span class="n">pₙ</span> <span class="n">j₁</span> <span class="bp">...</span> <span class="n">jₘ</span><span class="bp">`</span><span class="o">,</span> <span class="n">where</span> <span class="bp">`</span><span class="n">I</span><span class="bp">`</span> <span class="n">is</span> <span class="n">an</span> <span class="kd">inductive</span> <span class="n">type</span> <span class="k">with</span> <span class="bp">`</span><span class="n">n</span><span class="bp">`</span>
  <span class="kd">parameters</span> <span class="n">and</span> <span class="bp">`</span><span class="n">m</span><span class="bp">`</span> <span class="n">indices</span><span class="o">,</span> <span class="n">has</span> <span class="n">a</span> <span class="n">complex</span> <span class="n">index</span> <span class="k">if</span> <span class="n">any</span> <span class="n">of</span> <span class="n">the</span> <span class="bp">`</span><span class="n">j</span><span class="bp">ᵢ`</span> <span class="n">are</span>
  <span class="n">complex.</span> <span class="n">In</span> <span class="n">this</span> <span class="n">situation</span><span class="o">,</span> <span class="n">standard</span> <span class="bp">`</span><span class="n">induction</span><span class="bp">`</span> <span class="n">effectively</span> <span class="n">forgets</span> <span class="n">the</span> <span class="n">exact</span>
  <span class="n">values</span> <span class="n">of</span> <span class="n">the</span> <span class="n">complex</span> <span class="n">indices</span><span class="o">,</span> <span class="n">which</span> <span class="n">often</span> <span class="n">leads</span> <span class="n">to</span> <span class="n">unprovable</span> <span class="n">goals.</span>
  <span class="bp">`</span><span class="n">induction'</span><span class="bp">`</span> <span class="bp">'</span><span class="n">remembers'</span> <span class="n">them</span> <span class="kd">by</span> <span class="n">adding</span> <span class="n">propositional</span> <span class="n">equalities.</span> <span class="n">As</span> <span class="n">a</span>
  <span class="n">result</span><span class="o">,</span> <span class="n">you</span> <span class="n">may</span> <span class="n">find</span> <span class="n">equalities</span> <span class="n">named</span> <span class="bp">`</span><span class="n">induction_eq</span><span class="bp">`</span> <span class="k">in</span> <span class="n">your</span> <span class="n">goal</span><span class="o">,</span> <span class="n">and</span> <span class="n">the</span>
  <span class="n">induction</span> <span class="n">hypotheses</span> <span class="n">may</span> <span class="n">also</span> <span class="n">quantify</span> <span class="n">over</span> <span class="n">additional</span> <span class="n">equalities.</span>
</code></pre></div>



<a name="315248146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315248146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315248146">(Dec 11 2022 at 19:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247773">said</a>:</p>
<blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean</a></p>
</blockquote>
<p>Yeah, I was not importing it. That's why didn't find it.</p>



<a name="315248155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315248155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315248155">(Dec 11 2022 at 19:26)</a>:</h4>
<p>Oh I vaguely remembered that <code>induction'</code> exists and tried it but was missing the import. Now I added the import but it still fails: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Failed</span> <span class="n">to</span> <span class="n">apply</span> <span class="n">the</span> <span class="o">(</span><span class="n">dependent</span><span class="o">)</span> <span class="n">recursor</span> <span class="n">for</span> <span class="n">pointclasses.sigma0_pi0_rec</span> <span class="n">on</span> <span class="n">h.</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">),</span>
<span class="n">index</span> <span class="o">:</span> <span class="n">ordinal</span><span class="o">,</span>
<span class="n">index_1</span> <span class="o">:</span> <span class="n">bool</span><span class="o">,</span>
<span class="n">index_2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">sigma0_pi0_rec</span> <span class="n">index</span> <span class="n">index_1</span> <span class="n">index_2</span>
<span class="bp">⊢</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span>
    <span class="n">index</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span>
    <span class="n">index_1</span> <span class="bp">=</span> <span class="n">ff</span> <span class="bp">→</span> <span class="n">index_2</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="bp">∅</span><span class="o">,</span> <span class="n">univ</span><span class="o">})),</span> <span class="o">(</span><span class="bp">⋃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">y</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">index_2</span><span class="o">)</span>
</code></pre></div>



<a name="315248209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315248209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315248209">(Dec 11 2022 at 19:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247669">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#induction'">tactic#induction'</a></p>
</blockquote>
<p>Btw, this points nowhere in my end. Missing docs? (though I see them in the sources)</p>



<a name="315248359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315248359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315248359">(Dec 11 2022 at 19:29)</a>:</h4>
<p>Why isn't it mentioned in the tactic page ... that's why I wasn't sure it exists</p>



<a name="315248569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315248569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315248569">(Dec 11 2022 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315248155">said</a>:</p>
<blockquote>
<p>Oh I vaguely remembered that <code>induction'</code> exists and tried it but was missing the import. Now I added the import but it still fails: </p>
</blockquote>
<p>Same here, though I was not so sure because my <code>h</code> was <code>z ∈ sigma0_pi0_rec 1 ff</code> (equivalent to <code>sigma0_pi0_rec 1 ff z</code> isn't it???)</p>



<a name="315249102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315249102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315249102">(Dec 11 2022 at 19:36)</a>:</h4>
<p>Yeah you have an abuse of defeq here: since <code>sigma0_pi0_rec 1 ff</code> is a predicate you should write <code>sigma0_pi0_rec 1 ff z</code>; if you want to use <code>∈</code> you should define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sigma0</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="n">sigma0_pi0_rec</span> <span class="n">i</span> <span class="n">ff</span> <span class="n">s</span><span class="o">}</span>
</code></pre></div>
<p>instead. But that shouldn't affect the execution of the tactic. You can do a <code>change</code> and it still doesn't work.</p>



<a name="315249194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315249194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315249194">(Dec 11 2022 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315248359">said</a>:</p>
<blockquote>
<p>Why isn't it mentioned in the tactic page ... that's why I wasn't sure it exists</p>
</blockquote>
<p>Hmm... that's unfortunate.</p>



<a name="315251700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315251700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315251700">(Dec 11 2022 at 20:05)</a>:</h4>
<p>At least <code>induction'</code> doesn't error out if I replace <code>parameters {α : Type u} (s : set (set α))</code> by <code>variables</code> ... Another reason to avoid <code>parameters</code>? I think it's already banned in mathlib.</p>



<a name="315252661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315252661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315252661">(Dec 11 2022 at 20:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315251700">said</a>:</p>
<blockquote>
<p>At least <code>induction'</code> doesn't error out if I replace <code>parameters {α : Type u} (s : set (set α))</code> by <code>variables</code> ... Another reason to avoid <code>parameters</code>? I think it's already banned in mathlib.</p>
</blockquote>
<p>Oh I didn't know what was the etiquette about that... Once things were more or less settled, I was going to read the docs concerning PRs.</p>
<p>But I noticed that they worked a bit erratically... Sometimes you are asked to provide them explicitly in function calls.</p>



<a name="315252936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315252936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315252936">(Dec 11 2022 at 20:20)</a>:</h4>
<p>Yeah <code>induction'</code> nails it. It's so intelligent that it knows <code>0 ≠ 1</code> in ordinals and generates exactly one goal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sigma0_one</span> <span class="o">:</span>
  <span class="n">sigma0</span> <span class="n">s</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">set.range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="bp">∅</span><span class="o">,</span><span class="n">univ</span><span class="o">}),</span> <span class="bp">⋃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">induction'</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">ordinal.lt_one_iff_zero</span> <span class="n">at</span> <span class="n">h_1</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">h_1</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">pi0</span> <span class="n">s</span> <span class="mi">0</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">pi0_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span> <span class="n">n</span><span class="o">,</span> <span class="n">h</span> <span class="n">n</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>



<a name="315253463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315253463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315253463">(Dec 11 2022 at 20:27)</a>:</h4>
<p>Right at the last line I'm left with this target <code>(⋃ (n : ℕ), ↑⟨f n, _⟩) = ⋃ (n : ℕ), f n</code>, which is discharged using <code>exact rfl</code>. Is that normal?</p>



<a name="315253554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315253554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315253554">(Dec 11 2022 at 20:28)</a>:</h4>
<p>Yes. <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.coe_mk">docs#subtype.coe_mk</a> holds definitionally.</p>



<a name="315253699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315253699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315253699">(Dec 11 2022 at 20:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315253554">said</a>:</p>
<blockquote>
<p>Yes. <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.coe_mk">docs#subtype.coe_mk</a> holds definitionally.</p>
</blockquote>
<p>What I mean is that it seems that <span class="user-mention" data-user-id="224323">@Junyan Xu</span>  didn't have that goal. (His proof doesn't close the goal here).</p>



<a name="315253829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315253829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315253829">(Dec 11 2022 at 20:31)</a>:</h4>
<p>Ah sorry, misunderstood your question.</p>



<a name="315254010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315254010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315254010">(Dec 11 2022 at 20:33)</a>:</h4>
<p>Maybe it's because I didn't use <code>simp</code>? So it's <code>.val</code> here but a coercion <code>↑</code> in your infoview.</p>



<a name="315254174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315254174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315254174">(Dec 11 2022 at 20:35)</a>:</h4>
<p>If I do <code>refine ⟨λ n, ⟨f n, h n⟩, _⟩</code> instead of <code>use</code> I get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="o">{</span><span class="bp">∅</span><span class="o">,</span> <span class="n">univ</span><span class="o">})),</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">⟨</span><span class="n">f</span> <span class="n">n</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span>
</code></pre></div>
<p>which <code>use</code> automatically closes. <code>exact rfl</code> can be replaced by <code>refl</code> BTW.</p>



<a name="315254270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315254270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315254270">(Dec 11 2022 at 20:36)</a>:</h4>
<p>It's strange (and bad) that I can't seem to change the name <code>h_1</code> auto-generated by <code>induction'</code> though ...</p>



<a name="315254433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315254433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315254433">(Dec 11 2022 at 20:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315254010">said</a>:</p>
<blockquote>
<p>Maybe it's because I didn't use <code>simp</code>? So it's <code>.val</code> here but a coercion <code>↑</code> in your infoview.</p>
</blockquote>
<p>I copypasted your code and it doesn't work as is, that's what I mean---but I think it works in your computer. That's the strange thing!<br>
I already pushed it, you can check it <a href="https://github.com/sterraf/mylearninglean/blob/62e7ad4c0de65767636bd2d6b36cf13939ab6581/src/borel_hierarchy.lean#L221">here</a>.</p>



<a name="315254722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315254722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315254722">(Dec 11 2022 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315254270">said</a>:</p>
<blockquote>
<p>It's strange (and bad) that I can't seem to change the name <code>h_1</code> auto-generated by <code>induction'</code> though ...</p>
</blockquote>
<p>You can, the problem is that there are way too many variables: <code>induction' h with _ _ _ _ _ _ _ IH g glt1,</code></p>



<a name="315254813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315254813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315254813">(Dec 11 2022 at 20:43)</a>:</h4>
<p>Nice find! I stopped at <code>h1 h2 h3 h4 h5 h6</code></p>



<a name="315256174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315256174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315256174">(Dec 11 2022 at 21:03)</a>:</h4>
<p>So, what is the final vote on mathlib-appropriate material? <a href="https://github.com/sterraf/mylearninglean/blob/main/src/borel_hierarchy.lean">Well-founded recursion</a> or an <a href="https://github.com/sterraf/mylearninglean/blob/1a6b27f9675b0f3561e29ff7971bc24c8aabafbe/src/borel_hierarchy.lean"><code>inductive</code> definition</a>?</p>
<p>(I mean, the definitions of <code>sigma0_pi0_rec</code>---both versions of the file need not-so-fine tuning.)</p>



<a name="315257358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Borel%20hierarchy/near/315257358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Borel.20hierarchy.html#315257358">(Dec 11 2022 at 21:21)</a>:</h4>
<p>Given that <code>induction'</code> works, I currently prefer <code>inductive</code>.<br>
<code>induction'</code> still isn't perfect though, it doesn't automatically closes goals with <code>0 ≠ 0</code> assumption here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sigma0_pi0_compl</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sigma0_pi0_rec</span> <span class="n">s</span> <span class="n">i</span> <span class="n">ff</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">sigma0_pi0_rec</span> <span class="n">s</span> <span class="n">i</span> <span class="n">tt</span> <span class="n">x</span><span class="bp">ᶜ</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">sigma0_pi0_rec.compl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">induction'</span> <span class="n">h</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">iterate</span> <span class="mi">3</span> <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">hi</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span> <span class="c1">-- `induction'` doesn't know `0 ≠ 0` is false ...</span>
  <span class="n">rwa</span> <span class="bp">←</span> <span class="n">compl_inj_iff.1</span> <span class="n">induction_eq_2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
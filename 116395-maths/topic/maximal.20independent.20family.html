---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/maximal.20independent.20family.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html">maximal independent family</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="232802996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232802996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232802996">(Apr 01 2021 at 18:29)</a>:</h4>
<p>Do we have the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>Does anyone feel they could prove this while I'm having dinner and putting my kids to bed?</p>



<a name="232803159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232803159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232803159">(Apr 01 2021 at 18:30)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> maybe?</p>



<a name="232803548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232803548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232803548">(Apr 01 2021 at 18:32)</a>:</h4>
<p>Maybe this is two separate lemmas?</p>
<ul>
<li>existence of a maximal linearly independent set</li>
<li>the fact that if <code>{i} \union I</code> is not linearly independent and <code>I</code> is then <code>∃ a : R, a ≠ 0 ∧ a • s i ∈ span R (s '' I)</code></li>
</ul>



<a name="232805171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232805171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232805171">(Apr 01 2021 at 18:43)</a>:</h4>
<p>I might spend some time trying this and live streaming on Discord</p>



<a name="232806461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232806461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232806461">(Apr 01 2021 at 18:51)</a>:</h4>
<p>Depending on how long it takes to get children to bed you may get a proof of that out of the matroid merging work too :D</p>



<a name="232807852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232807852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232807852">(Apr 01 2021 at 19:01)</a>:</h4>
<p>I'm assuming this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="c1">-- Zorn</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>and doing the dirty work of showing this is enough. I think you prove the above lemma with <code>zorn_subset</code> in <code>order.zorn</code>(and I won't start on it until I've shown it's enough, which might take a while, finsets are no fun)</p>



<a name="232808947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232808947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232808947">(Apr 01 2021 at 19:08)</a>:</h4>
<p>There's no <code>finset.comap</code> under an injectivity assumption??</p>



<a name="232809174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232809174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232809174">(Apr 01 2021 at 19:10)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.preimage">docs#finset.preimage</a></p>



<a name="232809237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232809237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232809237">(Apr 01 2021 at 19:10)</a>:</h4>
<p>Thanks. The one the other way is called <code>finset.map</code> :-/</p>



<a name="232809266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232809266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232809266">(Apr 01 2021 at 19:10)</a>:</h4>
<p>lol</p>



<a name="232809491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232809491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232809491">(Apr 01 2021 at 19:12)</a>:</h4>
<p>There's <code>finset.map</code> and <code>finset.image</code>.</p>



<a name="232809567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232809567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232809567">(Apr 01 2021 at 19:13)</a>:</h4>
<p>What's the difference? Oh map uses an embedding as the map?</p>



<a name="232810957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232810957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232810957">(Apr 01 2021 at 19:22)</a>:</h4>
<p>Right, so for one of them the resulting finset is computable</p>



<a name="232810981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232810981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232810981">(Apr 01 2021 at 19:22)</a>:</h4>
<p>Oh I see.</p>



<a name="232813306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813306">(Apr 01 2021 at 19:39)</a>:</h4>
<p>I'm back, where is my proof?</p>



<a name="232813410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813410">(Apr 01 2021 at 19:40)</a>:</h4>
<p>More seriously, is there any beginning of proof I should try to continue?</p>



<a name="232813416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813416">(Apr 01 2021 at 19:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="c1">-- Zorn</span>
<span class="gr">sorry</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">exists_maximal_independent'</span> <span class="n">R</span> <span class="n">s</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">,</span> <span class="n">hImaximal</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hImaximal</span> <span class="o">(</span><span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">hImaximal</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.ext_iff</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h2</span> <span class="n">i</span> <span class="k">with</span> <span class="o">⟨</span><span class="bp">-</span><span class="o">,</span> <span class="n">h3</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h3</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">set</span> <span class="n">J</span> <span class="o">:=</span> <span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">with</span> <span class="n">hJ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">linear_dependent_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">hS1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="o">,</span> <span class="n">hS2</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">hiJ</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hIJ</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hiS</span> <span class="o">:</span> <span class="o">(⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hiJ</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_contra</span> <span class="n">hiS'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">linear_independent_iff'</span> <span class="n">at</span> <span class="n">hIlinind</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS2</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="n">finset.preimage</span> <span class="n">S</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">i.1</span><span class="o">,</span> <span class="n">hIJ</span> <span class="n">i.2</span><span class="o">⟩)</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxI</span><span class="o">⟩</span> <span class="n">hx</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">hyI</span><span class="o">⟩</span> <span class="n">hy</span> <span class="n">h</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
    <span class="n">specialize</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">i.1</span><span class="o">,</span> <span class="n">hIJ</span> <span class="n">i.2</span><span class="o">⟩)</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">j.1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hS1</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">finset.sum_preimage</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
      <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxJ</span><span class="o">⟩</span> <span class="n">hxS</span> <span class="n">hxI</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hxI</span><span class="o">,</span>
      <span class="k">suffices</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">set.mem_union</span> <span class="n">at</span> <span class="n">hxJ</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hxJ</span> <span class="k">with</span> <span class="n">hxI</span> <span class="n">hxi</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hiS'</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hxS</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_singleton_iff</span> <span class="n">at</span> <span class="n">hxi</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hxi.symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">j</span> <span class="k">with</span> <span class="n">j</span> <span class="n">hjJ</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_union</span> <span class="n">at</span> <span class="n">hjJ</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hjJ</span> <span class="k">with</span> <span class="n">hjI</span> <span class="n">hji</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hjI</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hiS'</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hj</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_singleton_iff</span> <span class="n">at</span> <span class="n">hji</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hji.symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.mem_preimage</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hj</span> <span class="o">},</span>
    <span class="o">{</span> <span class="gr">sorry</span> <span class="o">}</span>
  <span class="o">},</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232813501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813501">(Apr 01 2021 at 19:40)</a>:</h4>
<p>I left you the Zorn and I'm nearly done with the proof that it implies what you want (I'm still going)</p>



<a name="232813533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813533">(Apr 01 2021 at 19:41)</a>:</h4>
<p>You eat quickly for a Frenchman</p>



<a name="232813600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813600">(Apr 01 2021 at 19:41)</a>:</h4>
<p>Here's the easy part of the Zorn, btw:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="c1">-- Zorn</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">zorn.zorn_subset</span> <span class="o">{</span><span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">|</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)}</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">intros</span> <span class="n">J</span> <span class="n">hIJ</span> <span class="n">hJ</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">hI</span> <span class="n">J</span> <span class="n">hJ</span> <span class="n">hIJ</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232813746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232813746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232813746">(Apr 01 2021 at 19:42)</a>:</h4>
<p>What's left is a variation on <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_independent_bUnion_of_directed">docs#linear_independent_bUnion_of_directed</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_independent_sUnion_of_directed">docs#linear_independent_sUnion_of_directed</a> etc, but I don't think it exists directly.</p>



<a name="232814124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232814124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232814124">(Apr 01 2021 at 19:46)</a>:</h4>
<p>I need to go for my dinner now, there's still some work to do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="c1">-- Zorn</span>
<span class="gr">sorry</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">exists_maximal_independent'</span> <span class="n">R</span> <span class="n">s</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">,</span> <span class="n">hImaximal</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hImaximal</span> <span class="o">(</span><span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">hImaximal</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.ext_iff</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h2</span> <span class="n">i</span> <span class="k">with</span> <span class="o">⟨</span><span class="bp">-</span><span class="o">,</span> <span class="n">h3</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h3</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">set</span> <span class="n">J</span> <span class="o">:=</span> <span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">with</span> <span class="n">hJ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">linear_dependent_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">hS1</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="o">,</span> <span class="n">hS2</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">hiJ</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hIJ</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hiS</span> <span class="o">:</span> <span class="o">(⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hiJ</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_contra</span> <span class="n">hiS'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">linear_independent_iff'</span> <span class="n">at</span> <span class="n">hIlinind</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS2</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="n">finset.preimage</span> <span class="n">S</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">i.1</span><span class="o">,</span> <span class="n">hIJ</span> <span class="n">i.2</span><span class="o">⟩)</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxI</span><span class="o">⟩</span> <span class="n">hx</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">hyI</span><span class="o">⟩</span> <span class="n">hy</span> <span class="n">h</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
    <span class="n">specialize</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">i.1</span><span class="o">,</span> <span class="n">hIJ</span> <span class="n">i.2</span><span class="o">⟩)</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">j.1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hS1</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">finset.sum_preimage</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
      <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxJ</span><span class="o">⟩</span> <span class="n">hxS</span> <span class="n">hxI</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hxI</span><span class="o">,</span>
      <span class="k">suffices</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">set.mem_union</span> <span class="n">at</span> <span class="n">hxJ</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hxJ</span> <span class="k">with</span> <span class="n">hxI</span> <span class="n">hxi</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hiS'</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hxS</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_singleton_iff</span> <span class="n">at</span> <span class="n">hxi</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hxi.symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">j</span> <span class="k">with</span> <span class="n">j</span> <span class="n">hjJ</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_union</span> <span class="n">at</span> <span class="n">hjJ</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hjJ</span> <span class="k">with</span> <span class="n">hjI</span> <span class="n">hji</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hjI</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hiS'</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hj</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_singleton_iff</span> <span class="n">at</span> <span class="n">hji</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hji.symm</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.mem_preimage</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hj</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hIlinind</span> <span class="o">},</span>
  <span class="o">},</span>
  <span class="n">use</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hiJ</span><span class="o">⟩,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232816654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232816654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232816654">(Apr 01 2021 at 20:03)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_linear_independent">docs#exists_linear_independent</a> for <code>division_ring</code>s</p>



<a name="232816840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232816840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232816840">(Apr 01 2021 at 20:05)</a>:</h4>
<p>But it's stated for sets, not for parametrized sets (Patrick's function <code>s : ι → M</code>).</p>



<a name="232817610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232817610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232817610">(Apr 01 2021 at 20:10)</a>:</h4>
<p>This is a nightmare. They are so many statements that are impossible to distinguish on paper yet crazily hard to prove from each other in Lean...</p>



<a name="232817786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232817786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232817786">(Apr 01 2021 at 20:11)</a>:</h4>
<p>I don't know why all these lemmas are written for sets.</p>



<a name="232817817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232817817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232817817">(Apr 01 2021 at 20:11)</a>:</h4>
<p>I'm going to rewrite most of them for indexed families.</p>



<a name="232817960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232817960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232817960">(Apr 01 2021 at 20:12)</a>:</h4>
<p>Weren't these things written initially for sets (even bases were sets at the beginning), and then we realized that indexed families were better but we haven't refactored everything yet?</p>



<a name="232818225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818225">(Apr 01 2021 at 20:14)</a>:</h4>
<p>I could cheat and rewrite what I'm actually interested in in terms of sets, but that would mean one more proof to refactor later.</p>



<a name="232818294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818294">(Apr 01 2021 at 20:15)</a>:</h4>
<p>I have a lecture in 1 hour, then I can refactor many proofs in <code>linear_algebra/linear_independent</code> to use families.</p>



<a name="232818331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818331">(Apr 01 2021 at 20:15)</a>:</h4>
<p>I am guilty of this laziness myself ... <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_maximal_orthonormal">docs#exists_maximal_orthonormal</a></p>



<a name="232818375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818375">(Apr 01 2021 at 20:15)</a>:</h4>
<p>Even if a theorem is about sets (and, e.g., unions), there is no reason to use <code>s : set M</code> + <code>coe</code> instead of <code>s : set α</code> and <code>f ∘ coe</code>.</p>



<a name="232818458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818458">(Apr 01 2021 at 20:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Can you wait till tomorrow morning?</p>



<a name="232818553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818553">(Apr 01 2021 at 20:17)</a>:</h4>
<p>Probably you'll be asleep when (1 hr + 2 hr lecture + time for dinner + time for refactor) passes.</p>



<a name="232818644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818644">(Apr 01 2021 at 20:18)</a>:</h4>
<p>I can definitely wait for tomorrow morning.</p>



<a name="232818878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232818878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232818878">(Apr 01 2021 at 20:20)</a>:</h4>
<p>It's a bit frustrating to be stuck on such a lemma while everything else was straightforward in the little goal I had for the second half of my afternoon: over a pid, finitely generated torsion free modules are free (Anne did all the hard work already).</p>



<a name="232820381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232820381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232820381">(Apr 01 2021 at 20:31)</a>:</h4>
<p>By the way, the first sorry in the big proof has maths proof "if f i = 0 then hS1 says that we have a linear relation on f(I) and hS2 says it's nontrivial, contradicting hIlinind" (which still looks like some pain) and the second is just a rephrasing of hS1 using the fact that J is the disjoint union of I and {i}</p>



<a name="232820590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232820590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232820590">(Apr 01 2021 at 20:32)</a>:</h4>
<p>I'll have a look at that part</p>



<a name="232820944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232820944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232820944">(Apr 01 2021 at 20:34)</a>:</h4>
<p>It's annoying that I gets coerced to a type, somehow I spend far too long dancing between the type corresponding to I and the one corresponding to I union {i}. If we were doing finsupps supported on I or J I think life would be much easier.</p>



<a name="232821014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232821014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232821014">(Apr 01 2021 at 20:35)</a>:</h4>
<p>You just say "if support of f is in I union {i} and f(i) = 0 then the support of f is in I"</p>



<a name="232823944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232823944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232823944">(Apr 01 2021 at 20:57)</a>:</h4>
<p>Another solution maybe to copy the weird setup of <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.has_basis">docs#filter.has_basis</a>. We would have a definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">linear_independent_on</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
</code></pre></div>
<p>which would be equivalent to <code>linear_independent R (λ x : subtype p, s x)</code> with a good interface.</p>



<a name="232825250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232825250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232825250">(Apr 01 2021 at 21:07)</a>:</h4>
<p>I'll take a stab at the following lemma, which should clear up a lot of the mucking about with subtypes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">set.linear_dependent_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">f.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">↑</span><span class="n">f.support</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="o">:=</span>
</code></pre></div>



<a name="232825563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232825563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232825563">(Apr 01 2021 at 21:09)</a>:</h4>
<p>OK, that was not so bad:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">set.linear_dependent_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">finsupp.supported</span> <span class="n">R</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">f.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_independent_comp_subtype</span><span class="o">,</span> <span class="n">not_forall</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">finsupp.total_apply</span><span class="o">,</span> <span class="n">finsupp.sum</span><span class="o">]</span>
</code></pre></div>



<a name="232826982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232826982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232826982">(Apr 01 2021 at 21:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">ι</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">exists_maximal_independent'</span> <span class="n">R</span> <span class="n">s</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">,</span> <span class="n">hImaximal</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hImaximal</span> <span class="o">(</span><span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">J</span> <span class="o">:=</span> <span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">with</span> <span class="n">hJ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">memJ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hJ</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hiJ</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hIJ</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">hImaximal</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hiJ</span> <span class="n">hi</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">supp_f</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.linear_dependent_iff.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hfi</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contrapose</span> <span class="n">hIlinind</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.linear_dependent_iff.mpr</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.mem_supported</span><span class="o">,</span> <span class="n">hJ</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">supp_f</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="n">hx</span><span class="o">))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="n">finsupp.mem_support_iff.mp</span> <span class="n">hx</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="n">hfi</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hfi'</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f.support</span> <span class="o">:=</span> <span class="n">finsupp.mem_support_iff.mpr</span> <span class="n">hfi</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.insert_erase</span> <span class="n">hfi'</span><span class="o">,</span> <span class="n">finset.sum_insert</span> <span class="o">(</span><span class="n">finset.not_mem_erase</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">add_eq_zero_iff_eq_neg</span><span class="o">]</span> <span class="n">at</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">neg_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">sum_mem</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="n">smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">subset_span</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩))),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="o">(</span><span class="n">finset.erase_subset</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hc</span><span class="o">)))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="o">(</span><span class="n">finset.ne_of_mem_erase</span> <span class="n">hc</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232827237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232827237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232827237">(Apr 01 2021 at 21:23)</a>:</h4>
<p>Now we just need to do Zorn</p>



<a name="232828179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232828179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232828179">(Apr 01 2021 at 21:32)</a>:</h4>
<p>Very nice! Yes this is much better than my approach, but I only realised it after struggling with my approach :-)</p>



<a name="232828753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232828753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232828753">(Apr 01 2021 at 21:38)</a>:</h4>
<p>Nearly there, just one <code>sorry</code> that I'm sure is in the library somewhere:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">import</span> <span class="n">order.zorn</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">//</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span> <span class="n">I.1</span> <span class="bp">⊆</span> <span class="n">J.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span><span class="o">,</span> <span class="n">set.subset.trans</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩,</span> <span class="n">hmax</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zorn.exists_maximal_of_chains_bounded</span> <span class="n">_</span> <span class="n">r</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">⋃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">I</span><span class="o">,</span> <span class="n">set.subset_bUnion_of_mem</span><span class="o">⟩)</span> <span class="n">trans</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">hsub</span> <span class="n">hli</span><span class="o">,</span> <span class="n">set.subset.antisymm</span> <span class="n">hsub</span> <span class="o">(</span><span class="n">hmax</span> <span class="o">⟨</span><span class="n">J</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩</span> <span class="n">hsub</span><span class="o">)⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">linear_independent_comp_subtype</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hsupport</span> <span class="n">hsum</span><span class="o">,</span>
    <span class="c1">-- `f` has finite support and `c` is a chain, so there must be an `I ∈ c`</span>
    <span class="c1">-- with `f.support ⊆ I`</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">I_mem</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="bp">↑</span><span class="n">f.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">I</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">linear_independent_comp_subtype.mp</span> <span class="n">I.2</span> <span class="n">f</span> <span class="n">hI</span> <span class="n">hsum</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">set.linear_dependent_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">finsupp.supported</span> <span class="n">R</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">f.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_independent_comp_subtype</span><span class="o">,</span> <span class="n">not_forall</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">finsupp.total_apply</span><span class="o">,</span> <span class="n">finsupp.sum</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">ι</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">exists_maximal_independent'</span> <span class="n">R</span> <span class="n">s</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">,</span> <span class="n">hImaximal</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hImaximal</span> <span class="o">(</span><span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">J</span> <span class="o">:=</span> <span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">with</span> <span class="n">hJ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">memJ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hJ</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hiJ</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">hImaximal</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hiJ</span> <span class="n">hi</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">supp_f</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.linear_dependent_iff.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hfi</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contrapose</span> <span class="n">hIlinind</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.linear_dependent_iff.mpr</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.mem_supported</span><span class="o">,</span> <span class="n">hJ</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">supp_f</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="n">hx</span><span class="o">))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="n">finsupp.mem_support_iff.mp</span> <span class="n">hx</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="n">hfi</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hfi'</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f.support</span> <span class="o">:=</span> <span class="n">finsupp.mem_support_iff.mpr</span> <span class="n">hfi</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.insert_erase</span> <span class="n">hfi'</span><span class="o">,</span> <span class="n">finset.sum_insert</span> <span class="o">(</span><span class="n">finset.not_mem_erase</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">add_eq_zero_iff_eq_neg</span><span class="o">]</span> <span class="n">at</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">neg_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">sum_mem</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="n">smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">subset_span</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩))),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="o">(</span><span class="n">finset.erase_subset</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hc</span><span class="o">)))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="o">(</span><span class="n">finset.ne_of_mem_erase</span> <span class="n">hc</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232829260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232829260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232829260">(Apr 01 2021 at 21:42)</a>:</h4>
<p>Hmm, I can't find the following lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">zorn.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="232829909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232829909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232829909">(Apr 01 2021 at 21:49)</a>:</h4>
<p>Tried messing about with <code>directed</code> but can't make the puzzle fit yet and it's time to go to bed. So I'll let you fill in the last piece :)</p>



<a name="232830257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232830257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232830257">(Apr 01 2021 at 21:52)</a>:</h4>
<p>Full code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">import</span> <span class="n">order.zorn</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">zorn.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">library_search</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">//</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span> <span class="n">I.1</span> <span class="bp">⊆</span> <span class="n">J.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span><span class="o">,</span> <span class="n">set.subset.trans</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩,</span> <span class="n">hmax</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zorn.exists_maximal_of_chains_bounded</span> <span class="n">_</span> <span class="n">r</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">⋃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">I</span><span class="o">,</span> <span class="n">set.subset_bUnion_of_mem</span><span class="o">⟩)</span> <span class="n">trans</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">hsub</span> <span class="n">hli</span><span class="o">,</span> <span class="n">set.subset.antisymm</span> <span class="n">hsub</span> <span class="o">(</span><span class="n">hmax</span> <span class="o">⟨</span><span class="n">J</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩</span> <span class="n">hsub</span><span class="o">)⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">linear_independent_comp_subtype</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hsupport</span> <span class="n">hsum</span><span class="o">,</span>
    <span class="c1">-- `f` has finite support and `c` is a chain, so there must be an `I ∈ c`</span>
    <span class="c1">-- with `f.support ⊆ I`</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">I_mem</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="bp">↑</span><span class="n">f.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">I</span> <span class="o">:=</span>
      <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="n">_</span> <span class="n">c</span> <span class="n">hc</span> <span class="n">f.support</span> <span class="n">hsupport</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">linear_independent_comp_subtype.mp</span> <span class="n">I.2</span> <span class="n">f</span> <span class="n">hI</span> <span class="n">hsum</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">set.linear_dependent_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">finsupp.supported</span> <span class="n">R</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">f.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_independent_comp_subtype</span><span class="o">,</span> <span class="n">not_forall</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">finsupp.total_apply</span><span class="o">,</span> <span class="n">finsupp.sum</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">ι</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">exists_maximal_independent'</span> <span class="n">R</span> <span class="n">s</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">,</span> <span class="n">hImaximal</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hImaximal</span> <span class="o">(</span><span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">J</span> <span class="o">:=</span> <span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">with</span> <span class="n">hJ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">memJ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hJ</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hiJ</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">hImaximal</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hiJ</span> <span class="n">hi</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">supp_f</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.linear_dependent_iff.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hfi</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contrapose</span> <span class="n">hIlinind</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.linear_dependent_iff.mpr</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.mem_supported</span><span class="o">,</span> <span class="n">hJ</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">supp_f</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="n">hx</span><span class="o">))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="n">finsupp.mem_support_iff.mp</span> <span class="n">hx</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="n">hfi</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hfi'</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f.support</span> <span class="o">:=</span> <span class="n">finsupp.mem_support_iff.mpr</span> <span class="n">hfi</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.insert_erase</span> <span class="n">hfi'</span><span class="o">,</span> <span class="n">finset.sum_insert</span> <span class="o">(</span><span class="n">finset.not_mem_erase</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">add_eq_zero_iff_eq_neg</span><span class="o">]</span> <span class="n">at</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">neg_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">sum_mem</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="n">smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">subset_span</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩))),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="o">(</span><span class="n">finset.erase_subset</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hc</span><span class="o">)))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="o">(</span><span class="n">finset.ne_of_mem_erase</span> <span class="n">hc</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232830446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232830446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232830446">(Apr 01 2021 at 21:54)</a>:</h4>
<p>I think the lemma is false because c can be empty.</p>



<a name="232832878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232832878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232832878">(Apr 01 2021 at 22:17)</a>:</h4>
<p>I need to go to bed but we're nearly there: I went for the "just do it by induction" approach but unfortunately I don't have time to finish. I modified the lemma so it should hopefully be true now and I fixed the application:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">import</span> <span class="n">order.zorn</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="kd">lemma</span> <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">zorn.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset.induction_on</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">hac</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">b</span> <span class="n">t</span> <span class="n">hbt</span> <span class="n">htc</span> <span class="n">hbtc</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">htc</span> <span class="o">(</span><span class="n">set.subset.trans</span> <span class="n">_</span> <span class="n">hbtc</span><span class="o">),</span> <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">hbtc</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">set.mem_bUnion_iff</span> <span class="n">at</span> <span class="n">hbc</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">htc</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hic</span><span class="o">,</span> <span class="n">hti</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">hbc</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hjc</span><span class="o">,</span> <span class="n">htj</span><span class="o">⟩,</span>
    <span class="gr">sorry</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">//</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span> <span class="n">I.1</span> <span class="bp">⊆</span> <span class="n">J.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span><span class="o">,</span> <span class="n">set.subset.trans</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩,</span> <span class="n">hmax</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zorn.exists_maximal_of_chains_bounded</span> <span class="n">_</span> <span class="n">r</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">⋃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">I</span><span class="o">,</span> <span class="n">set.subset_bUnion_of_mem</span><span class="o">⟩)</span> <span class="n">trans</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">hsub</span> <span class="n">hli</span><span class="o">,</span> <span class="n">set.subset.antisymm</span> <span class="n">hsub</span> <span class="o">(</span><span class="n">hmax</span> <span class="o">⟨</span><span class="n">J</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩</span> <span class="n">hsub</span><span class="o">)⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">linear_independent_comp_subtype</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hsupport</span> <span class="n">hsum</span><span class="o">,</span>
    <span class="c1">-- `f` has finite support and `c` is a chain, so there must be an `I ∈ c`</span>
    <span class="c1">-- with `f.support ⊆ I`</span>
    <span class="n">by_cases</span> <span class="n">ha</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">a</span> <span class="n">hac</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">I_mem</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="bp">↑</span><span class="n">f.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">I</span> <span class="o">:=</span>
        <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="n">_</span> <span class="n">c</span> <span class="n">a</span> <span class="n">hac</span> <span class="n">hc</span> <span class="n">f.support</span> <span class="n">hsupport</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">linear_independent_comp_subtype.mp</span> <span class="n">I.2</span> <span class="n">f</span> <span class="n">hI</span> <span class="n">hsum</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp.mem_supported'</span> <span class="n">at</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span>
  <span class="n">exists_imp_distrib</span><span class="o">],</span>
      <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span> <span class="n">hc</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">hc</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232833178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232833178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232833178">(Apr 01 2021 at 22:20)</a>:</h4>
<p>You just take the max of i and j to finish it</p>



<a name="232849390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232849390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232849390">(Apr 02 2021 at 01:41)</a>:</h4>
<p>hadn't done lean for a couple days, so finished it up to get unrust a little. all that's needed after the sorry is this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">haveI</span> <span class="o">:</span> <span class="n">is_refl</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">hc.total_of_refl</span> <span class="n">hic</span> <span class="n">hjc</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">j</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">hjc</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">,</span> <span class="n">set.insert_subset</span><span class="o">],</span>
        <span class="n">exact</span> <span class="o">⟨</span><span class="n">htj</span><span class="o">,</span> <span class="n">trans</span> <span class="n">hti</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">i</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">hic</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">,</span> <span class="n">set.insert_subset</span><span class="o">],</span>
        <span class="n">exact</span> <span class="o">⟨</span><span class="n">h</span> <span class="n">htj</span><span class="o">,</span> <span class="n">hti</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>
<p>If I wake up early tomorrow morning I'll try to tidy up to learn the style (tbh, all I know is that  non-terminating <code>simp</code>s  should be replaced with <code>simp only</code>, but gotta start learning somewhere) but have a feeling I won't be the first awake :b</p>



<a name="232881005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881005">(Apr 02 2021 at 09:51)</a>:</h4>
<p>Thanks everybody, you are wonderful!</p>



<a name="232881167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881167">(Apr 02 2021 at 09:53)</a>:</h4>
<p>Tonight I'll open mathlib PR with all that (with proper coauthors) if nobody does it first. Right now, at the bottom of <code>linear_algebra.free_module</code>, right before the section end, if I have the following content. The plan is of course to move preparatory lemmas and definitions into proper place. But it can be helpful to see everything at once if <span class="user-mention" data-user-id="238446">@Anne Baanen</span>  wants to comment on the strategy.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">set</span> <span class="n">submodule</span> <span class="n">function</span> <span class="n">finset</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">zorn.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finset.induction_on</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">hac</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">b</span> <span class="n">t</span> <span class="n">hbt</span> <span class="n">htc</span> <span class="n">hbtc</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">htc</span> <span class="o">(</span><span class="n">set.subset.trans</span> <span class="n">_</span> <span class="n">hbtc</span><span class="o">),</span> <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="bp">⋃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">hbtc</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">set.mem_bUnion_iff</span> <span class="n">at</span> <span class="n">hbc</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">htc</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hic</span><span class="o">,</span> <span class="n">hti</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">hbc</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hjc</span><span class="o">,</span> <span class="n">htj</span><span class="o">⟩,</span>
    <span class="n">haveI</span> <span class="o">:</span> <span class="n">is_refl</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">hc.total_of_refl</span> <span class="n">hic</span> <span class="n">hjc</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">j</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">hjc</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">,</span> <span class="n">set.insert_subset</span><span class="o">],</span>
        <span class="n">exact</span> <span class="o">⟨</span><span class="n">htj</span><span class="o">,</span> <span class="n">trans</span> <span class="n">hti</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">i</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">hic</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">,</span> <span class="n">set.insert_subset</span><span class="o">],</span>
        <span class="n">exact</span> <span class="o">⟨</span><span class="n">h</span> <span class="n">htj</span><span class="o">,</span> <span class="n">hti</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">//</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span> <span class="n">I.1</span> <span class="bp">⊆</span> <span class="n">J.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span><span class="o">,</span> <span class="n">set.subset.trans</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩,</span> <span class="n">hmax</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zorn.exists_maximal_of_chains_bounded</span> <span class="n">_</span> <span class="n">r</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">⋃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">I</span><span class="o">,</span> <span class="n">set.subset_bUnion_of_mem</span><span class="o">⟩)</span> <span class="n">trans</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">hsub</span> <span class="n">hli</span><span class="o">,</span> <span class="n">set.subset.antisymm</span> <span class="n">hsub</span> <span class="o">(</span><span class="n">hmax</span> <span class="o">⟨</span><span class="n">J</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩</span> <span class="n">hsub</span><span class="o">)⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">linear_independent_comp_subtype</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hsupport</span> <span class="n">hsum</span><span class="o">,</span>
    <span class="c1">-- `f` has finite support and `c` is a chain, so there must be an `I ∈ c`</span>
    <span class="c1">-- with `f.support ⊆ I`</span>
    <span class="n">by_cases</span> <span class="n">ha</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">a</span> <span class="n">hac</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">I_mem</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="bp">↑</span><span class="n">f.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">I</span> <span class="o">:=</span>
        <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="n">_</span> <span class="n">c</span> <span class="n">a</span> <span class="n">hac</span> <span class="n">hc</span> <span class="n">f.support</span> <span class="n">hsupport</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">linear_independent_comp_subtype.mp</span> <span class="n">I.2</span> <span class="n">f</span> <span class="n">hI</span> <span class="n">hsum</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp.mem_supported'</span> <span class="n">at</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span>
  <span class="n">exists_imp_distrib</span><span class="o">],</span>
      <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span> <span class="n">hc</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">hc</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">set.linear_dependent_iff</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">finsupp.supported</span> <span class="n">R</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">f.support</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">f</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_independent_comp_subtype</span><span class="o">,</span> <span class="n">not_forall</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">finsupp.total_apply</span><span class="o">,</span> <span class="n">finsupp.sum</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
               <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:=</span> <span class="n">classical.dec_eq</span> <span class="n">ι</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">exists_maximal_independent'</span> <span class="n">R</span> <span class="n">s</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">,</span> <span class="n">hImaximal</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">hIlinind</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hImaximal</span> <span class="o">(</span><span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="n">set</span> <span class="n">J</span> <span class="o">:=</span> <span class="n">I</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="k">with</span> <span class="n">hJ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">memJ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">J</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hJ</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hiJ</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">J</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">mt</span> <span class="n">hImaximal</span> <span class="n">_</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hiJ</span> <span class="n">hi</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">supp_f</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.linear_dependent_iff.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hfi</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contrapose</span> <span class="n">hIlinind</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.linear_dependent_iff.mpr</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">sum_f</span><span class="o">,</span> <span class="n">f_ne</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finsupp.mem_supported</span><span class="o">,</span> <span class="n">hJ</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">supp_f</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="n">hx</span><span class="o">))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hIlinind</span> <span class="o">(</span><span class="n">finsupp.mem_support_iff.mp</span> <span class="n">hx</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="n">hfi</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hfi'</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">f.support</span> <span class="o">:=</span> <span class="n">finsupp.mem_support_iff.mpr</span> <span class="n">hfi</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.insert_erase</span> <span class="n">hfi'</span><span class="o">,</span> <span class="n">finset.sum_insert</span> <span class="o">(</span><span class="n">finset.not_mem_erase</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">add_eq_zero_iff_eq_neg</span><span class="o">]</span> <span class="n">at</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_f</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">neg_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">sum_mem</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="n">smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">subset_span</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩))),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">memJ.mp</span> <span class="o">(</span><span class="n">supp_f</span> <span class="o">(</span><span class="n">finset.erase_subset</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hc</span><span class="o">)))</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="o">(</span><span class="n">finset.ne_of_mem_erase</span> <span class="n">hc</span><span class="o">),</span>
<span class="kd">end</span>

<span class="sd">/-- A module is torsion free if `a • x = 0` implies `a = 0` or `x = 0`. -/</span>
<span class="kd">def</span> <span class="n">torsion_free</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">linear_map.smul_left</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span>  <span class="bp">•</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">smul_algebra_smul_comm</span> <span class="n">b</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">smul_add</span> <span class="n">a</span> <span class="o">}</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span>


<span class="kd">lemma</span> <span class="n">torsion_free.injective_smul_left</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">torsion_free</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">injective</span> <span class="o">(</span><span class="n">linear_map.smul_left</span> <span class="n">M</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">linear_map.ker_eq_bot</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map.mem_ker</span><span class="o">,</span> <span class="n">mem_bot</span><span class="o">],</span>
  <span class="n">change</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hax</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">a</span> <span class="n">x</span> <span class="n">hax</span><span class="o">,</span>
    <span class="n">tauto</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">smul_zero</span> <span class="n">a</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">torsion_free.ker_smul_left</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">torsion_free</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">linear_map.smul_left</span> <span class="n">M</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">ker</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="n">linear_map.ker_eq_bot_of_injective</span> <span class="o">(</span><span class="n">h.injective_smul_left</span> <span class="n">ha</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">finset.prod_eq_mul_prod_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">insert_erase</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">finset.prod_insert</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_mem_erase</span> <span class="n">a</span> <span class="n">s</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">finset.prod_eq_prod_erase_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">erase</span> <span class="n">s</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.prod_eq_mul_prod_erase</span> <span class="n">h</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">fintype.prod_eq_mul_prod_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">erase</span> <span class="n">univ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">finset.prod_eq_mul_prod_erase</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_univ</span> <span class="n">a</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">fintype.prod_eq_prod_erase_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">i</span> <span class="k">in</span> <span class="n">erase</span> <span class="n">univ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">finset.prod_eq_prod_erase_mul</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_univ</span> <span class="n">a</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">linear_map.map_span_le</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">N</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">map_span</span><span class="o">,</span> <span class="n">span_le</span><span class="o">,</span> <span class="n">set.image_subset_iff</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">iff.rfl</span>
<span class="kd">end</span>


<span class="kd">lemma</span> <span class="n">module.free_of_finite_type_torsion_free</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">range</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">torsion_free</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">M</span><span class="o">),</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span>
          <span class="n">indepI</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">),</span>
          <span class="n">hI</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)⟩</span> <span class="o">:=</span>
    <span class="n">exists_maximal_independent</span> <span class="n">R</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">range</span> <span class="bp">$</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)),</span> <span class="c1">-- same as `span R (s '' I)` but more convenient</span>
  <span class="k">let</span> <span class="n">sI</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">N</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="n">i.1</span><span class="o">,</span> <span class="n">subset_span</span> <span class="o">(</span><span class="n">mem_range_self</span> <span class="n">i</span><span class="o">)⟩,</span> <span class="c1">-- `s` restricted to `I`</span>
  <span class="k">have</span> <span class="n">sI_basis</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="n">sI</span><span class="o">,</span> <span class="c1">-- `s` restricted to `I` is a basis of `N`</span>
    <span class="k">from</span> <span class="n">is_basis_span</span> <span class="n">indepI</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">exists_a</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">zero_ne_one.symm</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">one_smul</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">subset_span</span> <span class="o">(</span><span class="n">mem_range_self</span> <span class="o">(⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">I</span><span class="o">))</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">image_eq_range</span> <span class="n">s</span> <span class="n">I</span><span class="o">]</span> <span class="n">using</span> <span class="n">hI</span> <span class="n">i</span> <span class="n">hi</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">choose</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">ha'</span> <span class="n">using</span> <span class="n">exists_a</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.prod_ne_zero_iff</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">ha</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">linear_map.smul_left</span> <span class="n">M</span> <span class="n">A</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">φ.ker</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">h.ker_smul_left</span> <span class="n">ha</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ψ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">φ.range</span> <span class="o">:=</span> <span class="n">linear_equiv.of_injective</span> <span class="n">φ</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">φ.range</span> <span class="bp">≤</span> <span class="n">N</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">φ</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map.range</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hs</span><span class="o">,</span> <span class="n">φ.map_span_le</span><span class="o">],</span>
      <span class="n">rintros</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">apply</span> <span class="n">this</span> <span class="o">},</span>
    <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="k">calc</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span><span class="o">,</span> <span class="n">a</span> <span class="n">j</span><span class="o">)</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.erase</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">j</span><span class="o">)</span> <span class="bp">•</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fintype.prod_eq_prod_erase_mul</span> <span class="n">i</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">]</span>
                      <span class="bp">...</span> <span class="bp">∈</span> <span class="n">N</span>  <span class="o">:</span> <span class="n">N.smul_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">ha'</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">φ.range</span><span class="o">,</span> <span class="n">hB</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="n">B</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">submodule.exists_is_basis_of_le</span> <span class="n">this</span> <span class="n">sI_basis</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">ψ.symm</span> <span class="bp">∘</span> <span class="n">B</span><span class="o">,</span> <span class="n">linear_equiv.is_basis</span> <span class="n">hB</span> <span class="n">ψ.symm</span><span class="o">⟩</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232881346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881346">(Apr 02 2021 at 09:55)</a>:</h4>
<p>Note for everyone: since the final lemma is pretty important, I tried to write it in a readable style. I'd be interested in people skipping everything and trying to read it, without tactic state help. Let me copy it again on its own:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">module.free_of_finite_type_torsion_free</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">range</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">torsion_free</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">M</span><span class="o">),</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span>
          <span class="n">indepI</span> <span class="o">:</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">),</span>
          <span class="n">hI</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∉</span> <span class="n">I</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">''</span> <span class="n">I</span><span class="o">)⟩</span> <span class="o">:=</span>
    <span class="n">exists_maximal_independent</span> <span class="n">R</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">range</span> <span class="bp">$</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)),</span> <span class="c1">-- same as `span R (s '' I)` but more convenient</span>
  <span class="k">let</span> <span class="n">sI</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">N</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="n">i.1</span><span class="o">,</span> <span class="n">subset_span</span> <span class="o">(</span><span class="n">mem_range_self</span> <span class="n">i</span><span class="o">)⟩,</span> <span class="c1">-- `s` restricted to `I`</span>
  <span class="k">have</span> <span class="n">sI_basis</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="n">sI</span><span class="o">,</span> <span class="c1">-- `s` restricted to `I` is a basis of `N`</span>
    <span class="k">from</span> <span class="n">is_basis_span</span> <span class="n">indepI</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">exists_a</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">zero_ne_one.symm</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">one_smul</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">subset_span</span> <span class="o">(</span><span class="n">mem_range_self</span> <span class="o">(⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">I</span><span class="o">))</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">image_eq_range</span> <span class="n">s</span> <span class="n">I</span><span class="o">]</span> <span class="n">using</span> <span class="n">hI</span> <span class="n">i</span> <span class="n">hi</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">choose</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">ha'</span> <span class="n">using</span> <span class="n">exists_a</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">∏</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.prod_ne_zero_iff</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">ha</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">linear_map.smul_left</span> <span class="n">M</span> <span class="n">A</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">φ.ker</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">h.ker_smul_left</span> <span class="n">ha</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ψ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">φ.range</span> <span class="o">:=</span> <span class="n">linear_equiv.of_injective</span> <span class="n">φ</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">φ.range</span> <span class="bp">≤</span> <span class="n">N</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">φ</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map.range</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hs</span><span class="o">,</span> <span class="n">φ.map_span_le</span><span class="o">],</span>
      <span class="n">rintros</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">apply</span> <span class="n">this</span> <span class="o">},</span>
    <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="k">calc</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span><span class="o">,</span> <span class="n">a</span> <span class="n">j</span><span class="o">)</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∏</span> <span class="n">j</span> <span class="k">in</span> <span class="n">finset.univ.erase</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">j</span><span class="o">)</span> <span class="bp">•</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">s</span> <span class="n">i</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">fintype.prod_eq_prod_erase_mul</span> <span class="n">i</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">]</span>
                      <span class="bp">...</span> <span class="bp">∈</span> <span class="n">N</span>  <span class="o">:</span> <span class="n">N.smul_mem</span> <span class="n">_</span> <span class="o">(</span><span class="n">ha'</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">φ.range</span><span class="o">,</span> <span class="n">hB</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="n">B</span><span class="o">⟩</span> <span class="o">:=</span>
    <span class="n">submodule.exists_is_basis_of_le</span> <span class="n">this</span> <span class="n">sI_basis</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">ψ.symm</span> <span class="bp">∘</span> <span class="n">B</span><span class="o">,</span> <span class="n">linear_equiv.is_basis</span> <span class="n">hB</span> <span class="n">ψ.symm</span><span class="o">⟩</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232881465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881465">(Apr 02 2021 at 09:57)</a>:</h4>
<p>We should probably also discuss introducing more definitions, like "finite type module" and "free module", but maybe not.</p>



<a name="232881481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881481">(Apr 02 2021 at 09:57)</a>:</h4>
<p>We've been waiting for this result for years :-)</p>



<a name="232881705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881705">(Apr 02 2021 at 10:00)</a>:</h4>
<p>Let me quote myself from yesterday: "Anne did all the hard work already"</p>



<a name="232881786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232881786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232881786">(Apr 02 2021 at 10:00)</a>:</h4>
<p>The hard work is proving a submodule of a free module is free (with appropriate assumptions).</p>



<a name="232882156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232882156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232882156">(Apr 02 2021 at 10:05)</a>:</h4>
<p>Related: the structure theorem for f.g. modules over a PID R says they're isomorphic to the direct sum of finitely many modules of the form R/(f) and one can go further to say something about uniqueness of the f's in question (this is a bit subtle and there are several approaches, but for example if you restrict the f's to be 0 or positive powers of irreducibles then the multiset is well defined up to associates). How close are we to this general statement?</p>



<a name="232888617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232888617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232888617">(Apr 02 2021 at 11:28)</a>:</h4>
<p>There is an intermediate statement that is easy with what we now have: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mi>T</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⊕</mo><mi>T</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M/Tor(M) \oplus Tor(M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mi>T</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M/Tor(M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> is free and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Tor(M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> is... torsion. Then the big piece is classification of torsion modules. This is indeed subtle, already with abelian groups. In the abelian group case there are shortcuts, but I'm not sure mathlib is interested in shortcuts.</p>



<a name="232889701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232889701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232889701">(Apr 02 2021 at 11:43)</a>:</h4>
<p>We know the torsion-free quotient is free so we can deduce it's projective and hence the surjection splits :-) I think I made a PR about this recently!</p>



<a name="232889771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232889771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232889771">(Apr 02 2021 at 11:44)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6813">#6813</a></p>



<a name="232897323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232897323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232897323">(Apr 02 2021 at 13:16)</a>:</h4>
<p>I wasn't aware of this PR. With it the result is indeed even more within reach...</p>



<a name="232897375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232897375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232897375">(Apr 02 2021 at 13:16)</a>:</h4>
<p>Oh I was only being half-serious: of course freeness implies the surjection splits immediately :-)</p>



<a name="232897499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232897499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232897499">(Apr 02 2021 at 13:18)</a>:</h4>
<p>You should be careful when writing that anything is immediate in mathlib linear algebra.</p>



<a name="232909186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232909186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232909186">(Apr 02 2021 at 15:05)</a>:</h4>
<p>Isn't the <a href="https://leanprover-community.github.io/mathlib_docs/find/no_zero_smul_divisors">docs#no_zero_smul_divisors</a> class the same as the definition of torsion_free above?</p>



<a name="232909966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232909966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232909966">(Apr 02 2021 at 15:11)</a>:</h4>
<p>And <code>linear_map.smul_left</code> is called <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.lsmul">docs#linear_map.lsmul</a> (see also <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.lsmul_injective">docs#linear_map.lsmul_injective</a>).</p>



<a name="232911911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232911911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232911911">(Apr 02 2021 at 15:25)</a>:</h4>
<p>The proof of the final lemma is readable enough for a long tactic proof, I'd add a couple of comments highlighting the strategy ("let <code>N</code> be the submodule spanned by a maximal lin.ind. subset of <code>s</code>", "then there is an <code>A</code> such that <code>∀ x, A • x ∈ N</code>", "the basis on <code>N</code> gives a basis on <code>A • M</code>, which gives a basis on <code>M</code>")</p>



<a name="232927234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232927234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232927234">(Apr 02 2021 at 17:26)</a>:</h4>
<p>Thanks Anne. <a href="https://leanprover-community.github.io/mathlib_docs/find/no_zero_smul_divisors">docs#no_zero_smul_divisors</a> is indeed the correct definition, but with a very unfriendly name. I think we should at least write "torsion free" in the docstring. I did grep for torsion before writing my definition.</p>



<a name="232930479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232930479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232930479">(Apr 02 2021 at 17:52)</a>:</h4>
<p>Should we add <code>torsion_free</code> as an <code>abbreviation</code> like we do with <code>vector_space</code>?</p>



<a name="232933168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232933168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232933168">(Apr 02 2021 at 18:14)</a>:</h4>
<p>I know a slightly different definition of torsion-free: if <code>c • x = 0</code>, then <code>x = 0</code> or <code>c</code> is a zero divisor. Of course, we should mention "torsion free" in <code>no_zero_smul_divisors</code>.</p>



<a name="232934571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232934571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232934571">(Apr 02 2021 at 18:25)</a>:</h4>
<p>So <code>[no_zero_divisors R] [torsion_free R M]</code> would imply <code>[no_zero_smul_divisors R M]</code>?</p>



<a name="232937098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232937098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232937098">(Apr 02 2021 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/maximal.20independent.20family/near/232881465">said</a>:</p>
<blockquote>
<p>We should probably also discuss introducing more definitions, like "finite type module" and "free module", but maybe not.</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/module.finite">docs#module.finite</a> already exists</p>



<a name="232946987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232946987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232946987">(Apr 02 2021 at 20:21)</a>:</h4>
<p>I can quite believe that torsion-free becomes an ambiguous concept when the underlying ring has zero divisors</p>



<a name="232947418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232947418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232947418">(Apr 02 2021 at 20:25)</a>:</h4>
<p>In general if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-module and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> there is a canoniccal map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mi>a</mi><mi>n</mi><mi>n</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M/ann(a) \cdot M \to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> given by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>↦</mo><mi>a</mi><mo>⋅</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m \mapsto a \cdot m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>. I guess the "correct(?)" general definition is to say that this map is injective for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>? In this sense flat modules are torsion free in general.</p>



<a name="232954407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/232954407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#232954407">(Apr 02 2021 at 21:28)</a>:</h4>
<p>(and over a principal ideal <strong>ring</strong>, flat is equivalent to torsion free with this definition)</p>



<a name="233003114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003114">(Apr 03 2021 at 12:27)</a>:</h4>
<p>I just checked my notes from my lecture in early December: as the very beginning of the section about Torsion I wrote that all rings in this section are domains.</p>



<a name="233003178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003178">(Apr 03 2021 at 12:28)</a>:</h4>
<p>It's like factoring perhaps -- you can try and struggle along to make some kind of a general theory, but if you can solve <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">xy=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> in a non-trivial way then factoring is not going to be much fun.</p>



<a name="233003342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003342">(Apr 03 2021 at 12:31)</a>:</h4>
<p>Kevin, since you're here and I'm cleaning up this story before PRing, let me tell you about a trick you missed.</p>



<a name="233003346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003346">(Apr 03 2021 at 12:31)</a>:</h4>
<p>You wrote</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>
<span class="kn">import</span> <span class="n">order.zorn</span>

<span class="kn">open</span> <span class="n">submodule</span> <span class="n">set</span>

<span class="kd">lemma</span> <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">zorn.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent'</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">//</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span> <span class="n">I.1</span> <span class="bp">⊆</span> <span class="n">J.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span><span class="o">,</span> <span class="n">set.subset.trans</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩,</span> <span class="n">hmax</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zorn.exists_maximal_of_chains_bounded</span> <span class="n">_</span> <span class="n">r</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">⋃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">I</span><span class="o">,</span> <span class="n">set.subset_bUnion_of_mem</span><span class="o">⟩)</span> <span class="n">trans</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">hsub</span> <span class="n">hli</span><span class="o">,</span> <span class="n">set.subset.antisymm</span> <span class="n">hsub</span> <span class="o">(</span><span class="n">hmax</span> <span class="o">⟨</span><span class="n">J</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩</span> <span class="n">hsub</span><span class="o">)⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">linear_independent_comp_subtype</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hsupport</span> <span class="n">hsum</span><span class="o">,</span>
    <span class="c1">-- `f` has finite support and `c` is a chain, so there must be an `I ∈ c`</span>
    <span class="c1">-- with `f.support ⊆ I`</span>
    <span class="n">by_cases</span> <span class="n">ha</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">a</span> <span class="n">hac</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">I_mem</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="bp">↑</span><span class="n">f.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">I</span> <span class="o">:=</span>
        <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="n">_</span> <span class="n">c</span> <span class="n">a</span> <span class="n">hac</span> <span class="n">hc</span> <span class="n">f.support</span> <span class="n">hsupport</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">linear_independent_comp_subtype.mp</span> <span class="n">I.2</span> <span class="n">f</span> <span class="n">hI</span> <span class="n">hsum</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp.mem_supported'</span> <span class="n">at</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span>
  <span class="n">exists_imp_distrib</span><span class="o">],</span>
      <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span> <span class="n">hc</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">hc</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">exists_maximal_independent''</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">I</span> <span class="bp">⊆</span> <span class="n">J</span> <span class="bp">→</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">J</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">J</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span> <span class="bp">//</span> <span class="n">linear_independent</span> <span class="n">R</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">coe</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span><span class="o">,</span> <span class="n">I.1</span> <span class="bp">⊆</span> <span class="n">J.1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span><span class="o">,</span> <span class="n">set.subset.trans</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩,</span> <span class="n">hmax</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zorn.exists_maximal_of_chains_bounded</span> <span class="n">_</span> <span class="n">r</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="bp">⋃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">I</span><span class="o">,</span> <span class="n">set.subset_bUnion_of_mem</span><span class="o">⟩)</span> <span class="n">trans</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hli</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">hsub</span> <span class="n">hli</span><span class="o">,</span> <span class="n">set.subset.antisymm</span> <span class="n">hsub</span> <span class="o">(</span><span class="n">hmax</span> <span class="o">⟨</span><span class="n">J</span><span class="o">,</span> <span class="n">hli</span><span class="o">⟩</span> <span class="n">hsub</span><span class="o">)⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">linear_independent_comp_subtype</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">f</span> <span class="n">hsupport</span> <span class="n">hsum</span><span class="o">,</span>
    <span class="c1">-- `f` has finite support and `c` is a chain, so there must be an `I ∈ c`</span>
    <span class="c1">-- with `f.support ⊆ I`</span>
    <span class="n">by_cases</span> <span class="n">ha</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">a</span> <span class="n">hac</span><span class="o">,</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">I_mem</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="bp">↑</span><span class="n">f.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">I</span> <span class="o">:=</span>
        <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="n">_</span> <span class="n">c</span> <span class="n">a</span> <span class="n">hac</span> <span class="n">hc</span> <span class="n">f.support</span> <span class="n">hsupport</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">linear_independent_comp_subtype.mp</span> <span class="n">I.2</span> <span class="n">f</span> <span class="n">hI</span> <span class="n">hsum</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp.mem_supported'</span> <span class="n">at</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hsupport</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">subtype.exists</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span>
  <span class="n">exists_imp_distrib</span><span class="o">],</span>
      <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span> <span class="n">hc</span><span class="o">,</span>
      <span class="n">exfalso</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">hc</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233003410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003410">(Apr 03 2021 at 12:32)</a>:</h4>
<p>Note the line <code>by_cases ha : ∃ a : X, a ∈ c,</code>. The interesting case is of course the case where <code>a</code> exists. But the proof in the other case is much longer and painful.</p>



<a name="233003458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003458">(Apr 03 2021 at 12:33)</a>:</h4>
<p>Right -- this was to work around Anne's slightly false lemma.</p>



<a name="233003464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003464">(Apr 03 2021 at 12:33)</a>:</h4>
<p>Since about one year ago, we have a very nice pattern to deal with this. Replace the <code>by_cases</code> line with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rcases</span> <span class="n">eq_empty_or_nonempty</span> <span class="n">c</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">hac</span><span class="o">⟩,</span>
</code></pre></div>



<a name="233003481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003481">(Apr 03 2021 at 12:33)</a>:</h4>
<p>Note that goals now come in the reversed order (the empty case comes first).</p>



<a name="233003525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003525">(Apr 03 2021 at 12:34)</a>:</h4>
<p>But the whole proof in that annoying empty case is now: <code>simpa using hsupport,</code></p>



<a name="233003536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003536">(Apr 03 2021 at 12:34)</a>:</h4>
<p>Oh nice!</p>



<a name="233003544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003544">(Apr 03 2021 at 12:34)</a>:</h4>
<p>Yeah I agree "there doesn't exist c" was not the most appealing way of saying that c was empty :-)</p>



<a name="233003578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003578">(Apr 03 2021 at 12:34)</a>:</h4>
<p>By the way, now you're here you can tell me what I'm doing wrong with push_neg in #general ;-)</p>



<a name="233003591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233003591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233003591">(Apr 03 2021 at 12:35)</a>:</h4>
<p>I encourage you to put that code in the editor (I posted a mwe) and see the miracle occur to internalize it.</p>



<a name="233097818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233097818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233097818">(Apr 04 2021 at 16:57)</a>:</h4>
<p>I'm still very slowly working towards PRing the code from this thread. I have a location problem with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finset.exists_mem_subset_of_subset_bUnion_of_chain</span> <span class="o">{</span><span class="n">α</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">zorn.chain</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">⋃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">c</span><span class="o">,</span> <span class="bp">↑</span><span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
</code></pre></div>
<p>It needs <code>finset</code> and <a href="https://leanprover-community.github.io/mathlib_docs/find/zorn.chain">docs#zorn.chain</a>. But it doesn't use anything Zorny apart from this definition. Where should it go? One option would be to but it in <code>finset.basic</code> but spell out the definition of <code>zorn.chain</code>, but it would make it less readable, especially since this definition is in term of <a href="https://leanprover-community.github.io/mathlib_docs/find/pairwise.pairwise_on">docs#pairwise.pairwise_on</a> which is not so common. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> any opinion here?</p>



<a name="233098006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233098006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233098006">(Apr 04 2021 at 17:00)</a>:</h4>
<p>Actually it also uses <a href="https://leanprover-community.github.io/mathlib_docs/find/zorn.chain.total_of_refl">docs#zorn.chain.total_of_refl</a> which is the very first lemma after the definition.</p>



<a name="233098286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233098286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233098286">(Apr 04 2021 at 17:04)</a>:</h4>
<p>I'm pretty sure the answer is to remove <code>chain</code> from the <code>zorn</code> namespace and file, but that's not very convenient in the middle of a different project</p>



<a name="233098310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233098310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233098310">(Apr 04 2021 at 17:04)</a>:</h4>
<p>Actually I never realized we had this definition of chain avoiding to say anything about reflexivity of the relation.</p>



<a name="233099364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233099364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233099364">(Apr 04 2021 at 17:22)</a>:</h4>
<p>Actually, you could also use <code>directed_on</code>, because it’s true just assuming that</p>



<a name="233099380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233099380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233099380">(Apr 04 2021 at 17:22)</a>:</h4>
<p>And there might be something in the <code>compactly_generated</code> file that makes that obvious</p>



<a name="233099415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233099415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233099415">(Apr 04 2021 at 17:23)</a>:</h4>
<p>That would be really nice!</p>



<a name="233099493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233099493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233099493">(Apr 04 2021 at 17:25)</a>:</h4>
<p>But it's dinner time, so I'll investigate this later (unless you do it in the mean time).</p>



<a name="233100978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233100978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233100978">(Apr 04 2021 at 17:52)</a>:</h4>
<p>I don't actually think anything in that file will make this lemma obvious, but it would be good to prove the maximal independent family results at the <code>compactly_generated</code> generality.</p>



<a name="233119411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119411">(Apr 04 2021 at 23:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/maximal.20independent.20family/near/232881346">said</a>:</p>
<blockquote>
<p>Note for everyone: since the final lemma is pretty important, I tried to write it in a readable style. I'd be interested in people skipping everything and trying to read it, without tactic state help. Let me copy it again on its own:</p>
</blockquote>
<p>I tried this out -- just reading the proof from your message, with no interaction with Lean. I found it generally quite readable, with a few rough spots.</p>
<p>The major rough spot was here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="o">:</span> <span class="n">φ.range</span> <span class="bp">≤</span> <span class="n">N</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">φ</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map.range</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hs</span><span class="o">,</span> <span class="n">φ.map_span_le</span><span class="o">],</span>
      <span class="n">rintros</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">apply</span> <span class="n">this</span> <span class="o">},</span>
</code></pre></div>
<p>It's not hard to see in a paper-proof sense why the first line follows from the second. But this was the one place where I found I really couldn't follow in my head what the steps in the proof were doing. I think the major reason is that I found it hard to guess what <code>linear_map.range</code> and <code>φ.map_span_le</code> meant.</p>



<a name="233119480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119480">(Apr 04 2021 at 23:13)</a>:</h4>
<p><code>linear_map.range</code> will be the range (i.e. the image) of a linear map. We don't use "image" because we use image to mean the image of a subspace under the linear map; the range is the image of the full source space.</p>



<a name="233119554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119554">(Apr 04 2021 at 23:14)</a>:</h4>
<p><code>φ</code> has type <code>linear_map</code> so <code>φ.map_span_le</code> means <code>linear_map.map_span_le φ</code>, and this function is defined in Patrick's code.</p>



<a name="233119620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119620">(Apr 04 2021 at 23:15)</a>:</h4>
<p>If you're looking at the code in VS Code then you can click within the brackets in the <code>rw</code> line and see how the goal is changing as the results are applied.</p>



<a name="233119659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119659">(Apr 04 2021 at 23:16)</a>:</h4>
<p>One minor rough spot was here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.prod_ne_zero_iff</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">ha</span> <span class="o">},</span>
</code></pre></div>
<p>where at first glance it appears to be trying to do something circular. It's not, of course, but the name <code>ha</code> is being reused.</p>
<p>The remaining small rough spots were all just a matter of seeing a reference to some hypothesis by a very terse name, and having to search a ways up in the proof to find what it meant. This happens with <code>h</code>, <code>hs</code>, and <code>ha'</code> at least. In a paper proof, naturally those would be spelled more like "Because M is torsion-free,". Perhaps some names more in the style of <code>sI_basis</code> would help.</p>



<a name="233119682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119682">(Apr 04 2021 at 23:17)</a>:</h4>
<p>You are reading this proof within a VS Code session, right? These things are not written to be read by just staring at the code.</p>



<a name="233119746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119746">(Apr 04 2021 at 23:18)</a>:</h4>
<p>Certainly they often aren't, but Patrick had said he was interested in polishing this one to that level of readability.</p>



<a name="233119769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119769">(Apr 04 2021 at 23:19)</a>:</h4>
<p>The way I typically make this sort of stuff readable in that way is just to add in comments explaining the mathematical steps which are happening in the code.</p>



<a name="233119772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119772">(Apr 04 2021 at 23:19)</a>:</h4>
<p>Which I think is a nice thing to aim for when polishing a proof one likes, even though it probably isn't practical for the whole library.</p>



<a name="233119779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119779">(Apr 04 2021 at 23:19)</a>:</h4>
<p>I think that mathlib would be a better place if there were more comments in code!</p>



<a name="233119782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119782">(Apr 04 2021 at 23:19)</a>:</h4>
<p>Very likely!</p>



<a name="233119843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119843">(Apr 04 2021 at 23:20)</a>:</h4>
<p>Not for the mathematical trivialities (e.g. 3000 lines of lemmas about finsets all of which take 1 or 2 cryptic lines of term mode and all of which are obvious to a mathematician), but for the deeper stuff, so a human can read along without having to fire up VS Code.</p>



<a name="233119892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119892">(Apr 04 2021 at 23:22)</a>:</h4>
<p>See for example <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/82c70345ff3246a74f92f32e9418e4d23de6d66d/src/week_4/solutions/Part_C_topology.lean#L144">the way I teach Lean to mathematicians</a>.</p>



<a name="233119901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119901">(Apr 04 2021 at 23:22)</a>:</h4>
<p>Where applicable I think it's better yet to have names that make clear the same thing that a comment would. So for example instead of <code>h.ker_smul_left ha, -- here we use that M is torsion-free</code>, one could write something like <code>M_torsion_free.ker_smul_left ha</code>.</p>



<a name="233119944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233119944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233119944">(Apr 04 2021 at 23:22)</a>:</h4>
<p>You can't write that because here one is using dot notation -- this doesn't offer the flexibility which you're thinking about.</p>



<a name="233120006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233120006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233120006">(Apr 04 2021 at 23:24)</a>:</h4>
<p>Oh I see -- I think you're suggesting more long-winded hypothesis names. Yes I do think you have a point -- I hardly ever use <code>h</code>, I usually use stuff like <code>hxC</code> to denote the hypothesis that x is in C etc.</p>



<a name="233120009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233120009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233120009">(Apr 04 2021 at 23:24)</a>:</h4>
<p>No? I just mean using a different name for the hypothesis -- instead of <code>h : torsion_free R M</code>, to write <code>M_torsion_free : torsion_free R M</code>.</p>
<p>I suppose that example would be annoying because it shows up in the lemma's own interface, and it's repetitive there. But one can do that for an intermediate hypothesis like <code>ha'</code>.</p>



<a name="233120067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233120067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233120067">(Apr 04 2021 at 23:25)</a>:</h4>
<p>Yes, I see and I agree that this would also make things more readable. I think I'd rather go for <code>hM_tf</code> and maybe establish some standard abbreviations for stuff like this.</p>



<a name="233120117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233120117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233120117">(Apr 04 2021 at 23:26)</a>:</h4>
<p>Sure. Yeah, <code>hM_tf</code> would be quite a good hint in the context of that proof as to what the hypothesis meant.</p>



<a name="233154298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233154298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233154298">(Apr 05 2021 at 09:45)</a>:</h4>
<p><span class="user-mention" data-user-id="397997">@Greg Price</span> thank you very much for do this and reporting back. I'm sorry about the <code>ha</code> name, I changed some variable names and forgot to rename that assumption. I'll change some other variable names to a more verbose style. I think every statement that we would call a theorem when lecturing in the real world deserves a readable proof in this sense. But this is very time consuming.</p>



<a name="233155844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233155844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233155844">(Apr 05 2021 at 10:08)</a>:</h4>
<p>There are also interesting differences between what I wrote on paper and the Lean proof. The story of that Lean proof began during a conversation with Johan when he mentioned that Anne proved a submodule of a free module over a PID is free, but not this important corollary. I immediately knew this was an easy corollary because I lectured about it in December. When preparing this lecture I noted the key idea of introducing these <code>N</code> and (some version of) <code>A</code> but then I probably improvised the proof details.  One interesting side effect of remote teaching is that I have a written trace of exactly what I wrote on "blackboard". I'm using <a href="https://xournalpp.github.io/">xournal++</a> as a whiteboard and I simply save the resulting file at the end of the lecture. So I can tell you that, although the proof is only half a hand-written page long, it is far less efficient than what I wrote in Lean. The main thing is that instead of stating <code>∀ i : ι, ∃ a : R, a ≠ 0 ∧ a • s i ∈ N,</code> I numbered the elements of a finite generating set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>s</mi><mi>n</mi></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>s</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">s_1, \dots, s_n, \dots, s_N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> assuming that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>s</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">s_1, \dots, s_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> was free and maximal, and I only stated and proved the existence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i &gt; n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> (I even started with a completely useless case disjunction depending on whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n = N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> or not). And then I wrote each element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as a linear combination of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and split all sums into two pieces, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i \leq n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i &gt; n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>. And I certainly did not write the analogue of <code>suffices : ∀ i, φ (s i) ∈ N,</code>. I applied <code>φ</code> to a sum, split the sum,  distributed etc.</p>



<a name="233155891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233155891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233155891">(Apr 05 2021 at 10:08)</a>:</h4>
<p>Next year I'll teach this following the Lean proof.</p>



<a name="233158392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233158392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233158392">(Apr 05 2021 at 10:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> cool story (-;</p>



<a name="233158999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233158999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233158999">(Apr 05 2021 at 10:58)</a>:</h4>
<p>It makes me think I think I never wrote here that, in my secret topology course, I taught the construction of the Stone-Cech compactification following the Lean file in mathlib. Actually I probably have a version with slightly more readable proofs that I should PR, because I edited the proofs while reading them.</p>



<a name="233159144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233159144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233159144">(Apr 05 2021 at 11:00)</a>:</h4>
<p>I also need to modify the <a href="https://en.wikipedia.org/wiki/Stone%E2%80%93%C4%8Cech_compactification">wikipedia page</a> which claims you can use ultrafilters only for discrete spaces (sure there are additional steps in the general case, but there is no reason to switch to a completely different story).</p>



<a name="233163068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/maximal%20independent%20family/near/233163068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/maximal.20independent.20family.html#233163068">(Apr 05 2021 at 11:56)</a>:</h4>
<p>I taught the Hilbert basis theorem for several years in an MSc algebra course and when I tried to formalise it I ultimately realised that my proof was both really ugly and also incorrect. I formalised it shortly after polynomials in one variable had been formalised by Chris Hughes and I thought the proof would be a good test of the API. I realised the proof was ugly very quickly -- there was a step I always left to the reader and it was really messy to do in lean. I realised it was incorrect a bit later -- I was cursing Chris for not having formalised the simple lemma that the degree of X was equal to 1, and it was only when I gave up and decided to prove it myself that I discovered that it wasn't true (the base ring could be the zero ring, and in fact Chris had proved the result for nonzero rings). This incident made me rethink the entire proof and ultimately I came up with a much better and cleaner one which furthermore worked for the zero ring too :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
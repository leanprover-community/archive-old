---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html">Facts on sheaves and schemes via constructive logic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="261177101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261177101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Eckl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261177101">(Nov 11 2021 at 19:46)</a>:</h4>
<p>Some days ago, I saw <a href="https://arxiv.org/pdf/2111.03685.pdf">Ingo Blechschmidt's thesis</a> from 2017 on the arXiv. As far as I understood it, it explains how properties of and facts on sheaves and schemes local over a base scheme, like Grothendieck's generic freeness, translate to statements of an internal language in the Zariski topoi of sheaves and schemes over a base scheme where they become statements on sets, rings and modules and are therefore easier to prove. The proofs somehow make exact hand-waving arguments that properties hold respectively construction work on affine schemes and are natural enough to glue.</p>
<p>I find two points particularly interesting:</p>
<ul>
<li>
<p>The internal language is intuitionistic/constructive, so proofs about sets, rings and modules cannot use the Law of Excluded Middles or the Axiom of Choice. There is a very mathematical reason why this must be the case: The Axiom of Choice is equivalent to the freeness of every vector space, and this translates to the statement that every sheaf of modules on a reduced scheme is locally free! So this is an example where constructive logic is forced on us by facts of a classical theory, but where at the same time we gain significant simplifications of proofs. Such features contradict common assumptions of classically working mathematicians (like me) on constructive logic.</p>
</li>
<li>
<p>Second, the translation process relies on a <em>metatheorem</em>: If the translation of the statement A to the internal language implies the translation of the statement B inside the internal language, then the original statement A implies the original statement B. Can such a metatheorem be (effectively) implemented in a proof assistant like LEAN?</p>
</li>
</ul>



<a name="261177879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261177879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261177879">(Nov 11 2021 at 19:54)</a>:</h4>
<p><span class="user-mention" data-user-id="126734">@Thomas Eckl</span> I think such a metatheorem can be implemented as a tactic. In principle. But what I understood from the experts is that it will be quite challenging to do this in a way that is actually usable.</p>



<a name="261177913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261177913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261177913">(Nov 11 2021 at 19:54)</a>:</h4>
<p>But I know that <span class="user-mention" data-user-id="127136">@Alex J. Best</span> was thinking about this recently. Such a tactic is certainly on my wishlist!</p>



<a name="261180997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261180997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261180997">(Nov 11 2021 at 20:25)</a>:</h4>
<p>Yes, I've been thinking a quite a bit about this recently, but only thinking so far! Its a fascinating idea, and Ingo's thesis especially makes it seem like it might be actually useful, which is what I'd really hope for out of such meta work. I also liked some of the examples in <a href="https://math.jhu.edu/~eriehl/ct/DJM-LectureNotes.pdf">https://math.jhu.edu/~eriehl/ct/DJM-LectureNotes.pdf</a> . I'm very interesed in working out what an automated internalization of a mathlib statement and could look like, would it be unrecognizably general and require further post processing? And/or rewriting into external properties to obtain a "useful" result?</p>



<a name="261239943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261239943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Eckl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261239943">(Nov 12 2021 at 11:30)</a>:</h4>
<p>So, how should such a tactic work? Take the statement on sheaves/schemes, translate it to the internal language of the relevant topos, ask the user for a proof of the translated statement, check that it does only use constructive arguments (probably using another tactic), translate this proof back to a classical proof on sheaves or schemes? That would mean that the Lean kernel only sees the classical arguments, and the metatheorem is never scrutinized by a proof checker - maybe not only a little bit unsatisfactory when producing such a complex tool in the context of a proof checking.</p>



<a name="261257358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261257358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261257358">(Nov 12 2021 at 14:14)</a>:</h4>
<p>I imagine you would first define some sort of basic language for the type of statements you are interested in (together with rules for proofs and/or constructions in this language). Then you specify a way to interpret this language in, say, sheaves on <code>X</code> (so for example a formula in the language might get interpreted as an open set of <code>X</code>,  and a proof in your language interprets as a proof that this open set is all of <code>X</code>). All of this you can do formally in Lean with no metaprogramming (but maybe you'd want to use some tactics to post-process the interpretations of formulas). A third step would be a sort of reflection tactic which takes an ordinary Lean proof and gives you a corresponding proof in your language. This part might feel unsatisfactory, but you can't get around it. There's no way to internalize in Lean the idea that every (constructive) Lean proof can be reflected into your language, so the tactic has to actually inspect each proof it is fed.</p>



<a name="261275054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261275054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261275054">(Nov 12 2021 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="133584">@Joseph Hua</span> is this tactic discussed above something you would need for your Ax-Grothendieck proof?</p>



<a name="261305178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261305178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261305178">(Nov 12 2021 at 20:14)</a>:</h4>
<p>The story for Ax-Grothendieck should be similar but simpler since you'd only need to reflect / reify formulas (not proofs). So you would show that Ax-Grothendieck holds for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{\mathbb F_p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.174998em;vertical-align:-0.286108em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8888900000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.80889em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span>, prove that if some first-order sentence holds at almost every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{\mathbb F_p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.174998em;vertical-align:-0.286108em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8888900000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.80889em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span> then it holds for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">C</span></span></span></span>, and then deduce that Ax-Grothendieck holds for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">C</span></span></span></span> since it is a first-order sentence. This last step is the one of interest here; it's where you need to relate ordinary Lean formulas with formulas in the formal language of first-order logic. So this story is simpler since it doesn't matter how you prove the theorem for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi mathvariant="double-struck">F</mi><mi>p</mi></msub><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{\mathbb F_p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.174998em;vertical-align:-0.286108em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8888900000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.80889em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span> (in particular you don't have to work in FOL!).</p>



<a name="261306706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261306706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261306706">(Nov 12 2021 at 20:29)</a>:</h4>
<p>Oh nice. I'm supervising Joseph basically so he can teach me by example what such a proof looks like in Lean. Did I recently read that you can just "run the outer proof internally" or something, using the Nullstellensatz (which we have), to get a model-theory-free proof of A-G?</p>



<a name="261306708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261306708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261306708">(Nov 12 2021 at 20:29)</a>:</h4>
<p>I wonder if we can do this simple special case of internalising proofs in a sheaf topos: write a tactic which given an ordinary Lean proof like <code>example {p : Prop} : ¬¬(p ∨ ¬p) := λ a, a (or.inr (λ b, a (or.inl b)))</code>, outputs a proof that for a Heyting algebra <code>H</code> and <code>p : H</code>, <code>¬¬(p ∨ ¬p) = ⊤</code>.</p>



<a name="261307429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261307429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261307429">(Nov 12 2021 at 20:35)</a>:</h4>
<blockquote>
<p>Did I recently read that you can just "run the outer proof internally" or something, using the Nullstellensatz (which we have), to get a model-theory-free proof of A-G?</p>
</blockquote>
<p>I don't know but it sounds plausible, there's surely many ways to prove A-G</p>



<a name="261417393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261417393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261417393">(Nov 14 2021 at 13:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic/near/261307429">said</a>:</p>
<blockquote>
<blockquote>
<p>Did I recently read that you can just "run the outer proof internally" or something, using the Nullstellensatz (which we have), to get a model-theory-free proof of A-G?</p>
</blockquote>
<p>I don't know but it sounds plausible, there's surely many ways to prove A-G</p>
</blockquote>
<p>That's definitely possible and has been done in many ways, many times. See that paper of Serre, <a href="https://arxiv.org/abs/0903.0517">How to use finite fields for problems concerning infinite fields</a>, for references and a sketch of a proof, or Wikipedia, <a href="https://en.wikipedia.org/wiki/Ax%E2%80%93Grothendieck_theorem">Ax-Grothendieck theorem</a>.</p>
<p>On the other hand,  the model theory proof, the Nullstellensatz proof, and Grothendieck's proof by spreading-out basically rely on the same arguments.</p>



<a name="261421042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Facts%20on%20sheaves%20and%20schemes%20via%20constructive%20logic/near/261421042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic.html#261421042">(Nov 14 2021 at 14:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="126734">Thomas Eckl</span> <a href="#narrow/stream/116395-maths/topic/Facts.20on.20sheaves.20and.20schemes.20via.20constructive.20logic/near/261239943">said</a>:</p>
<blockquote>
<p>So, how should such a tactic work? Take the statement on sheaves/schemes, translate it to the internal language of the relevant topos, ask the user for a proof of the translated statement, check that it does only use constructive arguments (probably using another tactic), translate this proof back to a classical proof on sheaves or schemes? That would mean that the Lean kernel only sees the classical arguments, and the metatheorem is never scrutinized by a proof checker - maybe not only a little bit unsatisfactory when producing such a complex tool in the context of a proof checking.</p>
</blockquote>
<p>Personally I'm more interested in "getting theorems for free" and taking existing proofs and translating them into an arbitrary topos, and then massaging the statements into a nice form. So, rather than prompting the user for proofs, just rely on the user to prove in the logic of lean the theorem they want translated.<br>
The mathematics behind why this works (e.g. soundness theorems) is of course very interesting too, but seeing as you can't verify this for such a meta-tool I'm not too worried as long as it works in practice, my main goal is to reduce repetition and make formalization efforts faster and more efficient.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Associahedron.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html">Associahedron</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="258786891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258786891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258786891">(Oct 22 2021 at 23:05)</a>:</h4>
<p>I was talking with somene about the dreaded infinity categories and how we couldn't even define the association rules. So we started talking about <a href="https://en.wikipedia.org/wiki/Associahedron">associahedrons</a>. Does anybody know a way to characterize the faces (of all dimensions!) of the n-th associahedron? We thought hard about it and I came up with the idea that each face was corresponding to an invariant part of the binary trees/parenthezations, and then came across <a href="https://en.wikipedia.org/wiki/Associahedron#/media/File:Associahedron_K5_faces,_ovals.svg">this image on Wikipedia</a>.<br>
For now, I figured out it would be quite a good exercise to even define <a href="https://en.wikipedia.org/wiki/Tamari_lattice">the Tamari lattice</a>.</p>



<a name="258788953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258788953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258788953">(Oct 22 2021 at 23:32)</a>:</h4>
<p>I think the simplest characterisation of the faces of the n-th associahedron is as rooted "planar" trees with n leaves (not necessarily binary). The dimension of the face is the N-#vertices for some straightforward N(n). Containment of faces is given by the (transitive closure) of contraction of internal edges.</p>



<a name="258789218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789218">(Oct 22 2021 at 23:35)</a>:</h4>
<p>e.g. (ignore the text labels)<br>
<a href="/user_uploads/3121/0_ARYfcinI_aVfp1ZBmMMhg_/A4-faces.png">A4-faces.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/0_ARYfcinI_aVfp1ZBmMMhg_/A4-faces.png" title="A4-faces.png"><img src="/user_uploads/3121/0_ARYfcinI_aVfp1ZBmMMhg_/A4-faces.png"></a></div>



<a name="258789353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789353">(Oct 22 2021 at 23:37)</a>:</h4>
<p>(The labels are showing you the terms appearing in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>m</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">d m_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in an A_infty algebra.)</p>



<a name="258789512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789512">(Oct 22 2021 at 23:39)</a>:</h4>
<p>Ohohoh! Very interesting! So you're saying the faces are identifiable with rooted trees? What do you mean by planar here?</p>



<a name="258789533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789533">(Oct 22 2021 at 23:39)</a>:</h4>
<p>I remember some talk a while back about formalizing operads. Did anything happen with that?</p>



<a name="258789743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789743">(Oct 22 2021 at 23:42)</a>:</h4>
<p>Just look at the picture. There's a linear order on the children of each vertex.</p>



<a name="258789758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789758">(Oct 22 2021 at 23:42)</a>:</h4>
<p>And I guess you need to say every non-leaf vertex has at least 2 children.</p>



<a name="258789759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258789759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258789759">(Oct 22 2021 at 23:42)</a>:</h4>
<p>(deleted)</p>



<a name="258790079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790079">(Oct 22 2021 at 23:47)</a>:</h4>
<p>Does</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">face</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">:</span> <span class="n">face</span>
<span class="bp">|</span> <span class="n">fork</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span>

<span class="kn">namespace</span> <span class="n">face</span>

<span class="kd">def</span> <span class="n">children</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">face</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fork</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">children</span> <span class="n">b</span>

<span class="kd">end</span> <span class="n">face</span>
</code></pre></div>
<p>Do it?</p>



<a name="258790101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790101">(Oct 22 2021 at 23:47)</a>:</h4>
<p><code>fork</code> is for a 2-child vertex, then you use <code>cons</code> to add more children?</p>



<a name="258790331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790331">(Oct 22 2021 at 23:50)</a>:</h4>
<p>Okay, I see.</p>



<a name="258790355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790355">(Oct 22 2021 at 23:51)</a>:</h4>
<p>And contraction is replacing <code>fork</code> by <code>cons</code>, right?</p>



<a name="258790385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790385">(Oct 22 2021 at 23:51)</a>:</h4>
<p>No, it's more complicated, you need to do something with <code>cons</code>s as well.</p>



<a name="258790437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790437">(Oct 22 2021 at 23:52)</a>:</h4>
<p>It might be easier to define <code>boundary</code> rather than <code>coboundary</code>.</p>



<a name="258790463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790463">(Oct 22 2021 at 23:52)</a>:</h4>
<p>i.e. all the ways to uncontract an edge</p>



<a name="258790478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790478">(Oct 22 2021 at 23:52)</a>:</h4>
<p>but I guess we want both anyway</p>



<a name="258790501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258790501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258790501">(Oct 22 2021 at 23:53)</a>:</h4>
<p>Okay okay</p>



<a name="258791498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258791498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258791498">(Oct 23 2021 at 00:05)</a>:</h4>
<p>Is there a moduli space of metric planar rooted trees, where each edge has an associated positive length? It seems like you can set it up so that edge contraction is a limit of shrinking an edge's length.  Can this (or rather some subspace) map cleanly onto the associahedron as a geometric object?  I'd expect the subspace where the edges incident to the leaves are all unit length would work, but it seems like it gives a dual cell structure.  (A tree with n internal vertices is contained in a cell of dimension n.)</p>



<a name="258794048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258794048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258794048">(Oct 23 2021 at 00:52)</a>:</h4>
<p>The following code is possibly correct. At least it seems to get the number and sizes of faces correct:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pnat.basic</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kd">def</span> <span class="n">splits</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[([],</span> <span class="o">[])]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="o">([],</span> <span class="n">a</span> <span class="o">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">splits</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">p.2</span><span class="o">))</span>

<span class="sd">/-- Give all ways of decomposing a list into a prefix, a singleton, and a suffix. -/</span>
<span class="kd">def</span> <span class="n">prefix_singleton_suffix</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">:=</span> <span class="o">[([],</span> <span class="n">a</span><span class="o">,</span> <span class="o">[])]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="o">([],</span> <span class="n">a</span><span class="o">,</span> <span class="n">L</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">prefix_singleton_suffix</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">p.1</span><span class="o">,</span> <span class="n">p.2</span><span class="o">))</span>

<span class="kd">end</span> <span class="n">list</span>

<span class="kd">inductive</span> <span class="n">face</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">:</span> <span class="n">face</span>
<span class="bp">|</span> <span class="n">fork</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span>

<span class="kn">namespace</span> <span class="n">face</span>

<span class="kd">def</span> <span class="n">of</span> <span class="o">:</span> <span class="n">list</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">face</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">leaf</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="o">[])</span>  <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="o">[])</span> <span class="o">:=</span> <span class="n">fork</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">of</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">L</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">children</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">face</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fork</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">children</span> <span class="n">b</span>

<span class="kd">lemma</span> <span class="n">children_of</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">face</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L.length</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">of</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">children</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">top</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span> <span class="bp">→</span> <span class="n">face</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">leaf</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">fork</span> <span class="n">leaf</span> <span class="n">leaf</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">leaf</span> <span class="o">(</span><span class="n">top</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩)</span>

<span class="kd">def</span> <span class="n">leaves</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="bp">+</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fork</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">leaves</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">leaves</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">leaves</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">leaves</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">leaf</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fork</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">b</span><span class="o">)</span>

<span class="sd">/-- For a face with n children, choose between 2 and n-1 contiguous children,</span>
<span class="sd">and combine those as a single child. -/</span>
<span class="c1">-- TODO define this on the constructors?</span>
<span class="kd">def</span> <span class="n">uncontract</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">face</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">face</span> <span class="o">:=</span>
<span class="k">do</span> <span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">QR</span><span class="o">)</span> <span class="bp">←</span> <span class="n">f.children.splits</span><span class="o">,</span>
   <span class="o">(</span><span class="n">Q</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">←</span> <span class="n">QR.splits</span><span class="o">,</span>
   <span class="n">guard</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">≤</span> <span class="n">Q.length</span> <span class="bp">∧</span> <span class="n">Q.length</span> <span class="bp">&lt;</span> <span class="n">f.children.length</span><span class="o">),</span>
   <span class="n">return</span> <span class="bp">$</span> <span class="n">of</span> <span class="o">(</span><span class="n">P</span> <span class="bp">++</span> <span class="o">[</span><span class="n">of</span> <span class="n">Q</span><span class="o">]</span> <span class="bp">++</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">face</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">face</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">face</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">face</span> <span class="o">:=</span>
<span class="k">do</span> <span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">←</span> <span class="n">f.children.prefix_singleton_suffix</span><span class="o">,</span>
   <span class="n">q</span> <span class="bp">←</span> <span class="n">g</span> <span class="n">a</span><span class="o">,</span>
   <span class="n">return</span> <span class="bp">$</span> <span class="n">of</span> <span class="o">(</span><span class="n">P</span> <span class="bp">++</span> <span class="o">[</span><span class="n">q</span><span class="o">]</span> <span class="bp">++</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">boundary</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">face</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">face</span> <span class="o">:=</span>
<span class="n">uncontract</span> <span class="n">f</span> <span class="bp">++</span> <span class="n">f.map</span> <span class="n">uncontract</span>

<span class="c1">-- The n=5 associahedron has 9 faces:</span>
<span class="k">#eval</span> <span class="o">((</span><span class="n">top</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">boundary</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="c1">-- Of those faces, 3 are squares and 6 are pentagons:</span>
<span class="k">#eval</span> <span class="o">((</span><span class="n">top</span> <span class="mi">5</span><span class="o">)</span><span class="bp">.</span><span class="n">boundary</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">face</span><span class="o">,</span> <span class="n">f.boundary.length</span><span class="o">)</span>

<span class="c1">-- The n=6 associahedron has 14 faces:</span>
<span class="k">#eval</span> <span class="o">((</span><span class="n">top</span> <span class="mi">6</span><span class="o">)</span><span class="bp">.</span><span class="n">boundary</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="c1">-- Those faces themselves have either 7 or 9 faces:</span>
<span class="c1">-- https://www.shapeways.com/product/YAHGXP2QS/associahedron-k-6</span>
<span class="k">#eval</span> <span class="o">((</span><span class="n">top</span> <span class="mi">6</span><span class="o">)</span><span class="bp">.</span><span class="n">boundary</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">face</span><span class="o">,</span> <span class="n">f.boundary.length</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">face</span>
</code></pre></div>
<p>It is a bit hacky.</p>



<a name="258794163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258794163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258794163">(Oct 23 2021 at 00:55)</a>:</h4>
<p>Dual to the tree characterization for faces is a characterization in terms of arcs in a disk between labeled points:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">arc</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">(</span><span class="n">le</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">ℕ</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>

<span class="sd">/-- whether the interiors of the arcs must intersect --/</span>
<span class="kd">def</span> <span class="n">arc.interlaces</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">arc</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">p.a</span> <span class="bp">&lt;</span> <span class="n">q.a</span> <span class="bp">∧</span> <span class="n">p.b</span> <span class="bp">&lt;</span> <span class="n">q.b</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q.a</span> <span class="bp">&lt;</span> <span class="n">p.a</span> <span class="bp">∧</span> <span class="n">q.b</span> <span class="bp">&lt;</span> <span class="n">p.b</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">face</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">arcs</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">arc</span> <span class="n">n</span><span class="o">))</span>
<span class="o">(</span><span class="n">disj</span> <span class="o">:</span> <span class="n">arcs.val.pairwise</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">arc</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">p.interlaces</span> <span class="n">q</span><span class="o">))</span>
</code></pre></div>
<p>This illustrates the correspondence between a tree and this <code>face</code> structure for a four-leafed tree:</p>
<p><a href="/user_uploads/3121/5LJH3T-iLTnTS2UY65GdLRBP/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/5LJH3T-iLTnTS2UY65GdLRBP/image.png" title="image.png"><img src="/user_uploads/3121/5LJH3T-iLTnTS2UY65GdLRBP/image.png"></a></div><p>Edge contraction corresponds to deleting an arc from the <code>arcs</code> set.</p>
<p>(Edit: That (0,5) edge seems unnecessary -- it probably should be excluded in the definition.)</p>



<a name="258794167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258794167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258794167">(Oct 23 2021 at 00:55)</a>:</h4>
<p>In what form should the associahedron first enter mathlib.</p>
<ol>
<li>just as a combinatorial object (a simplicial complex?)</li>
<li>the definition of an A_infty algebra?</li>
</ol>



<a name="258813596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813596">(Oct 23 2021 at 09:28)</a>:</h4>
<p>Oh wow! I tried but failed to have working code.</p>



<a name="258813619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813619">(Oct 23 2021 at 09:29)</a>:</h4>
<p>I was wondering if it makes sense to provide the definition of an abstract polytope, and then the associahedra as examples.</p>



<a name="258813664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813664">(Oct 23 2021 at 09:30)</a>:</h4>
<p>I don't know what a A_infty algebra is, so I was envisioning defining it as an abstract polytopial complex. Certainly not as a simplicial complex in the way I'm defining them in <a href="https://github.com/leanprover-community/mathlib/issues/9762">#9762</a> because that assumes a geometrical embedding.</p>



<a name="258813684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813684">(Oct 23 2021 at 09:31)</a>:</h4>
<p>What's your definition of an abstract polytope?</p>



<a name="258813723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813723">(Oct 23 2021 at 09:32)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Abstract_polytope">https://en.wikipedia.org/wiki/Abstract_polytope</a> seems good. :-) There's some basic order theory about chains and flags that I suspect we don't quite have.</p>



<a name="258813815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813815">(Oct 23 2021 at 09:34)</a>:</h4>
<p>We would need <code>flag</code> in an arbitrary partial_order, defined as a maximal chain.</p>



<a name="258813823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813823">(Oct 23 2021 at 09:34)</a>:</h4>
<p>And <code>rank x</code> as the length of the longest chain ending at <code>x</code>.</p>



<a name="258813847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813847">(Oct 23 2021 at 09:35)</a>:</h4>
<p>What about <a href="https://leanprover-community.github.io/mathlib_docs/find/zorn.is_max_chain">docs#zorn.is_max_chain</a> ?</p>



<a name="258813852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813852">(Oct 23 2021 at 09:35)</a>:</h4>
<p>Btw I'm all for splitting the chain stuff from <code>order.zorn</code></p>



<a name="258813896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813896">(Oct 23 2021 at 09:36)</a>:</h4>
<p>Yes, that should be factored out a bit.</p>



<a name="258813915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813915">(Oct 23 2021 at 09:37)</a>:</h4>
<p>I guess we also need <code>incident</code> as the relation <code>x \le y \or y \le x</code>, and <code>connected</code> as the transitive closure of <code>incident</code>.</p>



<a name="258813928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813928">(Oct 23 2021 at 09:37)</a>:</h4>
<p>That doesn't work. Everything is connected through <code>bot</code>.</p>



<a name="258813973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813973">(Oct 23 2021 at 09:38)</a>:</h4>
<p>Oops!</p>



<a name="258813977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813977">(Oct 23 2021 at 09:38)</a>:</h4>
<p>hmm, I guess you restrict <code>incident</code> to the "proper" (i.e. neither top nor bot) elements and take transitive closure there</p>



<a name="258813992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813992">(Oct 23 2021 at 09:39)</a>:</h4>
<p>Yeah, that's what wikipedia does. A bit hacky, isn't it?</p>



<a name="258813994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813994">(Oct 23 2021 at 09:39)</a>:</h4>
<p>None of this is particularly important, but I do love associahedra. :-)</p>



<a name="258813999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258813999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258813999">(Oct 23 2021 at 09:39)</a>:</h4>
<p>I too <span aria-label="heart eyes" class="emoji emoji-1f60d" role="img" title="heart eyes">:heart_eyes:</span></p>



<a name="258814001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258814001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258814001">(Oct 23 2021 at 09:39)</a>:</h4>
<p>I have to head off now, but I'll think about it some more at some point!</p>



<a name="258814004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258814004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258814004">(Oct 23 2021 at 09:39)</a>:</h4>
<p>Okay! I can try working on the definition of an abstract polytope.</p>



<a name="258815691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258815691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258815691">(Oct 23 2021 at 10:19)</a>:</h4>
<p>combinatorics ppl like me would says that associahedrons are just secondary polytopes of convex n-gons. So, everything is convex, unlike for abstract polytopes, which need not be realizible as convex polytopes.</p>



<a name="258817000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258817000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258817000">(Oct 23 2021 at 10:51)</a>:</h4>
<p>While "concrete"/"geometric" polytopes are "better", and in the end we want them, I suspect it's going to be easier to start with something that involves no geometry. The secondary polytope construction immediately requires us to think about volumes, doesn't it?</p>



<a name="258833550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258833550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258833550">(Oct 23 2021 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Associahedron/near/258794167">said</a>:</p>
<blockquote>
<p>In what form should the associahedron first enter mathlib.</p>
<ol>
<li>just as a combinatorial object (a simplicial complex?)</li>
<li>the definition of an A_infty algebra?</li>
</ol>
</blockquote>
<p>I would understand an A_infty algebra to be an algebra over an operad (that is a cofibrant replacement of the Assoc operad), so 1 and 2 are kind of the same thing</p>



<a name="258846322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258846322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258846322">(Oct 23 2021 at 22:39)</a>:</h4>
<p>If only Lean felt that way. :-)</p>



<a name="258848508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258848508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258848508">(Oct 23 2021 at 23:40)</a>:</h4>
<p>Right, a better thing to say would be I think it makes sense for it to start out as some combinatorial structure/polytope, then the plan is to realize it as a space/chain complex, and at some point along the way it will gain an operad structure</p>



<a name="258925367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258925367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258925367">(Oct 25 2021 at 07:37)</a>:</h4>
<p>Yes, one would need convex polytopes, their triangulations, and volumes (of simplices, to begin with - but well, it's just a determinant ;-)). This would be a very useful project, IMHO, I don't know how hard.</p>



<a name="258925401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258925401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258925401">(Oct 25 2021 at 07:37)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/mathlib/tree/sperner-again">branch#sperner-again</a> for a start <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="258954299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258954299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258954299">(Oct 25 2021 at 12:55)</a>:</h4>
<p>Does <a href="https://github.com/leanprover-community/mathlib/tree/sperner-again">https://github.com/leanprover-community/mathlib/tree/sperner-again</a> let one talk about convex hulls of finitely many points? How about facets (and, maybe dual polytopes)?</p>



<a name="258954680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258954680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258954680">(Oct 25 2021 at 12:58)</a>:</h4>
<p>You can already talk about convex hulls of finitely many points. Do you mean bundled as polytopes? If so, yes, although the API is currently quite dry: <a href="https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L375">https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L375</a></p>



<a name="258962193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258962193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258962193">(Oct 25 2021 at 13:54)</a>:</h4>
<p>I mean an alternative definition of polytope, as a bounded set defined by finitely many linear inequalities.</p>



<a name="258962466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258962466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258962466">(Oct 25 2021 at 13:56)</a>:</h4>
<p>among such systems of inequalies there is (essentially) one canonical, with as few inequalities as possible.</p>



<a name="258962536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258962536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258962536">(Oct 25 2021 at 13:57)</a>:</h4>
<p>a.k.a. "dual polytope"</p>



<a name="258962675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258962675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258962675">(Oct 25 2021 at 13:58)</a>:</h4>
<p>That's what I'm trying to do at this line: <a href="https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L466">https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L466</a></p>



<a name="258962746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258962746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258962746">(Oct 25 2021 at 13:58)</a>:</h4>
<p>Well, not for the "bounded" part.</p>



<a name="258989296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258989296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258989296">(Oct 25 2021 at 17:04)</a>:</h4>
<p>unbounded convex polyhedra are a bit too general - anyhow, to have a decomposition theorem for these (any such polyhedron is Minkowski sum of a polytope, a cone, and an affine subspace) you need bounded ones, and cones.</p>



<a name="258989386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258989386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258989386">(Oct 25 2021 at 17:04)</a>:</h4>
<p>We already have cones in mathlib!</p>



<a name="258989692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258989692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258989692">(Oct 25 2021 at 17:06)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/convex_cone">docs#convex_cone</a></p>



<a name="258989779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/258989779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#258989779">(Oct 25 2021 at 17:07)</a>:</h4>
<p>If you have some idea of what to do and in what order, I'm very happy to hear it. I'm pretty interested in convexity.</p>



<a name="259304282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259304282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259304282">(Oct 27 2021 at 20:49)</a>:</h4>
<p>how hard is to prove in Lean that a finitely generated (pointed) cone has finitely generated dual?</p>



<a name="259306167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259306167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259306167">(Oct 27 2021 at 21:03)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>, what do you think? <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span></p>



<a name="259310951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259310951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259310951">(Oct 27 2021 at 21:42)</a>:</h4>
<p>to this end, I can only think of proving this by showing correctness of an algorithmic procedure which computes the facets.</p>



<a name="259311054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259311054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259311054">(Oct 27 2021 at 21:43)</a>:</h4>
<p>Bhavik has proved Gordan's lemma, if that's related.</p>



<a name="259313464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259313464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259313464">(Oct 27 2021 at 22:07)</a>:</h4>
<p>Is any of this related to the simplex algorithm? I proved correctness of that back in 2019 <a href="https://github.com/ChrisHughes24/LP/blob/master/src/simplex.lean">https://github.com/ChrisHughes24/LP/blob/master/src/simplex.lean</a> It never went into mathlib.</p>



<a name="259313483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259313483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259313483">(Oct 27 2021 at 22:07)</a>:</h4>
<p>Gordan's lemma seems related to me.</p>



<a name="259314215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259314215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259314215">(Oct 27 2021 at 22:15)</a>:</h4>
<p>well, there is "reverse search", one of procedures to enumerate facets, whch is sort of running simplex method backwards: <br>
<a href="https://www.sciencedirect.com/science/article/pii/0166218X9500026N">https://www.sciencedirect.com/science/article/pii/0166218X9500026N</a></p>



<a name="259358453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259358453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259358453">(Oct 28 2021 at 08:57)</a>:</h4>
<p>the simplest "paper"  proof I know is in K. Fukuda's lecture notes <a href="https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf">https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf</a> - which uses an easy algorithm to eliminate variables in systems of linear inequalities (Fourier-Motzkin elimination).</p>



<a name="259363082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259363082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259363082">(Oct 28 2021 at 09:40)</a>:</h4>
<p>Ahah! <code>linarith</code> is an implementation of Fourier-Motzkin, but we have no formalization per say.</p>



<a name="259366228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259366228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dima Pasechnik <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259366228">(Oct 28 2021 at 10:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="316505">Dima Pasechnik</span> <a href="#narrow/stream/116395-maths/topic/Associahedron/near/259358453">said</a>:</p>
<blockquote>
<p>the simplest "paper"  proof I know is in K. Fukuda's lecture notes (Theorem 3.10) <a href="https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf">https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf</a> - which uses an easy algorithm to eliminate variables in systems of linear inequalities (Fourier-Motzkin elimination).</p>
</blockquote>
<p>tl; dr: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>R</mi><mi>λ</mi></mrow><annotation encoding="application/x-tex">x=R\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">λ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is representing all the vectors in the cone generated by the columns of the matrix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, then eliminating <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span></span></span></span>'s will leave us with a finite system of linear inequalities on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>.</p>



<a name="259391688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Associahedron/near/259391688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Associahedron.html#259391688">(Oct 28 2021 at 13:56)</a>:</h4>
<p>I have a formalization of what is basically Fourier-Motzkin elimination in <a href="https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/examples/isolating.lean">https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/examples/isolating.lean</a> though it's probably not quite close enough to be useful here without extra work--in any case, it's not very difficult</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
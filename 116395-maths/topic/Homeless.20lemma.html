---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Homeless.20lemma.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html">Homeless lemma</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223298273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223298273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223298273">(Jan 19 2021 at 21:31)</a>:</h4>
<p>I believe I need to use the following lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.lattice</span>

<span class="kd">lemma</span> <span class="n">monotone_nat_action_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₂</span> <span class="n">a</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h_mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₁</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₂</span> <span class="n">a₂</span><span class="o">))</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">f</span> <span class="mi">1</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">h_zero</span> <span class="n">a₂</span><span class="o">,</span> <span class="o">},</span> <span class="n">exact</span> <span class="n">h</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span><span class="o">,</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="bp">;</span> <span class="n">intros</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h_zero</span><span class="o">,</span> <span class="n">h_zero</span><span class="o">],</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">calc</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">))</span> <span class="o">:</span> <span class="n">h_add</span> <span class="n">n</span> <span class="mi">1</span> <span class="n">_</span>
                             <span class="bp">...</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">n</span> <span class="o">((</span><span class="n">f</span> <span class="mi">1</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">h_mono</span> <span class="n">n</span> <span class="o">(</span><span class="n">h</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">)</span>
                             <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span> <span class="n">a₁</span><span class="o">))</span> <span class="bp">⊔</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">ih</span> <span class="n">_</span> <span class="n">_</span>
                             <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">h_add</span> <span class="n">n</span> <span class="mi">1</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
    <span class="k">calc</span> <span class="n">f</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₂</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">))</span> <span class="o">:</span> <span class="n">h_add</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
                           <span class="bp">...</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₂</span> <span class="o">(</span><span class="n">a₂</span> <span class="bp">⊔</span> <span class="n">a₁</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">sup_comm</span>
                           <span class="bp">...</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">n₁</span> <span class="o">((</span><span class="n">f</span> <span class="n">n₂</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">h_mono</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">h'</span> <span class="n">n₂</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
                           <span class="bp">...</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₂</span> <span class="n">a₂</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">sup_comm</span>
                           <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₁</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">f</span> <span class="n">n₂</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">h'</span> <span class="n">n₁</span> <span class="n">a₁</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>but I'm not sure:</p>
<ul>
<li>where it should live,</li>
<li>what it should be called,</li>
<li>whether I'm stating it in appropriate generality.</li>
</ul>
<p>I'd be grateful for any comments!</p>



<a name="223298765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223298765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223298765">(Jan 19 2021 at 21:35)</a>:</h4>
<p>Would it make sense to make this literally, rather than just morally, a result about an action of <code>ℕ</code> on <code>α</code>? There is a theory of monoid action, <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action">docs#mul_action</a>.  Seemingly only in the multiplicative case, should we add the additive case?</p>



<a name="223298931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223298931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223298931">(Jan 19 2021 at 21:36)</a>:</h4>
<p>I have also wondered lately whether we need a fancier theory, to deal with actions which are "category-respecting":  actions on orders which are monotone, actions on topological spaces which are continuous, actions on manifolds which are smooth.</p>



<a name="223299119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223299119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223299119">(Jan 19 2021 at 21:38)</a>:</h4>
<p>Absolutely agreed on using <code>mul_action</code>, great point.</p>



<a name="223299134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223299134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223299134">(Jan 19 2021 at 21:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Homeless.20lemma/near/223298931">said</a>:</p>
<blockquote>
<p>I have also wondered lately whether we need a fancier theory, to deal with actions which are "category-respecting":  actions on orders which are monotone, actions on topological spaces which are continuous, actions on manifolds which are smooth.</p>
</blockquote>
<p>One way to do that here would be to write down the monoid instance on the type of monotone self-maps of <code>α</code>, and phrase your lemma as a result about a homomorphism of <code>ℕ</code> into that monoid.</p>



<a name="223299267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223299267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223299267">(Jan 19 2021 at 21:39)</a>:</h4>
<p>Also a nice idea, though I have to pick between this approach and <code>mul_action</code> then I guess.</p>



<a name="223299347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223299347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223299347">(Jan 19 2021 at 21:40)</a>:</h4>
<p>I thought I'd leave the decision to someone else! :)</p>



<a name="223299416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223299416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223299416">(Jan 19 2021 at 21:41)</a>:</h4>
<p>I'm pretty much done for the day so I'll mull it for a day or so. Currently leaning toward <code>mul_action</code>.</p>



<a name="223299545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223299545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223299545">(Jan 19 2021 at 21:42)</a>:</h4>
<p>I'd also like it if there was a helpful generalisation of <code>ℕ</code> though it's not clear to me that there is (at least a helpful one).</p>



<a name="223300088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223300088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223300088">(Jan 19 2021 at 21:46)</a>:</h4>
<p>Incidentally the mysterious <code>f</code> in my case is <code>lie_algebra.derived_series_of_ideal</code> cf <a href="https://github.com/leanprover-community/mathlib/pull/5815">https://github.com/leanprover-community/mathlib/pull/5815</a></p>



<a name="223327434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223327434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223327434">(Jan 20 2021 at 03:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Homeless.20lemma/near/223298931">said</a>:</p>
<blockquote>
<p>I have also wondered lately whether we need a fancier theory, to deal with actions which are "category-respecting":  actions on orders which are monotone, actions on topological spaces which are continuous, actions on manifolds which are smooth.</p>
</blockquote>
<p>This is possible to do since <code>End X</code> has a monoid instance (where <code>X</code> is a term of some type with a category instance). A monoid action of <code>M</code> on <code>X</code> compatible with the category structure is then a morphism of monoids <code>M \to End X</code>.</p>



<a name="223327449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223327449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223327449">(Jan 20 2021 at 03:17)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.End">docs#category_theory.End</a></p>



<a name="223327548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223327548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223327548">(Jan 20 2021 at 03:18)</a>:</h4>
<p>I tried to play with this once before ( I was trying to do some Tannakian sort of stuff in lean)... IIRC I found it somewhat cumbersome. But maybe it's worth another shot.</p>



<a name="223327641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223327641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223327641">(Jan 20 2021 at 03:20)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span>  one can also do this "by hand":  construct the group/monoid instance on the monotone self-maps of an order, the self-homeomorphisms of a topological space, the diffeomorphism group of a manifold, and then define an action to be a homomorphism into this group/monoid.  Is there any reason to do this construction "by category theory"?  (Sorry for the naive question!)</p>



<a name="223327656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223327656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223327656">(Jan 20 2021 at 03:20)</a>:</h4>
<p>I'll sketch some code...</p>



<a name="223327657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223327657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223327657">(Jan 20 2021 at 03:20)</a>:</h4>
<p>1 sec</p>



<a name="223328116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328116">(Jan 20 2021 at 03:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>
<span class="kn">import</span> <span class="n">category_theory.endomorphism</span>
<span class="kn">import</span> <span class="n">category_theory.concrete_category</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">concrete_category</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">mul_action'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">act</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">End</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">⟨</span><span class="kt">Type</span><span class="bp">*</span><span class="o">,</span><span class="bp">λ</span> <span class="n">Y</span><span class="o">,</span> <span class="o">(</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="n">Y</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">X</span><span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">[</span><span class="n">mul_action'</span> <span class="n">M</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">mul_action'.act</span> <span class="n">m</span><span class="o">)</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="n">baz</span> <span class="o">[</span><span class="n">mul_action'</span> <span class="n">M</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">M</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="n">foo</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span> <span class="o">}</span>
</code></pre></div>



<a name="223328156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328156">(Jan 20 2021 at 03:29)</a>:</h4>
<p>So now you can define an action on a monoid on an object in any concrete category (such as <code>Top</code>, <code>Type*</code>, etc.) which is compatible with the underlying structure.</p>



<a name="223328234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328234">(Jan 20 2021 at 03:30)</a>:</h4>
<p>I don't know if this can be made to be useful enough so that the "standard" actions, like the action on a topological space by continuous maps, a manifold by diffeomorphisms, etc., don't need to be individually written by hand.</p>



<a name="223328267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328267">(Jan 20 2021 at 03:31)</a>:</h4>
<p>I think this is more subtle, though.  Back in 10 mins, but what about Lie group actions on manifolds?  Action needs to be smooth in the "group" co-ordinate too.</p>



<a name="223328276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328276">(Jan 20 2021 at 03:32)</a>:</h4>
<p>Oh, I see....</p>



<a name="223328317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328317">(Jan 20 2021 at 03:32)</a>:</h4>
<p>Sorry, I misunderstood the question.</p>



<a name="223328325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328325">(Jan 20 2021 at 03:32)</a>:</h4>
<p>In this case we need to use monoid objects internal to a cateogry.</p>



<a name="223328371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328371">(Jan 20 2021 at 03:33)</a>:</h4>
<p>This exists <del>docs#category_theory.monoidal.Mon_</del> and it should be doable...</p>



<a name="223328394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328394">(Jan 20 2021 at 03:33)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/category_theory/monoidal/Mon_.html#Mon_">https://leanprover-community.github.io/mathlib_docs/category_theory/monoidal/Mon_.html#Mon_</a></p>



<a name="223328581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223328581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223328581">(Jan 20 2021 at 03:37)</a>:</h4>
<p>One can use this:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/category_theory/monoidal/Mod.html#Mod">https://leanprover-community.github.io/mathlib_docs/category_theory/monoidal/Mod.html#Mod</a></p>



<a name="223329512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223329512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223329512">(Jan 20 2021 at 03:54)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> I am glad to hear that people have found a suitable theory for this.  Can you explain the terminology?  Is a Lie group a monoid object in the category of smooth manifolds?</p>



<a name="223329605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223329605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223329605">(Jan 20 2021 at 03:57)</a>:</h4>
<p>A Lie monoid (is that a thing?) is a monoid object in the category of manifolds. A Lie group is a group object in the category of manifolds.</p>



<a name="223329606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223329606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223329606">(Jan 20 2021 at 03:57)</a>:</h4>
<p>etc.</p>



<a name="223329913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223329913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223329913">(Jan 20 2021 at 04:03)</a>:</h4>
<p>Mathlib does <a href="https://leanprover-community.github.io/mathlib_docs/geometry/manifold/algebra/monoid.html">have</a> Lie monoids, although there was <a href="https://github.com/leanprover-community/mathlib/pull/3641#issuecomment-671575032">some debate</a></p>



<a name="223329992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223329992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223329992">(Jan 20 2021 at 04:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Homeless.20lemma/near/223329605">said</a>:</p>
<blockquote>
<p>A Lie group is a group object in the category of manifolds.</p>
</blockquote>
<p>So one still has to prove this fact, right?</p>



<a name="223330011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330011">(Jan 20 2021 at 04:05)</a>:</h4>
<p>And the idea is that then one gets access to a family of general theorems about structure-preserving group actions?</p>



<a name="223330073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330073">(Jan 20 2021 at 04:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Homeless.20lemma/near/223329992">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Homeless.20lemma/near/223329605">said</a>:</p>
<blockquote>
<p>A Lie group is a group object in the category of manifolds.</p>
</blockquote>
<p>So one still has to prove this fact, right?</p>
</blockquote>
<p>This is "the definition" :)</p>



<a name="223330158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330158">(Jan 20 2021 at 04:08)</a>:</h4>
<p>Well, we have another definition <a href="https://leanprover-community.github.io/mathlib_docs/find/lie_group">docs#lie_group</a>, and need some glue between them :)</p>



<a name="223330181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330181">(Jan 20 2021 at 04:09)</a>:</h4>
<p>Do we have "the category of manifolds" in mathlib?</p>



<a name="223330257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330257">(Jan 20 2021 at 04:10)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Lord_Kitchener_Wants_You">https://en.wikipedia.org/wiki/Lord_Kitchener_Wants_You</a></p>



<a name="223330287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330287">(Jan 20 2021 at 04:11)</a>:</h4>
<p><span aria-label="expressionless" class="emoji emoji-1f611" role="img" title="expressionless">:expressionless:</span></p>



<a name="223330757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330757">(Jan 20 2021 at 04:20)</a>:</h4>
<p>If this is a serious proposal, then a good test case would be to redefine <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_group">docs#topological_group</a> as a group object in the category of topological spaces.</p>



<a name="223330769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330769">(Jan 20 2021 at 04:20)</a>:</h4>
<p>Yeah, this should be easier.</p>



<a name="223330792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330792">(Jan 20 2021 at 04:21)</a>:</h4>
<p>Has anything like this been done in mathlib before?  That is, to make a "real-life" definition by invoking category theory?</p>



<a name="223330892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330892">(Jan 20 2021 at 04:23)</a>:</h4>
<p>I would be very curious to know whether something "practical" like Floris' construction of Haar measure is unaffected by switching to a category-theoretic definition of topological group.</p>



<a name="223330938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223330938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223330938">(Jan 20 2021 at 04:24)</a>:</h4>
<p>I can't think of an example. But it's usually not as good as a "standard" definition, because of universe issues.</p>



<a name="223331029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331029">(Jan 20 2021 at 04:26)</a>:</h4>
<p>I see.  This is a <strong>very</strong> naive question, but if it can't be used for such things, then what is the purpose of the category theory library?</p>



<a name="223331052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331052">(Jan 20 2021 at 04:26)</a>:</h4>
<p>Is it to provide a sanity check that the definitions (given the concrete way) are correct?</p>



<a name="223331259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331259">(Jan 20 2021 at 04:31)</a>:</h4>
<p>Oh, it can certainly be used. Here's an example of what I mean. <br>
Suppose I want to define monoids. I can define the objects themselves as a type with extra data, etc., or I can define them as monoid objects in the category <code>Type u</code> for a fixed universe u. Now when I go to define morphisms of monoids, I can define them as functions satsifying assumptions in the first case, or I can define them as morphisms in the category <code>Type u</code> which satisfy some conditions in terms of commuting diagrams. The difference is that with the first example, I can define morphisms of monoids whose underlying type has different universes, while in the second case you can only have the two monoids coming from the same universe since the thing which underlies a morphism of monoids is a morphism in the category <code>Type u</code> itself.</p>
<p>Long story short -- if you don't care about universes, then either approach is fine.</p>



<a name="223331336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331336">(Jan 20 2021 at 04:32)</a>:</h4>
<p>But given that mathlib philosophy is to care about universes, we can never use the category theory approach, right?</p>



<a name="223331444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331444">(Jan 20 2021 at 04:34)</a>:</h4>
<p>I haven't work on the flat module project for a while. But when I was thinking about it recently, I realized that I wanted an induction principle for the <code>category</code> of <code>R</code>-modules, and that would probably simplify my proofs drastically.</p>



<a name="223331452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331452">(Jan 20 2021 at 04:34)</a>:</h4>
<p>It is true that there would be some universe restrictions, but those can be dealt with in a separate part of the proof.</p>



<a name="223331472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331472">(Jan 20 2021 at 04:35)</a>:</h4>
<p>Basically, use <code>ulift</code> to put everything in 1 universe, and then apply some machinery from category theory.</p>



<a name="223331484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331484">(Jan 20 2021 at 04:35)</a>:</h4>
<p>Not optimal, but ey! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="223331502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223331502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223331502">(Jan 20 2021 at 04:35)</a>:</h4>
<p>:) This stuff isn't a problem in Coq right? They have cumulative universes?</p>



<a name="223340600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223340600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223340600">(Jan 20 2021 at 07:46)</a>:</h4>
<p>When Amelia was working on tensor algebras she observed that the construction using quotients was quite universe-flexible, but when she made a second construction using sigma types she had to put the ring and the module into the same universe. I tried using <code>ulift</code> to get around this but when I found that lean didn't seem to know that if R was a ring then <code>ulift R</code> was too, I told her that I wouldn't be at all bothered if R and M were in the same universe, because I've spent 30 years of my life thinking that there _was_ only one universe and it didn't stop me doing the p-adic Langlands program</p>



<a name="223340696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223340696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223340696">(Jan 20 2021 at 07:48)</a>:</h4>
<p>Heather asks (and Mario has also raised this issue several times) what the point of the category theory library is if it enables us to do stuff but only under some universe restrictions. One might conversely ask what the point of more than one universe is, given that mathematicians like Heather probably will never need them to do anything she's interested in.</p>



<a name="223360124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homeless%20lemma/near/223360124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homeless.20lemma.html#223360124">(Jan 20 2021 at 11:13)</a>:</h4>
<p>I'd actually love to find a good excuse to use the category theory library but for what it's worth in the case of the lemma at the top of this thread I think I'm going to go with something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.preorder_hom</span>
<span class="kn">import</span> <span class="n">logic.function.iterate</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">lemma</span> <span class="n">preorder_hom.iterate_sup_le_sup_iff</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→ₘ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">]</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span><span class="o">]</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₂</span><span class="o">]</span> <span class="n">a₂</span><span class="o">))</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="mi">1</span> <span class="mi">0</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span><span class="o">,</span> <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="bp">;</span> <span class="n">intros</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">calc</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)))</span> <span class="o">:</span> <span class="n">iterate_succ_apply</span> <span class="n">f</span> <span class="n">n</span> <span class="n">_</span>
                             <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">((</span><span class="n">f</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">))</span> <span class="o">:</span> <span class="n">f.monotone.iterate</span> <span class="n">n</span> <span class="o">(</span><span class="n">h</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">)</span>
                             <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="n">a₁</span><span class="o">))</span> <span class="bp">⊔</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">ih</span> <span class="n">_</span> <span class="n">_</span>
                             <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">]</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₂</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">iterate_succ_apply</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
    <span class="k">calc</span> <span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">]</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₂</span><span class="o">]</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="n">a₂</span><span class="o">)))</span> <span class="o">:</span> <span class="n">iterate_add_apply</span> <span class="n">f</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="n">_</span>
                           <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₂</span><span class="o">]</span> <span class="o">(</span><span class="n">a₂</span> <span class="bp">⊔</span> <span class="n">a₁</span><span class="o">)))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">sup_comm</span>
                           <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span><span class="o">]</span> <span class="o">((</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₂</span><span class="o">]</span> <span class="n">a₂</span><span class="o">)</span> <span class="bp">⊔</span> <span class="n">a₁</span><span class="o">))</span> <span class="o">:</span> <span class="n">f.monotone.iterate</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">h'</span> <span class="n">n₂</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
                           <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span><span class="o">]</span> <span class="o">(</span><span class="n">a₁</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₂</span><span class="o">]</span> <span class="n">a₂</span><span class="o">)))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">sup_comm</span>
                           <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₁</span><span class="o">]</span> <span class="n">a₁</span><span class="o">)</span> <span class="bp">⊔</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n₂</span><span class="o">]</span> <span class="n">a₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">h'</span> <span class="n">n₁</span> <span class="n">a₁</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
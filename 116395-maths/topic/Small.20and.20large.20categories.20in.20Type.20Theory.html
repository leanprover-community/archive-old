---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html">Small and large categories in Type Theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235457996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235457996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235457996">(Apr 21 2021 at 05:33)</a>:</h4>
<p>As is well-known and almost always ignored in graduate textbooks and courses in anything involving homological algebra, a distinction between small and large categories has to be made in set theory. This is due to the fact that the set of all sets can not be formed due to Russel paradox.<br>
However, Lean is not based on set theory, but rather in a version of type theory I do not yet understand very well. But it seems like a type of all types which are not its own members does not make sense in Lean. Does no Russel paradox mean it is ok to form the category of all types?<br>
So I want to understand two things:<br>
a) Where can I find a list of type theory axioms which Lean uses, preferably summarized in a mathematician’s notation.<br>
b) Where can I find a summary of what difficulties in standard smallness-sensitive category-theoretic constructions (Freyd adjoint functor theorem, localization of categories, enough injectives in abelian categories, etc) disappear in type theory, and what are some new difficulties? A concrete example — how to define a derived category of R-mod not yet in Lean, but in Lean’s type theory informally? Are large Hom-sets allowed? Does a theorem that these Hom-sets are actually small makes any sense?</p>



<a name="235459348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235459348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235459348">(Apr 21 2021 at 05:55)</a>:</h4>
<p><span class="user-mention" data-user-id="407114">@Stepan Nesterov</span> Everything has a type. The type of the natural numbers <code>nat</code> is called <code>Type</code>. This thing <code>Type</code> is the type of all types. And mathlib knows that it is a "large" category. But since everything has a type, <code>Type</code> also needs to have a type. In some systems, <code>Type</code> is it's own type, which leads to Russell-like paradoxes. In Lean <code>Type</code> the type turns out to be <code>Type 1</code>. And <code>Type 1</code> has type <code>Type 2</code>. Etc...</p>



<a name="235459577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235459577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235459577">(Apr 21 2021 at 05:58)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Does it have any kind of a 'reduction axiom' as Russell was trying to have in the 1900's? Let's say, if we can prove that a 'Type 1' is a countable 'Type 1', then can it be regarded as a 'Type'?</p>



<a name="235459658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235459658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235459658">(Apr 21 2021 at 06:00)</a>:</h4>
<p>Nope, not really. You can try to define an equivalence (aka isomorphism, aka bijection) between <code>X : Type 1</code> and <code>Y : Type</code>, and for countable types that will always be possible.</p>



<a name="235459720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235459720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235459720">(Apr 21 2021 at 06:00)</a>:</h4>
<p>But in general it's tricky to downsize your universe.</p>



<a name="235459751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235459751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235459751">(Apr 21 2021 at 06:00)</a>:</h4>
<p>Bumping up is easy: there's a function <code>ulift : Type u -&gt; Type (max u v)</code></p>



<a name="235460041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460041">(Apr 21 2021 at 06:04)</a>:</h4>
<p>And do all the definitions in Lean have 'Type 1' counterpart? Say, a Gromov-Hausdorff space (<a href="https://en.wikipedia.org/wiki/Gromov%E2%80%93Hausdorff_convergence">https://en.wikipedia.org/wiki/Gromov%E2%80%93Hausdorff_convergence</a>) is a metric space whose points are isomorphism classes of compact metric spaces. A correct statement in Lean is than 'Gromov-Hausdorff space is a 'Metric Space 1' which is non-canonically isomorphic to a 'Metric Space'', is that right?</p>



<a name="235460279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460279">(Apr 21 2021 at 06:07)</a>:</h4>
<p>Yes, almost everything in mathlib is "universe polymorphic"</p>



<a name="235460373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460373">(Apr 21 2021 at 06:08)</a>:</h4>
<p>Note that mathlib knows about your example: <a href="https://leanprover-community.github.io/mathlib_docs/find/Gromov_Hausdorff.GH_space">docs#Gromov_Hausdorff.GH_space</a></p>



<a name="235460403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460403">(Apr 21 2021 at 06:09)</a>:</h4>
<p>But metric spaces (and almost all other definitions) are defined using a <code>universe variable u</code>, so that they make sense in <code>Type u</code> for arbitrary <code>u</code>.</p>



<a name="235460683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460683">(Apr 21 2021 at 06:13)</a>:</h4>
<p>I type #check Gromov_Hausdorff.GH_space and it says Type though.<br>
While you just explained it should be Type 1. I'm confused</p>



<a name="235460771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460771">(Apr 21 2021 at 06:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235460403">said</a>:</p>
<blockquote>
<p>But metric spaces (and almost all other definitions) are defined using a <code>universe variable u</code>, so that they make sense in <code>Type u</code> for arbitrary <code>u</code>.</p>
</blockquote>
<p>Is u here a natural number? Or is there a Type \omega and more?</p>



<a name="235460897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460897">(Apr 21 2021 at 06:17)</a>:</h4>
<p>It's not a natural number as in <code>nat</code>, but you can only construct them using <code>zero</code>, <code>succ</code>, and <code>max</code>.</p>



<a name="235460914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460914">(Apr 21 2021 at 06:17)</a>:</h4>
<p>So effectively there's countably many universes.</p>



<a name="235460936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235460936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235460936">(Apr 21 2021 at 06:17)</a>:</h4>
<p>You cannot quantify explicitly over <code>u</code>.</p>



<a name="235461036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461036">(Apr 21 2021 at 06:19)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/Gromov_Hausdorff.isometry_rel.setoid">docs#Gromov_Hausdorff.isometry_rel.setoid</a> explains why this particular example is in <code>Type</code>. It's not defined (in mathlib) exactly in the way you described.</p>



<a name="235461054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461054">(Apr 21 2021 at 06:19)</a>:</h4>
<p>So maybe <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal">docs#cardinal</a> is a better example.</p>



<a name="235461336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461336">(Apr 21 2021 at 06:23)</a>:</h4>
<p>Yes, Gromov-Hausdorff space is defined as a space of all subspaces of l^{\infty}(\R), and than it is a theorem that every compact metric space so arises.</p>



<a name="235461489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461489">(Apr 21 2021 at 06:24)</a>:</h4>
<p>Is there a list of axioms anywhere in mathlib docs, so that I can see full list of which consructions are possible? I can't find one in there.</p>



<a name="235461616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461616">(Apr 21 2021 at 06:26)</a>:</h4>
<p>What exactly do you mean by axioms? Things like how to construct new types from existing ones? Those are usually not called axioms, afaik.</p>



<a name="235461672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461672">(Apr 21 2021 at 06:27)</a>:</h4>
<p>I mean, in ZFC we have Axiom of Union, Axion of Comprehension, Axiom of Powerset, etc</p>



<a name="235461691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461691">(Apr 21 2021 at 06:27)</a>:</h4>
<p>What is Lean's analogue for that?</p>



<a name="235461755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461755">(Apr 21 2021 at 06:28)</a>:</h4>
<p>I don't know ZFC, but your questions are probably answered in Mario's thesis. (searching link for you)</p>



<a name="235461789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461789">(Apr 21 2021 at 06:29)</a>:</h4>
<p><a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>



<a name="235461908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235461908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235461908">(Apr 21 2021 at 06:30)</a>:</h4>
<p>Looks like it, thanks!</p>



<a name="235465339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235465339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235465339">(Apr 21 2021 at 07:09)</a>:</h4>
<p>It is possible to resize types both up and down. The general mechanism for resizing up is <code>ulift</code>, so for example if you need a copy of the real numbers in a big universe you can use <code>ulift real</code></p>



<a name="235465428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235465428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235465428">(Apr 21 2021 at 07:10)</a>:</h4>
<p>To resize down, you have to know some kind of smallness property of the type. For example if the type is countable, then by definition that means it is isomorphic to a subset of nat, and that subset lives in <code>Type</code></p>



<a name="235465474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235465474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235465474">(Apr 21 2021 at 07:11)</a>:</h4>
<p>We also have <a href="https://leanprover-community.github.io/mathlib_docs/find/small/src">src#small</a>, for working with types that you know are "smaller" than the universe that the typechecker knows they inhabit.</p>



<a name="235465496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235465496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235465496">(Apr 21 2021 at 07:11)</a>:</h4>
<p>Also <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.essentially_small/src">src#category_theory.essentially_small</a>, for the corresponding categorical idea.</p>



<a name="235465652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235465652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235465652">(Apr 21 2021 at 07:13)</a>:</h4>
<p>If you want to think in terms of set theory, lean is fairly well approximated by thinking of it as ZFC + countably many inaccessible cardinals. The types <code>Type</code>, <code>Type 1</code>, <code>Type 2</code> correspond to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><msub><mi>κ</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">V_{\kappa_i}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.93343em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">κ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\kappa_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">κ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the i'th inaccessible</p>



<a name="235465745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235465745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235465745">(Apr 21 2021 at 07:14)</a>:</h4>
<p>In particular, <code>Type</code> can be used to construct a model of ZFC, <code>Type 1</code> can be used to construct a model of ZFC with one inaccessible, and so on</p>



<a name="235466211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235466211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235466211">(Apr 21 2021 at 07:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235465652">said</a>:</p>
<blockquote>
<p>If you want to think in terms of set theory, lean is fairly well approximated by thinking of it as ZFC + countably many inaccessible cardinals. The types <code>Type</code>, <code>Type 1</code>, <code>Type 2</code> correspond to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><msub><mi>κ</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">V_{\kappa_i}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.93343em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">κ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\kappa_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">κ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the i'th inaccessible</p>
</blockquote>
<p>So in particular, Axiom of Replacement is provable/has an analogue in Lean?<br>
How do I define \aleph_\omega?</p>



<a name="235466446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235466446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235466446">(Apr 21 2021 at 07:23)</a>:</h4>
<p>Another problem with set theory-based category theory is that the embeddings V_k into V are not necessary elementary. Can we prove an analogue of reflection principle for Type u universes in Lean?</p>



<a name="235471107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235471107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235471107">(Apr 21 2021 at 08:11)</a>:</h4>
<p>The axiom schema of replacement is a set-theoretic concept really. Lean's dependent type theory is equiconsistent with ZFC + infinitely many inaccessibles in the sense that we can build a model of ZFC + inaccessibles in Lean, and conversely in ZFC one can build sets which correspond to Lean's dependent types. This doesn't mean however that there is some direct translation between the axioms of ZFC and what is happening in Lean.</p>



<a name="235471261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235471261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235471261">(Apr 21 2021 at 08:12)</a>:</h4>
<p>Any function in Lean has a well-defined domain and codomain. The axiom of replacement talks about this more general concept of a mapping or whatever you want to call it; such a concept does not really exist in Lean's type theory.</p>



<a name="235471588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235471588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235471588">(Apr 21 2021 at 08:15)</a>:</h4>
<p>Lean's maths library does have a model of ZFC in it, and within that model you can define stuff like its aleph_omega.</p>



<a name="235471849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235471849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235471849">(Apr 21 2021 at 08:17)</a>:</h4>
<p>Here's a more math way of reformulating the Replacement issue: does Lean prove that the category of all types has all (small) limits and colimits?</p>



<a name="235471914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235471914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235471914">(Apr 21 2021 at 08:18)</a>:</h4>
<p>Yup, that's in mathlib</p>



<a name="235472249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472249">(Apr 21 2021 at 08:21)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/category_theory/limits/types.html#category_theory.limits.types.sort.category_theory.limits.has_limits">https://leanprover-community.github.io/mathlib_docs/category_theory/limits/types.html#category_theory.limits.types.sort.category_theory.limits.has_limits</a></p>



<a name="235472325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472325">(Apr 21 2021 at 08:21)</a>:</h4>
<p>(deleted)</p>



<a name="235472447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472447">(Apr 21 2021 at 08:22)</a>:</h4>
<p>We should have a <code>:wat:</code> emoji</p>



<a name="235472472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472472">(Apr 21 2021 at 08:22)</a>:</h4>
<p>Gah, somehow the name is not what it should be, so it's hard to link to in the documentation.</p>



<a name="235472498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472498">(Apr 21 2021 at 08:23)</a>:</h4>
<p>And here's a math explanation of the problem with embeddings of V_k -&gt; V:<br>
Assume that we have proved that the category of all schemes inside Type has products. By definition, that means that for a small scheme Z one has Hom(Z,X \times Y) = Hom(Z,X) \times Hom(Z,Y). But what if we changed our mind and at some point needed a scheme in Type 1 or Type 2? Then for such a large scheme Z the universal property has no reason to hold.<br>
Is this just as much pain in Lean as it is in set theory?</p>



<a name="235472520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472520">(Apr 21 2021 at 08:23)</a>:</h4>
<p>I <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span> instance names</p>



<a name="235472645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472645">(Apr 21 2021 at 08:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407114">Stepan Nesterov</span> <a href="#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235472498">said</a>:</p>
<blockquote>
<p>And here's a math explanation of the problem with embeddings of V_k -&gt; V:<br>
Assume that we have proved that the category of all schemes inside Type has products. By definition, that means that for a small scheme Z one has Hom(Z,X \times Y) = Hom(Z,X) \times Hom(Z,Y). But what if we changed our mind and at some point needed a scheme in Type 1 or Type 2? Then for such a large scheme Z the universal property has no reason to hold.<br>
Is this just as much pain in Lean as it is in set theory?</p>
</blockquote>
<p>Yes. But it doesn't happen in "real math" so it hasn't really bitten us yet.</p>



<a name="235472694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472694">(Apr 21 2021 at 08:24)</a>:</h4>
<p>Also, that's not actually "the definition" of having products. :-)</p>



<a name="235472762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472762">(Apr 21 2021 at 08:25)</a>:</h4>
<p>Of course as a lemma one has that equivalence (not equality :-).</p>



<a name="235472905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235472905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235472905">(Apr 21 2021 at 08:26)</a>:</h4>
<p>We do run into universe problems sometimes when trying to be uber-general (e.g. if we're proving theorems about two modules over a ring, the mathlib style is to have the ring in universe u, one module in universe v and the other in universe w, and then maybe the tensor product of them will be in universe max(u,v,w)). If universes get out of hand then we tend to roll back and start putting things in the same universe. But in the kind of maths which is happening in mathlib, if you just restrict everything to one universe then this in practice solves all your universe problems.</p>



<a name="235473199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473199">(Apr 21 2021 at 08:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235472645">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="407114">Stepan Nesterov</span> <a href="#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235472498">said</a>:</p>
<blockquote>
<p>And here's a math explanation of the problem with embeddings of V_k -&gt; V:<br>
Assume that we have proved that the category of all schemes inside Type has products. By definition, that means that for a small scheme Z one has Hom(Z,X \times Y) = Hom(Z,X) \times Hom(Z,Y). But what if we changed our mind and at some point needed a scheme in Type 1 or Type 2? Then for such a large scheme Z the universal property has no reason to hold.<br>
Is this just as much pain in Lean as it is in set theory?</p>
</blockquote>
<p>Yes. But it doesn't happen in "real math" so it hasn't really bitten us yet.</p>
</blockquote>
<p>I learned some etale cohomology recently and I believe that it present an example of such a 'real-math' universe juggling.<br>
Let X be a scheme in Type. Then its etale site is Type 1, and therefore so is any etale sheaf and any of its injective resolution. Therefore the etale cohomology of X are a priori abelian groups in Type 1 until we prove otherwise in the cases we deem interesting.</p>



<a name="235473283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473283">(Apr 21 2021 at 08:30)</a>:</h4>
<p>Yes that's absolutely right.</p>



<a name="235473286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473286">(Apr 21 2021 at 08:30)</a>:</h4>
<p>But I understand that etale cohomology is not coming to Lean anytime soon sadly :(</p>



<a name="235473308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473308">(Apr 21 2021 at 08:30)</a>:</h4>
<p>That's not right!</p>



<a name="235473361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473361">(Apr 21 2021 at 08:31)</a>:</h4>
<p>I thought we didn't even have that the category of affine schemes is antiequivalent to commutative rings</p>



<a name="235473370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473370">(Apr 21 2021 at 08:31)</a>:</h4>
<p>It's on the horizon, like lots of other things, and indeed we will have to deal with your issue, either by doing the kind of thing de Jong does, or by not caring.</p>



<a name="235473449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473449">(Apr 21 2021 at 08:31)</a>:</h4>
<p>The only reason schemes are stagnating right now is that nobody is working hard on them because all of the algebraic geometers and category people and number theorists have been sucked into this Scholze formalisation project going on in <a class="stream" data-stream-id="267928" href="/#narrow/stream/267928-condensed-mathematics">#condensed mathematics</a></p>



<a name="235473670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473670">(Apr 21 2021 at 08:33)</a>:</h4>
<p>What is happening in practice is that those of us who care about these things have decided that getting homological algebra off the ground is a more important project, and here we run into a type theory issue which probably does not exist in set theory (although I'm not sure about this, I've never formalised mathematics in set theory).</p>



<a name="235473870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473870">(Apr 21 2021 at 08:35)</a>:</h4>
<p>As you can imagine, a solid homological algebra base is going to be necessary before we embark on a serious cohomology theory project. It is possible to get around it, e.g. I have had an MSc student formalising group cohomology, but they stopped before they proved the long exact sequence (they just defined <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^n(G,M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> and proved they were functorial).</p>



<a name="235473954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235473954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235473954">(Apr 21 2021 at 08:36)</a>:</h4>
<p>There's no reason etale cohomology can't be in mathlib a year after condensed sets are done. :-)</p>



<a name="235474071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474071">(Apr 21 2021 at 08:36)</a>:</h4>
<p>The problem we run into when formalising is that if we have abelian groups <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_i\to A_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> then we have maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i-1}\to A_{(i-1)+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(i-1)+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> is equal, but not definitionally equal, to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>, which means that although there are canonical maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_{(i-1)+1}\to A_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the other way, these are not in some sense "the identity function", and this causes an added layer of confusion which we're still learning how to tame.</p>



<a name="235474079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474079">(Apr 21 2021 at 08:36)</a>:</h4>
<p>(Or just a year from now if we keep finding new people at this rate. Or 6 months if someone is especially keen.)</p>



<a name="235474136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474136">(Apr 21 2021 at 08:37)</a>:</h4>
<p>(...I better get back to the <code>homology2</code> branch. I got bored for a few days.)</p>



<a name="235474155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stepan Nesterov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474155">(Apr 21 2021 at 08:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235473449">said</a>:</p>
<blockquote>
<p>The only reason schemes are stagnating right now is that nobody is working hard on them because all of the algebraic geometers and category people and number theorists have been sucked into this Scholze formalisation project going on in <a class="stream" data-stream-id="267928" href="/#narrow/stream/267928-condensed-mathematics">#condensed mathematics</a></p>
</blockquote>
<p>Okay, makes sense, will check this out.<br>
I'd love to join some work on schemes after I play with some easy theorems and get the hang of it, hopefully soon :)</p>



<a name="235474242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474242">(Apr 21 2021 at 08:38)</a>:</h4>
<p>Right -- group cohomology was sufficiently "easy" to do that an MSc student with no Lean experience at all could formalise the objects (which involved doing a lot of combinatorics with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d^2=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> etc) in 9 months whilst working on his other masters courses.</p>



<a name="235474330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474330">(Apr 21 2021 at 08:39)</a>:</h4>
<p><span class="user-mention" data-user-id="407114">@Stepan Nesterov</span> you might also be interested in the "Schemes in Isabelle/HOL" thread in this #maths stream. In particular <a href="#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235395589">there is some recent activity</a> due to Justus Springer.</p>



<a name="235474385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Small%20and%20large%20categories%20in%20Type%20Theory/near/235474385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory.html#235474385">(Apr 21 2021 at 08:39)</a>:</h4>
<p><span class="user-mention" data-user-id="384542">@Justus Springer</span> has recently been doing some great work improving our existing material on sheaf theory. Johan and I wrote much of the first version of this that made it into mathlib, and it wasn't uniformly lovely. <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> has then done sheaves on sites, but we haven't unified the two developments yet. :-(</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
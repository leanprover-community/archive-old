---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html">bundling subgroups -- kernel</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="189968634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968634">(Mar 07 2020 at 12:12)</a>:</h4>
<p>What's the best definition of kernel? Are there arguments in both directions?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ker</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">(</span><span class="err">⊥</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span>

<span class="n">def</span> <span class="n">ker&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">},</span>
  <span class="n">zero_mem</span> <span class="o">:=</span> <span class="bp">...</span>
  <span class="bp">...</span>
<span class="o">}</span>
</pre></div>


<p>The difference is that with the second definition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g\in ker(f)\iff f(g)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is definitional, whereas the other definition expands to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(g)\in\{0\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">}</span></span></span></span> which is defeq to something else</p>



<a name="189968744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968744">(Mar 07 2020 at 12:16)</a>:</h4>
<p>My gut feeling would say, go for (2).</p>



<a name="189968746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968746">(Mar 07 2020 at 12:16)</a>:</h4>
<p>But you'll want a lemma that says that the two definition are equal anyway.</p>



<a name="189968753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968753">(Mar 07 2020 at 12:17)</a>:</h4>
<p>Sure, this is purely a question of which one you want to be the definition and which one you want to be the theorem. But I don't have any real criteria for deciding.</p>



<a name="189968800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968800">(Mar 07 2020 at 12:18)</a>:</h4>
<p>Alternatively you could step back to <code>\bot</code> itself, to fix the definition so that you get the definitional equality you want with the first version</p>



<a name="189968805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968805">(Mar 07 2020 at 12:19)</a>:</h4>
<p>\bot is a subgroup of H so I need to define the carrier set.</p>



<a name="189968808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968808">(Mar 07 2020 at 12:19)</a>:</h4>
<p><code>{x | x = 0}</code></p>



<a name="189968809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968809">(Mar 07 2020 at 12:19)</a>:</h4>
<p>!</p>



<a name="189968810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968810">(Mar 07 2020 at 12:19)</a>:</h4>
<p>If I do it like this then they're probably defeq.</p>



<a name="189968812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968812">(Mar 07 2020 at 12:19)</a>:</h4>
<p>:D</p>



<a name="189968852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968852">(Mar 07 2020 at 12:20)</a>:</h4>
<p>I  feel like a lot of things would be simpler if this was the definition of <code>singleton 0</code></p>



<a name="189968856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968856">(Mar 07 2020 at 12:21)</a>:</h4>
<p>maybe we should remove the definition of <code>singleton</code> from <code>init.core</code>?</p>



<a name="189968858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968858">(Mar 07 2020 at 12:21)</a>:</h4>
<p>One could imagine that notation could handle this somehow -- <code>{}</code> expands to false and <code>{x}</code> to what you just said and then <code>{a,b}</code> could mean <code>{x | x = a \or x = b}</code> etc.</p>



<a name="189968903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968903">(Mar 07 2020 at 12:22)</a>:</h4>
<p>the idea that <code>singleton a = insert a empty</code> in all circumstances is probably a bad idea</p>



<a name="189968904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968904">(Mar 07 2020 at 12:22)</a>:</h4>
<p>but the definition is in <code>core</code>, in the very first file</p>



<a name="189968909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968909">(Mar 07 2020 at 12:23)</a>:</h4>
<p>we have a typeclass <code>has_insert</code>, so we could have <code>has_singleton</code> as well for the version in core to bind to</p>



<a name="189968912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189968912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189968912">(Mar 07 2020 at 12:24)</a>:</h4>
<p>and then the <code>{a, ..., z}</code> notation expands to <code>insert a (insert b ... (singleton z))</code></p>



<a name="189969004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969004">(Mar 07 2020 at 12:26)</a>:</h4>
<p>This would probably break a lot of stuff in a good way i.e. the fix would be "make it a bit simpler"</p>



<a name="189969006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969006">(Mar 07 2020 at 12:26)</a>:</h4>
<p>and <code>mem_singleton</code> would be <code>rfl</code></p>



<a name="189969051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969051">(Mar 07 2020 at 12:28)</a>:</h4>
<p>it is very often that I am too lazy or golfy to go find the relevant theorem and given <code>a \in {b}</code> use <code>rcases h with rfl|&lt;&lt;&gt;&gt;</code> to get at the value. This idiom would get simpler</p>



<a name="189969331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969331">(Mar 07 2020 at 12:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="kn">notation</span> <span class="n">false</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="o">{</span><span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">singleton</span><span class="o">,</span>
  <span class="c1">-- there&#39;s a metavariable in the goal?!</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  ⊢ has_mem.mem t (has_insert.insert s (has_emptyc.emptyc ?m_1))</span>
<span class="cm">  -/</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">tactic failed, result contains meta-variables</span>
<span class="cm">state:</span>
<span class="cm">no goals</span>
<span class="cm">-/</span>
</pre></div>


<p>I was trying to work out what <code>t ∈ {s}</code> was defeq to and I think I broke something</p>



<a name="189969378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969378">(Mar 07 2020 at 12:40)</a>:</h4>
<p>Notice that both <code>{s} : set α</code> and <code>{s} : finset α</code> would be consistent with your theorem statement. I imagine that if you use <code>theorem T</code> instead of <code>example</code> you will get an error</p>



<a name="189969385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969385">(Mar 07 2020 at 12:41)</a>:</h4>
<p>it's because <code>insert</code> has type <code>A -&gt; B -&gt; B</code></p>



<a name="189969395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969395">(Mar 07 2020 at 12:41)</a>:</h4>
<p>and mem has type <code>A -&gt; B -&gt; Prop</code></p>



<a name="189969397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969397">(Mar 07 2020 at 12:41)</a>:</h4>
<p>so nothing there says what <code>B</code> is</p>



<a name="189969443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969443">(Mar 07 2020 at 12:42)</a>:</h4>
<p>nice catch -- thanks.</p>



<a name="189969912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189969912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189969912">(Mar 07 2020 at 12:59)</a>:</h4>
<p>Just to confirm that <code>{s}</code> currently expands to <code>{b : α | b = s ∨ false}</code> -- I was going to say this in the first post but then I got distracted by the example/theorem thing</p>



<a name="189970605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189970605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189970605">(Mar 07 2020 at 13:23)</a>:</h4>
<p>I can't solve the analogous question for range though. If I use <code>set.univ</code> for top (which is {x | true}) and define <code>range</code> to be <code>map top</code> then <code>mem_range</code> (h is in the range iff there exists g with f(g) = h) isn't <code>rfl</code>, it's </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span>
</pre></div>


<p><code>library_search</code> couldn't find this in <code>logic.basic</code>.</p>



<a name="189970706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189970706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189970706">(Mar 07 2020 at 13:26)</a>:</h4>
<p>Indeed, for <code>set.range</code> they just define it directly so mem_range is rfl.</p>



<a name="189970828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/189970828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#189970828">(Mar 07 2020 at 13:31)</a>:</h4>
<p>Aah, <code>simp</code> does it.</p>



<a name="190138721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190138721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190138721">(Mar 10 2020 at 03:03)</a>:</h4>
<p>Last time I checked <code>{a, b}</code> expanded to <code>insert b {a}</code>, not <code>insert a {b}</code>. I think, it would be nice to change this but my knowledge of lean notation syntax is not good enough.</p>



<a name="190140798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190140798">(Mar 10 2020 at 04:02)</a>:</h4>
<p>This is an easy change to core, although it will cause lots of breakage</p>



<a name="190140816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190140816">(Mar 10 2020 at 04:03)</a>:</h4>
<p>Oh! The notation for <code>{a, ..., z}</code> is actually never declared, it is lean magic</p>



<a name="190140823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190140823">(Mar 10 2020 at 04:03)</a>:</h4>
<p>so it would require changes to the C++</p>



<a name="190140874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190140874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190140874">(Mar 10 2020 at 04:05)</a>:</h4>
<p>in a way that's a good thing since I'm not sure it's possible to define <code>{} = empty</code> and <code>{a, b, c} = insert a (insert b (singleton c))</code> as proposed in another thread using the lean 3 <code>notation</code> syntax, which is quite limited</p>



<a name="190141114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190141114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190141114">(Mar 10 2020 at 04:13)</a>:</h4>
<p>Actually, it looks like lean already does the case distinction between empty and nonempty cases. Look what happens if I make my own prelude:</p>
<div class="codehilite"><pre><span></span><span class="n">prelude</span>

<span class="n">def</span> <span class="n">has_emptyc</span><span class="bp">.</span><span class="n">emptyc</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">singleton</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">has_insert</span><span class="bp">.</span><span class="n">insert</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{}</span>  <span class="c1">-- has_emptyc.emptyc ?M_1 : ?M_1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="c1">-- singleton a : Type</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="c1">-- singleton a : Type</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">}</span> <span class="c1">-- has_insert.insert b (singleton a) : singleton a</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">}</span> <span class="c1">-- has_insert.insert c (has_insert.insert b (singleton a)) : Type</span>
</pre></div>


<p>The built in notation parser doesn't actually know what the functions <code>has_insert.insert</code> and <code>singleton</code> are, it just writes these expressions down and hands them off to the elaborator. So really all that is necessary is to remove the definition of <code>singleton</code> and replace it with a typeclass to enable the <code>{0} = {x | x = 0}</code> defeq. However as you can see the order is still flipped; the C++ has to be changed to fix this</p>



<a name="190141180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20subgroups%20--%20kernel/near/190141180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/bundling.20subgroups.20--.20kernel.html#190141180">(Mar 10 2020 at 04:15)</a>:</h4>
<p>(If you are wondering why <code>{a, ..., z}</code> is baked into lean like this, while <code>[a, ... z]</code> is not, it's because lean has to disambiguate the various notations that start with <code>{</code>, e.g. <code>{x // p x}</code>, <code>{x | p x}</code> and <code>{x, y}</code>, and this requires more lookahead than the normal notation parser can tolerate.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
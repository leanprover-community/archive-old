---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/rigid.20(autonomous).20categories.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html">rigid (autonomous) categories</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="248492503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/248492503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#248492503">(Aug 05 2021 at 15:20)</a>:</h4>
<p><a href="https://github.com/javra/mathlib/blob/a9c23f53a33b464beec1132bad625d3f7aef1fa1/src/category_theory/monoidal/rigid.lean">https://github.com/javra/mathlib/blob/a9c23f53a33b464beec1132bad625d3f7aef1fa1/src/category_theory/monoidal/rigid.lean</a></p>



<a name="248492870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/248492870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#248492870">(Aug 05 2021 at 15:22)</a>:</h4>
<p>Maybe that's interesting to any of the category theory formalisers here. Proving that adjoint mates of morphisms compose already seems super hard. Certainly makes the case that one carefully has to prove a lot of "sliding" lemmas for monoidal categories and/or write more tactics to somehow tackle these kinds of equalities.</p>



<a name="249086352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249086352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249086352">(Aug 11 2021 at 09:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110789">@Jakob von Raumer</span>, have a look at <a href="https://github.com/leanprover-community/mathlib/tree/rigid">branch#rigid</a> for my attempt at this. I also discovered that it is disappointingly hard. :-)</p>



<a name="249529227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249529227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249529227">(Aug 15 2021 at 20:30)</a>:</h4>
<p>I now <a href="https://github.com/javra/mathlib/blob/autonomous_cat/src/category_theory/monoidal/rigid.lean">finished</a> some of the complicated proofs, but I think it's an</p>



<a name="249529248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249529248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249529248">(Aug 15 2021 at 20:31)</a>:</h4>
<p>I think its's not disappointingly hard but it's a nice challenge to come up with the infrastructure on both sides of the tactic monad to tackle those kinds of rewriting arguments...</p>



<a name="249531524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249531524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249531524">(Aug 15 2021 at 21:34)</a>:</h4>
<p>I know it's sweeping a lot of coherence theorems under the rug, but it's funny how straightforward the string diagram version of the proof is in comparison:</p>
<p><a href="/user_uploads/3121/SKx1TgrzMF7l3aW8PIHBAY_6/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/SKx1TgrzMF7l3aW8PIHBAY_6/image.png" title="image.png"><img src="/user_uploads/3121/SKx1TgrzMF7l3aW8PIHBAY_6/image.png"></a></div><p>Something I've wondered about is having some tool like <a href="https://ncatlab.org/nlab/show/Globular">Globular</a> that could deal with more abstract diagrams (like the <code>^*</code> operator applied to a diagram) and which could input and output data that could be pasted into a tactic proof.  It seems like no one should ever have to manually insert associators or left/right unitors...  I've heard that in Metamath they take a similar approach to automation, where you can use tools to create proofs.</p>
<p>(Edit: Scott's mentioned this before, of course <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>. I also just learned about <a href="http://homotopy.io">homotopy.io</a> by looking for previous mentions of Globular.)</p>



<a name="249536303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249536303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249536303">(Aug 15 2021 at 23:49)</a>:</h4>
<p>Nicely done, <span class="user-mention" data-user-id="110789">@Jakob von Raumer</span>!</p>



<a name="249556409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249556409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249556409">(Aug 16 2021 at 07:15)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Yes, I'd really like to have a widget for string diagram rewriting proofs! I already tried to motivate my students to do it as a master thesis, but I haven't found anyone so far. I'm not sure if it's worth pursuing in Lean 3 or if it's better to use the widget infrastructure <span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> is implementing in Lean 4.</p>
<p><a href="http://Homotopy.io">Homotopy.io</a> has one huge advantage when visualising the diagrams: They work in a strictly associative setting. I'm not entirely sure how applying an associator would change the visual representation...</p>



<a name="249557107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249557107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249557107">(Aug 16 2021 at 07:25)</a>:</h4>
<p>When I last thought about this I was thinking about formalizing Jamie's definition of quasi-strict n-categories.</p>



<a name="249557143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249557143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249557143">(Aug 16 2021 at 07:26)</a>:</h4>
<p>Much more approachable would be to just do the n=2 case, or perhaps just the monoidal category (2-category with only one 0-morphism) case.</p>



<a name="249557968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249557968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249557968">(Aug 16 2021 at 07:38)</a>:</h4>
<p><span class="user-mention" data-user-id="260921">@Markus Himmel</span> said about his formalisation of the coherence theorem for monoidal categories that he doesn't think it's much easier to reason about strict monoidal categories, because you end up having transport terms all over the place...</p>



<a name="249618656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249618656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249618656">(Aug 16 2021 at 17:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110789">@Jakob von Raumer</span> Maybe this is too limiting, but I was imagining a tool for monoidal categories that pretends you're in a strictly associative setting, but then under-the-hood it would reassociate and introduce identities for you.  You'd give the tool a list of allowed coupons and their signatures, and the data structure of a diagram is compatible compositions of products of coupons.  Sometimes you'd want to bind wires together into a product wire, but that can be done with additional coupons, like one with two input wires for objects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and one output wire for object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\otimes y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</p>
<p>A while back I made some tool in LaTeX and python for drawing string diagram proofs for bialgebras:</p>
<p><a href="/user_uploads/3121/9zY3dx_oskRxrVd8t5IjFNKl/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/9zY3dx_oskRxrVd8t5IjFNKl/image.png" title="image.png"><img src="/user_uploads/3121/9zY3dx_oskRxrVd8t5IjFNKl/image.png"></a></div><p>All it does is draw things, and it's not very sophisticated (all wires are labeled by the same object), but I thought I'd show how these diagrams are written using a mini-language for compositions of coupons:</p>
<div class="codehilite" data-code-language="TeX"><pre><span></span><code>  <span class="k">\begin</span><span class="nb">{</span>align*<span class="nb">}</span>
    <span class="k">\pyc</span><span class="nb">{</span>diag("S; S")<span class="nb">}</span>
    <span class="nb">&amp;</span>= <span class="k">\pyc</span><span class="nb">{</span>diag("m*; e* S; e S; m")<span class="nb">}</span>
    = <span class="k">\pyc</span><span class="nb">{</span>diag("m*; m* S; id S S; m id; m")<span class="nb">}</span>
      = <span class="k">\pyc</span><span class="nb">{</span>diag("m*; id m*; id S S; id id S; id m; m")<span class="nb">}</span><span class="k">\\</span>
    <span class="nb">&amp;</span>=<span class="k">\pyc</span><span class="nb">{</span>diag("m*; id S; id m*; id sw; id id S; id m; m")<span class="nb">}</span>
      =<span class="k">\pyc</span><span class="nb">{</span>diag("m*; id S; id m*; id S id; id sw; id m; m")<span class="nb">}</span>
      =<span class="k">\pyc</span><span class="nb">{</span>diag("m*; id S; id m*; id S id; id m; m")<span class="nb">}</span> <span class="k">\\</span>
    <span class="nb">&amp;</span>= <span class="k">\pyc</span><span class="nb">{</span>diag("m*; id S; id e*; id e; m")<span class="nb">}</span>
      = <span class="k">\pyc</span><span class="nb">{</span>diag("id")<span class="nb">}</span>
  <span class="k">\end</span><span class="nb">{</span>align*<span class="nb">}</span>
</code></pre></div>
<p>Ideally, this could have a graphical editor to help you move things around and apply axioms/2-morphisms.</p>



<a name="249619240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249619240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249619240">(Aug 16 2021 at 17:26)</a>:</h4>
<p>Yes, that's roughly what I was imagining</p>



<a name="249620886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249620886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249620886">(Aug 16 2021 at 17:35)</a>:</h4>
<p>If there were also a way to group coupons into subdiagrams (which can be thought of as composite coupons) then that would at least give a way to say where axioms can be applied.  It's not as elegant as Globular, which seems to be able to efficiently compute where axioms can be applied without this additional structure, but at least it would be workable.</p>



<a name="249690154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249690154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249690154">(Aug 17 2021 at 08:18)</a>:</h4>
<p>I'm formalising all these things with equalities, but I guess the formalisation should actually be agnostic as to whether it really is a category or a 2-category, meaning instead of <code>rw</code> we'd need a version of <code>rw</code> that builds 2-cells using whiskering...</p>



<a name="249690558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249690558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249690558">(Aug 17 2021 at 08:24)</a>:</h4>
<p>Oh --- when I was talking about 2-categories above, I just meant to say that monoidal categories are precisely the 2-categories with a unique 0-morphism (and then shifting everything down a level). I wasn't intending to replace equality with some "richer" 2-morphism structure.</p>



<a name="249690724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249690724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249690724">(Aug 17 2021 at 08:25)</a>:</h4>
<p>Jamie's version of monoidal categories is actually very simple: you no longer have a tensor-product-of-morphisms operation, but only composition and tensoring-with-identities, and these operations are strictly associative. You just have one interesting axiom, the exchange relation which lets you slide one coupon vertically past another one.</p>



<a name="249690851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249690851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249690851">(Aug 17 2021 at 08:27)</a>:</h4>
<p>You can represent diagrams of this form as a list of triples (each triple corresponds to a horizontal slice of a diagram). Each triple contains a list of objects (the strings to the left of the coupon), a morphism (the coupon), and another list of objects (the strings to the right of the coupon).</p>



<a name="249690865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249690865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249690865">(Aug 17 2021 at 08:28)</a>:</h4>
<p>Composition of diagrams is just concatenation of lists.</p>



<a name="249690990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249690990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249690990">(Aug 17 2021 at 08:29)</a>:</h4>
<p>Globular / <a href="http://homotopy.io">homotopy.io</a> (at least when restricted to two dimensional diagrams) only have one "click-and-drag" operation, i.e. the exchange relation swapping the heights of two adjacent slices (when they don't obstruct each other).</p>



<a name="249691451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249691451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249691451">(Aug 17 2021 at 08:36)</a>:</h4>
<p>Without aspiring (immediately) to have a widget interface, it could be really nice to write some tactics for working with this representation of monoidal diagrams. The key piece would be something that can take an expression in the usual (composition + tensor product) language of monoidal categories, and "look for it" in a Jamie-style diagram. (And then have a rewriter, that can rewrite a Jamie-style diagram by an equation written in the usual langauge.)</p>



<a name="249691464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249691464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249691464">(Aug 17 2021 at 08:36)</a>:</h4>
<p>Does that make any sense? I feel the need to draw pictures and gesture at them. :-)</p>



<a name="249694437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249694437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249694437">(Aug 17 2021 at 09:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/rigid.20.28autonomous.29.20categories/near/249690558">said</a>:</p>
<blockquote>
<p>Oh --- when I was talking about 2-categories above, I just meant to say that monoidal categories are precisely the 2-categories with a unique 0-morphism (and then shifting everything down a level). I wasn't intending to replace equality with some "richer" 2-morphism structure.</p>
</blockquote>
<p>I know, but the things I'm working with right now suggest them to be 2-cells instead. <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="249694740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249694740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249694740">(Aug 17 2021 at 09:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/rigid.20.28autonomous.29.20categories/near/249691451">said</a>:</p>
<blockquote>
<p>Without aspiring (immediately) to have a widget interface, it could be really nice to write some tactics for working with this representation of monoidal diagrams. The key piece would be something that can take an expression in the usual (composition + tensor product) language of monoidal categories, and "look for it" in a Jamie-style diagram. (And then have a rewriter, that can rewrite a Jamie-style diagram by an equation written in the usual langauge.)</p>
</blockquote>
<p>Do you mean to use these tactics with a strictly associative tensor product, or to try and "bake the associators in"?</p>



<a name="249695381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249695381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249695381">(Aug 17 2021 at 09:26)</a>:</h4>
<p>I'm just starting to prove that the left adjoint mate of the right adjoint mate of a morphism is the morphism itself, again a "sliding" proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">there</span> <span class="n">are</span> <span class="n">unsolved</span> <span class="n">goals</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">category</span> <span class="n">C</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">monoidal_category</span> <span class="n">C</span><span class="o">,</span>
<span class="n">W</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span>
<span class="n">WX</span> <span class="o">:</span> <span class="n">exact_pairing</span> <span class="n">W</span> <span class="n">X</span><span class="o">,</span>
<span class="n">YZ</span> <span class="o">:</span> <span class="n">exact_pairing</span> <span class="n">Y</span> <span class="n">Z</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⊗</span> <span class="n">η_</span> <span class="n">W</span> <span class="n">X</span><span class="o">)</span> <span class="bp">≫</span>
      <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">W</span> <span class="bp">⊗</span> <span class="o">(</span><span class="bp">λ</span><span class="n">_</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span><span class="o">)</span> <span class="bp">≫</span>
        <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">W</span> <span class="bp">⊗</span> <span class="n">η_</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">X</span><span class="o">)</span> <span class="bp">≫</span>
          <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">W</span> <span class="bp">⊗</span> <span class="o">(</span><span class="n">α_</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span><span class="o">)</span> <span class="bp">≫</span>
            <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⊗</span> <span class="o">(</span><span class="n">α_</span> <span class="n">W</span> <span class="n">Y</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span><span class="bp">.</span><span class="n">inv</span><span class="o">)</span> <span class="bp">≫</span>
              <span class="o">(</span><span class="n">α_</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">W</span> <span class="bp">⊗</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">≫</span>
                <span class="o">((</span><span class="n">α_</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">)</span> <span class="n">W</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span> <span class="bp">≫</span>
                  <span class="o">(((</span><span class="n">α_</span> <span class="n">Z</span> <span class="n">X</span> <span class="n">W</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span> <span class="bp">≫</span>
                    <span class="o">(((</span><span class="mi">𝟙</span> <span class="n">Z</span> <span class="bp">⊗</span> <span class="n">ε_</span> <span class="n">W</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span> <span class="bp">≫</span>
                      <span class="o">(((</span><span class="n">ρ_</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">ε_</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">⊗</span> <span class="mi">𝟙</span> <span class="o">(</span><span class="n">Z</span> <span class="bp">⊗</span> <span class="n">X</span><span class="o">))</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">α_</span> <span class="n">Z</span> <span class="n">X</span> <span class="o">(</span><span class="mi">𝟙</span><span class="n">_</span> <span class="n">C</span><span class="o">))</span><span class="bp">.</span><span class="n">hom</span> <span class="bp">≫</span> <span class="o">((</span><span class="bp">λ</span><span class="n">_</span> <span class="n">Z</span><span class="o">)</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">⊗</span> <span class="o">(</span><span class="n">ρ_</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">(</span><span class="n">α_</span> <span class="o">(</span><span class="mi">𝟙</span><span class="n">_</span> <span class="n">C</span><span class="o">)</span> <span class="n">Z</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">hom</span>
</code></pre></div>
<p>What struck me as useful is that we do not only generate reassociated lemmas in the category composition but generate versions that can be used to rewrite when additional terms are tensored to the left and right of the lemmas, to prevent having to conjugate with <code>tensor_comp</code> every time...</p>



<a name="249718036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249718036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249718036">(Aug 17 2021 at 13:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/rigid.20.28autonomous.29.20categories/near/249691451">said</a>:</p>
<blockquote>
<p>Without aspiring (immediately) to have a widget interface, it could be really nice to write some tactics for working with this representation of monoidal diagrams. The key piece would be something that can take an expression in the usual (composition + tensor product) language of monoidal categories, and "look for it" in a Jamie-style diagram. (And then have a rewriter, that can rewrite a Jamie-style diagram by an equation written in the usual langauge.)</p>
</blockquote>
<p>Is the proof that the category of Jamie-Style categories is equivalent to monoidal categories a done deal?</p>



<a name="249791787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249791787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249791787">(Aug 17 2021 at 23:28)</a>:</h4>
<p>Hmm, very good question.</p>



<a name="249827019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249827019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249827019">(Aug 18 2021 at 09:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/rigid.20.28autonomous.29.20categories/near/249690851">said</a>:</p>
<blockquote>
<p>You can represent diagrams of this form as a list of triples (each triple corresponds to a horizontal slice of a diagram). Each triple contains a list of objects (the strings to the left of the coupon), a morphism (the coupon), and another list of objects (the strings to the right of the coupon).</p>
</blockquote>
<p>Just to make sure that I'm on the same page, you mean that the sliding of morphisms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">g : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> would be represented by something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>g</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>D</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>C</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>g</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[([A],g,[]),([],f,[D])] = [([],f,[C]),([B],g,[])]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[([</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mclose">])</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">([</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">])]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[([</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">])</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">([</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mclose">])]</span></span></span></span>?</p>



<a name="249828199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249828199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249828199">(Aug 18 2021 at 09:58)</a>:</h4>
<p>Yes.</p>



<a name="249828288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249828288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249828288">(Aug 18 2021 at 09:59)</a>:</h4>
<p>The point is that by not allowing exactly-side-by-side morphisms (as are produced by <code>\otimes</code>), we can drastically reduce the number of axioms needed to describe a monoidal category.</p>



<a name="249831685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249831685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249831685">(Aug 18 2021 at 10:40)</a>:</h4>
<p>Yes, but it solves a provlem which is orthogonal to the one of having to deal with associators, right?</p>



<a name="249832517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249832517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249832517">(Aug 18 2021 at 10:50)</a>:</h4>
<p>I guess so. This formulation is (besides other things) strictifying the tensor product on objects, so I guess is no more helpful than strictification.</p>



<a name="249834615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/249834615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#249834615">(Aug 18 2021 at 11:16)</a>:</h4>
<p>Doesn't it require strictification first? Or are we able to go back and forth between Jamie-style categories and monoidal categories without strictification by removing/adding the associators?</p>



<a name="250478549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/250478549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#250478549">(Aug 24 2021 at 12:43)</a>:</h4>
<p>Do you think the rigid categories should be PR'ed? Or should  I first instantiate them with FinVec? (Which needs a construction of the coevaluation map first...)</p>



<a name="250568055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/250568055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#250568055">(Aug 25 2021 at 00:39)</a>:</h4>
<p>I would be very happy to have them PR'd even without an example, but FinVec would be lovely as well. (Small digestible PRs are great: big PRs are prone to either very long review, or not-that-great-a-job reviews.)</p>



<a name="251412748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251412748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251412748">(Aug 31 2021 at 16:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/rigid.20.28autonomous.29.20categories/near/250568055">said</a>:</p>
<blockquote>
<p>I would be very happy to have them PR'd even without an example, but FinVec would be lovely as well. (Small digestible PRs are great: big PRs are prone to either very long review, or not-that-great-a-job reviews.)</p>
</blockquote>
<p>FinVect is <a href="https://github.com/javra/mathlib/blob/autonomous_cat/src/algebra/category/FinVect.lean#L174">done</a> <span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span></p>



<a name="251414912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251414912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251414912">(Aug 31 2021 at 16:31)</a>:</h4>
<p>Can someone give me the rights to write on branches of mathlib?</p>



<a name="251415278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251415278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251415278">(Aug 31 2021 at 16:33)</a>:</h4>
<p>Invite sent! <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>



<a name="251415841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251415841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251415841">(Aug 31 2021 at 16:37)</a>:</h4>
<p>Thanks!</p>



<a name="251541568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251541568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251541568">(Sep 01 2021 at 11:19)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/8946">PR'ed</a></p>



<a name="251572209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251572209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251572209">(Sep 01 2021 at 14:50)</a>:</h4>
<p>No idea on how to prevent the linter from complaining about <code>reassoc</code> creating non-simp-nf lemmas</p>



<a name="251575080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251575080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251575080">(Sep 01 2021 at 15:04)</a>:</h4>
<p>What about swapping the order of the attributes simp and reassoc? so that reassoc comes first</p>



<a name="251599853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/rigid%20%28autonomous%29%20categories/near/251599853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/rigid.20(autonomous).20categories.html#251599853">(Sep 01 2021 at 17:42)</a>:</h4>
<p>Ah, that could work. Or adding the simp attribute after the declaration</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
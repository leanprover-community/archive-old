---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Inductive.20construction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html">Inductive construction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="186735706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186735706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186735706">(Jan 27 2020 at 23:03)</a>:</h4>
<p>I'm trying to formalise this argument: an infinite set contains countably many points. Proof: given infinite s, pick an element x0. Then s1 := s - {x0} is infinite, so we can pick an element x1. Then x2 := s1 - {x1} is infinite, continue inductively. <br>
Here's where I'm at so far</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">10</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="kn">lemma</span> <span class="n">exists_mem_of_infinite</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">exists_mem_of_ne_empty</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">hs</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">finite_empty</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">infinite_erase</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="o">{</span><span class="n">t</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">|</span> <span class="n">t</span> <span class="bp">≠</span> <span class="n">x</span><span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hs</span><span class="o">,</span> <span class="n">by_cases</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span>
    <span class="n">convert</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite_insert</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span> <span class="n">ext</span> <span class="n">t</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">intro</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="o">(</span><span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="o">),</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="err">‹</span><span class="bp">_</span><span class="err">›</span><span class="o">,</span> <span class="err">‹</span><span class="bp">_</span><span class="err">›</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">(</span><span class="n">rfl</span> <span class="bp">|</span> <span class="bp">_</span><span class="o">),</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">a_1</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">a</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">p</span><span class="o">,</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">has_sequence_of_infinite</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">a</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>I'll add that my question is about how to get this form of inductive construction as proof, rather than a different formalisation of the statement</p>



<a name="186736301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736301">(Jan 27 2020 at 23:11)</a>:</h4>
<p>You need to use <code>choice</code> recursively to construct the sequence</p>



<a name="186736321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736321">(Jan 27 2020 at 23:11)</a>:</h4>
<p>(this is a principle known as dependent choice in the literature)</p>



<a name="186736538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736538">(Jan 27 2020 at 23:14)</a>:</h4>
<p>This is the kind of thing that <a href="https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/logic/crec.lean" target="_blank" title="https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/logic/crec.lean">https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/logic/crec.lean</a> is supposed to be good for, though it might be a bit awkward in this specific setup</p>



<a name="186736622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736622">(Jan 27 2020 at 23:15)</a>:</h4>
<blockquote>
<p>(this is a principle known as dependent choice in the literature)</p>
</blockquote>
<p>Yeah I'm aware of this, but I can't get the recursion to work in lean</p>



<a name="186736715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736715">(Jan 27 2020 at 23:16)</a>:</h4>
<p>More generally I'm not sure how I'd do a construction like <a href="https://en.wikipedia.org/wiki/Recursive_definition#Principle_of_recursive_definition" target="_blank" title="https://en.wikipedia.org/wiki/Recursive_definition#Principle_of_recursive_definition">this one</a></p>



<a name="186736746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736746">(Jan 27 2020 at 23:17)</a>:</h4>
<p>that's just definition by well founded recursion, the equation compiler does it for you</p>



<a name="186736848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736848">(Jan 27 2020 at 23:18)</a>:</h4>
<p>But how can I do it myself? For instance if I had to do that inside a bigger theorem - I can't figure out how to get it then</p>



<a name="186736987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186736987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186736987">(Jan 27 2020 at 23:20)</a>:</h4>
<p>for example you can do something like this--your lemmas won't help here though</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">has_sequence_of_infinite</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">a</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="bp">⟩</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">a</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">}</span> <span class="o">:=</span>
    <span class="n">crec&#39;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_wf</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">y</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">If</span><span class="o">,</span> <span class="n">IH</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="n">If</span> <span class="n">i</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">},</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_trichotomy</span> <span class="n">i</span> <span class="n">j</span> <span class="k">with</span> <span class="n">h&#39;</span><span class="bp">|</span><span class="n">h&#39;</span><span class="bp">|</span><span class="n">h&#39;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">ha</span> <span class="n">i</span> <span class="n">j</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#39;</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">ha</span> <span class="n">j</span> <span class="n">i</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>



<a name="186737081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186737081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186737081">(Jan 27 2020 at 23:22)</a>:</h4>
<p>You have something more like a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:unfoldr" target="_blank" title="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:unfoldr">https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:unfoldr</a> (without the Maybe)</p>



<a name="186737150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186737150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186737150">(Jan 27 2020 at 23:23)</a>:</h4>
<p>Yeah I was surprised that something so natural in haskell is awkward here</p>



<a name="186737275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186737275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186737275">(Jan 27 2020 at 23:25)</a>:</h4>
<p>haskell doesn't care about proofs, though, which are what make this proof tricky</p>



<a name="186737290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186737290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186737290">(Jan 27 2020 at 23:25)</a>:</h4>
<p>Fair point!</p>



<a name="186742823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186742823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186742823">(Jan 28 2020 at 00:52)</a>:</h4>
<p>Alternative method. We need to unify <code>set.infinite</code> and <code>infinite</code> for types</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">denumerable</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>

<span class="n">def</span> <span class="n">seq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">denumerable</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">denumerable</span><span class="bp">.</span><span class="n">of_encodable_of_infinite</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">hs</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">⟩⟩</span>
</pre></div>



<a name="186742924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186742924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186742924">(Jan 28 2020 at 00:54)</a>:</h4>
<p>I think there is also a quick method using the <code>cardinal</code> library</p>



<a name="186743316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186743316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186743316">(Jan 28 2020 at 01:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">cardinal</span>

<span class="kn">theorem</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite_iff</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">infinite</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span> <span class="n">f</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">has_sequence_of_infinite</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">a</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">cardinal</span><span class="bp">.</span><span class="n">infinite_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">infinite_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span><span class="o">)</span> <span class="k">in</span>
<span class="bp">⟨λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">e</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">ulift</span><span class="bp">.</span><span class="n">down</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="n">e</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>



<a name="186765557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186765557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186765557">(Jan 28 2020 at 09:28)</a>:</h4>
<p>I wanted something like crec' recently, but I think it's not quite general enough? I wanted</p>
<div class="codehilite"><pre><span></span><span class="kn">parameters</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">hwf</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="n">r</span><span class="o">)</span> <span class="o">[</span><span class="n">is_trans</span> <span class="n">α</span> <span class="n">r</span><span class="o">]</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`&lt;`</span> <span class="o">:=</span> <span class="n">r</span>
<span class="kn">parameters</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">C</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">parameters</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
         <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">j</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">j</span> <span class="n">rja</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="n">rja</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">rij</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">(</span><span class="n">trans</span> <span class="n">rij</span> <span class="n">rja</span><span class="o">))}),</span>
       <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">//</span> <span class="n">q</span> <span class="n">x</span> <span class="n">f</span><span class="o">})</span>
<span class="o">:</span>
<span class="n">def</span> <span class="n">crec&#39;</span> <span class="o">:</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">j</span><span class="o">,</span> <span class="n">C</span> <span class="n">j</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">j</span><span class="o">,</span> <span class="n">q</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">rij</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)}</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>



<a name="186765812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186765812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186765812">(Jan 28 2020 at 09:32)</a>:</h4>
<p>Given that, the crec' of <span class="user-mention" data-user-id="110032">@Reid Barton</span> can be derived quite easily</p>
<div class="codehilite"><pre><span></span><span class="kn">parameters</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">⦃</span><span class="n">i</span> <span class="n">j</span><span class="o">⦄</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span><span class="o">),</span> <span class="n">C</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">j</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">parameters</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
         <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">i</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="n">ria</span> <span class="n">rja</span> <span class="n">rij</span><span class="o">,</span> <span class="n">q</span> <span class="n">rij</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">ria</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="n">rja</span><span class="o">)}),</span>
       <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">(</span><span class="n">ria</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">),</span> <span class="n">q</span> <span class="n">ria</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">val</span> <span class="n">i</span> <span class="n">ria</span><span class="o">)</span> <span class="n">x</span><span class="o">})</span>

<span class="n">def</span> <span class="n">q&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">j</span><span class="o">,</span> <span class="n">C</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">j</span> <span class="n">fj</span> <span class="n">f</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">rij</span><span class="o">,</span> <span class="n">q</span> <span class="n">rij</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">rij</span><span class="o">)</span> <span class="n">fj</span>

<span class="n">def</span> <span class="n">H&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
           <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">j</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">j</span> <span class="n">rja</span><span class="o">,</span> <span class="n">q&#39;</span> <span class="n">j</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span> <span class="n">rja</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">rij</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">(</span><span class="n">trans</span> <span class="n">rij</span> <span class="n">rja</span><span class="o">))}),</span>
         <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">//</span> <span class="n">q&#39;</span> <span class="n">a</span> <span class="n">x</span> <span class="n">f</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">f</span><span class="o">,</span> <span class="n">H</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span> <span class="n">ria</span> <span class="n">rja</span> <span class="n">rij</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="n">j</span> <span class="n">rja</span> <span class="n">i</span> <span class="n">rij</span><span class="o">)</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">old_crec&#39;</span> <span class="o">:</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">C</span> <span class="n">i</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="n">h</span><span class="o">,</span> <span class="n">q</span> <span class="n">h</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span><span class="o">)}</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">crec&#39;</span> <span class="n">hwf</span> <span class="n">q&#39;</span> <span class="n">H&#39;</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">f</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="n">j</span> <span class="n">i</span><span class="o">)</span><span class="bp">⟩</span>
</pre></div>



<a name="186765960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186765960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186765960">(Jan 28 2020 at 09:34)</a>:</h4>
<p>I guess I have assumed additionally that <code>&lt;</code> is transitive.</p>



<a name="186766040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186766040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186766040">(Jan 28 2020 at 09:35)</a>:</h4>
<p>Anyway it would be great to see this in mathlib</p>



<a name="186769596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186769596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186769596">(Jan 28 2020 at 10:29)</a>:</h4>
<blockquote>
<p>Alternative method. We need to unify <code>set.infinite</code> and <code>infinite</code> for types</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">denumerable</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>

<span class="n">def</span> <span class="n">seq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">denumerable</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">denumerable</span><span class="bp">.</span><span class="n">of_encodable_of_infinite</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">hs</span> <span class="bp">⟨</span><span class="n">h</span><span class="bp">⟩⟩</span>
</pre></div>


</blockquote>
<p>Sure, I realise we can get other formalisations of the statement, but I'm asking about how to formalise the proof idea. For instance, the same mathematical proof immediately adapts to show</p>
<div class="codehilite"><pre><span></span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="n">j</span><span class="o">)</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">-</span> <span class="mi">10</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">a</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="n">j</span> <span class="bp">+</span> <span class="mi">25</span><span class="o">)</span>
</pre></div>


<p>or</p>
<div class="codehilite"><pre><span></span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">a</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="n">a</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="n">j</span><span class="o">)</span>
</pre></div>


<p>but I don't see how to use <code>denumerable</code> to get these - whereas it appears <code>crec'</code> does adapt nicely to these cases</p>



<a name="186978506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Inductive%20construction/near/186978506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Inductive.20construction.html#186978506">(Jan 30 2020 at 12:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <code>crec'</code> works for me! Thanks so much</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
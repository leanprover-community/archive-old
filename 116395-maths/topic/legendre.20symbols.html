---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/legendre.20symbols.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html">legendre symbols</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="195294382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195294382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195294382">(Apr 25 2020 at 17:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">legendre_sym_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">legendre_sym</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">legendre_sym</span> <span class="n">a</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">legendre_sym</span> <span class="n">b</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="err">←</span> <span class="n">legendre_sym_hom_apply</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span> <span class="o">(</span><span class="n">legendre_sym_hom</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">]</span>
</pre></div>


<p><a href="https://github.com/leanprover-community/mathlib/blob/legendre-sym-mul/src/number_theory/quadratic_reciprocity.lean#L562" title="https://github.com/leanprover-community/mathlib/blob/legendre-sym-mul/src/number_theory/quadratic_reciprocity.lean#L562">https://github.com/leanprover-community/mathlib/blob/legendre-sym-mul/src/number_theory/quadratic_reciprocity.lean#L562</a></p>



<a name="195294394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195294394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195294394">(Apr 25 2020 at 17:26)</a>:</h4>
<p>Which leads to</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">legendre_sym</span> <span class="mi">43</span> <span class="mi">29</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="mi">29</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span>  <span class="mi">7</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">29</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span> <span class="mi">7</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">legendre_sym</span> <span class="mi">43</span> <span class="mi">29</span> <span class="bp">=</span> <span class="n">legendre_sym</span> <span class="mi">14</span> <span class="mi">29</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_mod</span><span class="o">,</span> <span class="k">show</span> <span class="mi">43</span> <span class="err">%</span> <span class="mi">29</span> <span class="bp">=</span> <span class="mi">14</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">]</span> <span class="o">}</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="n">legendre_sym</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="mi">7</span><span class="o">)</span> <span class="mi">29</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="k">show</span> <span class="mi">14</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="mi">7</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">]</span> <span class="o">}</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="n">legendre_sym</span> <span class="mi">2</span> <span class="mi">29</span> <span class="bp">*</span> <span class="n">legendre_sym</span> <span class="mi">7</span> <span class="mi">29</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_mul</span><span class="o">]</span> <span class="o">}</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">legendre_sym</span> <span class="mi">7</span> <span class="mi">29</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_two</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span><span class="err">^</span><span class="o">(</span><span class="mi">29</span><span class="bp">/</span><span class="mi">4</span> <span class="bp">+</span> <span class="mi">29</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">],</span>
                                 <span class="n">rw</span> <span class="o">[</span><span class="n">neg_one_mul</span><span class="o">]</span> <span class="o">}</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">legendre_sym</span> <span class="mi">29</span> <span class="mi">7</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_swap</span> <span class="mi">7</span> <span class="mi">29</span> <span class="n">dec_trivial</span><span class="o">],</span>
                                 <span class="n">rw</span> <span class="o">[</span><span class="k">show</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="mi">7</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">29</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="o">}</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">legendre_sym</span> <span class="mi">1</span> <span class="mi">7</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_mod</span><span class="o">,</span> <span class="k">show</span> <span class="mi">29</span> <span class="err">%</span> <span class="mi">7</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="o">]</span> <span class="o">}</span>
                      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:</span>
                            <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_one</span><span class="o">]</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="195294408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195294408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195294408">(Apr 25 2020 at 17:27)</a>:</h4>
<p>But I think that we might want to refactor this a bit. Because currently we cannot talk about the Legendre symbol of <code>x : Z_[p]</code> with respect to <code>p</code>.</p>



<a name="195295622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295622">(Apr 25 2020 at 17:57)</a>:</h4>
<p>I was thinking exactly the same thing last week! Legendre needs a little love, but it would be cool to generalize to kronecker symbols too</p>



<a name="195295767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295767">(Apr 25 2020 at 18:00)</a>:</h4>
<p>One of the codewars questions would be a whole lot easier if we had Kronecker symbols.</p>



<a name="195295905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295905">(Apr 25 2020 at 18:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">legendre_sym</span> <span class="n">n</span> <span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">]),</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">letI</span> <span class="bp">_</span><span class="n">hp</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">p</span><span class="bp">.</span><span class="n">prime</span> <span class="o">:=</span> <span class="err">‹</span><span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="err">›</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hn</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">legendre_sym_eq_zero_iff</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hn</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">h</span> <span class="n">zero_ne_one</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">legendre_sym_eq_one_iff</span> <span class="n">p</span> <span class="n">hn</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">nat_cast_surjective</span> <span class="n">x</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="bp">ℤ_</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">:=</span> <span class="n">X</span><span class="err">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="bp">@</span><span class="n">hensels_lemma</span> <span class="n">p</span> <span class="bp">_</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">_</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">H</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">sub_eq_zero</span><span class="o">,</span> <span class="n">eval_C</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">eval_pow</span><span class="o">,</span> <span class="n">eval_sub</span><span class="o">]</span> <span class="kn">using</span> <span class="n">hx</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">f</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval_C</span><span class="o">,</span> <span class="n">eval_X</span><span class="o">,</span> <span class="n">eval_pow</span><span class="o">,</span> <span class="n">eval_sub</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pow_two</span><span class="o">,</span> <span class="n">sub_eq_add_neg</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval_X</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">derivative_X</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">derivative_add</span><span class="o">,</span> <span class="n">derivative_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">eval_add</span><span class="o">],</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>



<a name="195295912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295912">(Apr 25 2020 at 18:04)</a>:</h4>
<p>When I took over teaching Imperial's basic number theory course just after I was employed there, the lecture notes handed to me contained this glorious fact that (2/p)=(-1)^{(p^2-1)/8}; I see Chris has found some simpler trick involving <code>p/4+p/2</code> but I was convinced that the students would rather be told that (2/p) is +1 if p=1 or 7 mod 8, and -1 if it's 3 or 5 mod 8. Similarly for this <code>(p/q)(q/p)=(-1)^{p/2*q/2}</code> result. Isn't it better to just reduce things mod 4 than to be working out <code>7/2*29/2</code>? Unfortunately I can't make a PR because I already have a very complicated one about de Morgan's laws on the pile.</p>



<a name="195295913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295913">(Apr 25 2020 at 18:04)</a>:</h4>
<p>Unfortunately the final <code>sorry</code> is out of reach for the time being</p>



<a name="195295932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295932">(Apr 25 2020 at 18:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/legendre.20symbols/near/195295913" title="#narrow/stream/116395-maths/topic/legendre.20symbols/near/195295913">said</a>:</p>
<blockquote>
<p>Unfortunately the final <code>sorry</code> is out of reach for the time being</p>
</blockquote>
<p>Are you kidding??</p>



<a name="195295942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295942">(Apr 25 2020 at 18:05)</a>:</h4>
<p><code>padic_norm</code> has no connection with <code>zmod p</code> at the moment</p>



<a name="195295952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295952">(Apr 25 2020 at 18:05)</a>:</h4>
<p>Hensels lemma doesn't mention finite fields in Lean</p>



<a name="195295996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195295996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195295996">(Apr 25 2020 at 18:06)</a>:</h4>
<p>We really need Henselian rings, and 7 different versions of Hensel's lemma</p>



<a name="195296008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195296008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195296008">(Apr 25 2020 at 18:06)</a>:</h4>
<p>Ashwin started on DVR's, at least.</p>



<a name="195311825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195311825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195311825">(Apr 26 2020 at 01:47)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I was inspired by your legendre calculation and the idea of having a legendre tactic to run through and calculate a symbol automatically (and then a ternary quadratic form tatic or something lol), so I made a PR to do one line of your proof automatically <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> rewriting <code>14=2*7</code> without thinking. <a href="https://github.com/leanprover-community/mathlib/issues/2536" title="https://github.com/leanprover-community/mathlib/issues/2536">#2536</a>.</p>



<a name="195315292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315292">(Apr 26 2020 at 03:37)</a>:</h4>
<p>Nice! I had recently been thinking about how to hook up more general computations. The vague idea that I had was:</p>
<ul>
<li>introduce a class <code>compute foo</code></li>
<li>add instances of <code>compute fib</code> and <code>compute legendre_sym</code> that "explain" how to compute these functions</li>
<li>make the <code>norm_num</code> tactic aware of this class</li>
</ul>
<p>Now the hard part is to figure out what "explain" means. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110026">@Simon Hudon</span> do you have any ideas on how this could work?</p>



<a name="195315511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315511">(Apr 26 2020 at 03:44)</a>:</h4>
<p>Probably it should return the answer and a proof of correctness.</p>



<a name="195315513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315513">(Apr 26 2020 at 03:44)</a>:</h4>
<p>My plan has been to use a <code>def_replacer</code> for <code>norm_num</code> so that you can dynamically add more disjuncts to <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/norm_num.lean#L450-L451" title="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/norm_num.lean#L450-L451">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/norm_num.lean#L450-L451</a></p>



<a name="195315580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315580">(Apr 26 2020 at 03:46)</a>:</h4>
<p>So for instance you could write something like <code>eval_prime</code> there in the file on primes instead of inside <code>norm_num</code> itself, and this tactic can do whatever trickery it needs to to efficiently compute the result</p>



<a name="195315585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315585">(Apr 26 2020 at 03:46)</a>:</h4>
<p>It's not just constrained to being an evaluator, although for a lot of functions that's probably what you would do</p>



<a name="195315696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315696">(Apr 26 2020 at 03:52)</a>:</h4>
<p>Would there be a dumbed down API method for people who are not very good at tactic writing?</p>



<a name="195315744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315744">(Apr 26 2020 at 03:53)</a>:</h4>
<p>I think the easy version is that you first match on the expr you are looking for (e.g. <code>`(prime %%e)</code>), then use a quick tactic script to rewrite with the definition and call norm_num on what remains</p>



<a name="195315748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315748">(Apr 26 2020 at 03:53)</a>:</h4>
<p>which will wind up calling this function again recursively if you aren't done yet</p>



<a name="195315796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315796">(Apr 26 2020 at 03:54)</a>:</h4>
<p>Alternatively, you run the function externally (in the tactic/VM), then construct the result numeral and hope that <code>rfl</code> works as a proof</p>



<a name="195315856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315856">(Apr 26 2020 at 03:56)</a>:</h4>
<p>But to really have the desired dumbed down API we need the <code>cbv</code> tactic</p>



<a name="195315868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315868">(Apr 26 2020 at 03:57)</a>:</h4>
<p>and that probably has to be implemented in core</p>



<a name="195315977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315977">(Apr 26 2020 at 04:00)</a>:</h4>
<p>What would we need to make <code>cbv</code> happen? Could you write a roadmap?</p>



<a name="195315983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315983">(Apr 26 2020 at 04:01)</a>:</h4>
<p>Basically it is a tactic that performs the same operation as <code>#reduce</code> but with proofs</p>



<a name="195315987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195315987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195315987">(Apr 26 2020 at 04:01)</a>:</h4>
<p>I think it needs to be implemented in C++ for efficiency</p>



<a name="195316024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195316024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195316024">(Apr 26 2020 at 04:02)</a>:</h4>
<p>It is more or less <code>simp [all equation lemmas]</code></p>



<a name="195316072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195316072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195316072">(Apr 26 2020 at 04:04)</a>:</h4>
<p>The name comes from a tactic with this behavior in Coq, but admittedly I don't know that much about how it works, what kinds of things cause it to stop and so on</p>



<a name="195316076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195316076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195316076">(Apr 26 2020 at 04:04)</a>:</h4>
<p>You don't want to completely reduce the term to normal form because it will get unreadable long before then</p>



<a name="195316467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195316467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195316467">(Apr 26 2020 at 04:19)</a>:</h4>
<p>I found <a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.cbv" title="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.cbv">the doc page</a> on the Coq tactic. Is it like <code>dsimp</code> but with more control?</p>



<a name="195322160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195322160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195322160">(Apr 26 2020 at 07:31)</a>:</h4>
<p>Regarding computing legendre symbols: Maybe it would be easier to teach <code>norm_num</code> how to evaluate <code>29^14</code> in <code>zmod p</code> and use Euler's criterion? This should certainly be much more computationally efficient for computing large legendre symbols.</p>



<a name="195323784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195323784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195323784">(Apr 26 2020 at 08:20)</a>:</h4>
<p>I don't know if this helps, but there's also a simple &amp; efficient algorithm to compute large Legendre symbols using QR: <a href="https://en.wikipedia.org/wiki/Jacobi_symbol#Calculating_the_Jacobi_symbol" title="https://en.wikipedia.org/wiki/Jacobi_symbol#Calculating_the_Jacobi_symbol">https://en.wikipedia.org/wiki/Jacobi_symbol#Calculating_the_Jacobi_symbol</a></p>



<a name="195324077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195324077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195324077">(Apr 26 2020 at 08:30)</a>:</h4>
<p>Right the quadratic reciprocity one is what I had in mind, it's what I would do by hand. I don't know what the runtime of exponentiating and using eulers criterion is but it seems like it should be harder to take exponentials, even if you do it in a smart way (but it is easiest to implement).</p>



<a name="195324757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195324757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195324757">(Apr 26 2020 at 08:49)</a>:</h4>
<p>Both should be polynomial in the number of digits, but exponentiation needs lots of expensive multiplications / remainders</p>



<a name="195325115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195325115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195325115">(Apr 26 2020 at 08:58)</a>:</h4>
<p>keep in mind that the asymptotic analysis in the books isn't quite correct for theorem provers. Division / modulus are exactly as expensive as multiplication + addition, because it's the same proof</p>



<a name="195325140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195325140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195325140">(Apr 26 2020 at 08:59)</a>:</h4>
<p>Unfortunately the literature is much sparser on what the best bounds are for nondeterministic TMs</p>



<a name="195326008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195326008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195326008">(Apr 26 2020 at 09:23)</a>:</h4>
<p>The standard algorithm using QR will be super-fast in practice as long as there's an efficient division with remainder algorithm, and will also compute Jacobi symbols (note that it needs no factoring either, just casting out powers of 2). The p^(q-1)/2 approach leaves you having to do multiplications mod q which might really hurt if q has 100 digits, and doesn't work for Jacobi symbols because it relies on the units being cyclic</p>



<a name="195326110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195326110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195326110">(Apr 26 2020 at 09:24)</a>:</h4>
<p>what's qt?</p>



<a name="195326124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195326124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195326124">(Apr 26 2020 at 09:25)</a>:</h4>
<p>did you mean qr?</p>



<a name="195326147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/legendre%20symbols/near/195326147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/legendre.20symbols.html#195326147">(Apr 26 2020 at 09:25)</a>:</h4>
<p>Sorry, phone autocorrect</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
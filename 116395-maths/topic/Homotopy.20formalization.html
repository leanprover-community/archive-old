---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Homotopy.20formalization.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html">Homotopy formalization</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264450846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264450846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Roberto Alvarez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264450846">(Dec 10 2021 at 14:01)</a>:</h4>
<p>Hello everyone,<br>
I'm thinking about formalizing results from homotopy theory as part of a course on the Lean theorem prover. <br>
I'd be happy to hear from the people that have contributed to the library about missing results that shouldn't be too complicated.<br>
Here is a list of ideas I got from Prof. Bartholdi and <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> <br>
(1) fundamental group of pointed space <br>
(2) more on pointed spaces <br>
(3) pi_n(X), its group structure <br>
(4) show pi_1(S^1) = Z <br>
(5) universal covers <br>
(6) show pi_1(X) is invariant under homotopy equivalence (for connected spaces?) <br>
(7) short exact sequence of a fibration</p>



<a name="264451007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264451007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264451007">(Dec 10 2021 at 14:02)</a>:</h4>
<p>Hi! Welcome! <span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> has been doing some homotopy stuff recently.</p>



<a name="264451024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264451024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264451024">(Dec 10 2021 at 14:02)</a>:</h4>
<p>In particular, I think (1) is done.</p>



<a name="264451412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264451412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264451412">(Dec 10 2021 at 14:05)</a>:</h4>
<p>Hi! I will be very happy to join forces, if possible: I will be teaching a graduate course next year on Lean and the proposal I wrote is precisely about developing the fundamental group. The idea was to let the students solve some sorry's in a pre-compiled file leading them to the definition, not in a mathlib style. For what students will your course be?</p>



<a name="264454658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264454658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264454658">(Dec 10 2021 at 14:29)</a>:</h4>
<p>We have the fundamental groupoid but I'm not sure that we have lots of theory about the fundamental group.</p>



<a name="264454870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264454870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264454870">(Dec 10 2021 at 14:31)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span> Roberto is going to formalize something as a part of <span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> 's course (fall 2021).</p>



<a name="264455019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455019">(Dec 10 2021 at 14:32)</a>:</h4>
<p>And the plan is to have some code merged to mathlib in a few weeks.</p>



<a name="264455098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455098">(Dec 10 2021 at 14:32)</a>:</h4>
<p>Let's wait for <span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> to avoid duplication of effort.</p>



<a name="264455314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455314">(Dec 10 2021 at 14:34)</a>:</h4>
<p>Oh nice! Well, this project was really teaching-oriented, for me: so it won't be a problem if by the moment my course starts (spring 2023...) everything will already be in <code>mathlib</code>. I should rather take inspiration from <span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> 's course, if the material is available.</p>



<a name="264455418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455418">(Dec 10 2021 at 14:35)</a>:</h4>
<p>I will may be interested in formalizing results about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> for <code>mathlib</code> when the definition will land in it, but now I am busy with LTE so will certainly wait for <span class="user-mention" data-user-id="266440">@Shing Tak Lam</span>.</p>



<a name="264455552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455552">(Dec 10 2021 at 14:36)</a>:</h4>
<p>In Laurent's course, students went through materials from <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> 's course at <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics">https://github.com/ImperialCollegeLondon/formalising-mathematics</a>, then each student chose a domain to formalize something new.</p>



<a name="264455584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455584">(Dec 10 2021 at 14:37)</a>:</h4>
<p>Roberto chose the fundamental group.</p>



<a name="264455647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455647">(Dec 10 2021 at 14:37)</a>:</h4>
<p>But that wasn't in Kevin's list, right?</p>



<a name="264455743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455743">(Dec 10 2021 at 14:38)</a>:</h4>
<p>No, we used the list to help students learn the syntax.</p>



<a name="264455801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455801">(Dec 10 2021 at 14:39)</a>:</h4>
<p>Now they formalize whatever they want (another student is going to formalize complex analysis once I get <a href="https://github.com/leanprover-community/mathlib/issues/10000">#10000</a> merged).</p>



<a name="264455835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264455835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264455835">(Dec 10 2021 at 14:39)</a>:</h4>
<p>And how long did it take to make them familiarize with the syntax? My students will be M2 students at "Ecole Normale Superieure" in Lyon (France) which means that they will be (very) good at Math, but with little/no CS culture.</p>



<a name="264456198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264456198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264456198">(Dec 10 2021 at 14:42)</a>:</h4>
<p>2 students covered most of the material in about a month, another two didn't come to today's meeting.</p>



<a name="264456238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264456238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264456238">(Dec 10 2021 at 14:43)</a>:</h4>
<p>Thanks for the feedback!</p>



<a name="264457109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264457109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264457109">(Dec 10 2021 at 14:49)</a>:</h4>
<p>(1) Can be stated as the automorphism group at a point, but there isn't much beyond the definitions atm.<br>
(3) I've been slowly working on it in <a href="https://github.com/leanprover-community/mathlib/tree/shing-higher-homotopy">this branch</a> (warning: code is a mess atm), right now it doesn't seem too hard, but it just seems like a lot of duplication of proofs I wrote for <code>fundamental_groupoid</code>, so I'm not too motivated to work on it at the moment :|<br>
(4) and (5) I have been working on covering spaces in <a href="https://github.com/leanprover-community/mathlib/tree/shing-covering-spaces-2">this branch</a> (again, code is a mess). What I have there so far is the definitions, and a start on homotopy lifting. I can PR the definition of covering spaces with some API first, which would unblock (5).<br>
(6) I have an open PR for defining homotopy equivalences, and with that it shouldn't be too hard to do.</p>
<p>For (2) and (7), I don't have anything about it atm. I think someone mentioned they were interested in (2) at some point, but I don't think I've seen anything.</p>



<a name="264459513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264459513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264459513">(Dec 10 2021 at 15:05)</a>:</h4>
<p>About (1): I think that we should define <code>def fundamental_group (x : X)</code> to be the group of endomorphisms of <code>x</code> as an element of <code>fundamental_groupoid X</code>.</p>



<a name="264459678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264459678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264459678">(Dec 10 2021 at 15:06)</a>:</h4>
<p>Then we should split <code>fundamental_groupoid_functor</code> into <code>path.homotopic.quotient.map</code> and a few lemmas about it.</p>



<a name="264459880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264459880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264459880">(Dec 10 2021 at 15:07)</a>:</h4>
<p>In particular, prove that a continuous map <code>f : C(X, Y)</code> between topological spaces (possibly, in different universes) defines a homomorphism <code>π₁ x →* π₁ (f x)</code></p>



<a name="264460216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264460216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264460216">(Dec 10 2021 at 15:09)</a>:</h4>
<p>Then relate these homomorphisms for two homotopic maps <code>f g : C(X, Y)</code>.</p>



<a name="264460615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264460615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264460615">(Dec 10 2021 at 15:12)</a>:</h4>
<p>Then relate homotopy groups of spaces related by <code>homotopy_equiv</code>.</p>



<a name="264460793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264460793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264460793">(Dec 10 2021 at 15:13)</a>:</h4>
<p>Note that mathematicians can say "<code>π₁ x</code> is isomorphic to <code>π₁ y</code>, so we don't care which <code>x</code> do we choose (at least, if we're in a path connected space)" but we can't easily do this in Lean.</p>



<a name="264461050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264461050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264461050">(Dec 10 2021 at 15:15)</a>:</h4>
<p>We need to carry those isomorphisms around.</p>



<a name="264462860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264462860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264462860">(Dec 10 2021 at 15:28)</a>:</h4>
<p>You could also try pi_n(X) abelian for n&gt;=2. I should think that a lot of this is very do-able even for beginners, if you're not asking for mathlib-ready code (and of course you shouldn't ask the generic maths student to write mathlib-ready code, I tend not to even fuss about non-terminal simps if a project is just a one-off thing and mathlib will likely never be bumped by the student).</p>



<a name="264463027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264463027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264463027">(Dec 10 2021 at 15:29)</a>:</h4>
<p>Another formalization target is to develop the theory of covering spaces, and (eventually) obtain the Galois correspondence (with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</p>



<a name="264463132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264463132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264463132">(Dec 10 2021 at 15:30)</a>:</h4>
<p>Sure, I won't ask for mathlib-ready code. If they will want to join, they will eventually learn how to prepare nice code. Yours seems a very nice suggestion, thanks! This will take place in a year or so, so I still have time to prepare; covering spaces were the other option.</p>



<a name="264483596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264483596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264483596">(Dec 10 2021 at 17:57)</a>:</h4>
<p>eckmann-hilton is already in mathlib, btw</p>



<a name="264506602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264506602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264506602">(Dec 10 2021 at 20:54)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> yes, I forgot it on the list -- $\pi_n x$ abelian for all $n\ge2$ is definitely among the things I would like to see. In fact, one should aim at much more: $\bigoplus_{n\ge2}\pi_n$ is a Lie algebra over the integers, and a $\pi_1$-module. All of this is pretty explicit, constructing maps and homotopies, so should be doable.</p>
<p>Another one I like a lot, and which is probably not too difficult, is $\Omega\Sigma X\sim F(X)$, in words the loop space of the suspension of $X$ is homotopy equivalent to the free group on $X$ (with the obvious topology coming from words over $X\cup X^{-1}$).</p>



<a name="264509294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/264509294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#264509294">(Dec 10 2021 at 21:15)</a>:</h4>
<p>In 2018 Luca Gerolla formalised pi_1 in Lean as a summer project and the thing he had real trouble with was just "obvious" stuff like "if f:[0,1/2]-&gt;R and g:[1/2,1]-&gt;R are continuous and agree at 1/2, then gluing them together is continuous". But I think the issue was that the API for this sort of thing just didn't exist at the time.</p>



<a name="286630228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286630228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286630228">(Jun 18 2022 at 05:19)</a>:</h4>
<p>I think we will have homotopy groups in mathlib very soon (the underlying type is defined in <a href="https://github.com/leanprover-community/mathlib/pull/14724">#14724</a>, and the group structure and commutativity when n &gt; 1 <a href="https://github.com/leanprover-community/mathlib/pull/14724#discussion_r900688203">seems within reach</a>). But how should we denote the operation? I can think of the following two options:</p>
<ul>
<li>
<p>Define the group structure only on π_{n+2} and use the <code>+</code> notation (because of commutativity, this seems to be the usual choice), and the only choice if we want the Lie algebra structure; then we could define the group structure on π_1 separately using the <code>*</code> notation (which will lead to a bit of code duplication, but the <code>add_comm_group</code> instance will be available only on π_{n+2} anyway) and show it's isomorphic to <a href="https://leanprover-community.github.io/mathlib_docs/find/fundamental_group">docs#fundamental_group</a> (which is multiplicative).</p>
</li>
<li>
<p>Define the group structure on all π_{n+1} and use the <code>+</code> notation. Then to talk about the π_1-module structure or isomorphism with fundamental group we'd have to use <code>multiplicative π_1</code>.</p>
</li>
</ul>
<p>Which one do people prefer?</p>



<a name="286640955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286640955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286640955">(Jun 18 2022 at 09:23)</a>:</h4>
<p>What a fascinating question! Forgive my ignorance -- what extra structure is there on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_2(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> other than that of an abelian group? You mentioned lie algebras -- is it a Lie module over something?</p>



<a name="286641118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286641118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286641118">(Jun 18 2022 at 09:27)</a>:</h4>
<p>We're running into this sort of thing in number theory as well: I want to look at group cohomology of Galois groups Gal(L/K) (with law <code>*</code> but it's really function.comp) acting on abelian groups like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">L^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span>  with group law also multiplication.</p>



<a name="286641367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286641367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286641367">(Jun 18 2022 at 09:34)</a>:</h4>
<p>The group law is not even defined for <code>n=0</code>. For n=1 you have a group structure and for n=2 it's abelian. What does pi_3(X) have that \pi_2(X) doesn't? </p>
<p>Can type class inference handle this sort of situation? You might end up having to define an addition on pi_0 (send everything to x?) and then try and convince type class inference that it's only a group for n&gt;=1 and only an abelian group for n&gt;=2, and it's not going to be looking at local hypotheses to find these assumptions...</p>



<a name="286642818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286642818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286642818">(Jun 18 2022 at 10:09)</a>:</h4>
<p>Option 1 seems better to me.</p>



<a name="286645032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645032">(Jun 18 2022 at 10:58)</a>:</h4>
<p>Do you want the fundamental object to be <code>higher_pi_succ_succ (n : nat) (x : X)</code>?</p>



<a name="286645048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645048">(Jun 18 2022 at 10:59)</a>:</h4>
<p>I also prefer option 1. I think one day we’ll have to have a way to uncouple our algebraic classes from their notation.</p>



<a name="286645059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645059">(Jun 18 2022 at 10:59)</a>:</h4>
<p>This is why I'm asking what pi_3 has that pi_2 doesn't: I'm wondering whether the set of pi's for n&gt;=3 also needs to be "special cased" later</p>



<a name="286645062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645062">(Jun 18 2022 at 11:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I think the “Lie algebra” mentioned is the Whitehead product. It’s a generalisation of the action of the fundamental group on the higher groups.</p>



<a name="286645143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645143">(Jun 18 2022 at 11:01)</a>:</h4>
<p>My reading is that is the pi_2 and above that will be special-cased.</p>



<a name="286645191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645191">(Jun 18 2022 at 11:02)</a>:</h4>
<p>(Or equivalently, that pi_0 and pi_1 will be special-cased.)</p>



<a name="286645193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645193">(Jun 18 2022 at 11:02)</a>:</h4>
<p>So is this all just some special case of some well known categorical abstraction which tells me exactly what the structure really is and has consequences such as <code>pi n X</code> is a pointed type for n&gt;=0, a group for n&gt;=1 and an abelian group for n&gt;= 2?</p>



<a name="286645235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645235">(Jun 18 2022 at 11:03)</a>:</h4>
<p>My only worry is what about when someone comes along who is an expert in whatever pi_3 is that pi_2 isn't and says it's inconvenient to do what they want to do because of it not working for stupid pi_2. But I think that this is a bit of a hypothetical worry at this point :-)</p>



<a name="286645306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645306">(Jun 18 2022 at 11:04)</a>:</h4>
<p>We seem to manage with <code>fin n</code> not having a point (a zero) for n=0 and not having a 1 for n=0,1. I guess it's a bit like that</p>



<a name="286645657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645657">(Jun 18 2022 at 11:13)</a>:</h4>
<p>There's no new property or structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\pi_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and so on, at least not considered in isolation.</p>



<a name="286645682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645682">(Jun 18 2022 at 11:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Homotopy.20formalization/near/286645193">said</a>:</p>
<blockquote>
<p>So is this all just some special case of some well known categorical abstraction which tells me exactly what the structure really is and has consequences such as <code>pi n X</code> is a pointed type for n&gt;=0, a group for n&gt;=1 and an abelian group for n&gt;= 2?</p>
</blockquote>
<p>It's a pointed set with <code>n</code> compatible group structures, which (by a theorem/computation) reduces to what you wrote.</p>



<a name="286645760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286645760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286645760">(Jun 18 2022 at 11:15)</a>:</h4>
<p>Basically just the Eckmann-Hilton argument: two compatible group structures have to be equal (and abelian), so then by "all horses are the same color" it doesn't matter if we add a third compatible group structure.</p>



<a name="286646605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286646605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286646605">(Jun 18 2022 at 11:35)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Whitehead_product">https://en.wikipedia.org/wiki/Whitehead_product</a> for the Lie algebra structure Junyan mentioned</p>



<a name="286646676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286646676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286646676">(Jun 18 2022 at 11:36)</a>:</h4>
<p>I think we will probably want <em>some</em> way to refer to the group structure on <code>pi n</code> uniformly for <code>n = 1</code> and for <code>n &gt;= 2</code>. For example if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>→</mo><mi>E</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">F \to E \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is a fiber sequence then there's a connecting homomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>B</mi><mo>→</mo><msub><mi>π</mi><mi>n</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\pi_{n+1} B \to \pi_n F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and it is still a group homomorphism for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>



<a name="286646707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286646707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286646707">(Jun 18 2022 at 11:37)</a>:</h4>
<p>How strange would it be to give <code>pi 1</code> both <code>+</code> and <code>*</code> group structures with the same definition?</p>



<a name="286646901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286646901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286646901">(Jun 18 2022 at 11:40)</a>:</h4>
<p>The only reason this might be a bad idea (other than the obvious reason that it's weird) would be that if later on someone wants to use <code>*</code> on higher pi_n for something else. This was why I was asking about other structures on higher pi.</p>



<a name="286646924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286646924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286646924">(Jun 18 2022 at 11:40)</a>:</h4>
<p>Alternatively, define <code>*</code> on all <code>pi n</code> (<code>n &gt;= 1</code>) and then define <code>+</code> to be the same as <code>*</code> for <code>n &gt;= 2</code></p>



<a name="286646944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286646944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286646944">(Jun 18 2022 at 11:41)</a>:</h4>
<p>Then will you be able to get <code>add_comm_group</code> to fire or will it get stuck looking for the proof that 2&lt;=n?</p>



<a name="286648515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286648515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286648515">(Jun 18 2022 at 12:16)</a>:</h4>
<p>In the Agda libraries they define the group structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\pi_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> by doing something like your <code>higher_pi_succ_succ</code>. I guess the Lean equivalent might be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">pi</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">pi</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="286648788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286648788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286648788">(Jun 18 2022 at 12:22)</a>:</h4>
<p>Maybe some <code>[fact (n &gt;= 2)]</code> approach is okay too</p>



<a name="286649216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286649216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286649216">(Jun 18 2022 at 12:33)</a>:</h4>
<p>I guess a minimal test case for this stuff would be to define an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi mathvariant="normal">Ω</mi><mi>X</mi><mo stretchy="false">)</mo><mo>≅</mo><msub><mi>π</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n}(\Omega X) \cong \pi_{n+1}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">Ω</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> (of groups for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, or possibly of abelian groups for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>).</p>



<a name="286649405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286649405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286649405">(Jun 18 2022 at 12:37)</a>:</h4>
<p>From the PR it sounds like maybe the strategy is to build this as an isomorphism of sets, and then transfer the group structure from left to right?</p>



<a name="286653843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286653843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286653843">(Jun 18 2022 at 14:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Homotopy.20formalization/near/286646605">said</a>:</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Whitehead_product">https://en.wikipedia.org/wiki/Whitehead_product</a> for the Lie algebra structure Junyan mentioned</p>
</blockquote>
<p>I actually didn't know about what the Lie algebra structure was, but it's mentioned two posts above my post.</p>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Homotopy.20formalization/near/286648788">said</a>:</p>
<blockquote>
<p>Maybe some <code>[fact (n &gt;= 2)]</code> approach is okay too</p>
</blockquote>
<p>The main problem I see is that the definition of <code>pi n</code> depends on <code>fin n → I</code> (i.e. the cube I^n), and to define the group structure you then need to resort to the non-defeq type equality <code>fin n.pred.succ = fin n</code> when <code>n &gt; 0</code>, which may bite you, so it's best to write <code>pi (n+1) X</code>. That's probably why in Agda they did it that way, and we should probably follow suite. The <code>add_comm_group</code> instance could take a <code>[fact (n &gt; 1)]</code> though, because commutativity is prop not data.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="o">(</span><span class="n">pi</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">pi</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>Does this mean they have + and * meaning the same thing for n &gt; 1? Then we could certainly follow, as you suggested.</p>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Homotopy.20formalization/near/286649405">said</a>:</p>
<blockquote>
<p>From the PR it sounds like maybe the strategy is to build this as an isomorphism of sets, and then transfer the group structure from left to right?</p>
</blockquote>
<p>What we want to utilize is rather the bijections <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msup><mi mathvariant="normal">Ω</mi><mi>n</mi></msup><mi>X</mi><mo stretchy="false">)</mo><mo>≅</mo><msub><mi>π</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(\Omega^n X)\cong \pi_{n+1}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> (one for each element of <code>fin (n+1)</code>, and we'd use two to show commutativity). The underlying type of the homotopy group is defined in the usual way, as maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mi>n</mi></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">I^n\to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><msup><mi>I</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\partial I^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> to <code>x</code> (named <code>gen_loop n x</code>, which is essentially <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Ω</mi><mi>n</mi></msup><mi>X</mi></mrow><annotation encoding="application/x-tex">\Omega^n X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>) up to homotopy relative to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><msup><mi>I</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\partial I^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>, and the plan is indeed to transfer the group structure from left to right; however it's easy to see the transferred group operation agree with the usual definition, i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><msub><mi>t</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mtext> for </mtext><msub><mi>t</mi><mn>0</mn></msub><mo>≤</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mtext> and </mtext><mi>g</mi><mo stretchy="false">(</mo><mn>2</mn><msub><mi>t</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mtext> for </mtext><msub><mi>t</mi><mn>0</mn></msub><mo>≥</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(f+g)(t_0,t_1,\dots,t_n)=f(2t_0,t_1,\dots,t_n)\text{ for }t_0 \leq 1/2\text{ and }g(2t_0-1,t_1,\dots,t_n)\text{ for }t_0 \geq 1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord text"><span class="mord"> for </span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/2</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord text"><span class="mord"> for </span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/2</span></span></span></span> (I suspect this will hold even definitionally when using the zeroth bijection between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msup><mi mathvariant="normal">Ω</mi><mi>n</mi></msup><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(\Omega^n X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n+1}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>).</p>
<p>I also want to hear about opinions about the notation for the underlying type. Currently <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> denoted <code>π n x</code>, with the space <code>X</code> implicit. Should we make it explicit? And can we make the notation prettier? I seem to remember that notations like <code>π_n(X,x)</code> doesn't work, and you have to add brackets, something like <code>π_[n](X,x)</code>? And should we make it a localized notation or global? Currently <code>π n x</code> is just a <code>local</code> notation and making the single letter <code>π</code> global is obviously bad, but a complicated notation like <code>π_[n](X,x)</code> could probably be made global, as in the case of <code>C(X, Y)</code> for <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_map">docs#continuous_map</a>.</p>



<a name="286671697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286671697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286671697">(Jun 18 2022 at 21:21)</a>:</h4>
<p>In my experience, the base point for the fundamental group is rarely moved around.  Maybe it makes sense to use <code>inhabited X</code> as an instance and only mention the space, using default as the basepoint?  This is closer to the standard abuse of notation in maths.</p>



<a name="286671748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286671748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286671748">(Jun 18 2022 at 21:22)</a>:</h4>
<p>I think there might be some subtleties here.</p>



<a name="286671963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286671963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286671963">(Jun 18 2022 at 21:28)</a>:</h4>
<p>In my experience, the base point plays a crucial role! For example the torsor of paths <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(X,x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is a fairly important object in anabelian geometry. We do have some tricks that let us ignore the base-point, essentially by considering the fundamental group not as a group but as an object in the category of groups (or profinite groups in the etale case) with "outer" morphisms, i.e. where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>o</mi><msup><mi>m</mi><mrow><mi>O</mi><mi>u</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>H</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>H</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>I</mi><mi>n</mi><mi>n</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom^{Out}(G,H) = Hom(G,H)/Inn(H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">nn</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>.</p>



<a name="286672044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286672044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286672044">(Jun 18 2022 at 21:30)</a>:</h4>
<p>Personally I would be fine with <code>π_ n X x</code> as notation for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p>



<a name="286672407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286672407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286672407">(Jun 18 2022 at 21:41)</a>:</h4>
<p>Ok, I'm convinced on including the basepoint explicitly and in the notation!</p>



<a name="286672922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286672922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286672922">(Jun 18 2022 at 21:55)</a>:</h4>
<p>We could use a bundled "pointed space" type and write <code>π_ n ⟨X, x⟩</code>--too bad we can't use <code>(X, x)</code></p>



<a name="286673664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286673664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286673664">(Jun 18 2022 at 22:13)</a>:</h4>
<p>I wonder if there's some trick where <code>π_ n X</code> could mean <code>π_ n ⟨X, default⟩</code>? I'm not sure you can write a coercion that depends on a typeclass like that (<code>inhabited</code> in this case).</p>



<a name="286673798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286673798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286673798">(Jun 18 2022 at 22:16)</a>:</h4>
<p>This, maybe?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">π_</span> <span class="n">n</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">default</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="286674088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286674088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286674088">(Jun 18 2022 at 22:24)</a>:</h4>
<p>That suggests a potential solution:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">--import category_theory.category.Pointed</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.default</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">default</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">Pointed</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">point</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">.</span> <span class="n">tactic.default</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(⟨</span><span class="n">ℕ</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">Pointed</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(⟨</span><span class="n">ℕ</span><span class="o">,</span> <span class="mi">37</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">Pointed</span><span class="o">)</span>
</code></pre></div>
<p>This means you can write <code>π_ n ⟨X⟩</code> for <code>π_ n ⟨X, default⟩</code>.</p>
<p>(Note that <code>by exact default</code> doesn't work in Lean 3 since that tactic will be resolved immediately. I think it works in Lean 4.)</p>



<a name="286674148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286674148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286674148">(Jun 18 2022 at 22:26)</a>:</h4>
<p>Nifty use of <a href="https://leanprover-community.github.io/mathlib_docs/find/Pointed">docs#Pointed</a>!</p>



<a name="286863918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Homotopy%20formalization/near/286863918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Roberto Alvarez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Homotopy.20formalization.html#286863918">(Jun 21 2022 at 04:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/Homotopy.20formalization/near/286674088">said</a>:</p>
<blockquote>
<p>This means you can write <code>π_ n ⟨X⟩</code> for <code>π_ n ⟨X, default⟩</code>.</p>
</blockquote>
<p>I don't know how to actually implement this notation, am I supposed to duplicate the Pointed structure so that it includes the tactic?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
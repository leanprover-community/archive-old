---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Geodesic.20spaces.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html">Geodesic spaces</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="257343941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257343941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257343941">(Oct 13 2021 at 10:39)</a>:</h4>
<p>I am trying to define geodesic spaces. The definition I want to implement is, on paper, the following: A geodesic space is a metric space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> such that for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x, y \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, there exists an isometry <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>:</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\gamma_{x, y} : [0, d(x, y)] \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\gamma_{x, y}(0) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\gamma_{x, y}((d(x, y)) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">((</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>. I am faced with a choice between the following two definitions below, one where geodesics take arguments in <code>set.Icc</code>, and one where they are defined on the whole <code>ℝ</code> with junk values outside of the interval of interest.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.basic</span>
<span class="kn">import</span> <span class="n">topology.metric_space.isometry</span>

<span class="kd">class</span> <span class="n">geodesic_space1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">metric_space</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">geodesic</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">set.Icc</span> <span class="mi">0</span> <span class="o">(</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">geodesic_iso</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">isometry</span> <span class="o">(</span><span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
<span class="o">(</span><span class="n">left_point</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.left_mem_Icc</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">dist_nonneg</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_point</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.right_mem_Icc</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">dist_nonneg</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">geodesic_space2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">metric_space</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">geodesic</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">geodesic_iso</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="mi">0</span> <span class="o">(</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)),</span> <span class="n">dist</span> <span class="o">(</span><span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">s</span> <span class="bp">-</span> <span class="n">t</span><span class="o">))</span>
<span class="o">(</span><span class="n">left_point</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_point</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>Which one do you think is best? With <code>geodesic_space1</code> I worry that keeping working with coercions to <code>set.Icc</code> might turn out cumbersome in the long run, but at the same time this allows me to use <a href="https://leanprover-community.github.io/mathlib_docs/find/isometry">docs#isometry</a> in the definition, so that I may easily rely on the lemmas about it.</p>



<a name="257350965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257350965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257350965">(Oct 13 2021 at 11:46)</a>:</h4>
<p>There is a problem with both your definitions, that you are putting data into it. Which can lead to diamonds later on. Instead, you could (should?) define it as Prop-valued (and as a mixin on metric spaces, instead of extending metric spaces) -- and then the precise definition doesn't matter, because they are equivalent. What you can do then, under the assumptions <code>[metric_space X] [geodesic_space X]</code>, is to choose some geodesic between <code>x</code> and <code>y</code> (and I'd probably choose it as a function on <code>Icc</code>, but providing also the extended value on the whole line, equal to <code>x</code> before <code>0</code> and to <code>y</code>after <code>d(x,y)</code> to have a globally continuous object).</p>



<a name="257351039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257351039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257351039">(Oct 13 2021 at 11:47)</a>:</h4>
<p>If it's a prop you could call it <code>is_geodesic_space X</code>, which makes it easier for people to guess that it's a Prop</p>



<a name="257398042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257398042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257398042">(Oct 13 2021 at 16:44)</a>:</h4>
<p>Thank you for the suggestions. Let me see if I understood it correctly. Is something like this what you mean?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.metric_space.basic</span>
<span class="kn">import</span> <span class="n">topology.metric_space.isometry</span>

<span class="kd">structure</span> <span class="n">is_geodesic</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">set.Icc</span> <span class="mi">0</span> <span class="o">(</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">iso</span> <span class="o">:</span> <span class="n">isometry</span> <span class="n">γ</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_point</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.left_mem_Icc</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">dist_nonneg</span><span class="o">⟩</span>  <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_point</span> <span class="o">:</span> <span class="n">γ</span> <span class="o">⟨</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.right_mem_Icc</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">dist_nonneg</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_geodesic_space</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">geodesic</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">γ</span><span class="o">,</span> <span class="n">is_geodesic</span> <span class="n">x</span> <span class="n">y</span> <span class="n">γ</span><span class="o">)</span>
</code></pre></div>



<a name="257398374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257398374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257398374">(Oct 13 2021 at 16:46)</a>:</h4>
<p>Also, I am not sure what do you mean by defining it on <code>Icc</code> while also providing the extension to the whole line? Do you mean that I should then define something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">geodesic_to_whole_line</span>
<span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">set.Icc</span> <span class="mi">0</span> <span class="o">(</span><span class="n">dist</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span>
<span class="k">if</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">x</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="k">then</span> <span class="n">y</span>
<span class="k">else</span> <span class="n">γ</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
</code></pre></div>



<a name="257398576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257398576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257398576">(Oct 13 2021 at 16:47)</a>:</h4>
<p>Note that we have <a href="https://leanprover-community.github.io/mathlib_docs/find/set.proj_Icc">docs#set.proj_Icc</a></p>



<a name="257398847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geodesic%20spaces/near/257398847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geodesic.20spaces.html#257398847">(Oct 13 2021 at 16:49)</a>:</h4>
<p>Also, we have some theory about paths indexed by <code>Icc 0 1</code> (e.g., homotopies), so you might want to use <code>f : Icc 0 1 → X</code> with <code>dist (f a) (f b) = dist x y * dist a b</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
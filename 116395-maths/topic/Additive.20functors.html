---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Additive.20functors.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html">Additive functors</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227295322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227295322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227295322">(Feb 22 2021 at 16:31)</a>:</h4>
<p>I'm working on additive functors.<br>
How bad is it if I tag <code>add_map_spec</code> with <code>simp</code> in the following code? (see examples)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.preadditive</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">class</span> <span class="n">functor.additive</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_hom'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">[</span><span class="n">functor.additive</span> <span class="n">F</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">functor.additive</span>

<span class="kd">lemma</span> <span class="n">exists_hom</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">functor.additive.exists_hom'</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">end</span> <span class="n">functor.additive</span>

<span class="kn">namespace</span> <span class="n">functor</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">add_map</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">classical.some</span> <span class="bp">$</span> <span class="n">functor.additive.exists_hom</span> <span class="n">F</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">add_map_spec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">F.add_map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">add_map</span><span class="o">,</span> <span class="n">rw</span> <span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">functor.additive.exists_hom</span> <span class="n">F</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">F.map</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">end</span> <span class="n">functor</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="227295809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227295809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227295809">(Feb 22 2021 at 16:34)</a>:</h4>
<p>Why not have the <code>F.map 0 = 0</code> and <code>F.map (f + g) = F.map f + F.map g</code> as the API lemmas instead?</p>



<a name="227295848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227295848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227295848">(Feb 22 2021 at 16:34)</a>:</h4>
<p>And, which direction would you want the distribution lemma to simplify in?</p>



<a name="227295935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227295935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227295935">(Feb 22 2021 at 16:35)</a>:</h4>
<p>Sure I can do that, but presumably there are 1000 other lemmas about morphisms of abelian groups which I would like to use eventually.</p>



<a name="227296089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227296089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227296089">(Feb 22 2021 at 16:36)</a>:</h4>
<p>This might be a case where some sort of <code>meta</code> code to transfer over the lemmas could work.</p>



<a name="227296677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227296677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227296677">(Feb 22 2021 at 16:40)</a>:</h4>
<p>This would all be a lot easier if we didn't depricate <code>is_hom</code>/<code>is_add_hom</code>, etc.</p>



<a name="227297289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227297289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227297289">(Feb 22 2021 at 16:44)</a>:</h4>
<p>I am confused about this. My current understanding is that the problem with <code>is_add_hom</code> is not that it <em>exists</em>, but that it is a <em>class</em>. I think. If I'm right and if a refactor with these changes would get files like <code>deprecated.group</code> out of <code>deprecated</code> then I might well be motivated to take this on. I totally agree that there are times when <code>is_add_hom</code> is useful, but I also very much believe that for group homomorphisms in Lean 3 you're better off using <code>-&gt;+</code> in general.</p>



<a name="227297732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227297732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227297732">(Feb 22 2021 at 16:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> do you have any thoughts about the <code>simp</code> tag in the code above?</p>



<a name="227297836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227297836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227297836">(Feb 22 2021 at 16:48)</a>:</h4>
<p>You should be able to define <code>add_map</code> computably I think?</p>



<a name="227297877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227297877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227297877">(Feb 22 2021 at 16:48)</a>:</h4>
<p>I am not really a computer scientist, I don't have much of an understanding of <code>simp</code>. If the linter is happy then why not just try it?</p>



<a name="227297909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227297909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227297909">(Feb 22 2021 at 16:48)</a>:</h4>
<p>Since you only need to unpack the existential inside the proof obligations</p>



<a name="227297958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227297958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227297958">(Feb 22 2021 at 16:48)</a>:</h4>
<p>In practice I guess I would try and stick to <code>add_map</code> as much as possible, so hopefully I'd not need the simp lemma much.</p>



<a name="227298072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298072">(Feb 22 2021 at 16:49)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> yeah I can make it computable.</p>



<a name="227298221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298221">(Feb 22 2021 at 16:50)</a>:</h4>
<p>We have this type of things with <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.single">docs#pi.single</a> too, where we have the regular version, and a separate bundled version <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.single">docs#add_monoid_hom.single</a>. We copy across the really obvious lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.single_add">docs#pi.single_add</a>, but for the more niche ones the user is expected to write "backwards" along <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.single_apply">docs#add_monoid_hom.single_apply</a> or similar.</p>



<a name="227298292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298292">(Feb 22 2021 at 16:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.preadditive</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">class</span> <span class="n">functor.additive</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_hom'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">[</span><span class="n">functor.additive</span> <span class="n">F</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">functor.additive</span>

<span class="kd">lemma</span> <span class="n">exists_hom</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">functor.additive.exists_hom'</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">end</span> <span class="n">functor.additive</span>

<span class="kn">namespace</span> <span class="n">functor</span>

<span class="kd">def</span> <span class="n">add_map</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">functor.additive.exists_hom</span> <span class="n">F</span> <span class="n">X</span> <span class="n">Y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span><span class="n">hf</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hf</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">functor.additive.exists_hom</span> <span class="n">F</span> <span class="n">X</span> <span class="n">Y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span><span class="n">hf</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hf</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">add_map_spec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">F.add_map</span> <span class="n">f</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_map</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">F.map</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">end</span> <span class="n">functor</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="227298390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298390">(Feb 22 2021 at 16:51)</a>:</h4>
<p>Looks good so far :-)</p>



<a name="227298540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298540">(Feb 22 2021 at 16:52)</a>:</h4>
<p>Kevin, that was exactly my thought too -- when I know my functor is additive, I will always use <code>add_map</code> instead of <code>map</code>. So why not add that simp lemma :)? Maybe <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> can convince me otherwise.</p>



<a name="227298588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298588">(Feb 22 2021 at 16:52)</a>:</h4>
<p>I guess you're forced to choose between:</p>
<ul>
<li>You want the lemmas about <code>functor.map</code> to apply automatically, and force the user to do a bit of a dance to get the lemmas about <code>add_monoid_hom</code></li>
<li>You want the lemmas about <code>add_monoid_hom</code> to apply automatically, and force the user to do a bit of a dance to get the lemmas about <code>functor.map</code></li>
</ul>



<a name="227298648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298648">(Feb 22 2021 at 16:52)</a>:</h4>
<p>Hmm.... yeah that's a good point.</p>



<a name="227298752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298752">(Feb 22 2021 at 16:53)</a>:</h4>
<p>I am a naive mathematician and want both to happen at once :-(</p>



<a name="227298779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227298779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227298779">(Feb 22 2021 at 16:53)</a>:</h4>
<p>Same here :(</p>



<a name="227299075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227299075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227299075">(Feb 22 2021 at 16:55)</a>:</h4>
<p>One argument goes "bundled homs are ubiquitous, users will recognize when they have a goal that needs them to try and turn <code>map</code> into <code>add_map</code> via manual rewrites, but are less likely to recognize when they need to do the reverse". But I only make that argument because I'm used to having to do it with things like <code>finsupp.lsingle</code> which would be way too bundled for it to match lots of lemmas about <code>finsupp.single</code> were it not for the fact that <code>simp</code> put it in that form for me</p>



<a name="227299976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227299976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227299976">(Feb 22 2021 at 17:00)</a>:</h4>
<p>This is a contrast the category theory part of the library has from other parts of the library. Which direction is the simplifying one here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">prod.map_comp_map</span> <span class="o">:</span> <span class="n">prod.map</span> <span class="n">g</span> <span class="n">g'</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="n">f</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">prod.map</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g'</span> <span class="bp">∘</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>That is, which one of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.comp_map</span> <span class="o">:</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">h</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">list.map</span> <span class="n">h</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">g</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.map_map</span> <span class="o">:</span> <span class="n">list.map</span> <span class="n">g</span> <span class="o">(</span><span class="n">list.map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">list.map</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>In <code>list</code>, the choice in <code>map_map</code>. In category theory portions of the library, I've seen that <code>comp_map</code> is the direction preferred.</p>



<a name="227300237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227300237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227300237">(Feb 22 2021 at 17:01)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="310045">@Eric Wieser</span> 's comment convinced me against this simp lemma.</p>



<a name="227300243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227300243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227300243">(Feb 22 2021 at 17:01)</a>:</h4>
<p>The thought likely being, anything which would have simplified <code>list.map f l</code> will also simplify <code>list.map (g ∘ f)</code>, and moreover, you'll get possible simplifcations once <code>g ∘ f</code> exists as a term.</p>



<a name="227300406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227300406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227300406">(Feb 22 2021 at 17:02)</a>:</h4>
<p>Maybe a <code>push_comp</code> and a <code>pull_comp</code> tactic?</p>



<a name="227300466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227300466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227300466">(Feb 22 2021 at 17:03)</a>:</h4>
<p>Can't we have axioms <code>map_add'</code> and <code>map_zero'</code>, and have a bundled version <code>map_hom</code> defined afterwards? I think that you don't need <code>exists_hom</code> then</p>



<a name="227300763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227300763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227300763">(Feb 22 2021 at 17:04)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Does it matter? I'm making a small api anyway...</p>



<a name="227301500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227301500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227301500">(Feb 22 2021 at 17:08)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
<p>LONG</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.preadditive</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">class</span> <span class="n">functor.additive</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span>
  <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_hom'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span> <span class="o">[</span><span class="n">functor.additive</span> <span class="n">F</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">functor.additive</span>

<span class="kd">lemma</span> <span class="n">exists_hom</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">functor.additive.exists_hom'</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">def</span> <span class="n">of_is_hom</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">G.map</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">map_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">),</span> <span class="n">G.map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G.map</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">G.map</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">functor.additive</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">functor.additive.mk</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span>
<span class="o">⟨⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">G.map</span> <span class="n">f</span><span class="o">,</span> <span class="n">map_zero</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">functor.additive</span>

<span class="kn">namespace</span> <span class="n">functor</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">add_map</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">(</span><span class="n">F.obj</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">F.obj</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">F.map</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">functor.additive.exists_hom</span> <span class="n">F</span> <span class="n">X</span> <span class="n">Y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span><span class="n">hf</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hf</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rcases</span> <span class="n">functor.additive.exists_hom</span> <span class="n">F</span> <span class="n">X</span> <span class="n">Y</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span><span class="n">hf</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hf</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">add_map_spec</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.add_map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_zero</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">add_map_spec</span><span class="o">,</span> <span class="n">add_monoid_hom.map_zero</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_add</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">F.map</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">add_map_spec</span><span class="o">,</span> <span class="n">add_monoid_hom.map_add</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_neg</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="bp">-</span><span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">F.map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">add_map_spec</span><span class="o">,</span> <span class="n">add_monoid_hom.map_neg</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">map_sub</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">-</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">-</span> <span class="n">F.map</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sub_eq_neg_add</span><span class="o">]</span>

<span class="kd">end</span> <span class="n">functor</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>
</div></div>



<a name="227301536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227301536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227301536">(Feb 22 2021 at 17:09)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> see the <code>of_is_hom</code> in the code above.</p>



<a name="227301548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227301548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227301548">(Feb 22 2021 at 17:09)</a>:</h4>
<p>I don't think it matters too much. But proving <code>map_add'</code> etc might be shorter proofs than <code>exists_hom</code></p>



<a name="227301554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227301554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227301554">(Feb 22 2021 at 17:09)</a>:</h4>
<p>I think this is probably good enough, no?</p>



<a name="227302424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227302424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227302424">(Feb 22 2021 at 17:14)</a>:</h4>
<p><del>Oh, an annoying thing about your case vs <code>pi.single</code> is that <code>map</code> is not defeq to <code>map_add</code></del></p>



<a name="227302511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227302511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227302511">(Feb 22 2021 at 17:14)</a>:</h4>
<p>They're defeq if you apply them :)</p>



<a name="227302549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227302549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227302549">(Feb 22 2021 at 17:14)</a>:</h4>
<p>I'd recommend exploiting the defeq-ness in your proofs then!</p>



<a name="227302698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227302698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227302698">(Feb 22 2021 at 17:15)</a>:</h4>
<p>And change to <code>lemma add_map_spec {X Y : C} {f : X ⟶ Y} : ⇑F.add_map = F.map := rfl</code> too</p>



<a name="227302828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227302828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227302828">(Feb 22 2021 at 17:16)</a>:</h4>
<p>See <code>LONG</code> above</p>



<a name="227303045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227303045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227303045">(Feb 22 2021 at 17:17)</a>:</h4>
<p>Yeah, my comment was in response to that</p>



<a name="227303218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227303218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227303218">(Feb 22 2021 at 17:18)</a>:</h4>
<p>What's the issue with <code>add_map_spec</code> then?</p>



<a name="227303227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227303227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227303227">(Feb 22 2021 at 17:18)</a>:</h4>
<p>I'm suggesting the proofs be akin to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">map_sub</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">-</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">-</span> <span class="n">F.map</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">F.add_map.map_sub</span> <span class="n">f</span> <span class="n">g</span>
</code></pre></div>



<a name="227303244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227303244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227303244">(Feb 22 2021 at 17:18)</a>:</h4>
<p>It's not as general as it could be</p>



<a name="227303257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227303257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227303257">(Feb 22 2021 at 17:18)</a>:</h4>
<p>Oh I see.</p>



<a name="227303293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227303293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227303293">(Feb 22 2021 at 17:19)</a>:</h4>
<p>Sometimes you might need to replace it even when not applied</p>



<a name="227311334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227311334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227311334">(Feb 22 2021 at 18:08)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6367">#6367</a></p>



<a name="227324805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227324805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227324805">(Feb 22 2021 at 19:38)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> concerning your comment on github. Would this be better in your opinion?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.preadditive</span>
<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">additive_functor</span> <span class="kd">extends</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_map</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">},</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">((</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⟶</span> <span class="o">(</span><span class="n">obj</span> <span class="n">Y</span><span class="o">)))</span>
<span class="o">(</span><span class="n">add_map_eq'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">},</span> <span class="n">add_map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="n">restate_axiom</span> <span class="n">additive_functor.add_map_eq'</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">additive_functor.add_map_eq</span>

<span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">⥤+</span> <span class="bp">`</span><span class="o">:</span><span class="mi">26</span> <span class="o">:=</span> <span class="n">additive_functor</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="227325519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227325519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227325519">(Feb 22 2021 at 19:42)</a>:</h4>
<p>I guess I can play with priorities to get something that sort of works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.preadditive</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">category</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">preadditive</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">additive_functor</span> <span class="kd">extends</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_map</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">},</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→+</span> <span class="o">((</span><span class="n">obj</span> <span class="n">X</span><span class="o">)</span> <span class="bp">⟶</span> <span class="o">(</span><span class="n">obj</span> <span class="n">Y</span><span class="o">)))</span>
<span class="o">(</span><span class="n">add_map_eq'</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">},</span> <span class="n">add_map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">map</span> <span class="n">f</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="n">restate_axiom</span> <span class="n">additive_functor.add_map_eq'</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">100</span><span class="o">]</span> <span class="n">additive_functor.add_map_eq</span>

<span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">⥤+</span> <span class="bp">`</span><span class="o">:</span><span class="mi">26</span> <span class="o">:=</span> <span class="n">additive_functor</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="n">D</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤+</span> <span class="n">D</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.add_map</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">F.add_map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.add_map</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">F.add_map</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">Z</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">F.add_map</span> <span class="o">(</span><span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F.add_map</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">F.add_map</span> <span class="n">g</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="227326028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227326028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227326028">(Feb 22 2021 at 19:45)</a>:</h4>
<p>The argument that I thought justified my suggestion is moot for reasons I don't quite understand</p>



<a name="227326103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227326103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227326103">(Feb 22 2021 at 19:46)</a>:</h4>
<p>So I have no opinion on whether that's better or worse</p>



<a name="227326269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227326269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227326269">(Feb 22 2021 at 19:47)</a>:</h4>
<p>But I'd like to understand why your case works when the <code>is_add_monoid_hom</code> case doesn't, in case it informs us about how to fix the <code>is_add_monoid_hom</code> case</p>



<a name="227326982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227326982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227326982">(Feb 22 2021 at 19:52)</a>:</h4>
<p>The answer is, of course, to just redefine groups as one-object groupoids! (joking, of course)</p>



<a name="227329472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227329472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227329472">(Feb 22 2021 at 20:08)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>

<span class="kd">structure</span> <span class="n">bundled_function</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">bundled_function</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_fun</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_monoid_hom_foo</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">bundled_function</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_one</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">is_monoid_hom_foo.map_one</span> <span class="n">is_monoid_hom_foo.map_mul</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">bundled_function</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">[</span><span class="n">is_monoid_hom_foo</span> <span class="n">f</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">bundled_function</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span>
  <span class="o">[</span><span class="n">is_monoid_hom_foo</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</code></pre></div>
<p>I'm confused.</p>



<a name="227330716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227330716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227330716">(Feb 22 2021 at 20:17)</a>:</h4>
<p>Just to be clear, that works?</p>



<a name="227330724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227330724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227330724">(Feb 22 2021 at 20:17)</a>:</h4>
<p>yes</p>



<a name="227330854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227330854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227330854">(Feb 22 2021 at 20:18)</a>:</h4>
<p>That might be a big discovery</p>



<a name="227331197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227331197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227331197">(Feb 22 2021 at 20:21)</a>:</h4>
<p>But I still have no idea why this works but it doesn't for plain functions...</p>



<a name="227352649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227352649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227352649">(Feb 22 2021 at 22:47)</a>:</h4>
<p>For plain functions the simp lemma can't match, because the head of the left-hand-side is a metavariable (any function <code>f</code>). For <code>bundled_function</code> the head is some constant (I guess the coercion?)</p>



<a name="227352803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227352803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227352803">(Feb 22 2021 at 22:49)</a>:</h4>
<p>Going back up a bit, I'm dubious about using the existential <code>exists_hom'</code>. As Johan says above, why not just have fields <code>map_zero'</code> and <code>map_add'</code>, and construct the bundled <code>F.map_add</code> after the fact?</p>



<a name="227353868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227353868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227353868">(Feb 22 2021 at 22:58)</a>:</h4>
<p>Perhaps worth a new thread in general about this odd bundling behavior</p>



<a name="227353905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227353905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227353905">(Feb 22 2021 at 22:59)</a>:</h4>
<p>Agreed on the existential not being better than the simpler solution</p>



<a name="227356859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Additive%20functors/near/227356859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Additive.20functors.html#227356859">(Feb 22 2021 at 23:23)</a>:</h4>
<p>Okay, I pushed this change to <a href="https://github.com/leanprover-community/mathlib/issues/6367">#6367</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
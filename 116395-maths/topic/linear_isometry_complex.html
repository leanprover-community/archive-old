---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/linear_isometry_complex.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html">linear_isometry_complex</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="230265008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230265008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230265008">(Mar 14 2021 at 20:12)</a>:</h4>
<p>Hi,<br>
I've been working on proving the following lemma since last week:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>I proved another helper lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex'</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">h</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">((</span><span class="n">h</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="bp">...</span>
<span class="kd">end</span>
</code></pre></div>
<p>I would now like to use the helper lemma <code>linear_isometry_complex'</code> in my proof of  <code>linear_isometry_complex</code> and am uncertain how to go at this.<br>
Since <code>linear_isometry_complex</code> has a <code>∃ a : ℂ, |a| = 1</code>, I wanted to use:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">use</span> <span class="n">exp</span> <span class="bp">^</span> <span class="n">I</span> <span class="bp">*</span> <span class="n">θ</span>
</code></pre></div>
<p>and I need to define a function, say <code>h</code> that will fit the hypotheses of <code>linear_isometry_complex'</code>:<br>
<code>h 0 = 0</code> and <code>h 1 = 1</code><br>
for <code>h 0 = 0</code>I can use <code>linear_isometry.map_zero</code>, but I get stuck with the definition of <code>h</code> because I would need to take in <code>θ</code> as an argument.<br>
I'm wondering if I'm going in a good direction here or if there is a way to define this <code>h</code> function without using <code>exp ^ I * θ</code>.</p>



<a name="230265372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230265372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230265372">(Mar 14 2021 at 20:20)</a>:</h4>
<p>How about defining <code>a := f 1</code> and then letting <code>h</code> be <code>a⁻¹ • f</code>, (i.e., <code>λ z, a⁻¹ * f z</code>, but the first definition will make it automatically a linear map)?</p>



<a name="230265827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230265827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230265827">(Mar 14 2021 at 20:30)</a>:</h4>
<p>ok nice thanks, then there is no need to define a <code>θ</code>. I'll try it out!</p>



<a name="230266595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230266595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230266595">(Mar 14 2021 at 20:42)</a>:</h4>
<p>By the way, <code>conj a</code> might work more nicely than <code>a⁻¹</code>, I'm not sure, you could try it both ways!</p>



<a name="230266974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230266974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230266974">(Mar 14 2021 at 20:49)</a>:</h4>
<p>The advantage of <code>conj a</code> is that you don't need to get division involved, which is in general a good idea (you can use <code>ring</code> to do your algebra, for example, if division is not involved).</p>



<a name="230267259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230267259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230267259">(Mar 14 2021 at 20:54)</a>:</h4>
<p>thanks for the tips :)</p>



<a name="230267282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230267282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230267282">(Mar 14 2021 at 20:55)</a>:</h4>
<p>btw for the definition of <code>h</code> I'm guessing I need to do something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
     <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">z</span>
     <span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
     <span class="o">,</span> <span class="n">map_smul'</span> <span class="o">:=</span> <span class="gr">sorry</span>
     <span class="o">},</span>
</code></pre></div>
<p>otherwise I'll just get a <code>h</code> with type <code>ℂ → ℂ</code></p>



<a name="230267519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230267519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230267519">(Mar 14 2021 at 20:59)</a>:</h4>
<p>If your f is already linear then just <code>bub</code> it with <code>conj a</code> like Heather said and hopefully you won't need to fill in those sorries</p>



<a name="230267634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230267634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230267634">(Mar 14 2021 at 21:00)</a>:</h4>
<p>Bubbing should send a linear map to a linear map</p>



<a name="230267674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230267674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230267674">(Mar 14 2021 at 21:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I guess François is saying that he can't do this because <code>f</code> lives in <code>ℂ →ₗᵢ[ℝ] ℂ</code> which is only a real vector space, not complex?  My bad.</p>



<a name="230268280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230268280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230268280">(Mar 14 2021 at 21:10)</a>:</h4>
<p>Sorry if I'm not understanding completely.. I'm still new to Lean. <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  What does bubbing mean (does it mean that Lean will just understand the type of <code>h</code> from using <code>conj</code>)? and I'm still unsure about the meaning of the  notation <code>ℂ →ₗᵢ[ℝ] ℂ</code>.. I know it is some sort of linear map but not sure what the <code>ᵢ</code> stands for, nor the <code>[ℝ]</code>.</p>



<a name="230268648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230268648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230268648">(Mar 14 2021 at 21:16)</a>:</h4>
<p>Indeed, one limitation of Lean's tools is that it can be hard to discover where a notation is defined.  <code>ℂ →ₗᵢ[ℝ] ℂ</code> is notation for <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_isometry">docs#linear_isometry</a>, here an <code>ℝ</code>-linear map from <code>ℂ</code> to <code>ℂ</code> which also preserves lengths.</p>



<a name="230268714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230268714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230268714">(Mar 14 2021 at 21:17)</a>:</h4>
<p>So, in your constructor, you'll have </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">norm_map'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">},</span>
</code></pre></div>



<a name="230269040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230269040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230269040">(Mar 14 2021 at 21:22)</a>:</h4>
<p>ok right, that's what I observed (Lean was asking me to provide something for <code>norm_map'</code> as well and I imagine this case isn't one where bubbing will work? (since for me just setting <code>h := λ z, a⁻¹ * f z</code> directly gives <code>ℂ → ℂ</code> instead of <code>ℂ →ₗᵢ[ℝ] ℂ</code>)</p>



<a name="230269155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230269155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230269155">(Mar 14 2021 at 21:25)</a>:</h4>
<p>Right ... the property <code>norm_map'</code> is not preserved under scalar multiplication/<code>\bub</code>/<code>•</code> !</p>



<a name="230276257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230276257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230276257">(Mar 14 2021 at 22:45)</a>:</h4>
<p><span class="user-mention" data-user-id="375581">@François Sunatori</span> sorry to mislead you! Bub is <code>\bub</code>, the dot. But as you have pointed out you might not be able to use it (I was reading on my phone and couldn't even see the little l and i because of a font issue). Yes why not just make it a function, and then beef it up to a linear isometry manually, the way you originally said. By the way if you write <code>def foo  : ℂ →ₗᵢ[ℝ] ℂ := {! !}</code> and then click on the light bulb and then click on the bottom-but-one option (something about fields of a structure) then it will print out all the fields of the structure which you need to fill in.</p>



<a name="230284246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/230284246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#230284246">(Mar 15 2021 at 01:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thanks for the clarification about the bub (I was searching for that word in the codebase but didn't find anything related to what we were talking about haha, but I just tried typing <code>\bub</code> now and indeed it gives the <code>•</code>)!  and also thanks for the trick involving <code>{! !}</code>. I didn't know I could do that.</p>



<a name="231243886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231243886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231243886">(Mar 21 2021 at 21:59)</a>:</h4>
<p>I've gotten further in the proof of <code>linear_isometry_complex</code> but not as quickly as I did  with <code>linear_isometry_complex'</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">((</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">z</span><span class="o">,</span>
      <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">linear_isometry.map_add</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="n">intros</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">linear_isometry.map_smul</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">algebra.mul_smul_comm</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="n">norm_map'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">complex.abs_inv</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">complex.abs_mul</span><span class="o">,</span>
        <span class="gr">sorry</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="n">use</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">f1</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="k">have</span> <span class="n">H0</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">linear_isometry.map_zero</span> <span class="n">h</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="c1">-- TODO from use to_fun definition: λ z, (f 1)⁻¹ * f z?</span>
        <span class="gr">sorry</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="c1">-- TODO from use to_fun definition: λ z, (f 1)⁻¹ * f z?</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">linear_isometry_complex'</span> <span class="n">z</span> <span class="n">h</span> <span class="n">H0</span> <span class="n">H1</span><span class="o">),</span>
      <span class="gr">sorry</span>
    <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm left with 3 <code>sorry</code>s. I'm trying to tackle the proof of <code>have H1 : h 1 = 1</code>.<br>
I'm not sure how to apply <code>λ z, (f 1)⁻¹ * f z</code> that I defined in <code>h.to_fun</code>.<br>
Once I write a proof for a field in an instance of a Lean <code>record</code>, can I invoke <code>h.to_fun</code> and use it with <code>exact</code> or <code>rw</code> for example?</p>
<p>Thanks :)</p>



<a name="231245828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231245828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231245828">(Mar 21 2021 at 22:35)</a>:</h4>
<p>You're proving the wrong thing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">((</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>This says "there exists a complex number a such that if |a|=1 then something is true" so you can prove it by supplying any complex number whose norm isn't 1.</p>



<a name="231245974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231245974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231245974">(Mar 21 2021 at 22:38)</a>:</h4>
<p>Oh ok... so in that case it needs to be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>
<p>?<br>
(replace the → with ∧)</p>



<a name="231246339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246339">(Mar 21 2021 at 22:46)</a>:</h4>
<p>but I would still like an answer to the following question:</p>
<blockquote>
<p>I'm not sure how to apply λ z, (f 1)⁻¹ * f z that I defined in h.to_fun.<br>
Once I write a proof for a field in an instance of a Lean record, can I invoke h.to_fun and use it with exact or rw for example?</p>
</blockquote>



<a name="231246442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246442">(Mar 21 2021 at 22:48)</a>:</h4>
<p>Instead of <code>have</code>, use <code>let</code>; <code>have</code> forgets the definition, <code>let</code> remembers it.</p>



<a name="231246445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246445">(Mar 21 2021 at 22:48)</a>:</h4>
<p>Thus,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
</code></pre></div>



<a name="231246466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246466">(Mar 21 2021 at 22:48)</a>:</h4>
<p>Then, when the time comes to remember how <code>h</code> was defined, you can do something like <code>rw h</code> or <code>simp only [h]</code> or <code>unfold h</code>.</p>



<a name="231246640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246640">(Mar 21 2021 at 22:52)</a>:</h4>
<p>I think you're going the wrong way with the first <code>sorry</code>. You have to use that |f(x)|=|x|. How about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>      <span class="n">norm_map'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
        <span class="n">change</span> <span class="bp">∥</span><span class="n">f</span> <span class="mi">1</span><span class="bp">∥⁻¹</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">x</span><span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">linear_isometry.norm_map</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">linear_isometry.norm_map</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="o">},</span>
</code></pre></div>



<a name="231246735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246735">(Mar 21 2021 at 22:55)</a>:</h4>
<p>For the others, I think Heather's advice on let v have should see you through.</p>
<p>While I'm here I should point out that in early 2018 I was running around on the Lean chat going "me and a bunch of undergraduates have defined schemes!" and there were essentially no other number theorists or algebraic geometers here at the time, so the definition just sat there for a while with the computer scientists looking bemusedly at it, and then Johan Commelin showed up, took one look at the definition and said "you know that -&gt;, don't you think it should be an \and?"</p>



<a name="231246997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231246997">(Mar 21 2021 at 23:00)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> for the trick to change to <code>∥-∥</code>.. I actually wasn't too sure how far I would be able to get with route I had taken.  And thanks for the story ! I guess I'll remember to watch out for that one in the future!</p>



<a name="231247069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231247069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231247069">(Mar 21 2021 at 23:01)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> <code>let</code> is exactly what I need! I guess I should have tried <code>let</code> in the first place.. I think I wrongly assumed that it was a synonym for <code>have</code> and maybe the parts of mathlib I was looking at weren't using <code>let</code> so much.</p>



<a name="231248033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231248033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231248033">(Mar 21 2021 at 23:20)</a>:</h4>
<p><code>have</code> is for proofs, <code>let</code> is for data.</p>



<a name="231251082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231251082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231251082">(Mar 22 2021 at 00:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246466">said</a>:</p>
<blockquote>
<p>Then, when the time comes to remember how <code>h</code> was defined, you can do something like <code>rw h</code> or <code>simp only [h]</code> or <code>unfold h</code>.</p>
</blockquote>
<p>In the proof for </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>
<p>When I try to use <code>rw h</code> or <code>unfold h</code>I get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="kd">lemma</span> <span class="n">is</span> <span class="n">not</span> <span class="n">an</span> <span class="n">equality</span> <span class="n">nor</span> <span class="n">a</span> <span class="n">iff</span>
</code></pre></div>
<p>but using <code>simp only [h]</code><br>
gives me<br>
<strong>A</strong>: <code>⇑{to_linear_map := {to_fun := λ (z : ℂ), a⁻¹ * ⇑f z, map_add' := _, map_smul' := _}, norm_map' := _} 1 = 1</code><br>
and I would like to apply <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> to <code>1</code><br>
so I tried using <code>simp</code> (which simplified the expression and applied <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> when I used it <code>norm_map'</code>) but it gives me <code>simplify tactic failed to simplify</code>.<br>
How would I go at getting <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> out of <strong>A</strong>?</p>



<a name="231253479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253479">(Mar 22 2021 at 01:19)</a>:</h4>
<p><span class="user-mention" data-user-id="375581">@François Sunatori</span>  Does it work to do <code>simp</code> rather than <code>simp only</code>?</p>



<a name="231253558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253558">(Mar 22 2021 at 01:20)</a>:</h4>
<p>no...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>gives</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">simplify</span> <span class="n">tactic</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">simplify</span>
</code></pre></div>



<a name="231253602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253602">(Mar 22 2021 at 01:21)</a>:</h4>
<p>Sorry, I should have been more precise.  I meant you to keep the <code>h</code> -- <code>simp [h]</code> rather than <code>simp only [h]</code>.</p>



<a name="231253676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253676">(Mar 22 2021 at 01:23)</a>:</h4>
<p>oh ok, yes it works but it gives me the same result as <code>simp only [h]</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⇑</span><span class="o">{</span><span class="n">to_linear_map</span> <span class="o">:=</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">},</span> <span class="n">norm_map'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>



<a name="231253771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253771">(Mar 22 2021 at 01:25)</a>:</h4>
<p>I would still need some way to get <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> out somehow... when I worked on the proof for <code>norm_map'</code> in the definition of <code>h</code>, I was able to use <code>simp</code> to get <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> out and apply it to an argument, but not in this case...</p>



<a name="231253906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253906">(Mar 22 2021 at 01:28)</a>:</h4>
<p>Ah, I see!  OK, here's a line that seems to do it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
</code></pre></div>
<p>Basically this is the <code>come_on_lean</code> tactic that people joke about ...</p>



<a name="231253925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253925">(Mar 22 2021 at 01:29)</a>:</h4>
<p>That is, we're instructing Lean to check that the following statement is definitionally equal to our goal.</p>



<a name="231253926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253926">(Mar 22 2021 at 01:29)</a>:</h4>
<p>oh lol I haven't heard about that one yet!</p>



<a name="231253938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253938">(Mar 22 2021 at 01:29)</a>:</h4>
<p>could it be because in the case of <code>norm_map'</code> I was dealing with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⇑</span><span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>
<p>while this time I'm dealing with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⇑</span><span class="o">{</span><span class="n">to_linear_map</span> <span class="o">:=</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">},</span> <span class="n">norm_map'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>
<p>where <code>to_fun</code> is a level deeper?</p>



<a name="231253986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231253986">(Mar 22 2021 at 01:30)</a>:</h4>
<p>Seems plausible!</p>



<a name="231254041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254041">(Mar 22 2021 at 01:31)</a>:</h4>
<p>Thanks a lot! I really couldn't wrap my head around why it worked for <code>norm_map'</code> but not in this case (I still don't know why but at least I have a workaround now!)</p>



<a name="231254089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254089">(Mar 22 2021 at 01:32)</a>:</h4>
<p>There are not many uses of <code>change</code> in mathlib, because usually each definition (in the library proper rather than a definition hidden inside a proof like yours is) is immediately followed by a lemma which unfolds that definition, whose proof is <code>rfl</code>.  Often this "definition-unfolding" lemma is even a simp-lemma.</p>



<a name="231254251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254251">(Mar 22 2021 at 01:35)</a>:</h4>
<p>Oh I see. Would it make sense to have that extra lemma or is it so specific that it doesn't really make sense to define it outside of this proof?</p>



<a name="231254379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254379">(Mar 22 2021 at 01:38)</a>:</h4>
<p>I'd say, not at this stage.  That sort of "infrastructure" can be figured out after everything else is working.</p>



<a name="231254492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254492">(Mar 22 2021 at 01:41)</a>:</h4>
<p>By the way, here's an example of the kind of thing I was describing:  see how the imaginary part function <a href="https://leanprover-community.github.io/mathlib_docs/find/complex.im_clm">docs#complex.im_clm</a>, as a continuous linear map, is immediately followed by a simp-lemma <a href="https://leanprover-community.github.io/mathlib_docs/find/complex.im_clm_apply">docs#complex.im_clm_apply</a> explaining what it does as a function.</p>



<a name="231254630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254630">(Mar 22 2021 at 01:44)</a>:</h4>
<p>(I tend to write my <code>@[simp]</code> lemmas as soon as they're needed --- every time I try <code>simp</code> and it doesn't solve the goal, I stop to think if a lemma is missing. Life is so much easier once they're in place.)</p>



<a name="231254750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231254750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231254750">(Mar 22 2021 at 01:47)</a>:</h4>
<p>Oh yes I remember seeing a few of those <code>rfl</code> lemmas often just after a definition.. Thanks, now I understand why they're there!</p>



<a name="231255926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231255926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231255926">(Mar 22 2021 at 02:08)</a>:</h4>
<p>Interestingly when I try the next step to go from <code>(f 1)⁻¹ * f 1 = 1</code> to <code>1 = 1</code>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">mul_left_inv</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span><span class="o">),</span>
        <span class="bp">...</span>
<span class="o">}</span>
</code></pre></div>
<p>I get </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="o">:=</span> <span class="bp">⇑</span><span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">to_linear_map</span> <span class="o">:=</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_smul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">},</span> <span class="n">norm_map'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">},</span>
<span class="n">H0</span> <span class="o">:</span> <span class="bp">⇑</span><span class="n">h</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">h.map_zero</span>
<span class="bp">⊢</span> <span class="n">group</span> <span class="n">ℂ</span>
</code></pre></div>
<p>but when I look in <code>analysis.normed_space.linear_isometry</code> I see an <code>instance : group (E ≃ₗᵢ[R] E)</code> with <code>mul_left_inv</code> defined..<br>
Is there something I'm missing to make Lean aware that <code>f</code> has access to <code>mul_left_inv</code>?</p>



<a name="231255945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231255945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231255945">(Mar 22 2021 at 02:09)</a>:</h4>
<p>I also tried adding <code>import analysis.normed_space.linear_isometry</code> but it didn't change anything</p>



<a name="231256111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231256111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231256111">(Mar 22 2021 at 02:13)</a>:</h4>
<p>Careful, <code>ℂ ≃ₗᵢ[ℝ] ℂ</code> is a group but <code>ℂ</code> itself is not a group!</p>



<a name="231256120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231256120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231256120">(Mar 22 2021 at 02:13)</a>:</h4>
<p>Because 0 is not invertible.</p>



<a name="231256174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231256174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231256174">(Mar 22 2021 at 02:14)</a>:</h4>
<p>oh right! oups</p>



<a name="231256396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231256396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231256396">(Mar 22 2021 at 02:19)</a>:</h4>
<p>Instead of the lemma <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_left_inv">docs#mul_left_inv</a> (for groups only), you want to use the lemma <a href="https://leanprover-community.github.io/mathlib_docs/find/inv_mul_cancel">docs#inv_mul_cancel</a>.</p>



<a name="231256597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231256597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231256597">(Mar 22 2021 at 02:22)</a>:</h4>
<p>Ok nice and then I need to supply a proof that <code>a ≠ 0</code></p>



<a name="231403731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231403731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231403731">(Mar 23 2021 at 00:06)</a>:</h4>
<p>I'm now running into an awkward situation..</p>
<p>I have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">∨</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span>
</code></pre></div>
<p>and would like to get to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div>
<p>When I use <code>rw ← mul_right_inj' H3</code> where (<code>H3 : a⁻¹ ≠ 0</code>), I'm able to get </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">∨</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span>
</code></pre></div>
<p>and then I try to use <code>rw ← mul_right_inj' H3 @(f z) @(a * conj z)</code> to act on the other equality<br>
but I get the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">mul_right_inj'</span> <span class="n">H3</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">?</span><span class="n">m_2</span> <span class="bp">↔</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="bp">?</span><span class="n">m_2</span>
</code></pre></div>



<a name="231403875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231403875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231403875">(Mar 23 2021 at 00:08)</a>:</h4>
<p>I was trying to use the <code>@</code> to pass the parameters to implicit arguments <code>{b c}</code></p>



<a name="231404382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231404382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231404382">(Mar 23 2021 at 00:14)</a>:</h4>
<p>The <code>@</code> has to go on the <code>mul_right_inj'</code></p>



<a name="231404439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231404439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231404439">(Mar 23 2021 at 00:15)</a>:</h4>
<p>You can also use <code>conv</code> in this situation to "zoom in" on the subexpression you want to rewrite. The proof is sometimes easier to follow this way.</p>



<a name="231404939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231404939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231404939">(Mar 23 2021 at 00:21)</a>:</h4>
<p>Thanks for the tips <span class="user-mention" data-user-id="110087">@Scott Morrison</span> , how would I use <code>conv</code>? Would I use it with <code>rw</code> or on its own?</p>



<a name="231404987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231404987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231404987">(Mar 23 2021 at 00:21)</a>:</h4>
<p>Something like <code>conv at h { congr, skip, rw p }</code>.</p>



<a name="231405050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231405050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231405050">(Mar 23 2021 at 00:22)</a>:</h4>
<p>This says: "look at h, split into subexpressions, skip over the first one, rewrite using <code>p</code> in the second one".</p>



<a name="231405444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231405444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231405444">(Mar 23 2021 at 00:26)</a>:</h4>
<p>nice, I just tried it.. yup it's much easier to follow like this! Thanks for the new tool!</p>



<a name="231566294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231566294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231566294">(Mar 24 2021 at 00:45)</a>:</h4>
<p>I'm trying to use </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">apply</span> <span class="o">(</span><span class="n">mul_left_cancel</span> <span class="mi">2</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="n">z.re</span><span class="o">)</span> <span class="n">H_left</span>
</code></pre></div>
<p>and am getting the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">pre</span><span class="bp">-</span><span class="n">numeral</span><span class="o">,</span> <span class="kd">universe</span> <span class="n">level</span> <span class="n">must</span> <span class="n">be</span> <span class="bp">&gt;</span> <span class="mi">0</span>
</code></pre></div>
<p>when I did my first pass on the proof, I wrote this lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">reals_mul_left_cancel</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and applied it like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">apply</span> <span class="o">(</span><span class="n">mul_left_cancel</span> <span class="mi">2</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="n">z.re</span><span class="o">)</span> <span class="n">H_left</span>
</code></pre></div>
<p>so that I could move on.<br>
But now I'm cleaning up the proof and would like to know what the error <code>invalid pre-numeral, universe level must be &gt; 0</code> means and how I can solve it.<br>
Thanks!</p>



<a name="231568055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231568055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231568055">(Mar 24 2021 at 01:09)</a>:</h4>
<p>Can you share the full lemma statement and attempted proof?</p>



<a name="231568291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231568291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231568291">(Mar 24 2021 at 01:13)</a>:</h4>
<p>it's for this lemma in particular (it's rather long and I'm working on making it shorter but here's the part I'm having an issue with):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">data.real.sqrt</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">linear_isometry_complex'</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">h</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">((</span><span class="n">h</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span>
<span class="kd">begin</span>
  <span class="bp">...</span>
  <span class="k">have</span> <span class="n">Hre</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="n">ext_iff</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_re</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
    <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_im</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
    <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">conj_re</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
    <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">conj_im</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
    <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_neg_self</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
    <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_self_eq</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
    <span class="n">cases</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">eq_comm</span> <span class="n">at</span> <span class="n">H_left</span><span class="o">,</span>
    <span class="n">ring</span> <span class="n">at</span> <span class="n">H_left</span><span class="o">,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">reals_mul_left_cancel</span> <span class="mi">2</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="n">z.re</span><span class="o">)</span> <span class="n">H_left</span><span class="o">,</span>   <span class="bp">&lt;</span><span class="c1">-------</span>
  <span class="o">},</span>
  <span class="bp">...</span>
<span class="kd">end</span>
</code></pre></div>



<a name="231568849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231568849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231568849">(Mar 24 2021 at 01:20)</a>:</h4>
<p>what's <code>H</code> here? just the statement</p>



<a name="231569127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231569127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231569127">(Mar 24 2021 at 01:24)</a>:</h4>
<p>oh sorry, yes it's </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">H</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">+</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">h</span> <span class="n">z</span> <span class="bp">+</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div>



<a name="231569773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231569773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231569773">(Mar 24 2021 at 01:34)</a>:</h4>
<p>This works for me, so something is different than what you shared:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.buffer.parser.basic</span>
<span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">data.real.sqrt</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kd">lemma</span> <span class="n">reals_mul_left_cancel</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">z.conj</span> <span class="bp">=</span> <span class="n">h</span> <span class="n">z</span> <span class="bp">+</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">conj</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">ext_iff</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_re</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
  <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_im</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
  <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">conj_re</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
  <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">conj_im</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
  <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">add_neg_self</span> <span class="n">at</span> <span class="n">H</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">two_mul</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">two_mul</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">eq_comm</span> <span class="n">at</span> <span class="n">H_left</span><span class="o">,</span>
  <span class="n">ring_nf</span> <span class="n">at</span> <span class="n">H_left</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">reals_mul_left_cancel</span> <span class="mi">2</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="n">z.re</span><span class="o">)</span> <span class="n">H_left</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="231570478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231570478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231570478">(Mar 24 2021 at 01:44)</a>:</h4>
<p>yes it works but I would like to get rid of </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">reals_mul_left_cancel</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and use </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">apply</span> <span class="o">(</span><span class="n">mul_left_cancel</span> <span class="mi">2</span> <span class="o">(</span><span class="n">h</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="n">z.re</span><span class="o">)</span> <span class="n">H_left</span>
</code></pre></div>
<p>instead</p>



<a name="231571729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231571729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231571729">(Mar 24 2021 at 02:03)</a>:</h4>
<p>The reason you're getting the cryptic pre-numeral error is because <code>mul_left_cancel</code> has the arguments implicit so you're feeding it numbers when it expects something completely different; you'll see the same error if you change your lemma to use <code>{a b c : ℝ}</code>. You could just <code>linarith [H_left]</code> to get around it if you don't like using that lemma, or maybe people that know a lot more than me know how to give Lean more hints so that it would understand, say, <code>apply mul_left_cancel H_left</code>.</p>



<a name="231572206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231572206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231572206">(Mar 24 2021 at 02:09)</a>:</h4>
<p>Oh great,  thanks <span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> ! I'll stick to <code>linarith [H_left]</code>. I haven't used much automation in my proofs yet. Does the <code>[H_left]</code>mean: try <code>linarith</code> lemmas with <code>H_left</code> as a parameter?</p>



<a name="231572266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231572266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#231572266">(Mar 24 2021 at 02:10)</a>:</h4>
<p>as far as I understand! I'm still learning so I'm sure the wiser ones will know far better :b</p>



<a name="232105648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232105648">(Mar 27 2021 at 17:39)</a>:</h4>
<p>I'm working on readying this lemma for a PR. I'm wondering:</p>
<ul>
<li>in which file it should be or should it be in its own file (e.g. <code>analysis/complex/isometry.lean</code>)?</li>
<li>I have another lemma that I used in the proof of <code>linear_isometry_complex</code> for now it's called <code>linear_isometry_complex'</code>. How should I name it?</li>
<li>I'll try to go through the documentation style (<a href="https://leanprover-community.github.io/contribute/doc.html">https://leanprover-community.github.io/contribute/doc.html</a>) and rename some variables and if it will be in its own file I guess I'll need to add a file header.</li>
<li>anything else I should know about the process?</li>
</ul>
<p>thanks!</p>



<a name="232105731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232105731">(Mar 27 2021 at 17:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="375581">François Sunatori</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105648">said</a>:</p>
<blockquote>
<ul>
<li>I have another lemma that I used in the proof of <code>linear_isometry_complex</code> for now it's called <code>linear_isometry_complex'</code>. How should I name it?</li>
</ul>
</blockquote>
<p>That depends a lot on the statement</p>



<a name="232105753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232105753">(Mar 27 2021 at 17:40)</a>:</h4>
<p>If it is reusable, it should be moved to the file where it belongs, and follow the naming convention</p>



<a name="232105761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232105761">(Mar 27 2021 at 17:40)</a>:</h4>
<p>If it's really a one-off helper lemma, we typically append <code>_aux</code> or something like that.</p>



<a name="232105894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232105894">(Mar 27 2021 at 17:43)</a>:</h4>
<p>I think it's more of a one-off helper lemma in this case so I'll add <code>_aux</code></p>



<a name="232106149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232106149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232106149">(Mar 27 2021 at 17:47)</a>:</h4>
<p>How about the <code>linear_isometry_complex</code> lemma itself? in which file would it make most sense to add it?</p>



<a name="232106387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232106387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232106387">(Mar 27 2021 at 17:51)</a>:</h4>
<p>your suggestion sounded good</p>



<a name="232106508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232106508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232106508">(Mar 27 2021 at 17:53)</a>:</h4>
<p>ok, thanks :)</p>



<a name="232130509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232130509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232130509">(Mar 28 2021 at 01:01)</a>:</h4>
<p>I think I would be ready to open a PR for this addition. This is a first for me and I look forward to getting some feedback. I would like to have write access for a non-master branch. My GitHub username is <code>frankymacster</code>. Thanks!</p>



<a name="232152343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232152343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232152343">(Mar 28 2021 at 08:34)</a>:</h4>
<p>@maintainers</p>



<a name="232154708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232154708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232154708">(Mar 28 2021 at 09:24)</a>:</h4>
<p><span class="user-mention" data-user-id="375581">@François Sunatori</span>, invitation sent! (Sorry, everyone must be enjoying their weekend, usually we're fast on these. :-)</p>



<a name="232169836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232169836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232169836">(Mar 28 2021 at 14:20)</a>:</h4>
<p>Thanks! No worries, I expected that since I asked on a Saturday night ;)</p>



<a name="232214979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232214979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232214979">(Mar 29 2021 at 03:53)</a>:</h4>
<p>Hi, I'm trying to use <code>conv</code> on the following expression</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span>
</code></pre></div>
<p>by doing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>        <span class="n">conv</span> <span class="o">{</span>
          <span class="n">congr</span><span class="o">,</span>
          <span class="n">intro</span> <span class="n">z</span>    <span class="bp">&lt;</span><span class="c1">--------</span>
        <span class="o">},</span>
</code></pre></div>
<p>but <code>intro z</code> gives the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">unknown</span> <span class="n">identifier</span> <span class="sc">'z'</span>
</code></pre></div>
<p>How come I can't use <code>intro</code> in <code>conv</code>? Is there some other way to deal with a situation like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span>
</code></pre></div>
<p>to affect change to <code>a⁻¹ * ⇑f z = z</code> for example?<br>
Thanks!</p>



<a name="232215051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232215051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232215051">(Mar 29 2021 at 03:55)</a>:</h4>
<p>Use <code>funext</code> to rewrite under binders in <code>conv</code>. See <a href="https://leanprover-community.github.io/extras/conv.html">the docs</a>.</p>



<a name="232215496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232215496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232215496">(Mar 29 2021 at 04:03)</a>:</h4>
<p>Thanks! I tried replacing <code>intro z</code> with <code>funext</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>       <span class="n">conv</span> <span class="o">{</span>
          <span class="n">congr</span><span class="o">,</span>
          <span class="n">funext</span>
        <span class="o">},</span>
</code></pre></div>
<p>but the goal didn't change... the goal is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span>
</code></pre></div>
<p>before and after <code>funext</code></p>



<a name="232215839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232215839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232215839">(Mar 29 2021 at 04:09)</a>:</h4>
<p>Ah, I guess <code>funext</code> only works on lambdas. Maybe you can try to get inside using <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#conv:%20find"><code>find</code></a>?</p>



<a name="232216033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232216033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232216033">(Mar 29 2021 at 04:12)</a>:</h4>
<p><code>conv in ..</code> should work?<br>
e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">lemma</span> <span class="n">a</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>PS it'll be easier to help if you can make  a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> like I did here for people to try their suggestions</p>



<a name="232216255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232216255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232216255">(Mar 29 2021 at 04:16)</a>:</h4>
<p>great, both <code>find (f _ = _)</code> and  <code>conv in (_ = _)</code> worked! (I think I'll opt for <code>conv in (_ = _)</code> since it gave less lines). Thanks to you both :)</p>



<a name="232216293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232216293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232216293">(Mar 29 2021 at 04:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232216033">said</a>:</p>
<blockquote>
<p>PS it'll be easier to help if you can make  a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> like I did here for people to try their suggestions</p>
</blockquote>
<p>One nice thing about a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> is that anyone can open it instantly in the web editor (using the tool in the top right corner of the code snippet) to play with it.</p>



<a name="232216503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232216503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232216503">(Mar 29 2021 at 04:21)</a>:</h4>
<p>Oh I didn't know that it opened the web editor! ok I'll try to do that next time, I guess it will make communicating things easier!</p>



<a name="232524657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232524657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232524657">(Mar 31 2021 at 01:56)</a>:</h4>
<p>I'm trying to generalize the expression <code>(f z).re = z.re</code> to <code>∀ (z : ℂ), (f z).re = z.re</code> like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kd">lemma</span> <span class="n">add_self_eq</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring</span>

<span class="kd">lemma</span> <span class="n">hf_re</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">conv</span> <span class="n">at</span> <span class="n">h₃</span> <span class="o">{</span>
    <span class="n">find</span> <span class="o">(</span><span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">rw</span> <span class="n">ext_iff</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">add_re</span><span class="o">,</span> <span class="n">rw</span> <span class="n">add_re</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">add_im</span><span class="o">,</span> <span class="n">rw</span> <span class="n">add_im</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">conj_re</span><span class="o">,</span> <span class="n">rw</span> <span class="n">conj_re</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">conj_im</span><span class="o">,</span> <span class="n">rw</span> <span class="n">conj_im</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">add_neg_self</span><span class="o">,</span> <span class="n">rw</span> <span class="n">add_neg_self</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">add_self_eq</span><span class="o">,</span> <span class="n">rw</span> <span class="n">add_self_eq</span><span class="o">,</span>
      <span class="n">congr</span><span class="o">,</span>
      <span class="n">skip</span><span class="o">,</span>
      <span class="c1">-- refl,</span>
      <span class="c1">-- trivial,</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>I tried to use <code>refl</code> and <code>trivial</code> inside <code>conv at h3</code> (and thought that it would work since I saw it used in <a href="https://leanprover-community.github.io/extras/conv.html">https://leanprover-community.github.io/extras/conv.html</a>) but am getting this error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">conv.istep</span> <span class="mi">19</span> <span class="mi">6</span> <span class="mi">19</span> <span class="mi">6</span> <span class="n">refl</span>
<span class="n">term</span>
  <span class="n">refl</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">?</span><span class="n">m_2</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">conv</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>
<p>am I missing something here? or should I be trying a different tactic?<br>
Thanks!</p>



<a name="232526166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232526166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232526166">(Mar 31 2021 at 02:16)</a>:</h4>
<p>One way to generalize it is just to say:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hf_re</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">))</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">ext_iff</span><span class="o">,</span> <span class="n">add_re</span><span class="o">,</span> <span class="n">add_im</span><span class="o">,</span> <span class="n">conj_re</span><span class="o">,</span> <span class="n">conj_im</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_mul</span><span class="o">,</span>
         <span class="o">(</span><span class="k">show</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">two_ne_zero'</span><span class="o">])]</span> <span class="n">using</span> <span class="o">(</span><span class="n">h₃</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kd">end</span>
</code></pre></div>



<a name="232526625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232526625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232526625">(Mar 31 2021 at 02:23)</a>:</h4>
<p>oh nice, however an extra detail  is that <code>(∀ z : ℂ) : (f z).re = z.re</code> is a hypothesis in the lemma I'm working on. Will this work in that case?</p>



<a name="232526749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232526749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232526749">(Mar 31 2021 at 02:25)</a>:</h4>
<p>I'm not sure what you mean. All I did was move the <code>∀ (z : ℂ)</code> to the left of the <code>colon</code> in <code> lemma name args *here* : statement := proof</code></p>



<a name="232526778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232526778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232526778">(Mar 31 2021 at 02:25)</a>:</h4>
<p>And you'll be able to use it. Take a look:</p>



<a name="232526802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232526802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232526802">(Mar 31 2021 at 02:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kd">lemma</span> <span class="n">hf_re</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">))</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">ext_iff</span><span class="o">,</span> <span class="n">add_re</span><span class="o">,</span> <span class="n">add_im</span><span class="o">,</span> <span class="n">conj_re</span><span class="o">,</span> <span class="n">conj_im</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_mul</span><span class="o">,</span>
         <span class="o">(</span><span class="k">show</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">two_ne_zero'</span><span class="o">])]</span> <span class="n">using</span> <span class="o">(</span><span class="n">h₃</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="n">hf_re</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">hf_re :</span>
<span class="cm">  ∀ (f : ℂ →ₗᵢ[ℝ] ℂ),</span>
<span class="cm">    (∀ (z : ℂ), z + ⇑conj z = ⇑f z + ⇑conj (⇑f z)) → ∀ (z : ℂ), (⇑f z).re = z.re</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="232526888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232526888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232526888">(Mar 31 2021 at 02:26)</a>:</h4>
<p>As you can see, I placed the <code>z</code> to the left of the colon, and the lemma, as Lean sees it, still has the universal quantifier.</p>



<a name="232527122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232527122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232527122">(Mar 31 2021 at 02:30)</a>:</h4>
<p>ok thanks :) I'll see how I can use it in my lemma!</p>



<a name="232528845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232528845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232528845">(Mar 31 2021 at 02:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="375581">François Sunatori</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232524657">said</a>:</p>
<blockquote>
<p>I tried to use <code>refl</code> and <code>trivial</code> inside <code>conv at h3</code> (and thought that it would work since I saw it used in <a href="https://leanprover-community.github.io/extras/conv.html">https://leanprover-community.github.io/extras/conv.html</a>) </p>
</blockquote>
<p>I think the docs may be unclear about this. That page says (modulo formatting):</p>
<blockquote>
<p>Once arrived at the relevant target, we can use rw as in normal mode. Note that Lean tries to solves the current goal if it became x = x (in the strict syntactical sense, definitional equality is not enough: one needs to conclude by refl or trivial in this case).</p>
</blockquote>
<p>It sounds like it's saying you can use <code>refl</code> or <code>trivial</code> inside the <code>conv</code> block, but I think what it actually means is just that in that case you need to say <code>refl</code> or <code>trivial</code> after the <code>conv</code> is over.</p>



<a name="232529172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232529172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232529172">(Mar 31 2021 at 03:02)</a>:</h4>
<p>Putting the <code>z : ℂ</code> before the colon is a good way to write the proof, but perhaps it's informative to see another way you could more directly do what you were trying to do above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hf_re</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₄</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₃</span> <span class="n">z</span><span class="o">,</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">f : ℂ →ₗᵢ[ℝ] ℂ,</span>
<span class="cm">h₃ : ∀ (z : ℂ), z + ⇑conj z = ⇑f z + ⇑conj (⇑f z),</span>
<span class="cm">z : ℂ,</span>
<span class="cm">h₄ : z + ⇑conj z = ⇑f z + ⇑conj (⇑f z)</span>
<span class="cm">⊢ (⇑f z).re = z.re</span>
<span class="cm">-/</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="232530354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232530354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232530354">(Mar 31 2021 at 03:21)</a>:</h4>
<p>oh right, I haven't thought of doing that! thanks for the trick :)</p>



<a name="232530544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232530544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232530544">(Mar 31 2021 at 03:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="397997">Greg Price</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232529172">said</a>:</p>
<blockquote>
<p>Putting the <code>z : ℂ</code> before the colon is a good way to write the proof</p>
</blockquote>
<p>Is there a preferred style for mathlib in terms of having</p>
<ul>
<li><code>z : ℂ</code> before the colon vs</li>
<li><code>∀ (z : ℂ)</code> after the colon<br>
?</li>
</ul>



<a name="232530678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232530678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232530678">(Mar 31 2021 at 03:26)</a>:</h4>
<p>Yes, the former!  It avoids one <code>intros</code> step.</p>



<a name="232530760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232530760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232530760">(Mar 31 2021 at 03:27)</a>:</h4>
<p>And I might guess (not sure, though) that it's less sensitive to ordering of hypotheses in things like <code>library_search</code>.</p>



<a name="232531230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232531230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232531230">(Mar 31 2021 at 03:34)</a>:</h4>
<p>thanks! I'll work on cleaning up my code to follow that more and maybe also split some parts out as smaller lemmas (I get the feeling my proofs were too long when I compare with other ones in mathlib)</p>



<a name="232531335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232531335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232531335">(Mar 31 2021 at 03:36)</a>:</h4>
<p>Is there some rule of thumb or a style preference on when a code block should stay in a <code>have</code> inside a proof vs when it should be moved out?</p>



<a name="232531383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232531383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232531383">(Mar 31 2021 at 03:37)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? What are the two options (it's OK to use <code>foo</code> instead of a real example)?</p>



<a name="232532094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532094">(Mar 31 2021 at 03:49)</a>:</h4>
<p>actually I was asking more as a general question if there's a general way or heuristic to determine when a proof should be split into smaller lemmas (for one I'm guessing if it can be reused elsewhere it's a good idea to move it out as its own lemma, but would there be other reasons?), but here's how I had it:<br>
the "main" lemma to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>
<p>an auxiliary lemma that I'm using in the proof of the one above</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>
<p>but the proof I had for <code>linear_isometry_complex_aux</code> is almost 100 lines.. (maybe I didn't use the shortest path to get to it or I haven't used enough simplification tactics) but I'm asking because I'm guessing that at some point too many lines may not be preferable in the mathlib library.</p>



<a name="232532304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532304">(Mar 31 2021 at 03:52)</a>:</h4>
<p>In this case it looks like the <code>aux</code> lemma is an important particular case, and it can be used separately, so it should be a separate lemma.</p>



<a name="232532363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532363">(Mar 31 2021 at 03:53)</a>:</h4>
<p>"To split or not to split" is a matter of taste. I'm not sure what's more readable: a long proof with many named <code>have</code>s or a series of short lemmas.</p>



<a name="232532471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532471">(Mar 31 2021 at 03:54)</a>:</h4>
<p>Sure, if one of <code>have</code>s is a useful lemma, then it should be formulated separately. Otherwise it's OK to have long proofs.</p>



<a name="232532479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532479">(Mar 31 2021 at 03:55)</a>:</h4>
<p>The proof for the aux lemma, in my mind, is something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">show</span> <span class="n">that</span> <span class="n">the</span> <span class="n">real</span> <span class="n">parts</span> <span class="n">must</span> <span class="k">match</span> <span class="n">up</span> <span class="o">(</span><span class="n">you've</span> <span class="n">done</span> <span class="n">this</span><span class="o">,</span> <span class="mi">2</span> <span class="n">lines</span><span class="o">)</span>
<span class="k">show</span> <span class="n">that</span> <span class="n">I</span> <span class="n">maps</span> <span class="n">to</span> <span class="n">either</span> <span class="n">I</span> <span class="n">or</span> <span class="bp">-</span><span class="n">I</span>
<span class="n">every</span> <span class="n">z</span> <span class="n">is</span> <span class="n">a</span> <span class="n">linear</span> <span class="n">combination</span> <span class="n">of</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">I</span><span class="o">,</span> <span class="n">so</span>  <span class="n">the</span> <span class="n">properties</span> <span class="n">you've</span> <span class="n">proved</span> <span class="n">so</span> <span class="n">far</span> <span class="n">transfer</span>
</code></pre></div>



<a name="232532506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532506">(Mar 31 2021 at 03:55)</a>:</h4>
<p>And the first two can be their own lemmas, I think (?)</p>



<a name="232532587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532587">(Mar 31 2021 at 03:56)</a>:</h4>
<p>ok yea I like that split. I'll try it that way</p>



<a name="232532606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532606">(Mar 31 2021 at 03:56)</a>:</h4>
<p>thanks <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  and <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> !</p>



<a name="232532629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232532629">(Mar 31 2021 at 03:57)</a>:</h4>
<p>Haven't done complex analysis in a long time, so my assumptions about what's easy or what implies what might be wrong here.</p>



<a name="232534109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232534109">(Mar 31 2021 at 04:18)</a>:</h4>
<p>so actually the way I had it for the <code>linear_isometry_complex_aux</code> (at a high level) was this way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="k">have</span> <span class="n">hf0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="n">f</span> <span class="mi">1</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">conj</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf_re</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf_im</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="bp">...</span>
  <span class="o">}</span>
</code></pre></div>
<p>since the last 2 (<code>hf_re</code> and <code>hf_im</code>) are rather general I think I'll move them to their own lemmas and maybe the other cases would stay in the proof. I don't know how conventional it is to split a proof up this way in terms of the <code>have</code>s but it felt easier to follow for me when I did the original write up.</p>



<a name="232534305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232534305">(Mar 31 2021 at 04:21)</a>:</h4>
<p>To tweak the statement a little further, how about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="n">linear_isometry.id</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">conj_li</span>
</code></pre></div>
<p>You don't need <code>h₀</code>, it's true automatically.</p>



<a name="232534490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232534490">(Mar 31 2021 at 04:24)</a>:</h4>
<p>ok sure! it looks more concise!</p>



<a name="232534975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232534975">(Mar 31 2021 at 04:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532479">said</a>:</p>
<blockquote>
<p>The proof for the aux lemma, in my mind, is something like</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">show</span> <span class="n">that</span> <span class="n">the</span> <span class="n">real</span> <span class="n">parts</span> <span class="n">must</span> <span class="k">match</span> <span class="n">up</span> <span class="o">(</span><span class="n">you've</span> <span class="n">done</span> <span class="n">this</span><span class="o">,</span> <span class="mi">2</span> <span class="n">lines</span><span class="o">)</span>
<span class="k">show</span> <span class="n">that</span> <span class="n">I</span> <span class="n">maps</span> <span class="n">to</span> <span class="n">either</span> <span class="n">I</span> <span class="n">or</span> <span class="bp">-</span><span class="n">I</span>
<span class="n">every</span> <span class="n">z</span> <span class="n">is</span> <span class="n">a</span> <span class="n">linear</span> <span class="n">combination</span> <span class="n">of</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">I</span><span class="o">,</span> <span class="n">so</span>  <span class="n">the</span> <span class="n">properties</span> <span class="n">you've</span> <span class="n">proved</span> <span class="n">so</span> <span class="n">far</span> <span class="n">transfer</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I noticed a lemma that might help carrying out Yakov's idea: <a href="https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext">docs#is_basis.ext</a></p>



<a name="232535020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232535020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232535020">(Mar 31 2021 at 04:31)</a>:</h4>
<p>applied to <a href="https://leanprover-community.github.io/mathlib_docs/find/complex.is_basis_one_I">docs#complex.is_basis_one_I</a></p>



<a name="232535107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232535107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232535107">(Mar 31 2021 at 04:32)</a>:</h4>
<p>With a <code>fin_cases</code> somewhere in there</p>



<a name="232541502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232541502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#232541502">(Mar 31 2021 at 06:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232530760">said</a>:</p>
<blockquote>
<p>And I might guess (not sure, though) that it's less sensitive to ordering of hypotheses in things like <code>library_search</code>.</p>
</blockquote>
<p>library_search (and indeed many tactics) can't tell the difference between arguments before vs after the colon.</p>



<a name="233009630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233009630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233009630">(Apr 03 2021 at 14:21)</a>:</h4>
<p>Hi, I'm continuing on the following lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">data.real.sqrt</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">hf_im</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">conv</span> <span class="n">at</span> <span class="n">h₁</span> <span class="o">{</span>
    <span class="n">find</span> <span class="o">(</span><span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">complex.abs</span><span class="o">],</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">real.sqrt_inj</span><span class="o">,</span> <span class="n">norm_sq_apply</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">),</span> <span class="n">norm_sq_apply</span> <span class="n">z</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">add_left_cancel_iff</span><span class="o">,</span>
        <span class="n">mul_self_eq_mul_self_iff</span><span class="o">],</span>
      <span class="c1">-- exact norm_sq_nonneg (f z),</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="o">}</span>
</code></pre></div>
<p>When I apply <code>rw real.sqrt_inj</code>, 2 more subgoals appear and I'm not sure within a <code>conv</code> how I can do a <code>swap</code>.<br>
Is it doable? or do I need to go at this a different way?<br>
Thanks!<br>
(I'm using <code>conv at h₁</code> because of the  <code> ∀ z</code>)</p>



<a name="233011565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233011565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233011565">(Apr 03 2021 at 14:58)</a>:</h4>
<p>Maybe this is easier?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hf_im</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h₁</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">complex.abs</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">real.sqrt_inj</span><span class="o">,</span> <span class="n">norm_sq_apply</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">),</span> <span class="n">norm_sq_apply</span> <span class="n">z</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">add_left_cancel_iff</span><span class="o">,</span>
        <span class="n">mul_self_eq_mul_self_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>



<a name="233012099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233012099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233012099">(Apr 03 2021 at 15:07)</a>:</h4>
<p>I hadn't used <code>specialize</code> yet. Thanks! it's much easier this way :)</p>



<a name="233050806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233050806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233050806">(Apr 04 2021 at 02:54)</a>:</h4>
<p>Hi, I managed to write up the proofs for all the <code>have</code>s here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="k">have</span> <span class="n">hf0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="n">f</span> <span class="mi">1</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">conj</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf_re</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf_im</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="gr">sorry</span>
 <span class="o">}</span>
</code></pre></div>
<p>what is left is the last <code>sorry</code>.</p>
<p>I'm trying to get <code>(∀ z, f z = z) ∨ (∀ z, f z = conj z)</code> from <code>hf_re</code> and <code>hf_im</code>.</p>
<p>After doing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">have</span> <span class="n">hf0'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hf1'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₃'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hf_re'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hf_im'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">conv</span> <span class="o">{</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">find</span> <span class="o">(</span><span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">rw</span> <span class="n">ext_iff</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="n">conv</span> <span class="o">{</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">skip</span><span class="o">,</span>
    <span class="n">find</span> <span class="o">(</span><span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">rw</span> <span class="n">ext_iff</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">conj_re</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">conj_im</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
</code></pre></div>
<p>I end up with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span>
</code></pre></div>
<p>I tried a few things but wasn't able to get to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span><span class="o">)</span>
</code></pre></div>
<p>the closest I got was </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">x.re</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">x.im</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">x.im</span>
</code></pre></div>
<p>but I still have a <code>∀ (x : ℂ)</code> too many (it's redundant but I don't know how to get rid of it).. Is there a way to simplify this expression to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span><span class="o">)</span>
</code></pre></div>
<p>or am I taking a difficult path?<br>
Thanks!</p>



<a name="233057767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233057767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233057767">(Apr 04 2021 at 05:25)</a>:</h4>
<p>It is worthwhile to try to carry through your own method, and probably someone will be able to help you with the details ... but I wanted to check that you also saw the advice from me and Yakov Pechersky above,<br>
<a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534975">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534975</a><br>
about a different method using <a href="https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext">docs#is_basis.ext</a>.</p>



<a name="233058082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233058082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233058082">(Apr 04 2021 at 05:32)</a>:</h4>
<p>I am on mobile, so I may be misunderstanding the issue, but you could try <code>and_distrib</code> (or something similar) to split/unsplit and-or statements.</p>



<a name="233058609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233058609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233058609">(Apr 04 2021 at 05:44)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span>  thanks, yes I had seen your and Yakov Pechersky's advice but I wasn't sure yet how to approach it that way so I wanted to try a first go at it with the tools that I already know and then on a second pass maybe try that advice. But maybe if it turns out that the path I'm taking is giving me too much trouble I might jump directly to trying <a href="https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext">docs#is_basis.ext</a>.</p>



<a name="233061165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233061165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233061165">(Apr 04 2021 at 06:39)</a>:</h4>
<p>Ok, this allows you to use some of your assumptions, but leaves still a tangled mess of foralls/ors!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rw</span> <span class="o">[</span><span class="n">forall_and_distrib</span><span class="o">,</span> <span class="n">forall_and_distrib</span><span class="o">,</span> <span class="bp">←</span> <span class="n">and_or_distrib_left</span><span class="o">,</span> <span class="bp">←</span> <span class="n">forall_or_distrib_left</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">hf_re'</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
</code></pre></div>



<a name="233061170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233061170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233061170">(Apr 04 2021 at 06:39)</a>:</h4>
<p>I am actually not even sure if what you want to prove is true...</p>



<a name="233066058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233066058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233066058">(Apr 04 2021 at 08:25)</a>:</h4>
<p>I think this might take you in a helpful direction:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">have</span> <span class="n">hf_im</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hf_im</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hf_im</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="c1">-- f: ℂ →ₗᵢ[ℝ] ℂ</span>
    <span class="c1">-- h: ⇑f 1 = 1</span>
    <span class="c1">-- hf_I : (⇑f I).im = I.im</span>
    <span class="c1">-- ⊢ ∀ (z : ℂ), ⇑f z = z</span>
    <span class="gr">sorry</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="c1">-- ...</span>
    <span class="c1">-- hf_I : (⇑f I).im = -I.im</span>
    <span class="c1">-- ⊢ ∀ (z : ℂ), ⇑f z = ⇑conj z</span>
    <span class="gr">sorry</span>
  <span class="o">},</span>
<span class="o">}</span>
</code></pre></div>



<a name="233093958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233093958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233093958">(Apr 04 2021 at 15:56)</a>:</h4>
<p><span class="user-mention" data-user-id="397997">@Greg Price</span>  the problem I get with using <code>specialize hf_im I</code> is that I still need to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">conj</span> <span class="n">z</span>
</code></pre></div>
<p>but now the hypothesis I would like to use (<code>∀ z, (f z).im = z.im ∨ (f z).im</code>) is specialized at <code>I</code>.</p>



<a name="233094467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233094467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233094467">(Apr 04 2021 at 16:04)</a>:</h4>
<p>then you can do <code>have hf_im_I := hf_im I,</code> or just <code>cases hf_im I</code></p>



<a name="233591848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233591848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233591848">(Apr 08 2021 at 02:14)</a>:</h4>
<p>My proof was getting more and more complicated to follow, so I'm starting to look into the <a href="https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext">docs#is_basis.ext</a> direction.<br>
I'm not sure how to start though... </p>
<p>I'm guessing that</p>
<ul>
<li>I'll want to use <code>is_basis.ext</code> with <code>is_basis_one_I</code> as one of its arguments.</li>
<li>I need to supply 2 linear maps in order to show  with <code>is_basis.ext</code> that they correspond everywhere, so I would use <code>f</code> as one of the linear maps and the other would be the identity map in once case and the conj map in the other?</li>
</ul>
<p>or will I be using one of these as the last argument to <code>is_basis.ext</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">hf_re'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="k">have</span> <span class="n">hf_im'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>?</p>
<p>Also I'm unsure how I'll be using <code>fin_cases</code>.. maybe the path will be clearer to me once I know how to call <code>is_basis.ext</code>..</p>
<p>Thanks again for all the help!</p>



<a name="233594476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233594476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233594476">(Apr 08 2021 at 02:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="375581">François Sunatori</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233591848">said</a>:</p>
<blockquote>
<p>I'm guessing that</p>
<ul>
<li>I'll want to use <code>is_basis.ext</code> with <code>is_basis_one_I</code> as one of its arguments.</li>
<li>I need to supply 2 linear maps in order to show  with <code>is_basis.ext</code> that they correspond everywhere, so I would use <code>f</code> as one of the linear maps and the other would be the identity map in once case and the conj map in the other?</li>
</ul>
</blockquote>
<p>This sounds good!</p>



<a name="233594509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233594509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233594509">(Apr 08 2021 at 02:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="375581">François Sunatori</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233591848">said</a>:</p>
<blockquote>
<p>or will I be using one of these as the last argument to <code>is_basis.ext</code></p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">hf_re'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="k">have</span> <span class="n">hf_im'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I don't think you should have to consider real and imaginary parts separately.  But feel free to show us the setup if this seems to be forced on you.</p>



<a name="233595334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233595334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#233595334">(Apr 08 2021 at 03:10)</a>:</h4>
<p>ok thanks for helping point the way..<br>
so I'll try using <code>is_basis.ext is_basis_one_I &lt;a proposition involving f and id&gt;</code></p>
<p><code>&lt;a proposition involving f and id&gt;</code> needs to be of type <code>(h : ∀i, f (v i) = g (v i))</code> where <code>i : ι</code> and <code>ι : Type*</code><br>
is the <code>i</code> used to parametrize the dimension of the vector space having <code>v</code> as an element?</p>



<a name="234953558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234953558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234953558">(Apr 17 2021 at 02:52)</a>:</h4>
<p>I'm still unsure how to move forward at this point... </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="k">have</span> <span class="n">hf0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="n">f</span> <span class="mi">1</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">conj</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf_re</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hf_im</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="gr">sorry</span>
 <span class="o">}</span>
</code></pre></div>
<p>(all but the last <code>sorry</code> have been proven)</p>
<p>I haven't found how to apply <code>is_basis.ext</code> and <code>is_basis_one_I</code> here.<br>
it looks like Lean expects the next argument to be of type <code>∀ (i : fin 1.succ), ⇑?m_4 (![1, I] i) = ⇑?m_5 (![1, I] i)</code></p>
<p>I have a few questions here:</p>
<ul>
<li>what does <code>!</code> mean?</li>
<li>what is the <code>i</code> of type <code>fin 1.succ</code>?<ul>
<li><code>def fin (n : ℕ) := {i : ℕ // i &lt; n}</code> so it's a natural number that is smaller than <code>1.succ</code>?<br>
    Where can I get this number from my current setup?</li>
</ul>
</li>
</ul>
<p>Thanks</p>



<a name="234953930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234953930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234953930">(Apr 17 2021 at 03:00)</a>:</h4>
<p>Ok actually for <code>!</code><br>
I found "The notation <code>![a, b, ...]</code> expands to <code>vec_cons a (vec_cons b ...)</code>"<br>
so I'm guessing <code>![1, I]</code> is just the way that Lean represents vectors.</p>



<a name="234956882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234956882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234956882">(Apr 17 2021 at 03:52)</a>:</h4>
<p>ok so my understanding is that <code>i</code> is the index of the length of the vector <code>![1, I]</code> which in this case is <code>1.succ</code></p>



<a name="234957903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234957903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234957903">(Apr 17 2021 at 04:12)</a>:</h4>
<p>I tried as a test to add hypothesis <code>h4</code>  (that would have the expected type for the 2nd argument of <code>is_basis.ext</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">have</span> <span class="n">hf0'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span> <span class="o">:=</span> <span class="n">hf0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hf1'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">|</span> <span class="o">:=</span> <span class="n">hf1</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₃'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">h₃</span> <span class="n">hf1'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hf_re'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="n">hf_re</span> <span class="n">h₃'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hf_im'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span> <span class="n">hf_im</span> <span class="n">hf0</span> <span class="n">hf_re'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="bp">.</span><span class="n">succ</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">I</span><span class="o">]</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">I</span><span class="o">]</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">is_basis.ext</span> <span class="n">is_basis_one_I</span> <span class="n">h4</span><span class="o">,</span>
</code></pre></div>
<p>However I get the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span> <span class="n">type</span> <span class="n">is</span> <span class="n">not</span> <span class="n">of</span> <span class="n">the</span> <span class="n">form</span> <span class="o">(</span><span class="n">C</span> <span class="bp">...</span><span class="o">)</span> <span class="n">where</span> <span class="n">C</span> <span class="n">is</span> <span class="n">a</span> <span class="kd">constant</span>
  <span class="mi">1</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span>
</code></pre></div>
<p>when mousing over <code>1.succ</code>.<br>
it seems to me that <code>fin n</code> is  a dependent type depending on a natural number.<br>
when I change it to <code>2</code> I don't get the error anymore, but I now get</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">is_basis_one_I.ext</span> <span class="n">h4</span>
<span class="n">term</span>
  <span class="n">h4</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">I</span><span class="o">]</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">I</span><span class="o">]</span> <span class="n">i</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="bp">.</span><span class="n">succ</span><span class="o">),</span> <span class="bp">⇑?</span><span class="n">m_4</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">I</span><span class="o">]</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⇑?</span><span class="n">m_5</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="n">I</span><span class="o">]</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>How can I get <code>∀ (i : fin 1.succ), ⇑f (![1, I] i) = id (![1, I] i)</code> to work here?</p>



<a name="234961612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234961612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234961612">(Apr 17 2021 at 05:26)</a>:</h4>
<p><span class="user-mention" data-user-id="375581">@François Sunatori</span> Right <code>![a,b,c,x,y,z]</code> is just notation for the vector <code>(a,b,c,x,y,z)</code> in 6-dim space.<br>
And <code>i : fin 1.succ</code> means some term of type <code>fin 1.succ</code> where <code>1.succ : nat</code> is just <code>2</code>. So <code>i = 0</code> or <code>i = 1</code>.<br>
In total <code>![1, I] i</code> means the <code>i</code>th component of the vector <code>(1,I)</code>. So this is <code>1</code> if <code>i = 0</code> and <code>I</code> if <code>i = 1</code>.</p>



<a name="234974756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234974756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234974756">(Apr 17 2021 at 09:20)</a>:</h4>
<p>Unpolished but sorry-free:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">data.real.sqrt</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">linear_isometry.id_apply</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">linear_isometry.id</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">linear_isometry.id_to_linear_map</span> <span class="o">:</span> <span class="o">(</span><span class="n">linear_isometry.id.to_linear_map</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">linear_map.id</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">hf_re</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">))</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">ext_iff</span><span class="o">,</span> <span class="n">add_re</span><span class="o">,</span> <span class="n">add_im</span><span class="o">,</span> <span class="n">conj_re</span><span class="o">,</span> <span class="n">conj_im</span><span class="o">,</span> <span class="bp">←</span><span class="n">two_mul</span><span class="o">,</span>
         <span class="o">(</span><span class="k">show</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">two_ne_zero'</span><span class="o">])]</span> <span class="n">using</span> <span class="o">(</span><span class="n">h₃</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">hf_im</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="bp">|</span><span class="n">f</span> <span class="n">z</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">z</span><span class="bp">|</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">z.im</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">z.im</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">specialize</span> <span class="n">h₁</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">complex.abs</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">real.sqrt_inj</span> <span class="o">(</span><span class="n">norm_sq_nonneg</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">norm_sq_nonneg</span> <span class="n">_</span><span class="o">),</span> <span class="n">norm_sq_apply</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">),</span> <span class="n">norm_sq_apply</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">h₂</span><span class="o">,</span> <span class="n">add_left_cancel_iff</span><span class="o">,</span> <span class="n">mul_self_eq_mul_self_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">linear_isometry.l0</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="bp">∥</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">linear_isometry.norm_map</span> <span class="n">f</span> <span class="o">(</span><span class="n">z</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">linear_isometry.map_sub</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">linear_isometry.l1</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">conj</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">linear_isometry.l0</span> <span class="n">h</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">apply_fun</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">norm_eq_abs</span><span class="o">,</span> <span class="bp">←</span><span class="n">norm_sq_eq_abs</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">of_real_inj</span><span class="o">,</span> <span class="bp">←</span><span class="n">mul_conj</span><span class="o">,</span> <span class="bp">←</span><span class="n">mul_conj</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">conj.map_sub</span><span class="o">,</span> <span class="n">conj.map_sub</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">sub_mul</span><span class="o">,</span> <span class="n">mul_sub</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_conj</span><span class="o">,</span> <span class="n">norm_sq_eq_abs</span><span class="o">,</span> <span class="bp">←</span><span class="n">norm_eq_abs</span><span class="o">,</span> <span class="n">linear_isometry.norm_map</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_conj</span><span class="o">,</span> <span class="n">norm_sq_eq_abs</span><span class="o">,</span> <span class="bp">←</span><span class="n">norm_eq_abs</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">sub_sub</span><span class="o">,</span> <span class="n">sub_right_inj</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">of_real_pow</span><span class="o">,</span> <span class="n">ring_hom.map_one</span><span class="o">,</span> <span class="n">norm_eq_abs</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_sub</span><span class="o">,</span> <span class="n">sub_left_inj</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">this</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span>
<span class="kd">end</span>
<span class="kd">lemma</span> <span class="n">linear_isometry.re</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">z.re</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">hf_re</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">linear_isometry.l1</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">linear_isometry_complex_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">have</span> <span class="n">h0</span> <span class="o">:</span> <span class="n">f</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">I</span> <span class="bp">∨</span> <span class="n">f</span> <span class="n">I</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">I</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="bp">|</span><span class="n">f</span> <span class="n">I</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">norm_eq_abs</span><span class="o">,</span> <span class="n">linear_isometry.norm_map</span><span class="o">,</span> <span class="n">norm_eq_abs</span><span class="o">,</span> <span class="n">abs_I</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ext_iff</span><span class="o">,</span> <span class="bp">←</span><span class="n">and_or_distrib_left</span><span class="o">,</span> <span class="n">neg_re</span><span class="o">,</span> <span class="n">I_re</span><span class="o">,</span> <span class="n">neg_im</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">I_re</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">linear_isometry.re</span> <span class="n">h</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">hf_im</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">intro</span> <span class="n">z</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">norm_eq_abs</span><span class="o">,</span> <span class="bp">←</span><span class="n">norm_eq_abs</span><span class="o">,</span> <span class="n">linear_isometry.norm_map</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intro</span> <span class="n">z</span><span class="o">,</span> <span class="n">rw</span> <span class="n">linear_isometry.re</span> <span class="n">h</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">or.imp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h1</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h1</span> <span class="n">z</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">h0</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="n">f.to_linear_map</span> <span class="bp">=</span> <span class="n">linear_isometry.id.to_linear_map</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="bp">←</span><span class="n">linear_isometry.coe_to_linear_map</span><span class="o">,</span> <span class="n">linear_map.id_apply</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">apply</span> <span class="n">is_basis.ext</span> <span class="n">is_basis_one_I</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">fin_cases</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- I expected `simp [h1]` to work. Not sure why it didn't.</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.head_cons</span><span class="o">,</span> <span class="n">linear_isometry.coe_to_linear_map</span><span class="o">,</span>
        <span class="n">linear_isometry.id_to_linear_map</span><span class="o">,</span> <span class="n">linear_map.id_coe</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">matrix.cons_val_one</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">h1</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">suffices</span> <span class="o">:</span> <span class="n">f.to_linear_map</span> <span class="bp">=</span> <span class="n">conj_li.to_linear_map</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">linear_isometry.coe_to_linear_map</span><span class="o">,</span> <span class="n">this</span><span class="o">],</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_isometry.coe_to_linear_map</span><span class="o">],</span>
      <span class="c1">-- should have a simp lemma that does this</span>
      <span class="n">refl</span> <span class="o">},</span>
    <span class="n">apply</span> <span class="n">is_basis.ext</span> <span class="n">is_basis_one_I</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">fin_cases</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">linear_isometry.coe_to_linear_map</span><span class="o">,</span> <span class="n">matrix.cons_val_zero</span><span class="o">],</span>
      <span class="n">change</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">conj</span> <span class="mi">1</span><span class="o">,</span> <span class="c1">-- simp lemma</span>
      <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- I expected `simp [h1]` to work. Not sure why it didn't.</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">matrix.head_cons</span><span class="o">,</span> <span class="n">linear_isometry.coe_to_linear_map</span><span class="o">,</span>
        <span class="n">linear_isometry.id_to_linear_map</span><span class="o">,</span> <span class="n">linear_map.id_coe</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">matrix.cons_val_one</span><span class="o">],</span>
      <span class="n">change</span> <span class="n">f</span> <span class="n">I</span> <span class="bp">=</span> <span class="n">conj</span> <span class="n">I</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">conj_I</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h1</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
<span class="o">}</span>
</code></pre></div>
</div></div>



<a name="234977861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/234977861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#234977861">(Apr 17 2021 at 10:17)</a>:</h4>
<p><span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span> oh that's quite a bit more than what I was asking for, but maybe I can go over it and try to learn from it and I may ask a few questions about some sections just so that I can learn and compare with what I had. Thanks</p>



<a name="235088114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235088114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235088114">(Apr 18 2021 at 17:46)</a>:</h4>
<p>I'm now working on changing the initial statement to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rotation</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">conj_li</span>
</code></pre></div>
<p>I defined <code>rotation</code> like so</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">rotation</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">mul_add</span> <span class="n">a</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
      <span class="n">intros</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">a</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">mul_assoc</span> <span class="bp">↑</span><span class="n">m</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">norm_map'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
      <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">one_mul</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">}</span>
</code></pre></div>
<p>but am getting the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">definition</span> <span class="bp">'</span><span class="n">rotation'</span> <span class="n">is</span> <span class="kd">noncomputable</span><span class="o">,</span> <span class="n">it</span> <span class="n">depends</span> <span class="n">on</span> <span class="bp">'</span><span class="n">complex.normed_field'</span>
</code></pre></div>
<p>I'm not sure what this error means.<br>
I thought I was not exposing <code>normed_field</code> and tried using <code>open complex.normed_field</code> but that gives the error <code>invalid namespace name 'complex.normed_field'</code>.<br>
Am I missing something here?</p>
<p>Thanks :)</p>



<a name="235088329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235088329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235088329">(Apr 18 2021 at 17:50)</a>:</h4>
<p>Add <code>noncomputable def ...</code> to the beginning</p>



<a name="235088446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235088446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235088446">(Apr 18 2021 at 17:53)</a>:</h4>
<p><span class="user-mention" data-user-id="355764">@Hanting Zhang</span> thanks! <br>
I just saw in <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html</a></p>
<blockquote>
<p>The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces “data” from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions as noncomputable to flag that fact.</p>
</blockquote>



<a name="235088540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235088540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235088540">(Apr 18 2021 at 17:54)</a>:</h4>
<p>If I understand well, I need to use <code>noncomputable def</code> when I use a record type to use it as data?</p>



<a name="235088699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235088699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235088699">(Apr 18 2021 at 17:57)</a>:</h4>
<p>I'm not sure what you mean by record type, but my understanding is that <code>noncomputable</code> means Lean can't produce bytecode for the data your working with. So you can't do <code>#print ...</code>, but otherwise everything else works as normal</p>



<a name="235088821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235088821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235088821">(Apr 18 2021 at 17:59)</a>:</h4>
<p>It's only some types that are <code>noncomputable</code>, things like <code>complex</code> and <code>real</code> are some of them. If you just want to prove theorems the standard advice is to put the line <code>noncomputable theory</code> at the top of your file (below the imports), and lean will stop bothering you about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">definition</span> <span class="bp">'</span><span class="n">rotation'</span> <span class="n">is</span> <span class="kd">noncomputable</span><span class="o">,</span> <span class="n">it</span> <span class="n">depends</span> <span class="n">on</span> <span class="bp">'</span><span class="n">complex.normed_field'</span>
</code></pre></div>
<p>you don't really lose anything by doing this.</p>



<a name="235091713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235091713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235091713">(Apr 18 2021 at 18:46)</a>:</h4>
<p>I remember as a beginner being really concerned/confused about what the ramifications of all this noncomputable stuff was, as I was trying to formalise random undergraduate maths from my intro to proof course, and it turned out some was computable and some was not. The thing which took a while to dawn on me was this: if you make noncomputable stuff, then <code>#eval</code> and <code>#reduce</code> might not work -- but if you just want to prove theorems you never use these things anyway, you just use <code>theorem</code>. So <code>noncomputable</code> doesn't matter at all. The majority of the perfectoid space repo was noncomputable, for example.</p>



<a name="235105073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235105073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235105073">(Apr 18 2021 at 21:56)</a>:</h4>
<p>I'm trying to get from</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rotation</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">conj_li</span>
</code></pre></div>
<p>to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">((</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>
<p>so that I can reuse the proof I have for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">conj</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>
<p>This is what I have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">rotation</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">mul_add</span> <span class="n">a</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
      <span class="n">intros</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">a</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">a</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">mul_assoc</span> <span class="bp">↑</span><span class="n">m</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">norm_map'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
      <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">one_mul</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rotation</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">conj_li</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="n">rotation</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span><span class="o">,</span>
      <span class="gr">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="gr">sorry</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>
<p>Specifically for now, I'm trying to get from</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span>
</code></pre></div>
<p>to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span>
</code></pre></div>
<p>I tried to use the <code>come_on_lean</code> tactic (<code>to_fun := λ (z : ℂ), a * z</code> because I want to get <code>λ (z : ℂ), a * z</code> "out" of <code>rotation</code>) to go from</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span>
</code></pre></div>
<p>to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span>
</code></pre></div>
<p>but I get this error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span>
<span class="n">term</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">ℂ</span> <span class="bp">→</span> <span class="n">ℂ</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span>
</code></pre></div>
<p>Is there a way for me to isolate the <code>to_fun</code> from the <code>rotation</code> linear isometry in this case?</p>
<p>Thanks!</p>



<a name="235105928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235105928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235105928">(Apr 18 2021 at 22:12)</a>:</h4>
<p>Is this true or am I missing something? <code>f</code> doesn't need to be a rotation, but you are asserting that it is?</p>



<a name="235106236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106236">(Apr 18 2021 at 22:16)</a>:</h4>
<p>You want the proof that <code>coe_fn</code> is injective</p>



<a name="235106254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106254">(Apr 18 2021 at 22:17)</a>:</h4>
<p>Something like <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.coe_injective">docs#linear_map.coe_injective</a>, but for <code> →ₗᵢ[ℝ]</code>. Edit: ah, <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_isometry.coe_fn_injective">docs#linear_isometry.coe_fn_injective</a></p>



<a name="235106336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106336">(Apr 18 2021 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="355764">@Hanting Zhang</span>   sorry, here I'm assuming <code>|a| = 1</code> so it <code>a = e^iθ</code> and I'm not considering translations</p>



<a name="235106426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106426">(Apr 18 2021 at 22:20)</a>:</h4>
<p>Oh, actually just <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#ext">tactic#ext</a> should do the trick</p>



<a name="235106471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106471">(Apr 18 2021 at 22:21)</a>:</h4>
<p>Oh nevermind, I missed the little <code>ₗᵢ</code> subscript, sorry!</p>



<a name="235106474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106474">(Apr 18 2021 at 22:21)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Thanks! I'll look into <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_isometry.coe_fn_injective">docs#linear_isometry.coe_fn_injective</a>. By the way, I've been seeing <code>coe</code> a lot and I think it has to do with <code>⇑</code> but I still don't really understand what it means... Could you enlighten me or point me to a doc about it? Thank you!</p>



<a name="235106738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106738">(Apr 18 2021 at 22:27)</a>:</h4>
<p>I don't know what <code>come_on_lean</code> refers to, but the trick is to add a helper lemma as soon as you've made the definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">rotation</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">norm_map'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">],</span>
  <span class="n">to_linear_map</span> <span class="o">:=</span> <span class="n">algebra.lmul</span> <span class="n">ℝ</span> <span class="n">ℂ</span> <span class="n">a</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">rotation_apply</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="235106827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106827">(Apr 18 2021 at 22:29)</a>:</h4>
<p><code>come_on_lean</code> refers to the comment <br>
<a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253906">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253906</a></p>



<a name="235106833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106833">(Apr 18 2021 at 22:29)</a>:</h4>
<p>Then you can get back to doing maths rather than fighting lean with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rotation</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">conj_li</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">f</span> <span class="mi">1</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span>
    <span class="n">ext1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">rotation_apply</span><span class="o">,</span>
    <span class="gr">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="235106936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106936">(Apr 18 2021 at 22:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106738">said</a>:</p>
<blockquote>
<p>I don't know what <code>come_on_lean</code> refers to, but the trick is to add a helper lemma as soon as you've made the definition:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">rotation</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">norm_map'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">],</span>
  <span class="n">to_linear_map</span> <span class="o">:=</span> <span class="n">algebra.lmul</span> <span class="n">ℝ</span> <span class="n">ℂ</span> <span class="n">a</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">rotation_apply</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div><br>
</p>
</blockquote>
<p>wow that's much simpler than what I had written.. I hope I can write concisely like that at some point</p>



<a name="235106990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235106990">(Apr 18 2021 at 22:32)</a>:</h4>
<p>The trick there was knowing that <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.lmul">docs#algebra.lmul</a> already existed</p>



<a name="235107005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107005">(Apr 18 2021 at 22:32)</a>:</h4>
<p>But all you actually needed to get out of your struggle is that <code>rotation_apply</code> lemma</p>



<a name="235107051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107051">(Apr 18 2021 at 22:33)</a>:</h4>
<p>When you define a bundled map <code>some_func</code>, you almost never want to <code>rw some_func</code>; you usually want to define an <code>_apply</code> lemma like I do there</p>



<a name="235107140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107140">(Apr 18 2021 at 22:34)</a>:</h4>
<p>ok yes, I recall seeing some <code>_apply</code> lemmas where there was just a <code>rfl</code> as proof.<br>
I'll keep in mind that I better add those when I have a <code>def</code> for a function inside a record</p>



<a name="235107184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107184">(Apr 18 2021 at 22:35)</a>:</h4>
<p>Sometimes its more useful to define <code>coe_some_func</code> instead of <code>some_func_apply</code>, especially if you didn't actually end up using a <code>λ</code> to define the function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_rotation</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="n">rotation</span> <span class="n">ha</span><span class="o">)</span> <span class="bp">=</span> <span class="n">algebra.lmul</span> <span class="n">ℝ</span> <span class="n">ℂ</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="235107252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107252">(Apr 18 2021 at 22:36)</a>:</h4>
<p>But that can often lead simp in a direction that's unhelpful</p>



<a name="235107673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107673">(Apr 18 2021 at 22:45)</a>:</h4>
<p>ok so, when I see <code>coe_</code> and <code>_apply</code> I can assume they are used for a similar purpose? The one of getting a "field" out of a record.</p>



<a name="235107739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107739">(Apr 18 2021 at 22:46)</a>:</h4>
<p>and is the <code>⇑</code> linked to <code>coe</code> (coercion)?</p>



<a name="235107745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107745">(Apr 18 2021 at 22:47)</a>:</h4>
<p>Strictly <code>⇑</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/coe_fn">docs#coe_fn</a></p>



<a name="235107852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107852">(Apr 18 2021 at 22:48)</a>:</h4>
<p><code>↑</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/coe">docs#coe</a>,  <code>↥</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/coe_sort">docs#coe_sort</a>. Lots of lemma names are pretty lax about the difference, especially since sometimes <code>↑</code> ends up meaning one of the other arrows</p>



<a name="235107892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235107892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235107892">(Apr 18 2021 at 22:49)</a>:</h4>
<p>ah ok, great! thanks.. it's getting clearer to me :)</p>



<a name="235115376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235115376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235115376">(Apr 19 2021 at 01:05)</a>:</h4>
<p>I managed to get a little further by adding <code>conj_li_apply</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.complex.basic</span>
<span class="kn">import</span> <span class="n">data.complex.exponential</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.linear_isometry</span>

<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span> <span class="n">x</span> <span class="bp">`|`</span> <span class="o">:=</span> <span class="n">complex.abs</span> <span class="n">x</span>


<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">rotation</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">norm_map'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">],</span>
  <span class="n">to_linear_map</span> <span class="o">:=</span> <span class="n">algebra.lmul</span> <span class="n">ℝ</span> <span class="n">ℂ</span> <span class="n">a</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">rotation_apply</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">rfl</span>


<span class="kd">lemma</span> <span class="n">linear_isometry_complex</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℂ</span> <span class="bp">→ₗᵢ</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">rotation</span> <span class="n">ha</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rotation</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">conj_li</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span>
    <span class="n">change</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">a</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">linear_isometry.norm_map</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">conv</span> <span class="o">{</span>
      <span class="n">congr</span><span class="o">,</span>
    <span class="o">},</span>

    <span class="c1">-- left,</span>
    <span class="c1">-- ext1 z,</span>
    <span class="c1">-- rw rotation_apply,</span>

    <span class="c1">-- right,</span>
    <span class="c1">-- ext1 z,</span>
    <span class="c1">-- norm_num,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Now I need to use <code>conv</code> followed by <code>congr</code> to change the 2 sides of the <code>∨</code> in <code>f = rotation _ ∨ f = (rotation _).comp conj_li</code>.<br>
I would like to apply the commented out sections to the 2 sides of the <code>∨</code>, but I don't know how to use <code>ext1</code> in conversion tactic mode. What should I be using once in <code>conv</code>?</p>
<p>Thanks!</p>



<a name="235116821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235116821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235116821">(Apr 19 2021 at 01:33)</a>:</h4>
<p>I looked for all instances of <code>conv</code> in mathlib but haven't seen an example of an <code>ext</code> being used in a <code>conv</code> block.. and I couldn't find something doing the equivalent of an <code>ext</code> either..<br>
Is it possible that it can't be used in a <code>conv</code> block and that I should approach this from a different direction?</p>



<a name="235117647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235117647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235117647">(Apr 19 2021 at 01:49)</a>:</h4>
<p>Does funext work in this context?</p>



<a name="235117696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235117696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235117696">(Apr 19 2021 at 01:50)</a>:</h4>
<p><code>ext</code> wouldn't work in <code>conv</code> i don't think, as presumably it'd have to write it as (<code>∀ z, &lt;stuff&gt; ∨ ∀ z, &lt;stuff&gt;</code> whilst <code>ext</code> immediately <code>intros</code>. not sure how feasible it is but maybe just do the work in some <code>have</code>s and then <code>rw</code></p>



<a name="235117728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235117728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235117728">(Apr 19 2021 at 01:50)</a>:</h4>
<p>just tried it alex, it basically seems to be a noop</p>



<a name="235118100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235118100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235118100">(Apr 19 2021 at 01:58)</a>:</h4>
<p>right, no <code>funext</code> didn't work.. I'll try with some <code>have</code>s then. Thanks!</p>



<a name="235139680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235139680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear_isometry_complex.html#235139680">(Apr 19 2021 at 07:36)</a>:</h4>
<p>Ideally at this point you'd use the maths proof to decide whether the left or right of the or is true</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
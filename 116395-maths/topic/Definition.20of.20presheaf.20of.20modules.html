---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html">Definition of presheaf of modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272790956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272790956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272790956">(Feb 22 2022 at 11:38)</a>:</h4>
<p>I was experimenting with definition of presheaves of modules following stack project 6.6. I came up with two formalizations</p>
<ol>
<li>
<p>presheaves of modules are a functor with values in <code>BundledModule</code>, see <a href="https://github.com/leanprover-community/mathlib/pull/10724">#10724</a>, i.e. then if <code>𝓕</code> is a presheaf of modules, aka, <code>(opens X)ᵒᵖ ⥤ BunledModule</code>, then <code>𝓕 ⋙ BundledModule.forget_to_Ring</code> is a presheaf of ring and <code>𝓕 ⋙ BundledModule.forget_to_Ab</code> is a presheaf of abelian groups. The nice thing about this approach is that, for any opens <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex"> U </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal F(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> is automatically <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>-module and restriction map is automatically compatible with scalar multiplication. But this definition will make category of presheaves of module over a presheaf of ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi></mrow><annotation encoding="application/x-tex">\mathcal O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span></span></span> difficult, because then the category needs to be defined as<br>
<code>{𝓕 | 𝓕 ⋙ BundledModule.forget_to_Ring = 𝓞}</code> with equalities of functor flowing around. And I think the sheaf condition would be presumably "wrong", because that would actually imply <code>𝓕 ⋙ BundledModule.forget_to_Ring</code> is a sheaf as well.</p>
</li>
<li>
<p>given a presheaf of rings <code>𝓞</code>,  define presheaf of modules over <code>𝓞</code> as</p>
</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">presheaf_of_module</span>
<span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">Ab</span> <span class="n">X</span><span class="o">)</span>
<span class="o">[</span><span class="n">module</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">),</span> <span class="n">module</span> <span class="o">(</span><span class="bp">𝓞.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">))</span> <span class="o">(</span><span class="n">self.obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">))]</span>
<span class="o">(</span><span class="n">compatible</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">inc</span> <span class="o">:</span> <span class="n">op</span> <span class="n">U</span> <span class="bp">⟶</span> <span class="n">op</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">𝓞.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">))</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">self.obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">)),</span>
   <span class="n">self.map</span> <span class="n">inc</span> <span class="o">(</span><span class="n">r</span> <span class="bp">•</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">𝓞.</span><span class="n">map</span> <span class="n">inc</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">self.map</span> <span class="n">inc</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">sheaf_of_module</span> <span class="kd">extends</span> <span class="n">presheaf_of_module</span> <span class="bp">𝓞</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_sheaf</span> <span class="o">:</span> <span class="n">presheaf.is_sheaf</span> <span class="n">self</span><span class="o">)</span>
</code></pre></div>
<p>see <a href="https://github.com/leanprover-community/mathlib/pull/12186">#12186</a> <a href="https://github.com/leanprover-community/mathlib/blob/6e7aa6302bf658bb037513ad65be80366befc4e1/src/scratch.lean#L61">this link</a>.</p>
<p>Now the problem with this approach is that</p>
<ul>
<li>then presheaf of module is not literally a presheaf in mathlib's sense</li>
<li>(common to both approaches, I think) given a morphism <code>f : 𝓞1 ⟶ 𝓞2</code> between presheaves of ring, defining restriction and extension of presheaf of modules by <code>f</code> is cumbersome, because lean's class inference cannot "see through <code>f</code>".</li>
</ul>



<a name="272791240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272791240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272791240">(Feb 22 2022 at 11:42)</a>:</h4>
<p>I think Adam was a big fan of (1).</p>



<a name="272792993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272792993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272792993">(Feb 22 2022 at 12:00)</a>:</h4>
<p>The equality in (1) seems quite awkward. I think in order to work with it directly, you would basically need to create an API for it that looked like (2) anyways.</p>



<a name="272793186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272793186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272793186">(Feb 22 2022 at 12:02)</a>:</h4>
<p>The DTT-natural way to say this would probably be using <a href="https://ncatlab.org/nlab/show/displayed+category">https://ncatlab.org/nlab/show/displayed+category</a>, which is basically an abstraction of (2), I think</p>



<a name="272794341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272794341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272794341">(Feb 22 2022 at 12:15)</a>:</h4>
<p>I would suggest first thinking about all the operations you will want to support--I guess there are a lot: sheafification of presheaves of O-modules, (co)limits, restriction and extension of scalars, closed monoidal structure, pullback/pushforward between ringed sites</p>



<a name="272798135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272798135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272798135">(Feb 22 2022 at 12:54)</a>:</h4>
<p>I was thinking of this <a href="#narrow/stream/267928-condensed-mathematics/topic/tensor.20product.20of.20sheaves/near/263012430">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/tensor.20product.20of.20sheaves/near/263012430</a> and the discussion following it</p>



<a name="272798644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272798644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272798644">(Feb 22 2022 at 12:59)</a>:</h4>
<p>OK so "essential fiber" means we have a ring+module and an isomorphism of its ring to <code>O</code>. That's better in some respects (and maybe not worse in any respects since <code>=</code> is so awkward anyways). But it still leaves a lot to be desired, for example, even to define the direct sum of two objects of this category you will need to make use of those isomorphisms already to define <code>+</code></p>



<a name="272798766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272798766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272798766">(Feb 22 2022 at 13:00)</a>:</h4>
<p>Ah not to define <code>+</code>, but to define the action of the "wrong" copy of <code>O</code> on one (or both) of the summands</p>



<a name="272799114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272799114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272799114">(Feb 22 2022 at 13:03)</a>:</h4>
<p>Johan you asked me once why HoTT people think definitional equality is so important--here is an example. I don't think it will be pleasant to work in the category of "modules over a ring equipped with an isomorphism to <code>R</code>".</p>



<a name="272800366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272800366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272800366">(Feb 22 2022 at 13:15)</a>:</h4>
<p>Using the second approach, I have defined the restriction and extension functor and close of finishing their adjunction.</p>



<a name="272813781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272813781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272813781">(Feb 22 2022 at 14:56)</a>:</h4>
<p>With approach 2, you would have to replicate literally everything we have  about sheafification.</p>



<a name="272815916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272815916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272815916">(Feb 22 2022 at 15:11)</a>:</h4>
<p>Here is a non-(pre)sheafy way I see to make approach 1 work in practice:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.category.Module.basic</span>
<span class="kn">import</span> <span class="n">algebra.category.CommRing</span>
<span class="kn">import</span> <span class="n">algebra.algebra.restrict_scalars</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">BundledModule</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Module.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">Module'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">BundledModule.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">M.R</span> <span class="bp">≅</span> <span class="n">A</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">Module'</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">Module'.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M.M.M</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Module'</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">A</span> <span class="n">M.M.R</span> <span class="o">:=</span> <span class="n">M.e.inv.to_algebra</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="n">restrict_scalars</span> <span class="n">A</span> <span class="n">M.M.R</span> <span class="n">M</span><span class="o">),</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">Module'</span>
</code></pre></div>



<a name="272816117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272816117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272816117">(Feb 22 2022 at 15:13)</a>:</h4>
<p>Essentially, set up the correct instances for your object so you can work with them as we usually work with modules from mathlib.</p>



<a name="272816529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272816529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272816529">(Feb 22 2022 at 15:16)</a>:</h4>
<p>Now you can't use the original restriction maps of the presheaf directly so you also need an API for those... and you end up at (2)</p>



<a name="272816571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272816571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272816571">(Feb 22 2022 at 15:16)</a>:</h4>
<p>So maybe the answer is "both", and you use (1) abstractly to prove that existence of sheafififcation</p>



<a name="272816673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272816673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272816673">(Feb 22 2022 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272816529">said</a>:</p>
<blockquote>
<p>Now you can't use the original restriction maps of the presheaf directly so you also need an API for those... and you end up at (2)</p>
</blockquote>
<p>There may be a way to convince the <code>scalar_tower</code> stuff to make this fairly quick?"</p>



<a name="272818229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272818229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272818229">(Feb 22 2022 at 15:27)</a>:</h4>
<p>Just to be clear -- Jujian has made extensive experiments with both approaches in the links he posts above.</p>



<a name="272818678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272818678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272818678">(Feb 22 2022 at 15:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272815916">said</a>:</p>
<blockquote>
<p>Here is a non-(pre)sheafy way I see to make approach 1 work in practice:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.category.Module.basic</span>
<span class="kn">import</span> <span class="n">algebra.category.CommRing</span>
<span class="kn">import</span> <span class="n">algebra.algebra.restrict_scalars</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">BundledModule</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Module.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">Module'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">BundledModule.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">M.R</span> <span class="bp">≅</span> <span class="n">A</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">Module'</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">Module'.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M.M.M</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Module'</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">A</span> <span class="n">M.M.R</span> <span class="o">:=</span> <span class="n">M.e.inv.to_algebra</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="n">restrict_scalars</span> <span class="n">A</span> <span class="n">M.M.R</span> <span class="n">M</span><span class="o">),</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">Module'</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I haven't thought about this <code>Module'</code> approach.</p>
<p>If to use this approach, do we see a possibility in which we use approach 1, but avoid equality of functor when defining sheaf of modules over some given sheaf of rings?</p>



<a name="272818764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272818764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272818764">(Feb 22 2022 at 15:30)</a>:</h4>
<p>Use isomorphism instead of equality.</p>



<a name="272818821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272818821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272818821">(Feb 22 2022 at 15:30)</a>:</h4>
<p>I.e. "sheafify" this definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Module'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">BundledModule.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">M.R</span> <span class="bp">≅</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div>



<a name="272819093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819093">(Feb 22 2022 at 15:32)</a>:</h4>
<p>My concern with approach (2) is that whenever there is some categorical thing you want to do, you would have to make some bespoke construction that only really applies to your structure, and doesn't really fit in with the rest of the <code>Sheaf</code>/<code>functor</code> library. I think that would get old REALLY fast.</p>



<a name="272819225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819225">(Feb 22 2022 at 15:33)</a>:</h4>
<p>I don't really understand how that doesn't also apply to (1), though</p>



<a name="272819242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819242">(Feb 22 2022 at 15:33)</a>:</h4>
<p>What constructions do you get on (1) for free?</p>



<a name="272819565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819565">(Feb 22 2022 at 15:35)</a>:</h4>
<p>For example, one obvious milestone would be to prove that the category of <code>O</code>-modules is abelian</p>



<a name="272819577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819577">(Feb 22 2022 at 15:35)</a>:</h4>
<p><code>BundledModule</code> is a sufficiently nice concrete category, so you get sheafification for free. <code>BundledModule</code> has (co)limits, so you get (co)limits of sheaves of <code>BundledModules</code> for free. The forgetful functors to <code>Ab</code> and <code>CommRing</code> preserve limits, so you get the forgetful functors from sheaves of <code>BundledModules</code> to Sheaves of <code>Ab</code> and/or <code>CommRing</code> for free (this allows you define (1) in the first place in the case of sheaves).</p>



<a name="272819896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819896">(Feb 22 2022 at 15:37)</a>:</h4>
<p>But the colimits of bundled modules aren't the colimits you want--they will have some kind of colimit in the ring part too.</p>



<a name="272819953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272819953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272819953">(Feb 22 2022 at 15:37)</a>:</h4>
<p>You need some kind of fiberwise colimit and now it is another custom construction</p>



<a name="272820879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272820879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272820879">(Feb 22 2022 at 15:43)</a>:</h4>
<p>Hmm... I thought there may be a way to use the isomorphism to make this work without a custom construction. Let me think.</p>



<a name="272821807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272821807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272821807">(Feb 22 2022 at 15:50)</a>:</h4>
<p>For sheafification specifically, I think it does work, but you need some argument to verify it (something like forgetting to rings preserves limits and colimits)</p>



<a name="272821939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272821939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272821939">(Feb 22 2022 at 15:50)</a>:</h4>
<p>I mean that tells you that sheafifying a presheaf of <code>O</code>-modules gives you another <code>O</code>-module, but I guess you still have to check that it has the right universal property</p>



<a name="272822401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272822401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272822401">(Feb 22 2022 at 15:53)</a>:</h4>
<p>I verified that for any <code>L : J  ⥤  BundledModule</code>,  denote <code>R</code> to be <code>L forget to ring</code> and <code>M</code> to be <code>L forget to abelian group</code>, then <code>lim M</code> is a <code>lim R</code>-module, but couldn't prove <code>(lim R, lim M)</code> has the universal property. (because I can only get a group homomorphism instead of linear map)</p>



<a name="272822768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272822768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272822768">(Feb 22 2022 at 15:55)</a>:</h4>
<p>Bah... I'm ready to throw my hands up and say that we should work internally in the Sheaf topos.</p>



<a name="272824108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272824108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272824108">(Feb 22 2022 at 16:03)</a>:</h4>
<p>Can you explain what that means?</p>



<a name="272824397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272824397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272824397">(Feb 22 2022 at 16:05)</a>:</h4>
<p>Roughly what I mean is one of the following two approaches:</p>
<p>Approach (3): Work with sheaves of sets, and define <code>Ring</code>-objects and <code>Module</code>-objects over such <code>Ring</code>-objects, inside of the category of sheaves of sets.</p>
<p>Approach (3'): Work with sheaves of abelian groups, define the monoidal structure, and use that to define <code>Ring</code>-objects (as monoid objects) and modules over them.</p>



<a name="272825005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272825005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272825005">(Feb 22 2022 at 16:08)</a>:</h4>
<p>Of course these approaches come with their own problems.</p>



<a name="272825287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272825287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272825287">(Feb 22 2022 at 16:10)</a>:</h4>
<p>Okay, now I really don't know what the best approach would be! It's an interesting problem to think about!</p>



<a name="272830289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272830289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272830289">(Feb 22 2022 at 16:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272819896">said</a>:</p>
<blockquote>
<p>But the colimits of bundled modules aren't the colimits you want--they will have some kind of colimit in the ring part too.</p>
</blockquote>
<p>Considering this: Let me just think about modules for a moment (the case of (pre)sheaves should be similar): Suppose I have a diagram <code>J : I ⥤ Module' A</code> where <code>Module'</code> is the category of <code>BunledModule</code>s with an isomorphism to <code>A</code> on the ring level (as in the code above).<br>
Let <code>F : Module' A ⥤ BundledModule</code> be the forgetful functor, and consider the colimit of <code>J ⋙ F</code>, say <code>M</code>. <br>
I suppose this is a module over the colimit of <code>J ⋙ F ⋙ R</code> where <code>R : BundledModule ⥤ CommRing</code> is the forgetful functor. Now, the isomorphisms used in the definition of <code>Module' A</code> give us a morphism from the colimit of <code>J ⋙ F ⋙ R</code> to <code>A</code> in the category of commutative rings. If I then base-change along this morphism, I suppose that should be the colimit of the original <code>J</code>.</p>
<p>(NB. I don't have a complete proof of this, but I think I convinced myself that this is true in the case of coproducts)</p>



<a name="272859073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272859073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272859073">(Feb 22 2022 at 20:03)</a>:</h4>
<p>At some point, anyway, it shall make sense to develop notions of group-objects, etc, in <em>general</em> monoidal categories, whether the monoidal structure is given by the categorical product (e.g. group schemes are group-objects in a category of S-schemes), or any other monoidal structure...</p>



<a name="272859939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272859939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272859939">(Feb 22 2022 at 20:10)</a>:</h4>
<p>It's probably a good idea to keep sheaves of modules and group schemes in mind at the same time, when thinking about this problem. As you say, they could benefit from similar approaches.</p>



<a name="272864984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272864984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272864984">(Feb 22 2022 at 20:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272818821">said</a>:</p>
<blockquote>
<p>I.e. "sheafify" this definition:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Module'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">BundledModule.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">M.R</span> <span class="bp">≅</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span>  Were you thinking about something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="n">Top.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>

<span class="kd">structure</span> <span class="n">presheaf_of_module</span> <span class="o">(</span><span class="bp">𝓞</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">CommRing</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">BundledModule</span> <span class="n">T</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">self</span> <span class="bp">⋙</span> <span class="n">BundledModule.forget_to_Ring</span> <span class="bp">≅</span> <span class="bp">𝓞</span><span class="o">)</span>
</code></pre></div>
<p>If so, I think this approach is weird because, for <code>𝓕 : presheaf_of_module 𝓞</code>, <code>(𝓕 .obj U).M</code> is not an <code>𝓞.obj U</code> module, rather a <code>(𝓕 .obj U).R</code> module.  I don't think class inference can pick up <code>e</code> and use it to synthesize what we want.</p>



<a name="272866162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272866162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272866162">(Feb 22 2022 at 21:00)</a>:</h4>
<p><span class="user-mention" data-user-id="252627">@Jujian Zhang</span> see <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272815916">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272815916</a></p>



<a name="272866298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272866298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272866298">(Feb 22 2022 at 21:01)</a>:</h4>
<p>specifically this part:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">Module'.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">M.M.M</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">CommRing.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Module'</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="n">M</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">A</span> <span class="n">M.M.R</span> <span class="o">:=</span> <span class="n">M.e.inv.to_algebra</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="n">restrict_scalars</span> <span class="n">A</span> <span class="n">M.M.R</span> <span class="n">M</span><span class="o">),</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272910048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272910048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272910048">(Feb 23 2022 at 06:32)</a>:</h4>
<p>The essential fiber could alternatively be defined as <code>{ f : structured_arrow 𝓞 forget // is_iso f }</code> but I'm not in favor of the approach. What <span class="user-mention" data-user-id="252627">@Jujian Zhang</span>  has done is essentially defining the restriction/extension (lax) functors from <code>presheaf CommRing X</code> to <code>Cat</code> (short of showing they're adjoint), and after that we could show that the Grothendieck constructions applied to these functors are isomorphic to the <code>presheaf BundledModule</code> category, and transition freely between them. (Working with the presheaf of abelian groups and its sheafification should be nice enough, but if we can somehow use the bundled presheaf category to automatically put module structures on abelian groups and verify compatibilit in constructions, that would even be better.)</p>
<p>Here are some mathlib API that <a href="https://github.com/leanprover-community/mathlib/pull/12186">#12186</a> failed to use, which seems to make it longer than necessary:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/find/module.comp_hom">docs#module.comp_hom</a> (or <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.module">docs#restrict_scalars.module</a>), <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.restrict_scalars">docs#linear_map.restrict_scalars</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.left_module">docs#tensor_product.left_module</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.base_change">docs#linear_map.base_change</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.compatible_smul">docs#linear_map.compatible_smul</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.algebra_tensor_module.lift.equiv">docs#tensor_product.algebra_tensor_module.lift.equiv</a> (more general than the hom_equiv of the restriction-extension adjunction but I can't find a simpler version), <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.mk_of_hom_equiv">docs#category_theory.adjunction.mk_of_hom_equiv</a></p>



<a name="272912537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272912537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272912537">(Feb 23 2022 at 07:20)</a>:</h4>
<p>Various constructions involving O-modules (e.g. tensor product, and those in abelian category axioms) could be abstracted into the following: module categories with restriction of scalars can be seen as a (strict) functor <code>module : CommRing ⥤ Cat</code>; whenever we have a (oplax) natural transformation from "<code>module^n</code>" to <code>module</code>, i.e. a functor <code>(module R)^n ⥤ module R</code> for each comm ring <code>R</code> that "commutes" with restriction of scalars, we get a functor from <code>O-modules^n</code> to <code>O-modules</code> (the natural transformation could be made strict for direct sum, kernel, image etc. but not for tensor products!).</p>



<a name="272927417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/272927417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#272927417">(Feb 23 2022 at 10:07)</a>:</h4>
<p>Thanks for pointing out the useful lemmas and apis. Though I don’t fully understand all the terminologies, am I correct to assume that you are suggesting to build two versions of (pre)sheaf of modules in parallel and prove the two versions are isomorphic and choose whichever version that is more convenient to do some specific construction, for example shefification using functor into bundled module etc.</p>



<a name="290149319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290149319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290149319">(Jul 19 2022 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272824397">said</a>:</p>
<blockquote>
<p>Roughly what I mean is one of the following two approaches:</p>
<p>Approach (3): Work with sheaves of sets, and define <code>Ring</code>-objects and <code>Module</code>-objects over such <code>Ring</code>-objects, inside of the category of sheaves of sets.</p>
<p>Approach (3'): Work with sheaves of abelian groups, define the monoidal structure, and use that to define <code>Ring</code>-objects (as monoid objects) and modules over them.</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272825005">said</a>:</p>
<blockquote>
<p>Of course these approaches come with their own problems.</p>
</blockquote>
<p>Can someone explain what the drawbacks to such an approach would be?</p>
<p>Surely it gets rid of the "category-is-hard" and "sheafification-is-hard" problems from before. I assume approaching it this way would make it much harder (at least, at first) to prove basic results. However, this seems like the most natural approach for a Bourbaki-style exposition in my (admittedly biased) opinion. </p>
<p>One a less subjective note, developing a theory of group/ring/module/monoid objects in an arbitrary category (not to mention groupoids in a category) will be quite useful as this is a suuuuuuper common perspective in cutting-edge research. I.e. buzzwords like group schemes, etale equivalence relations, ring spectra, etc. Might we end up having to go to this module-object approach eventually anyway?</p>



<a name="290149615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290149615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290149615">(Jul 19 2022 at 19:33)</a>:</h4>
<p>The difficulty is that if you have a sheaf of modules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> over a sheaf of rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> is open, then you want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> to be a module over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> <em>in the usual sense</em>!</p>



<a name="290149737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290149737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290149737">(Jul 19 2022 at 19:34)</a>:</h4>
<p>of course if you go with the internal objects approach, you could introduce the appropriate instances on such things, but that requires additional work and additional API.</p>



<a name="290149807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290149807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290149807">(Jul 19 2022 at 19:35)</a>:</h4>
<p>In the ideal world, we would have <em>all</em> the definitions, and a robust API that would let us go back-and-forth between any two definitions you chose.</p>



<a name="290151802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290151802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290151802">(Jul 19 2022 at 19:51)</a>:</h4>
<p>Ok, maybe I'll try this definition out and see what happens</p>



<a name="290151949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290151949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290151949">(Jul 19 2022 at 19:52)</a>:</h4>
<p>If you want to try to define monoid objects in sheaves on a site, and identify those with sheaves of monoids, that would be a very good test case!</p>



<a name="290151986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290151986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290151986">(Jul 19 2022 at 19:52)</a>:</h4>
<p>We already have monoid objects in a monoidal category, but we don't have the monoidal structure on sheaves</p>



<a name="290152059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290152059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290152059">(Jul 19 2022 at 19:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290151986">said</a>:</p>
<blockquote>
<p>...but we don't have the monoidal structure on sheaves</p>
</blockquote>
<p>well, we do, it's just the cartesian structure in this case, so you should be good to go</p>



<a name="290152150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290152150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290152150">(Jul 19 2022 at 19:54)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/Mon_">docs#Mon_</a></p>



<a name="290152210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290152210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290152210">(Jul 19 2022 at 19:54)</a>:</h4>
<p>There we go!</p>



<a name="290152519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290152519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290152519">(Jul 19 2022 at 19:57)</a>:</h4>
<p>That will give you sheaves of monoids</p>



<a name="290152541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290152541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290152541">(Jul 19 2022 at 19:57)</a>:</h4>
<p>Oh this is as a test case, carry on!</p>



<a name="290152651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290152651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290152651">(Jul 19 2022 at 19:58)</a>:</h4>
<p>Well, anyway we should choose a single-sorted thing as our first test case before jumping into modules</p>



<a name="290158138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290158138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290158138">(Jul 19 2022 at 20:46)</a>:</h4>
<p>Right, I was thinking of rings</p>



<a name="290193573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290193573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290193573">(Jul 20 2022 at 04:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290152059">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290151986">said</a>:</p>
<blockquote>
<p>...but we don't have the monoidal structure on sheaves</p>
</blockquote>
<p>well, we do, it's just the cartesian structure in this case, so you should be good to go</p>
</blockquote>
<p>So, I'm having trouble finding an instance of <code>has_finite_products</code> or <code>has_products</code> on any of the sheaf categories. Do you know if Lean has this somewhere? (also is there is a standard way to see if something has an instance somewhere? my method so far is searching on github)</p>



<a name="290193754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290193754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290193754">(Jul 20 2022 at 05:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290151949">said</a>:</p>
<blockquote>
<p>If you want to try to define monoid objects in sheaves on a site, and identify those with sheaves of monoids, that would be a very good test case!</p>
</blockquote>
<p>Is there a standard thing that we want to mean by "identify" here? I.e. some possibilities show an equivalence of categories between monoid objects in the category of sheaves and sheaves of monoids, or give some sort of function that takes a monoid object in the category of sheaves and gives a sheaf of monoids and then give an inverse, or is there some more mathlibby way?</p>



<a name="290194079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290194079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290194079">(Jul 20 2022 at 05:06)</a>:</h4>
<blockquote>
<p>is there is a standard way to see if something has an instance somewhere?</p>
</blockquote>
<p>do you mean starting from a specific structure and trying to figure out if it instantiates a specific class somehow? or do you mean starting from a class and finding a list of structures that instantiate it?</p>
<p>re: the latter, each class has an "Instances of this typeclass" list below it in the mathlib docs</p>



<a name="290194286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290194286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290194286">(Jul 20 2022 at 05:10)</a>:</h4>
<p>Searching in <a href="https://leanprover-community.github.io/mathlib_docs">the documentation</a> for "sheaf has_limits_of_shape" gives <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf.category_theory.limits.has_limits_of_shape">docs#category_theory.Sheaf.category_theory.limits.has_limits_of_shape</a></p>



<a name="290194385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20presheaf%20of%20modules/near/290194385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules.html#290194385">(Jul 20 2022 at 05:13)</a>:</h4>
<p>I think showing the equivalence of the two categories is the right way to go?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
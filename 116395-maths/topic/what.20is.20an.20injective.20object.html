---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/what.20is.20an.20injective.20object.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html">what is an injective object</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271107082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271107082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271107082">(Feb 08 2022 at 10:24)</a>:</h4>
<p>We could be clever and define an injective object in C to be a projective object in C^op. Is this a sensible thing to do or should we just make the API from first principles and avoid op hell?</p>



<a name="271107633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271107633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271107633">(Feb 08 2022 at 10:29)</a>:</h4>
<p>It's part of <a href="https://github.com/leanprover-community/mathlib/pull/11878">#11878</a> and I'm thinking it should be split off but I'm wondering whether people will object to the definition.</p>



<a name="271107786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271107786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271107786">(Feb 08 2022 at 10:30)</a>:</h4>
<p>So a projective object in  <code>C</code> is an injective object in <code>Cᵒᵖ</code>? How can you state that if you try to spare yourself the definition from first principles?</p>



<a name="271107985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271107985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271107985">(Feb 08 2022 at 10:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">injective</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">factors</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">[</span><span class="n">mono</span> <span class="n">f</span><span class="o">],</span> <span class="bp">∃</span> <span class="n">h</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">J</span><span class="o">,</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span>
</code></pre></div>



<a name="271108591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271108591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271108591">(Feb 08 2022 at 10:38)</a>:</h4>
<p>We duplicate the entire limit API into a colimit API. I would do the same here.</p>



<a name="271110371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271110371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271110371">(Feb 08 2022 at 10:56)</a>:</h4>
<p>OK great; Jujian is working on it!</p>



<a name="271962641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271962641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271962641">(Feb 15 2022 at 11:52)</a>:</h4>
<p>In the process of translating projectiveness to injectiveness, there is <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact.lift">docs#category_theory.exact.lift</a>, which says<br>
if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>→</mo><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Q\rightarrow R\rightarrow S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is exact and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is projective with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P\rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi><mo>→</mo><mi>S</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">P\rightarrow R\rightarrow S=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, then we can lift <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P\rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P\rightarrow Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>. So we need an analogous statement for injective objects. In the setting of abelian category, this is easily done, reverse arrow then use <code>exact.lift</code>, but that would require abelian category because we used <code>exact g.op f.op</code> from <code>exact f g</code>. To do this without abelian setting, we need the following fact (if this is true): if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Q</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">f : Q\rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">g:R\rightarrow S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is exact then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mi>f</mi><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">\mathrm{coker} f\rightarrow\mathrm{im} g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">coker</span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">im</span></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is mono (dual to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mrow><mi>f</mi><mo>→</mo><mrow><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">\mathrm{im} f\rightarrow\mathrm{ker} g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">im</span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ker</span></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> being epi).<br>
So is this true in a general category where all relevant notion makes sense?</p>
<p>The reason that I don't want to assume abelianness is that the corresponding <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact.lift">docs#category_theory.exact.lift</a> is proved with far weaker assumption (only zero_morphisms,  equalizers and images). So how much theory of injective objects and injective resolutions do we want to develop before introducing abelianness assumption?</p>



<a name="271968280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271968280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271968280">(Feb 15 2022 at 12:46)</a>:</h4>
<p>If we're trying to talk about projectives and injectives without exactness conditions on the category--I'm kind of surprised that the definition of projective object does not involve <em>regular</em> epimorphisms.</p>



<a name="271968287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271968287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271968287">(Feb 15 2022 at 12:46)</a>:</h4>
<p>I think we have a pretty assymetrical notion of exactness in mathlib, and maybe that's not a good idea.</p>



<a name="271968505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271968505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271968505">(Feb 15 2022 at 12:48)</a>:</h4>
<p>I guess I would be inclined to say that you shouldn't bother worrying about the non-abelian category case until you have some use for it</p>



<a name="271969077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271969077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271969077">(Feb 15 2022 at 12:53)</a>:</h4>
<p>I see both wikipedia and nLab say a projective object is an object that lifts against all epimorphisms but I think it's the kind of definition that someone would make if they only think about cases where every epi is regular (e.g. in a topos or an abelian category).</p>



<a name="271969255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271969255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271969255">(Feb 15 2022 at 12:54)</a>:</h4>
<p>I don't know if this helps with your question, but my point is that if you want to get correct definitions without any exactness assumptions on the category then maybe you have to start earlier.</p>



<a name="271969499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271969499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271969499">(Feb 15 2022 at 12:57)</a>:</h4>
<p>Are there general <code>has_lifting_property x C</code> for an object <code>x</code> and a class of morphisms <code>C</code>?</p>



<a name="271971371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271971371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271971371">(Feb 15 2022 at 13:12)</a>:</h4>
<p>We do have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.has_lifting_property">docs#category_theory.has_lifting_property</a> but it's not used much AFAIK</p>



<a name="271975724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271975724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271975724">(Feb 15 2022 at 13:50)</a>:</h4>
<p>I would agree that lifting against all mono- (resp. epi-)morphisms is mostly relevant to the abelian setup. If one wants to generalise the notion of a projective object, one should probably look into an exact category and then restrict having the lifting property to admissible mono- (resp. epi-) morphisms, aka inflations and deflations.</p>



<a name="271980404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271980404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271980404">(Feb 15 2022 at 14:22)</a>:</h4>
<p>I found out an almost comical solution, instead of assuming <code>exact f g</code>, we can work with assumption <code>exact g.op f.op</code>, so that the corresponding statement only requires <code>[has_zero_morphisms C] [has_images Cᵒᵖ] [has_equalizers Cᵒᵖ]</code></p>



<a name="271980869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271980869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271980869">(Feb 15 2022 at 14:25)</a>:</h4>
<p>Please don't change the definition of <code>projective</code>. We use it in LTE to talk about projective profinite spaces, and it works just fine as is. <code>Profinite</code> is not an exact category.</p>



<a name="271981051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981051">(Feb 15 2022 at 14:26)</a>:</h4>
<p>I think every epimorphism in <code>Profinite</code> is regular though, right?</p>



<a name="271981074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981074">(Feb 15 2022 at 14:26)</a>:</h4>
<p>Is it?</p>



<a name="271981137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981137">(Feb 15 2022 at 14:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/271980869">said</a>:</p>
<blockquote>
<p>Please don't change the definition of <code>projective</code>. We use it in LTE to talk about projective profinite spaces, and it works just fine as is. <code>Profinite</code> is not an exact category.</p>
</blockquote>
<p>I won't change it.</p>



<a name="271981140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981140">(Feb 15 2022 at 14:26)</a>:</h4>
<p>What does regular mean again?</p>



<a name="271981242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981242">(Feb 15 2022 at 14:27)</a>:</h4>
<p>Coequalizer of some pair (which can be taken to be the kernel pair if the category has pullbacks)</p>



<a name="271981328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981328">(Feb 15 2022 at 14:28)</a>:</h4>
<p>Oh, yeah that's fine.</p>



<a name="271981546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981546">(Feb 15 2022 at 14:29)</a>:</h4>
<p>I think it's usually less work to show that this agreess with what you want (surjections) than general epis</p>



<a name="271981905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271981905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271981905">(Feb 15 2022 at 14:31)</a>:</h4>
<p>Do we have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.regular_epi">docs#category_theory.regular_epi</a></p>



<a name="271982120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271982120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271982120">(Feb 15 2022 at 14:33)</a>:</h4>
<p>Hmm... is that the right definition for <code>regular_epi</code>? It includes the coequalizer as data.</p>



<a name="271982306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271982306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271982306">(Feb 15 2022 at 14:34)</a>:</h4>
<p>maybe a forgotten <code>: Prop</code>? I also don't understand why it is a class</p>



<a name="271982327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271982327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271982327">(Feb 15 2022 at 14:34)</a>:</h4>
<p>(why is anything a class <span aria-label="angry" class="emoji emoji-1f620" role="img" title="angry">:angry:</span>)</p>



<a name="271999175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/271999175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#271999175">(Feb 15 2022 at 16:27)</a>:</h4>
<p><a href="https://ncatlab.org/nlab/show/projective+object">nlab</a> seems to suggest that we should have different notions of <code>projective</code>, the one of lifting with respect to all epimorphisms, then also something called <code>regular_projective</code> which I have to admit I had not heard of before. In my area of research, the more frequently appearing notion is that of <code>projective with respect to some (Quillen) exact structure</code>, which is yet another version of a lifting property, see e.g. <a href="https://www.sciencedirect.com/science/article/pii/S0723086909000395">Exact categories</a> by Bühler.</p>



<a name="272013768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/272013768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#272013768">(Feb 15 2022 at 18:03)</a>:</h4>
<p>Regular epimorphisms are the right notion in categories of models of an algebraic theory. For example in rings, the inclusion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z} \to \mathbb{Q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8556em;vertical-align:-0.1667em;"></span><span class="mord mathbb">Q</span></span></span></span> is an epimorphism (but not surjective of course) and so the polynomial ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> isn't projective. Regular epimorphisms agree with the surjective maps.</p>



<a name="272013825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/272013825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#272013825">(Feb 15 2022 at 18:03)</a>:</h4>
<p>And one of the characteristic features of algebraic categories is that they have enough compact [regular] projective objects.</p>



<a name="272017826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/272017826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#272017826">(Feb 15 2022 at 18:32)</a>:</h4>
<p>But indeed in other situations you might want to take the "right" notion of "epimorphism" as a parameter.</p>



<a name="272081297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/272081297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#272081297">(Feb 16 2022 at 07:27)</a>:</h4>
<p><span class="user-mention" data-user-id="252627">@Jujian Zhang</span> how about you make the basic definitions of projective objects with as few assumptions as possible but the moment it's convenient to do so, assume abelian. In contrast to what we were worried about yesterday it looks unlikely that people will be using the notion any time soon in the nonabelian setting (indeed it may not even be the right one), and the sooner we're in a position to start talking about it in the abelian setting the better.</p>



<a name="273537890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273537890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273537890">(Feb 28 2022 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/271971371">said</a>:</p>
<blockquote>
<p>We do have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.has_lifting_property">docs#category_theory.has_lifting_property</a> but it's not used much AFAIK</p>
</blockquote>
<p>I have started attempting at formalising Quillen's model categories, and for that <code>has_lifting_property</code> shall be used and extended... (I guess that the first reachable example of <code>model_category</code> would be that of complexes (C^+) in an abelian category with enough injectives, or the dual version with enough projectives. )</p>



<a name="273538279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273538279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273538279">(Feb 28 2022 at 19:07)</a>:</h4>
<p>That sounds great <span class="user-mention" data-user-id="459699">@Joël Riou</span> ! Actually <span class="user-mention" data-user-id="306577">@Matthew Ballard</span> and I were discussing just a few days ago that it would be nice to have the model category of complexes, and perhaps (re?)define derived functors using this approach.</p>



<a name="273538476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273538476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273538476">(Feb 28 2022 at 19:08)</a>:</h4>
<p>And IIRC <span class="user-mention" data-user-id="247154">@Jakob Scholbach</span> 's original motivation for defining <code>has_lifting_property</code> was indeed as a start toward model categories!</p>



<a name="273538827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273538827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273538827">(Feb 28 2022 at 19:11)</a>:</h4>
<p>The only good things in categories come from <code>has_lifting_property</code></p>



<a name="273538928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273538928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273538928">(Feb 28 2022 at 19:12)</a>:</h4>
<p>The work on simplicial objects might make that equally accessible</p>



<a name="273539021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539021">(Feb 28 2022 at 19:13)</a>:</h4>
<p>I am working towards the "fundamental lemma of homotopical algebra", which is that is X is cofibrant and Y fibrant, then the morphisms in the localized category (obtained by formally inverting the weak equivalences) identifies to homotopy classes of maps defined by cylinder. I have already a draft of the construction of localized categories <code>C[W^-1]</code> (based on the great works that are already in mathlib, like <code>path_category</code> of a quiver and quotient categories).</p>



<a name="273539154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539154">(Feb 28 2022 at 19:14)</a>:</h4>
<p>Nice! I wonder, how did you formalize the definition of <code>(co)filbration</code> and <code>weak_equivalence</code>?</p>



<a name="273539190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539190">(Feb 28 2022 at 19:15)</a>:</h4>
<p>I believe that the model structure on simpliical sets will take more time! (I think we first need to have it for the category of topological spaces, with Serre fibrations. It would be nice if the on-going work on homotopies in topological helps there.)</p>



<a name="273539276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539276">(Feb 28 2022 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273539154">said</a>:</p>
<blockquote>
<p>Nice! I wonder, how did you formalize the definition of <code>(co)filbration</code> and <code>weak_equivalence</code>?</p>
</blockquote>
<p><code>abbreviation arrow_class := set (arrow C)</code></p>



<a name="273539497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539497">(Feb 28 2022 at 19:17)</a>:</h4>
<p>Happy to see people working on this! you might be interested in:<br>
<a href="https://github.com/rwbarton/lean-homotopy-theory">https://github.com/rwbarton/lean-homotopy-theory</a><br>
<a href="https://github.com/rwbarton/lean-model-categories/tree/top-dev">https://github.com/rwbarton/lean-model-categories/tree/top-dev</a> (old WIP, but has some stuff)</p>



<a name="273539500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539500">(Feb 28 2022 at 19:17)</a>:</h4>
<p>Aha I see. Did you find working with <code>arrow</code> to be easy enough? I would have guessed that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">arrow_class</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">⦃</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">⦄,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>
<p>might be easier to work with in practice.</p>



<a name="273539755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273539755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273539755">(Feb 28 2022 at 19:19)</a>:</h4>
<p>It looks like this is what <span class="user-mention" data-user-id="110032">@Reid Barton</span> chose to do in his repo:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_weak_equivalences</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_weq</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">⦃</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">C</span><span class="o">⦄,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</code></pre></div>



<a name="273540027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273540027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273540027">(Feb 28 2022 at 19:21)</a>:</h4>
<p>That was my first idea, but it turned out to be easier to work with <code>arrow C</code>. One of the reasons is that <code>has_lifting_property</code> is defined using <code>arrow</code>.</p>



<a name="273540157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273540157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273540157">(Feb 28 2022 at 19:22)</a>:</h4>
<p>Is there a reason for it to be? you can just use implicits for the objects and talk about lifting conditions between two morphisms without mentioning <code>arrow</code></p>



<a name="273540160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273540160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273540160">(Feb 28 2022 at 19:22)</a>:</h4>
<p>Yes, of course, but perhaps it would be worthwhile to change the definition of <code>has_lifting_property</code>? (I don't remember exactly why <span class="user-mention" data-user-id="247154">@Jakob Scholbach</span> decided to use <code>arrow</code> there.)</p>



<a name="273541292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273541292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273541292">(Feb 28 2022 at 19:30)</a>:</h4>
<p>In order to work with commutative squares (and lifting properties, etc), it is very convenient to use morphisms between objects in the category <code>arrow C</code>... Also, when stating some lemmas, we need only one variable for each arrow, not three!</p>



<a name="273541874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273541874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273541874">(Feb 28 2022 at 19:34)</a>:</h4>
<p>Progress in this direction is excellent. I've spent my time looking for appropriate emoji to express my feelings. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="273541902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273541902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273541902">(Feb 28 2022 at 19:35)</a>:</h4>
<p>I first want to apologize for leaving this topic. I simply didn't find the time do work on lean anymore.<br>
I thought it is a good idea to formalize lifting properties using the arrow category since for example the usual arguments involving transfinite compositions take place as colimits in the arrow category, I think. But of course, if you see any reason to undo this choice, go ahead!<br>
On the original question: what is an injective object, I would like to briefly point out a remark / definition in "Cesnavicius, Scholze.  Purity for flat cohomology" that a compact object is an object x such that Hom(x, -) commutes with sifted colimits. Does it make sense to define a projective object to be an object such that Hom(x, -) preserves reflexive coequalizers?</p>



<a name="273542193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273542193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273542193">(Feb 28 2022 at 19:37)</a>:</h4>
<p>Perhaps something like the following would be a good compromise</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.arrow</span>

<span class="kn">namespace</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span>

<span class="kd">abbreviation</span> <span class="n">arrow_class</span> <span class="o">:=</span> <span class="n">set</span> <span class="o">(</span><span class="n">arrow</span> <span class="n">C</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">arrow_class</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">⦃</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">⦄,</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span> <span class="o">(</span><span class="n">arrow.mk</span> <span class="n">f</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">a</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">category_theory</span>
</code></pre></div>



<a name="273542946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273542946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273542946">(Feb 28 2022 at 19:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273538279">said</a>:</p>
<blockquote>
<p>That sounds great <span class="user-mention silent" data-user-id="459699">Joël Riou</span> ! Actually <span class="user-mention silent" data-user-id="306577">Matthew Ballard</span> and I were discussing just a few days ago that it would be nice to have the model category of complexes, and perhaps (re?)define derived functors using this approach.</p>
</blockquote>
<p>After a little thought, I might temper this though. The derived functor will depend on the model structure and that seems hard to unify in a simple way. Relating Tor sheaves over a scheme and sheaf cohomology might be annoying as an example</p>



<a name="273543299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273543299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273543299">(Feb 28 2022 at 19:45)</a>:</h4>
<p>But bounded above chain complexes with the projective model structure is definitely a good target given the work <span class="user-mention" data-user-id="243562">@Adam Topaz</span>, <span class="user-mention" data-user-id="439483">@Andrew Yang</span>, and others have done for LTE.</p>



<a name="273543505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273543505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob Scholbach <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273543505">(Feb 28 2022 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306577">Matthew Ballard</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273542946">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273538279">said</a>:</p>
<blockquote>
<p>That sounds great <span class="user-mention silent" data-user-id="459699">Joël Riou</span> ! Actually <span class="user-mention silent" data-user-id="306577">Matthew Ballard</span> and I were discussing just a few days ago that it would be nice to have the model category of complexes, and perhaps (re?)define derived functors using this approach.</p>
</blockquote>
<p>After a little thought, I might temper this though. The derived functor will depend on the model structure and that seems hard to unify in a simple way. Relating Tor sheaves over a scheme and sheaf cohomology might be annoying as an example</p>
</blockquote>
<p>Yes, this is true. To get a formalism independent of choices of (co)fibrations, one can use the notion of a category with weak equivalences (as in this book <a href="https://ncatlab.org/nlab/show/Homotopy+Limit+Functors+on+Model+Categories+and+Homotopical+Categories">https://ncatlab.org/nlab/show/Homotopy+Limit+Functors+on+Model+Categories+and+Homotopical+Categories</a> ).</p>



<a name="273543734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273543734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273543734">(Feb 28 2022 at 19:48)</a>:</h4>
<p>The model category structures on complexes always have quasi isos as the weak equivalences right?</p>



<a name="273543766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273543766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273543766">(Feb 28 2022 at 19:49)</a>:</h4>
<p>Not the pure versions if I remember correctly</p>



<a name="273544484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273544484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273544484">(Feb 28 2022 at 19:54)</a>:</h4>
<p>Actually, I think that in this context, model categories can be considered as a tool in order to study derived categories and construct derived functors. The homotopy category does not depend on the choice of cofibrations/fibrations, only on the class of weak equivalences. Similarly, the (total) left/right derived functors is defined by a universal property which depends only on the class of weak equivalences.</p>



<a name="273544894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273544894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273544894">(Feb 28 2022 at 19:57)</a>:</h4>
<p>If we want to define derived functors as Kan extensions, then we should try to resolve this issue as well:<br>
<a href="https://github.com/leanprover-community/mathlib/issues/7051">https://github.com/leanprover-community/mathlib/issues/7051</a></p>



<a name="273545852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273545852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273545852">(Feb 28 2022 at 20:03)</a>:</h4>
<p>True. But using adapted objects to "compute" derived functors in the linear setting seems more complicated here to me.</p>



<a name="273546264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273546264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273546264">(Feb 28 2022 at 20:06)</a>:</h4>
<p>I think in this case having a characteristic predicate for a Kan extension would help if, for example, you want to "compute" a derived functor using projectives, i.e. you get some functor (defined in terms of projectives) which should satisfy the characteristic predicate, hence would be isomorphic to "the" derived functor defined in terms of a Kan extension.</p>



<a name="273546283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273546283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273546283">(Feb 28 2022 at 20:06)</a>:</h4>
<p>Or maybe I am misunderstanding the issue?</p>



<a name="273547360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273547360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273547360">(Feb 28 2022 at 20:15)</a>:</h4>
<p>I want to compute sheaf cohomology using a cover.</p>



<a name="273547395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273547395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273547395">(Feb 28 2022 at 20:15)</a>:</h4>
<p>As an example</p>



<a name="273547758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273547758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273547758">(Feb 28 2022 at 20:19)</a>:</h4>
<p>Okay, so in that case you can show that some functor you define in terms of (hyper)cover(s) of your scheme/space satisfies the characteristic predicate. I'm not saying it would be easy to show, but I don't think it's much more difficult than the proof showing that sheaf cohomology (defined in terms of injective resolutions of the sheaf) agrees with the object defined in terms of hypercovers.</p>



<a name="273548434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273548434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273548434">(Feb 28 2022 at 20:25)</a>:</h4>
<p>Same for sheaf Tor and a resolution by locally frees?</p>



<a name="273550143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273550143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273550143">(Feb 28 2022 at 20:38)</a>:</h4>
<p>The problem with <code>arrow</code> is that you cannot really compose <code>arrow</code>s. More generally, you are forced to either introduce variables in a restricted format (which will sometimes be impossible, as in the case of composition) or just go ahead and use <code>{X Y Z : C} (f : X -&gt; Y) (g : Y -&gt; Z)</code> anyways. The latter form will be required at least some of the time. If you always use the latter form, then there is obviously no advantage to "<code>arrow</code> classes" since it forces you to write <code>&lt;f&gt;</code> for no reason. If you mix them, then you have to decide when to talk about <code>arrow</code>s versus morphisms, and you're likely to have annoyances due to a lack of eta <code>f = &lt;f.hom&gt;</code>.</p>



<a name="273550260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273550260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273550260">(Feb 28 2022 at 20:38)</a>:</h4>
<p>I can't imagine there is any advantage of <code>arrow</code> that outweighs this problem.</p>



<a name="273550661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273550661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273550661">(Feb 28 2022 at 20:40)</a>:</h4>
<p>(Another subjective advantage is that it's nicer to talk about maps <code>B -&gt; X</code> than maps <code>f.cod -&gt; g.dom</code> or whatever.)</p>



<a name="273550862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273550862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273550862">(Feb 28 2022 at 20:42)</a>:</h4>
<p>It's true that at some point you'll want to say things like "weak equivalences are closed under filtered colimits in the arrow category", but this isn't made harder by working with morphism classes: use a cocone in <code>arrow C</code>, and then formulate the hypotheses and conclusions in terms of <code>is_weq (F.obj i).hom</code> or whatever.</p>



<a name="273552827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273552827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273552827">(Feb 28 2022 at 20:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273550260">said</a>:</p>
<blockquote>
<p>I can't imagine there is any advantage of <code>arrow</code> that outweighs this problem.</p>
</blockquote>
<p>Actually, when working with model categories, it is important to be able to talk about retracts of arrows, and this is a very good <em>mathematical</em> reason to work with the category <code>arrow C</code>. Anyway, I do not think this is a serious discussion, and I will refrain from fueling it more here.</p>



<a name="273553177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273553177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273553177">(Feb 28 2022 at 21:00)</a>:</h4>
<p>I'm not exactly sure what you mean by a serious discussion.</p>



<a name="273553571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273553571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273553571">(Feb 28 2022 at 21:03)</a>:</h4>
<p>It's true that retracts of arrows come up but it's not clear to me that this notion is necessarily more conveniently phrased in terms of <code>arrow</code>--in order to work with it you have to unwind this definition anyways.</p>



<a name="273553825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273553825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273553825">(Feb 28 2022 at 21:05)</a>:</h4>
<p>I spent a lot of time thinking specifically about formalizing model categories in Lean (as you can see from the linked repos) and my heartfelt opinion is that you will save yourself a lot of annoyance by avoiding <code>arrow</code> when talking about classes of morphisms. Of course you can just ignore me, if you like.</p>



<a name="273609653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/what%20is%20an%20injective%20object/near/273609653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/what.20is.20an.20injective.20object.html#273609653">(Mar 01 2022 at 09:12)</a>:</h4>
<p>I think that Reid probably has the most experience of everyone, when it comes to formalizing model categories (and homotopy theory outside of HoTT). I would take his opinion very serious.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
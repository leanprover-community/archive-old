---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html">Jordan Hölder theorem</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="250607073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250607073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250607073">(Aug 25 2021 at 11:28)</a>:</h4>
<p>I've proved a general version of the Jordan Hölder theorem for a class <code>jordan_hoelder_class</code> which I defined and this should mean that it should be possible to prove that <code>subgroup G</code> or <code>submodule M</code> is a Jordan Hölder class. The main definitions are as follows</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">jordan_hoelder_class</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">X</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_maximal</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_is_maximal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">is_maximal</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">sup_eq_of_is_maximal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">},</span> <span class="n">is_maximal</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">is_maximal</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span>
  <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">⊔</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_maximal_inf_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">},</span> <span class="n">is_maximal</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">is_maximal</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">is_maximal</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⊓</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">isom</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="c1">--(isom_refl : ∀ x, isom x x)</span>
<span class="o">(</span><span class="n">isom_symm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">isom</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">isom</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">isom_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">},</span> <span class="n">isom</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">isom</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">isom</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">second_iso</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">isom</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">⊔</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⊓</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span><span class="bp">```</span>

<span class="bp">```</span><span class="n">lean</span>
<span class="kd">structure</span> <span class="n">composition_series</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">lattice</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">jordan_hoelder_class</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">length</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">series</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">length</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">step'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">length</span><span class="o">,</span> <span class="n">is_maximal</span> <span class="o">(</span><span class="n">series</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">series</span> <span class="n">i.succ</span><span class="o">))</span>
</code></pre></div>
<p>I'm looking for comments on this stuff. There needs to be an API for composition series which includes mapping over morphisms (so we maybe need to define morphisms of  and I'm not sure whether to attempt to write this all in the generality of Jordan Hölder class or not). I'm not sure if there are any applications other than groups and modules, obviously if there are more, then we might want a more general API. I may have to change the definition of <code>second_iso</code> to stipulate that <code>x</code> is maximal inside <code>x ⊔ y</code>.</p>



<a name="250610388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250610388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250610388">(Aug 25 2021 at 12:07)</a>:</h4>
<p>I definitely think generality is useful here, at least I've seen applications that make use of Jordan Holder for p-divisible groups and the like. My understanding was that the "right" generality is that the theorem holds in any abelian category, how does your Jordan-Holder class compare to that? (Edit: I guess it really should be more general! groups aren't an abelian category after all)</p>



<a name="250611384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250611384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250611384">(Aug 25 2021 at 12:17)</a>:</h4>
<p>I'm guessing you already saw <a href="https://en.wikipedia.org/wiki/Composition_series#Generalization">https://en.wikipedia.org/wiki/Composition_series#Generalization</a>, I've never heard of those things before but if its the right generality to reduce duplicate proofs maybe groups with a set of operators is the way to go?</p>



<a name="250614060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250614060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250614060">(Aug 25 2021 at 12:44)</a>:</h4>
<p>Is there a reason to prefer the dependent fin for a series as opposed to a list.chain'?</p>



<a name="250614288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250614288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250614288">(Aug 25 2021 at 12:47)</a>:</h4>
<p>You could have local notation within the structure like "&lt;m" so that it's more clear that is_maximal has the maximal term on the right.</p>



<a name="250616169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250616169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250616169">(Aug 25 2021 at 13:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem/near/250614060">said</a>:</p>
<blockquote>
<p>Is there a reason to prefer the dependent fin for a series as opposed to a list.chain'?</p>
</blockquote>
<p><code>fin</code> makes it a lot easier to state equivalence of composition series. I just need a <code>fin s₁.length ≃ fin s₂.length</code> to define equivalence, but isomorphisms of lists is harder to deal with.</p>



<a name="250620725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250620725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250620725">(Aug 25 2021 at 13:36)</a>:</h4>
<p><a href="https://www.isa-afp.org/entries/Jordan_Hoelder.html">Here</a>'s my Isabelle formalisation of Jordan-Hölder. I compared the isomorphism classes of the quotients as multisets</p>



<a name="250624802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250624802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250624802">(Aug 25 2021 at 14:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem/near/250620725">said</a>:</p>
<blockquote>
<p><a href="https://www.isa-afp.org/entries/Jordan_Hoelder.html">Here</a>'s my Isabelle formalisation of Jordan-Hölder. I compared the isomorphism classes of the quotients as multisets</p>
</blockquote>
<p>That might have been a better idea for me in hindsight.</p>



<a name="250625049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250625049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250625049">(Aug 25 2021 at 14:06)</a>:</h4>
<p>One issue is that we don't have a great way of taking the list of adjacent pairs given a list, but I could easily have defined a composition series to be a list of pairs.</p>



<a name="250625594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250625594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250625594">(Aug 25 2021 at 14:11)</a>:</h4>
<p><code>zip l l.tail</code></p>



<a name="250625629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250625629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250625629">(Aug 25 2021 at 14:11)</a>:</h4>
<p>Which I use to great extent in <a href="https://leanprover-community.github.io/mathlib_docs/find/list.form_perm">docs#list.form_perm</a></p>



<a name="250626769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250626769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250626769">(Aug 25 2021 at 14:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem/near/250611384">said</a>:</p>
<blockquote>
<p>I'm guessing you already saw <a href="https://en.wikipedia.org/wiki/Composition_series#Generalization">https://en.wikipedia.org/wiki/Composition_series#Generalization</a>, I've never heard of those things before but if its the right generality to reduce duplicate proofs maybe groups with a set of operators is the way to go?</p>
</blockquote>
<p>I really think anyone interested in math formalization should have a look at Bourbaki. Some of the greatest mathematicians of their time faced a lot of those questions, and they sorted it out. Groups with operators are defined on Page 31 of Algebra I. Jordan-Hölder starts on Page 41.</p>



<a name="250630450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/250630450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#250630450">(Aug 25 2021 at 14:46)</a>:</h4>
<p>I just fixed that Wikipedia page.</p>



<a name="307003595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307003595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307003595">(Oct 30 2022 at 20:13)</a>:</h4>
<p>Context is <a href="https://github.com/leanprover-community/mathlib/pull/17226">#17226</a>. I'm looking at <a href="https://leanprover-community.github.io/mathlib_docs/find/jordan_holder_lattice.is_maximal">docs#jordan_holder_lattice.is_maximal</a>. Is there any other notion of maximality than <a href="https://leanprover-community.github.io/mathlib_docs/find/covby">docs#covby</a>?</p>



<a name="307003754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307003754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307003754">(Oct 30 2022 at 20:14)</a>:</h4>
<p>By that I mean: Will we ever define an instance of <a href="https://leanprover-community.github.io/mathlib_docs/find/jordan_holder_lattice">docs#jordan_holder_lattice</a> that won't set <code>is_maximal := (⋖)</code>?</p>



<a name="307003799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307003799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307003799">(Oct 30 2022 at 20:15)</a>:</h4>
<p>The docstring in the file mentions</p>
<blockquote>
<p>In the example of subgroups of a group, <code>is_maximal H K </code>means that <code>H</code> is a maximal <em>normal</em> subgroup of <code>K</code>.</p>
</blockquote>



<a name="307003896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307003896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307003896">(Oct 30 2022 at 20:16)</a>:</h4>
<p>Somehow this is still <code>covby</code>, simply in another lattice <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="307003946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307003946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307003946">(Oct 30 2022 at 20:17)</a>:</h4>
<p>Okay, better question: Will <code>is_maximal</code> always be the pullback of <code>covby</code> over some sublattice of <code>α</code>?</p>



<a name="307004065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307004065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307004065">(Oct 30 2022 at 20:18)</a>:</h4>
<p>I'm trying to see whether there's something automatic about checking the <code>jordan_holder_lattice</code> axioms.</p>



<a name="307004091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307004091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307004091">(Oct 30 2022 at 20:18)</a>:</h4>
<p>(as an aside, that really should be called <code>jordan_hoelder_lattice</code>!)</p>



<a name="307004249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307004249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307004249">(Oct 30 2022 at 20:20)</a>:</h4>
<p>(<code>jordan_hölder_lattice</code> would be even better.)</p>



<a name="307004365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307004365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307004365">(Oct 30 2022 at 20:22)</a>:</h4>
<p>(French keyboard users would be overadvantaged <span aria-label="wine" class="emoji emoji-1f377" role="img" title="wine">:wine:</span>)</p>



<a name="307018874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307018874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307018874">(Oct 30 2022 at 23:50)</a>:</h4>
<p>mathlib convention is to not include any accent in declaration names, e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/stone_cech">docs#stone_cech</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/witt_vector.teichmuller">docs#witt_vector.teichmuller</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/picard_lindelof">docs#picard_lindelof</a> ...</p>



<a name="307018920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307018920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307018920">(Oct 30 2022 at 23:51)</a>:</h4>
<p>The fact that this is the convention, does not mean that having accents would be worst!  <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="307019100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307019100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307019100">(Oct 30 2022 at 23:54)</a>:</h4>
<p>Lean 4 also use capital letters extensively in declaration names. Maybe we should capitalize appropriately and add accents to the Lean3-Lean4 mathport dictionary?</p>



<a name="307019585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307019585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307019585">(Oct 31 2022 at 00:03)</a>:</h4>
<p>We also need proper VSCode (and other text editor) support to type the accents. It seems to follow LaTeX convention now, but you can't actually type ö using <code>\"o</code> according to <a href="https://github.com/vihdzp/vscode-lean/blob/3ddd1b669a5f09f67bb34978153974284fd34d9e/src/abbreviation/abbreviations.json#L141">the list</a>.</p>



<a name="307020002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307020002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307020002">(Oct 31 2022 at 00:11)</a>:</h4>
<p>The thing is that german umlauts have prescribed digramm transcriptions:</p>
<ul>
<li>ä → ae</li>
<li>ö → oe</li>
<li>ü → ue</li>
</ul>



<a name="307020773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307020773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307020773">(Oct 31 2022 at 00:24)</a>:</h4>
<p>If we really go there, an option could be to allow <code>jordan_hölder_lattice</code> and <code>jordan_holder_lattice</code> to be the same declaration, similar to how <code>-&gt;</code> and <code>→</code> already mean the same.</p>



<a name="307051657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307051657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307051657">(Oct 31 2022 at 08:00)</a>:</h4>
<p>In Swedish web addresses and such, people just write aao instead of åäö (never aa ae oe). It does lose information but it feels like a smaller change than turning one letter into two</p>



<a name="307053346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307053346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307053346">(Oct 31 2022 at 08:13)</a>:</h4>
<p>As Swedes won't get tired to explain the Swedish åäö are separate vowels while the German äöü are umlaut, so it makes sense that there are different rules to transcribe them if they are not available :-)</p>



<a name="307085977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307085977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307085977">(Oct 31 2022 at 11:51)</a>:</h4>
<p>Indeed I could have this discussion all day :-) Let me just say that I agree with the conclusion: we have two different languages with two different conventions and they both make sense. Most occurrences of äö in mathlib are surely German, but there's also <a href="https://leanprover-community.github.io/mathlib_docs/find/picard_lindelof">docs#picard_lindelof</a> and <a href="https://tqft.net/mathlib/analysis/complex/phragmen_lindelof">file#analysis/complex/phragmen_lindelof</a>, where I approve of the status quo</p>



<a name="307105417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/307105417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#307105417">(Oct 31 2022 at 13:41)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Umlaut_(diacritic)#History">https://en.wikipedia.org/wiki/Umlaut_(diacritic)#History</a> The German <code>ö ↦ oe</code> phenomenon has a good historical explanation: it reverts a process that took place several centuries ago.</p>



<a name="308490474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308490474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308490474">(Nov 07 2022 at 23:09)</a>:</h4>
<blockquote>
<p>In the example of subgroups of a group, <code>is_maximal H K </code>means that <code>H</code> is a maximal <em>normal</em> subgroup of <code>K</code>.</p>
</blockquote>
<p>Let me note that if you take the lattice of <em>normal</em> subgroups and consider the <code>covby</code> relation, then the composition_series you get is called a <a href="https://en.wikipedia.org/wiki/Chief_series">chief series</a>. Normal subgroups and submodules are both examples of  <a href="https://en.wikipedia.org/wiki/Group_with_operators">Ω-subgroups</a>, and it's apparently possible to <a href="https://en.wikipedia.org/wiki/Composition_series#Generalization">unify both cases</a>.</p>
<p>(Update: Wikipedia says <a href="https://en.wikipedia.org/wiki/Zassenhaus_lemma">the butterfly lemma</a> (not in mathlib?) holds for the lattice of Ω-subgroups for any choice of Ω. Maybe that's how you may unify the proofs.)</p>



<a name="308569084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308569084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308569084">(Nov 08 2022 at 11:54)</a>:</h4>
<p>But is it a good idea to set up a theory for Omega groups (or I guess monoids acting on groups sounds slightly more modern)? Certainly you won't want to define a module as a commutative Omega group with extra properties.</p>



<a name="308569451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308569451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308569451">(Nov 08 2022 at 11:57)</a>:</h4>
<p>I think the current approach is already general enough. <br>
We might want to separate the <code>is_maximal</code> and <code>iso</code> part of the typeclass so that composition series of modules is definitionally equal to compositon series on modular lattices.</p>



<a name="308577003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308577003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308577003">(Nov 08 2022 at 12:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem/near/307003896">said</a>:</p>
<blockquote>
<p>Somehow this is still <code>covby</code>, simply in another lattice <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>
</blockquote>
<p>It isn't really, because the relation of being a normal subgroup is not transitive</p>



<a name="308577824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308577824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308577824">(Nov 08 2022 at 12:53)</a>:</h4>
<p>Then we just need a generalization of lattices where <code>le</code> need not be transitive <span aria-label="yum" class="emoji emoji-1f60b" role="img" title="yum">:yum:</span></p>



<a name="308578194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308578194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308578194">(Nov 08 2022 at 12:55)</a>:</h4>
<p>it makes me wonder though how often transitivity is used in all those proofs</p>



<a name="308590896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308590896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308590896">(Nov 08 2022 at 13:47)</a>:</h4>
<p>Actually, maybe just taking the transitive closure of the normal subgroup relation works.</p>



<a name="308608093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308608093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308608093">(Nov 08 2022 at 15:12)</a>:</h4>
<p>Since we take <code>is_maximal</code> to be <code>covby</code> I guess we don't care about those extra relations.</p>



<a name="308608203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308608203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daan van Gent <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308608203">(Nov 08 2022 at 15:12)</a>:</h4>
<p>Side note:  Is it a problem that our underlying set <code>subgroup G</code> gets two partial orders (the usual inclusion and the closure of normal_in)?</p>



<a name="308624028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308624028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308624028">(Nov 08 2022 at 16:27)</a>:</h4>
<blockquote>
<p>But is it a good idea to set up a theory for Omega groups (or I guess monoids acting on groups sounds slightly more modern)? Certainly you won't want to define a module as a commutative Omega group with extra properties.</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_distrib_mul_action">docs#mul_distrib_mul_action</a> is the proper typeclass, and <a href="https://leanprover-community.github.io/mathlib_docs/find/module">docs#module</a> extends its additive version <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action">docs#distrib_mul_action</a>. So if to_additive can handle this, then you can write the code for Ω-groups and it automatically applies to modules. We'd also need the multiplicative version of <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule">docs#submodule</a>, and relax <code>[module]</code> to <code>[distrib_mul_action]</code>, but this has <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/297067912">led to timeout</a>. Maybe after transition to Lean 4?</p>



<a name="308629252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308629252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308629252">(Nov 08 2022 at 16:53)</a>:</h4>
<blockquote>
<p>Actually, maybe just taking the transitive closure of the normal subgroup relation works.</p>
</blockquote>
<p>This isn't a lattice though. If H is a maximal subgroup in the whole group G that is not normal, then H and G have no supremum :( G isn't a top element, even though the trivial group is always a bottom element.</p>



<a name="308652380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308652380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308652380">(Nov 08 2022 at 18:52)</a>:</h4>
<p>If we only consider those subgroups reachable from the whole group G via (the transitive closure of) the normal-subgroup relation, i.e. the <a href="https://en.wikipedia.org/wiki/Subnormal_subgroup">subnormal subgroups</a>, it's true that a subnormal subgroup H of G is a subnormal subgroup of any subgroup containing it, so the transitive closure of the normal-subgroup relation is just the subgroup relation on subnormal subgroups, and the intersection of two subnormal subgroups is still subnormal so infima exist. However, the subgroup generated by two subnormal subgroups may not be subnormal, so it's not clear whether the supremum exists. <a href="https://math.stackexchange.com/a/1319663/12932">https://math.stackexchange.com/a/1319663/12932</a></p>



<a name="308653690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jordan%20H%C3%B6lder%20theorem/near/308653690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jordan.20H.C3.B6lder.20theorem.html#308653690">(Nov 08 2022 at 18:59)</a>:</h4>
<blockquote>
<p>Side note: Is it a problem that our underlying set subgroup G gets two partial orders (the usual inclusion and the closure of normal_in)?</p>
</blockquote>
<p>I think we don't need to do this; I think in the general situation, the <code>is_maximal H K</code> relation on the lattice of Ω-subgroup is always "H is a maximal Ω-stable normal subgroup in K" (Ω-stable subgroup means the same thing as Ω-subgroup and is a notion independent of K). When G is commutative (e.g. it's a module) or when Ω is the inner automorphisms (so H is normal in G and hence in K), the normality requirement is vacuous and we recover the <code>covby</code> relation.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
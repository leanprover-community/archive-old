---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Computing.20Roth.20numbers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html">Computing Roth numbers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263729893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263729893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263729893">(Dec 04 2021 at 20:30)</a>:</h4>
<p>In <a href="https://github.com/leanprover-community/mathlib/issues/10509">#10509</a>, Bhavik and I are computing small Roth numbers. The <code>n</code>-th Roth number is the size of the largest subset of <code>finset.range n</code> which doesn't contain arithmetic progressions of length 3 (aka Salem-Spencer set). Our current decidability instances (aka algorithms <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span>) for <code>roth_number_nat n ≤ m</code> run in <code>O (n.choose m * m^2)</code>. Can we do better?</p>



<a name="263730223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730223">(Dec 04 2021 at 20:38)</a>:</h4>
<p>One idea would be to define inductively the maximal (wrt inclusion) Salem-Spencer subsets of a finset. This can work quite quickly because you know that a maximal Salem-Spencer subset of <code>insert a s</code> is a maximal Salem-Spencer subset of <code>s</code> with eventually <code>a</code> added.</p>



<a name="263730329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730329">(Dec 04 2021 at 20:41)</a>:</h4>
<p>And we can trim further by restricting to maximal Salem-Spencer subsets but this time wrt card. It happens that quite often there's a unique such maximal subset, which can speed up subsequent calculations.</p>



<a name="263730528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730528">(Dec 04 2021 at 20:46)</a>:</h4>
<p>I guess this is a question to <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, how much can we get out of working over lists rather than finsets, and is there any way we can speed up using some lazy evaluation or related black magic?</p>



<a name="263730594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730594">(Dec 04 2021 at 20:48)</a>:</h4>
<p>Not exactly sure what the algorithm is, but it sounds like it's possible to do better</p>



<a name="263730616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730616">(Dec 04 2021 at 20:49)</a>:</h4>
<p>You probably don't need to do anything fancy with lazy evaluation, and it doesn't make much difference whether you are working over finsets or lists but lists are generally easier to work with</p>



<a name="263730623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730623">(Dec 04 2021 at 20:49)</a>:</h4>
<p>also you don't want to use <code>insert</code> to build a finset unless you have to</p>



<a name="263730730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730730">(Dec 04 2021 at 20:52)</a>:</h4>
<p>What would you use instead of <code>insert</code>?</p>



<a name="263730760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730760">(Dec 04 2021 at 20:52)</a>:</h4>
<p><code>cons</code></p>



<a name="263730765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730765">(Dec 04 2021 at 20:52)</a>:</h4>
<p>Ah sure!</p>



<a name="263730882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263730882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263730882">(Dec 04 2021 at 20:55)</a>:</h4>
<p>Another perk of lists is that you can use the underlying order on the elements to cut down by a factor of 3 or 6 the amount of computation required.</p>



<a name="263731611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263731611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263731611">(Dec 04 2021 at 21:12)</a>:</h4>
<p>I can't tell if this is correct. It seems to be unique all the time</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">check</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l.all</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="n">check</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">maximal_salem_spencer</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">[(</span><span class="mi">0</span><span class="o">,</span> <span class="o">[])]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">ls</span> <span class="o">:=</span> <span class="n">maximal_salem_spencer</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">candidates</span> <span class="o">:=</span> <span class="n">ls.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="k">if</span> <span class="n">check</span> <span class="n">n</span> <span class="n">p.2</span> <span class="k">then</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">::</span><span class="n">p.2</span><span class="o">)</span> <span class="k">else</span> <span class="n">p</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">maxlen</span> <span class="o">:=</span> <span class="n">candidates.foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">l</span><span class="o">,</span> <span class="n">max</span> <span class="n">a</span> <span class="n">l.1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="n">candidates.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">maxlen</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">maximal_salem_spencer</span> <span class="mi">80</span>
<span class="c1">-- [(59, [79, 78, 77, 74, 73, 71, 70, 69, 67, 66, 65, 62, 61, 59, 58, 57, 56, 55, 54, 53, 51, 48, 47, 46,</span>
<span class="c1">--    43, 42, 41, 40, 39, 38, 37, 35, 34, 33, 31, 30, 29, 27, 26, 24, 23, 22, 21, 19, 17, 16, 15, 14, 13, 11, 10, 8, 7, 6, 5, 3, 2, 1, 0])]</span>
</code></pre></div>



<a name="263731780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263731780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263731780">(Dec 04 2021 at 21:16)</a>:</h4>
<p>I know it should be unique at 14, not unique for 15,16,17 or 18, and not unique at a few points below that too; it's definitely not unique at 4: {0,1,3} and {0,2,3} both work</p>



<a name="263732002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732002">(Dec 04 2021 at 21:20)</a>:</h4>
<p>It's worth adding that there has been research on this from the computer science side: eg <a href="https://www.cs.umd.edu/~gasarch/papers/3apI.pdf">https://www.cs.umd.edu/~gasarch/papers/3apI.pdf</a></p>



<a name="263732087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732087">(Dec 04 2021 at 21:22)</a>:</h4>
<p>There is an important difference however in that to prove lower bounds we can just provide an example (computed by someone else), but to prove upper bounds we'd need to re-do the search in Lean (or find some clever other method, which is itself hard)</p>



<a name="263732318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732318">(Dec 04 2021 at 21:26)</a>:</h4>
<p><code>check</code> should use addition instead of multiplication. Otherwise it looks correct to me</p>



<a name="263732327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732327">(Dec 04 2021 at 21:26)</a>:</h4>
<p>The numbers all seem to match the computations in the PR but it's definitely not finding all the solutions</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">check</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l.all</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="n">check</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">maximal_salem_spencer</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">[(</span><span class="mi">0</span><span class="o">,</span> <span class="o">[])]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">ls</span> <span class="o">:=</span> <span class="n">maximal_salem_spencer</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">candidates</span> <span class="o">:=</span> <span class="n">ls.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="k">if</span> <span class="n">check</span> <span class="n">n</span> <span class="n">p.2</span> <span class="k">then</span> <span class="o">(</span><span class="n">p.1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">::</span><span class="n">p.2</span><span class="o">)</span> <span class="k">else</span> <span class="n">p</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">maxlen</span> <span class="o">:=</span> <span class="n">candidates.foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">l</span><span class="o">,</span> <span class="n">max</span> <span class="n">a</span> <span class="n">l.1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="n">candidates.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">maxlen</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">list.range</span> <span class="mi">50</span><span class="o">)</span><span class="bp">.</span><span class="n">mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">maximal_salem_spencer</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">sformat</span><span class="bp">!</span><span class="s2">"roth {n} = {p.head.1}, {p.length} solutions"</span><span class="o">)</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">roth</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">6</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">7</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">8</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">9</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">10</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">11</span> <span class="bp">=</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">12</span> <span class="bp">=</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">13</span> <span class="bp">=</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
<span class="n">roth</span> <span class="mi">14</span> <span class="bp">=</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">1</span> <span class="n">solutions</span>
</code></pre></div>



<a name="263732438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732438">(Dec 04 2021 at 21:28)</a>:</h4>
<p>In the example for 4, the issue is that {0, 2} is not marked as a maximal set for n = 3 because it is not obtained by adding 2 to a maximal set for n = 2</p>



<a name="263732475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732475">(Dec 04 2021 at 21:29)</a>:</h4>
<p>Oh, so you need to keep track of all maximal sets wrt inclusion.</p>



<a name="263732588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732588">(Dec 04 2021 at 21:32)</a>:</h4>
<p><code>roth 51</code> should be 17, for example - but <code>maximal_salem_spencer</code> computes 16</p>



<a name="263732637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732637">(Dec 04 2021 at 21:32)</a>:</h4>
<p>Wait, that doesn't work either <span aria-label="confused" class="emoji emoji-1f615" role="img" title="confused">:confused:</span></p>



<a name="263732640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732640">(Dec 04 2021 at 21:32)</a>:</h4>
<p>Even removing the max size restriction doesn't help, because {0} is not maximal wrt inclusion for n = 2 but it participates in a maximal set for n = 3</p>



<a name="263732688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732688">(Dec 04 2021 at 21:33)</a>:</h4>
<p>So what's true is that if the Roth number increases, then the new maximal Salem-Spencer subsets come from previous ones.</p>



<a name="263732742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732742">(Dec 04 2021 at 21:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263732588">said</a>:</p>
<blockquote>
<p><code>roth 51</code> should be 17, for example - but <code>maximal_salem_spencer</code> computes 16</p>
</blockquote>
<p><code>1 2 4 5 10 13 14 17 31 35 37 38 40 46 47 50 51</code> (1-indexed rather than 0-indexed, sorry) is an example</p>



<a name="263732771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732771">(Dec 04 2021 at 21:35)</a>:</h4>
<p>And if it doesn't increase, then it comes from a previous maximal subset, or a previous almost maximal subset</p>



<a name="263732777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732777">(Dec 04 2021 at 21:35)</a>:</h4>
<p>maybe the candidates need to consider not just <code>n :: l</code> where l is from the previous set but also <code>n :: (l \ a)</code> where a is an element from l</p>



<a name="263732866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263732866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263732866">(Dec 04 2021 at 21:37)</a>:</h4>
<p>May I point you to the paper I linked above to save some time, since there are some algorithms given to do these computations (eg in section 6 - also section 9 talks about a dynamic program which I think is similar to the one above)</p>



<a name="263735966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263735966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263735966">(Dec 04 2021 at 22:45)</a>:</h4>
<p>I think this is a rendering of the BASIC2 algorithm from the paper:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">three_free</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l.all</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="n">three_free</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">roth_aux</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">s</span> <span class="o">::</span> <span class="n">sz</span><span class="o">)</span> <span class="n">n</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">((</span><span class="n">s</span> <span class="bp">≥</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="n">roth_aux</span> <span class="n">sz</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="bp">||</span>
  <span class="o">(</span><span class="n">three_free</span> <span class="n">n</span> <span class="n">α</span> <span class="bp">&amp;&amp;</span> <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">tt</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">d'</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">roth_aux</span> <span class="n">sz</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d'</span> <span class="o">(</span><span class="n">n</span> <span class="o">::</span> <span class="n">α</span><span class="o">)</span>
    <span class="kd">end</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">roth</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">list</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">roth</span> <span class="n">n</span> <span class="k">in</span> <span class="o">(</span><span class="k">if</span> <span class="n">roth_aux</span> <span class="o">(</span><span class="n">a</span><span class="o">::</span><span class="n">l</span><span class="o">)</span> <span class="mi">0</span> <span class="n">a</span> <span class="o">[]</span> <span class="k">then</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">roth</span> <span class="mi">40</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">reverse.enum</span>
<span class="c1">-- [(0, 0), (1, 1), (2, 2), (3, 2), (4, 3), (5, 4), (6, 4), (7, 4), (8, 4), (9, 5), (10, 5), (11, 6), (12, 6), (13, 7), (14, 8), (15, 8),</span>
<span class="c1">--  (16, 8), (17, 8), (18, 8), (19, 8), (20, 9), (21, 9), (22, 9), (23, 9), (24, 10), (25, 10), (26, 11), (27, 11), (28, 11), (29, 11), (30, 12),</span>
<span class="c1">--  (31, 12), (32, 13), (33, 13), (34, 13), (35, 13), (36, 14), (37, 14), (38, 14), (39, 14)]</span>
</code></pre></div>



<a name="263735972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263735972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263735972">(Dec 04 2021 at 22:45)</a>:</h4>
<p>unfortunately it times out before getting to 51</p>



<a name="263736300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263736300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263736300">(Dec 04 2021 at 22:53)</a>:</h4>
<p>That's already much better than we what we currently have! Ours times out at 15.</p>



<a name="263736769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263736769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263736769">(Dec 04 2021 at 23:03)</a>:</h4>
<p>oh hey, I ran it at the console and it gave <code>roth 51 = 17</code></p>



<a name="263736815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263736815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263736815">(Dec 04 2021 at 23:04)</a>:</h4>
<p>after 49 seconds</p>



<a name="263736854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263736854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263736854">(Dec 04 2021 at 23:05)</a>:</h4>
<p>I leave the proof of correctness as an exercise to the reader :D</p>



<a name="263736946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263736946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263736946">(Dec 04 2021 at 23:07)</a>:</h4>
<p>This ios gonna be a tough one <span aria-label="cold sweat" class="emoji emoji-1f630" role="img" title="cold sweat">:cold_sweat:</span></p>



<a name="263737228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737228">(Dec 04 2021 at 23:14)</a>:</h4>
<p>Is there any reason to use <code>bool</code> here? Does it compute faster somehow?</p>



<a name="263737238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737238">(Dec 04 2021 at 23:14)</a>:</h4>
<p>faster than what?</p>



<a name="263737254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737254">(Dec 04 2021 at 23:15)</a>:</h4>
<p>than <code>Prop</code></p>



<a name="263737307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737307">(Dec 04 2021 at 23:16)</a>:</h4>
<p>prop doesn't compute at all; you would have to write a decidability instance on top of this, which would more than double the length (more because the decidability instance is dependent over the original function so it has to do a bunch of cases and simp stuff)</p>



<a name="263737321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737321">(Dec 04 2021 at 23:16)</a>:</h4>
<p>you can think of <code>bool</code> as being a cheap way to bundle a prop with its decidability instance</p>



<a name="263737333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737333">(Dec 04 2021 at 23:17)</a>:</h4>
<p>Also, I want to be very sure that the <code>&amp;&amp;</code> and <code>||</code> are short circuiting here, otherwise the algorithm doesn't work at all</p>



<a name="263737383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737383">(Dec 04 2021 at 23:18)</a>:</h4>
<p>Aaah okay. I had never seen how both ways of computing relate. And, to be honest, I had no idea how to compute anything remotely nontrivial until 4 days ago.</p>



<a name="263737454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737454">(Dec 04 2021 at 23:20)</a>:</h4>
<p>ANd what's the correct way to get information out of a <code>bool</code>? That is, what should my lemma relating <code>roth_number_nat</code>/|<code>add_salem_spencer</code> and your <code>roth</code> be writing? <code>a = tt</code>?</p>



<a name="263737472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737472">(Dec 04 2021 at 23:21)</a>:</h4>
<p>there are coercions both ways and simp lemmas every which way, so you don't have to acknowledge the difference for the most part</p>



<a name="263737528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737528">(Dec 04 2021 at 23:22)</a>:</h4>
<p>So something like <code>salem_spencer _ ↔ three_free _ </code> will do?</p>



<a name="263737537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737537">(Dec 04 2021 at 23:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">roth_number_nat</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">list.range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">roth_number_nat</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="263737542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737542">(Dec 04 2021 at 23:23)</a>:</h4>
<p>Is it better in lean 4?</p>



<a name="263737669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737669">(Dec 04 2021 at 23:26)</a>:</h4>
<p>Yeah sure, but what about <code>three_free</code>? I will ned to prove that <code>three_free</code> is equivalent to <code>add_salem_spencer</code> to prove correctness of the algorithm.</p>



<a name="263737738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263737738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263737738">(Dec 04 2021 at 23:28)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">})</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">three_free</span> <span class="n">a</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="263738289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263738289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263738289">(Dec 04 2021 at 23:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="n">n</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">})</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">list.chain'</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">roth_number_nat</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">α.length</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">roth_aux</span> <span class="o">((</span><span class="n">list.range</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">roth_number_nat</span><span class="o">)</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">β</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">β</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">β</span> <span class="bp">→</span>
    <span class="n">add_salem_spencer</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">nat.card</span> <span class="n">β</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="263743109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263743109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263743109">(Dec 05 2021 at 01:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263736300">said</a>:</p>
<blockquote>
<p>That's already much better than we what we currently have! Ours times out at 15.</p>
</blockquote>
<p>This is more awkward than I expected; our original one computes via #eval at 17 (maybe 18); but <code>:= rfl</code> or <code>:= dec_trivial</code> times out instead, similarly <code>(roth 40).1 = 15 := dec_trivial</code> doesn't work either :/</p>



<a name="263743148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263743148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263743148">(Dec 05 2021 at 01:46)</a>:</h4>
<p>Nonetheless the new version does get further than my crappy version in both metrics</p>



<a name="263758509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263758509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263758509">(Dec 05 2021 at 09:12)</a>:</h4>
<p>Is there any way to reuse calculations from one lemma for another? This would clearly come in handy here.</p>



<a name="263776215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263776215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263776215">(Dec 05 2021 at 16:28)</a>:</h4>
<p>If there were a lemma which stated the result of some calculations, then a later lemma wouldn't need to repeat them since they'd been proved</p>



<a name="263776494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263776494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263776494">(Dec 05 2021 at 16:35)</a>:</h4>
<p>Yes of course, but I was fearing that the results would be too long to state.</p>



<a name="263776608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263776608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263776608">(Dec 05 2021 at 16:36)</a>:</h4>
<p>While I was under the Channel I figured out that Mario's version is compact enough for this.</p>



<a name="263821660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263821660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263821660">(Dec 06 2021 at 08:48)</a>:</h4>
<p>Okay, I managed to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">three_free_spec</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">three_free</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">}</span> <span class="o">:=</span>
</code></pre></div>
<p>This was Not So Fun.  Also, why is <code>add_salem_spencer {n | n ∈ l}</code> needed?</p>



<a name="263821864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263821864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263821864">(Dec 06 2021 at 08:50)</a>:</h4>
<p>This is becoming big, so I'm gonna get rid of the <code>explicit_values</code> bit of the PR.</p>



<a name="263833989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263833989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263833989">(Dec 06 2021 at 10:58)</a>:</h4>
<p>because <code>add_salem_spencer</code> is about sets while <code>three_free</code> is about lists. Alternatively, you could coerce the list to a finset and then to a set, but there isn't a coercion from lists directly to sets at the moment.</p>



<a name="263834034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263834034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263834034">(Dec 06 2021 at 10:58)</a>:</h4>
<p>I'm curious what your proof was, because it seems like it wouldn't be <em>that</em> bad</p>



<a name="263834118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263834118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263834118">(Dec 06 2021 at 10:59)</a>:</h4>
<p>In fact, it might help to have a theorem about <code>add_salem_spencer (insert a s)</code> and apply it here</p>



<a name="263834552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263834552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263834552">(Dec 06 2021 at 11:02)</a>:</h4>
<p>I did add a theorem <code>add_salem_spencer_insert</code> to reduce the number of cases to check from 3 (new element on the left of the LHS, on the right of the LHS, on the RHS) to 2 (on the LHS, on the RHS).</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>The proof</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite"><pre><span></span><code>lemma three_free_spec (hl : chain (&gt;) a l) (h₁ : add_salem_spencer {n | n ∈ l}) :
  three_free a l ↔ add_salem_spencer {n | n ∈ a :: l} :=
begin
  induction l with d l ih,
  { refine iff_of_true rfl _,
    simp_rw [mem_singleton, set.set_of_eq_eq_singleton],
    exact add_salem_spencer_singleton a },
  have : {n : ℕ | n ∈ a :: d :: l} = insert d {n : ℕ | n ∈ a :: l},
  { ext,
    simp only [set.mem_insert_iff, mem_cons_iff, set.mem_set_of_eq],
    exact or.left_comm },
  rw [this, three_free, bool.band_comm, band_coe_iff, bool.coe_all,
    ih (hl.mono $ sublist_cons _ _) (h₁.mono $ l.subset_cons _), add_salem_spencer_insert],
  simp_rw bool.coe_to_bool,
  refine and_congr_right (λ hl&#39;, ⟨λ hs, ⟨_, _⟩, _⟩),
  { rintro b c (rfl | hb) (rfl | hc),
    { exact add_right_cancel },
    { rintro h,
      cases hl with _ _ _ _ hdb hl,
      have hcd : c &lt; d := hl.rel hc,
      exact ((add_lt_add hcd $ hcd.trans hdb).ne&#39; h).elim },
    { exact λ h, ((add_lt_add (rel_of_chain_cons hl : c &gt; d) $
        hl.rel $ mem_cons_of_mem _ hb).ne h).elim },
    { exact h₁ (mem_cons_self _ _) (mem_cons_of_mem _ hb) (mem_cons_of_mem _ hc) } },
  { rintro b c (rfl | hb) (rfl | hc),
    { exact λ _, rfl },
    { exact λ h, (hs _ hc h).elim },
    { exact λ h, (hs _ hb $ (add_comm _ _).trans h).elim },
    { exact h₁ (mem_cons_of_mem _ hb) (mem_cons_of_mem _ hc) (mem_cons_self _ _) } },
  { rintro ⟨_, hs⟩ b hb h,
    have hab : a = b := hs (mem_cons_self _ _) (or.inr hb) h,
    rw hab at hl h,
    have hbd : b &gt; d := rel_of_chain_cons hl,
    exact (add_lt_add hbd hbd).ne&#39; h }
end
</code></pre></div>
</div></div>



<a name="263834666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263834666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263834666">(Dec 06 2021 at 11:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263833989">said</a>:</p>
<blockquote>
<p>because <code>add_salem_spencer</code> is about sets while <code>three_free</code> is about lists.</p>
</blockquote>
<p>That explains the notation <code>{n | n ∈ l}</code>, but not why we need the hypothesis, unless you mean because of the order in the list?</p>



<a name="263834827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263834827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263834827">(Dec 06 2021 at 11:05)</a>:</h4>
<p>Also, is this supposed to be true?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">three_free.of_cons'</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">three_free</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">))</span> <span class="o">:</span> <span class="n">three_free</span> <span class="n">b</span> <span class="n">l</span> <span class="o">:=</span>
</code></pre></div>



<a name="263834985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263834985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263834985">(Dec 06 2021 at 11:07)</a>:</h4>
<p>no</p>



<a name="263835033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835033">(Dec 06 2021 at 11:07)</a>:</h4>
<p><code>three_free</code> is checking only whether adding <code>a</code> to <code>l</code> keeps it three-free</p>



<a name="263835132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835132">(Dec 06 2021 at 11:08)</a>:</h4>
<p>Yeah okay that's what I thought. You never check for <code>b</code> on the LHS.</p>



<a name="263835173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835173">(Dec 06 2021 at 11:08)</a>:</h4>
<p>also the ordering relation is used to ensure that the only thing we have to check is <code>a + c = b + b</code> and not other permutations of that</p>



<a name="263835179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835179">(Dec 06 2021 at 11:08)</a>:</h4>
<p>but I guess you figured that out already</p>



<a name="263835213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835213">(Dec 06 2021 at 11:09)</a>:</h4>
<p>Yeah, that's what I was trying to get to before Bhavik sent the paper.</p>



<a name="263835775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835775">(Dec 06 2021 at 11:14)</a>:</h4>
<p>do you have an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> version of that proof? I pulled the PR but I don't have <code>add_salem_spencer_singleton</code>, <code>bool.coe_all</code> and possibly others</p>



<a name="263835829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263835829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263835829">(Dec 06 2021 at 11:15)</a>:</h4>
<p>Let me 5min. I'll remove the <code>explicit_values</code> off the PR and put that on a new branch <code>small_roth</code>.</p>



<a name="263836220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263836220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263836220">(Dec 06 2021 at 11:19)</a>:</h4>
<p>I suspect that a lot of the work can be reduced to things like <code>list.pairwise_iff_chain</code> for sorted lists, and expressing the salem spencer property as <code>pairwise</code> of something</p>



<a name="263836242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263836242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263836242">(Dec 06 2021 at 11:19)</a>:</h4>
<p>although it's a ternary property which makes it harder</p>



<a name="263836372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263836372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263836372">(Dec 06 2021 at 11:20)</a>:</h4>
<p>Pushed!</p>



<a name="263836457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263836457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263836457">(Dec 06 2021 at 11:21)</a>:</h4>
<p>I thought about that, but decided it wasn't worth changing because the list appearing in <code>list.chain</code> (<code>d :: l</code>) has one <code>cons</code> while the one in <code>list.pairwise</code> (<code>a :: d :: l</code>) has two, so you spend more time just looking into it.</p>



<a name="263837820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263837820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263837820">(Dec 06 2021 at 11:37)</a>:</h4>
<p>It's still missing <code>coe_all</code> and <code>list.chain.mono</code>. (BTW for the second one I've inferred the theorem statement</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.chain.mono</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">l'</span> <span class="bp">&lt;+</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l.chain</span> <span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">l'.chain</span> <span class="n">R</span> <span class="n">a</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>but I would have preferred this name to be dealing with monotonicity wrt <code>R</code>.)</p>



<a name="263838008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263838008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263838008">(Dec 06 2021 at 11:39)</a>:</h4>
<p><code>bool.coe_all</code> and <code>list.chain.mono</code> are in namespaces at lines 53 and 83 respectively.</p>



<a name="263838124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263838124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263838124">(Dec 06 2021 at 11:40)</a>:</h4>
<p>i'll be happy to rename <code>list.chain.mono</code> into <code>list.chain.sublist</code> because it's also clearer that it's monotonicity wrt <code>list.sublist</code>, not <code>list.prefix</code> or <code>list.suffix</code>.</p>



<a name="263838340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263838340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263838340">(Dec 06 2021 at 11:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263838008">said</a>:</p>
<blockquote>
<p><code>bool.coe_all</code> and <code>list.chain.mono</code> are in namespaces at lines 53 and 83 respectively.</p>
</blockquote>
<p>in the <code>salem_spencer</code> PR? I don't see it.</p>



<a name="263838460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263838460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263838460">(Dec 06 2021 at 11:44)</a>:</h4>
<p>No, in <a href="https://github.com/leanprover-community/mathlib/tree/small_roth">branch#small_roth</a></p>



<a name="263838480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263838480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263838480">(Dec 06 2021 at 11:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263835829">said</a>:</p>
<blockquote>
<p>Let me 5min. I'll remove the <code>explicit_values</code> off the PR and put that on a new branch <code>small_roth</code>.</p>
</blockquote>
<p>Sorry you must've missed that</p>



<a name="263843218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263843218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263843218">(Dec 06 2021 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263737537">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">roth_number_nat</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">list.range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">roth_number_nat</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This is missing a <code>reverse</code>. <code>list.range</code> goes the wrong way.</p>



<a name="263844370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263844370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263844370">(Dec 06 2021 at 12:46)</a>:</h4>
<p><code>list.iota</code> might work then</p>



<a name="263844416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263844416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263844416">(Dec 06 2021 at 12:47)</a>:</h4>
<p>it might be off by one</p>



<a name="263847652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263847652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263847652">(Dec 06 2021 at 13:15)</a>:</h4>
<p>What is each variable in <code>roth_aux</code> supposed to represent?</p>



<a name="263849034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263849034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263849034">(Dec 06 2021 at 13:26)</a>:</h4>
<p>Here's a shorter proof for <code>three_free_spec</code> making more use of <code>pairwise</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">list.forall_of_forall_of_pairwise_flip</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">R</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">pairwise</span> <span class="n">R</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">H₃</span> <span class="o">:</span> <span class="n">pairwise</span> <span class="o">(</span><span class="n">flip</span> <span class="n">R</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">),</span> <span class="n">R</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">three_free_spec</span> <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">three_free</span> <span class="n">a</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">transitivity</span> <span class="n">list.pairwise</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="n">l</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">clear</span> <span class="n">hl</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">l</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">three_free</span><span class="o">,</span> <span class="n">list.pairwise.nil</span><span class="o">,</span> <span class="n">list.pairwise.cons</span><span class="o">,</span> <span class="n">bool.coe_all</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">}</span> <span class="bp">=</span> <span class="n">insert</span> <span class="n">a</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_insert_iff</span><span class="o">,</span> <span class="n">mem_cons_iff</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">add_salem_spencer_insert</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">forall_of_forall_of_pairwise_flip</span> <span class="n">_</span> <span class="n">H</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hc</span> <span class="n">_</span> <span class="n">hb</span> <span class="n">e</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">ne_of_gt</span> <span class="o">(</span><span class="n">add_lt_add_right</span> <span class="o">(</span><span class="n">hl.rel</span> <span class="n">hb</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">transitive</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">lt_trans</span> <span class="n">h2</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">pairwise_cons.1</span> <span class="o">((</span><span class="n">chain_iff_pairwise</span> <span class="n">this</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hl</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">imp_of_mem</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">ne_of_gt</span> <span class="o">(</span><span class="n">add_lt_add</span> <span class="o">(</span><span class="n">hl.rel</span> <span class="n">hc</span><span class="o">)</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">ne_of_lt</span> <span class="o">(</span><span class="n">add_lt_add</span> <span class="o">(</span><span class="n">hl.rel</span> <span class="n">hb</span><span class="o">)</span> <span class="o">(</span><span class="n">hl.rel</span> <span class="n">hc</span><span class="o">))</span> <span class="n">e</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">pairwise.imp_mem.2</span> <span class="o">(</span><span class="n">pairwise_of_forall</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="n">b</span> <span class="n">hc</span> <span class="n">hb</span> <span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">)),</span>
    <span class="n">exact</span> <span class="n">ne_of_gt</span> <span class="o">(</span><span class="n">hl.rel</span> <span class="n">hb</span><span class="o">)</span> <span class="o">(</span><span class="n">H.2.1</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">e</span><span class="o">)</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="263850070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263850070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263850070">(Dec 06 2021 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span></p>
<ul>
<li><code>sz</code> is the list of previous roth values, but only up to a bound <code>s</code> satisfying <code>s + m = n + 1</code>.</li>
<li><code>n</code> is a constant, and does not actually appear in <code>roth_aux</code>, but <code>s</code> goes down as <code>m</code> goes up.</li>
<li>In the paper, <code>m</code> corresponds to <code>|α|</code>.</li>
<li><code>d</code> corresponds to <code>roth n - #α</code>; we're trying to find out if <code>roth (n+1) = roth n</code> or <code>roth (n+1) = roth n + 1</code>, so if <code>d</code> underflows then we're done.</li>
<li><code>α</code> is the bitstring <code>α</code> from the paper, except that it is represented as a list of nat instead of a 0-1 string, so <code>α.length</code> is <code>#α</code> and <code>|α|</code> has to be tracked separately (that's <code>m</code>).</li>
</ul>



<a name="263850185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263850185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263850185">(Dec 06 2021 at 13:34)</a>:</h4>
<p>You can read a lot of this from the statement of <code>roth_aux_spec</code></p>



<a name="263852601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263852601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263852601">(Dec 06 2021 at 13:54)</a>:</h4>
<p>Oh, the statement of <code>roth_aux_spec</code> is wrong, the <code>n</code> at the end should be <code>roth_number_nat n</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="n">n</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">})</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">list.chain'</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">roth_number_nat</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">α.length</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span> <span class="n">roth_aux</span> <span class="o">((</span><span class="n">list.range</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">roth_number_nat</span><span class="o">)</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="bp">↔</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">β</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">β</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">β</span> <span class="bp">→</span>
    <span class="n">add_salem_spencer</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">nat.card</span> <span class="n">β</span> <span class="bp">≤</span> <span class="n">roth_number_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="263853984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263853984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263853984">(Dec 06 2021 at 14:05)</a>:</h4>
<p>Here's another way to write <code>roth_aux</code> in terms of a set of lemmas which expresses a nondeterministic computation along the lines of <code>roth_aux</code>. <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Do you think it would be easier to prove these lemmas instead of <code>roth_aux_spec</code>? The nondeterminism is a boon, because it means that many things don't have to be checked: any branches of the search that turned out not to matter are not explored.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">roth_ub_aux</span> <span class="o">(</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">list.chain'</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">α</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">β</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">β</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">}</span> <span class="bp">⊆</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">add_salem_spencer</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">nat.card</span> <span class="n">β</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">α.length</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux_zero</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">roth_ub_aux₁</span> <span class="o">(</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">d</span> <span class="bp">≥</span> <span class="n">roth_number_nat</span> <span class="n">s</span> <span class="bp">∨</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">roth_ub_aux₂</span> <span class="o">(</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">¬</span> <span class="n">three_free</span> <span class="n">m</span> <span class="n">α</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">d'</span><span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">d'</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d'</span> <span class="o">(</span><span class="n">m</span> <span class="o">::</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux_succ</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">roth_ub_aux₁</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">roth_ub_aux₂</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="o">(</span><span class="n">s</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₁_left</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_number_nat</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux₁</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₁_right</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux₁</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inr</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₂_left</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">three_free</span> <span class="n">m</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux₂</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₂_right</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="o">(</span><span class="n">m</span><span class="o">::</span><span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">roth_ub_aux₂</span> <span class="n">s</span> <span class="n">m</span> <span class="o">(</span><span class="n">d</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inr</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux_out</span> <span class="o">{</span><span class="n">n</span> <span class="n">d</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">d</span> <span class="o">[])</span> <span class="o">:</span> <span class="n">roth_number_nat</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">d</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="263854525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263854525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263854525">(Dec 06 2021 at 14:09)</a>:</h4>
<p>This set of lemmas is tuned for proving that <code>roth (n+1) = roth n</code>, because that's the hard case; you can also skip a row of roth numbers that are all the same and only work on the last case before it increases. When the number goes up, it's easy because you just need a counterexample</p>



<a name="263884441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263884441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263884441">(Dec 06 2021 at 17:22)</a>:</h4>
<p>What do you mean by "nondeterministic computation"? I'm a bit lost by what you're trying to do, I think.</p>



<a name="263887160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263887160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263887160">(Dec 06 2021 at 17:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263853984">said</a>:</p>
<blockquote>
<p>Here's another way to write <code>roth_aux</code> in terms of a set of lemmas which expresses a nondeterministic computation along the lines of <code>roth_aux</code>. <span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> Do you think it would be easier to prove these lemmas instead of <code>roth_aux_spec</code>? The nondeterminism is a boon, because it means that many things don't have to be checked: any branches of the search that turned out not to matter are not explored.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">roth_ub_aux</span> <span class="o">(</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">m</span> <span class="n">α</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">β</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">β</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β.filter</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">list.to_finset</span> <span class="n">α</span> <span class="bp">→</span>
<span class="n">add_salem_spencer</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β.card</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">α.length</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux_zero</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">roth_ub_aux₁</span> <span class="o">(</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">d</span> <span class="bp">≥</span> <span class="n">roth_number_nat</span> <span class="n">s</span> <span class="bp">∨</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">roth_ub_aux₂</span> <span class="o">(</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">¬</span> <span class="n">three_free</span> <span class="n">m</span> <span class="n">α</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">d'</span><span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">d'</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d'</span> <span class="o">(</span><span class="n">m</span> <span class="o">::</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux_succ</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">roth_ub_aux₁</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">roth_ub_aux₂</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="o">(</span><span class="n">s</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₁_left</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_number_nat</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux₁</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₁_right</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux₁</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inr</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₂_left</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">three_free</span> <span class="n">m</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_ub_aux₂</span> <span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux₂_right</span> <span class="o">{</span><span class="n">s</span> <span class="n">m</span> <span class="n">d</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="n">s</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="o">(</span><span class="n">m</span><span class="o">::</span><span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">roth_ub_aux₂</span> <span class="n">s</span> <span class="n">m</span> <span class="o">(</span><span class="n">d</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">or.inr</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">roth_ub_aux_out</span> <span class="o">{</span><span class="n">n</span> <span class="n">d</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">roth_ub_aux</span> <span class="n">n</span> <span class="mi">0</span> <span class="n">d</span> <span class="o">[])</span> <span class="o">:</span> <span class="n">roth_number_nat</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">d</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This looks very promising!</p>



<a name="263904866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263904866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263904866">(Dec 06 2021 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263884441">said</a>:</p>
<blockquote>
<p>What do you mean by "nondeterministic computation"? I'm a bit lost by what you're trying to do, I think.</p>
</blockquote>
<p>The set of lemmas mentioned there can be used to construct a proof of <code>roth_number_nat n &lt;= d</code> in a fairly obvious way: first apply <code>roth_ub_aux_out</code>, then <code>roth_ub_aux_succ</code>, then for each subgoal apply <code>roth_ub_aux[₁,₂]_left</code> or <code>roth_ub_aux[₁,₂]_right</code>, and keep going until you reach a leaf where you apply <code>roth_ub_aux_zero</code>. This exactly mimics the evaluation of the boolean expression in <code>roth_aux</code>, assuming that it evaluates to <code>ff</code>.</p>
<p>The part that is nondeterministic here is that unlike <code>roth_aux</code>, there is no "order of evaluation" here. In each of the two disjunctions you have a choice of two proofs, but for a boolean function <code>a &amp;&amp; b = ff</code> you have to first evaluate <code>a = ff</code>, or else <code>a = tt</code> and then <code>b = ff</code>. With the nondeterministic version you either evaluate <code>a = ff</code> or <code>b = ff</code>, so the computation of <code>a = tt</code> is saved (a significant win in the case <code>a := three_free a l</code>).</p>
<p>Furthermore, we also have an advantage in the first conjunct. Evaluating <code>d &lt; s</code> is cheap, so it's not that important to skip it, but in the revised lemmas that is actually a <code>roth_number_nat s ≤ d</code> assumption, which can be a reference to a previously proved theorem. But more powerfully, we can choose to use <code>roth_ub_aux₁_right</code> even when <code>roth_number_nat s ≤ d</code> is true. This is a bunch of extra work so at first it might seem counterproductive, but this can be used in order to skip steps in the Roth sequence.</p>
<p>For example, <code>roth 9 = 5</code> while <code>roth 5 .. 8 = 4</code>, so to prove all the values in this neighborhood it suffices to give bounds like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">roth</span> <span class="mi">4</span> <span class="bp">&lt;=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="bp">&lt;=</span> <span class="n">roth</span> <span class="mi">5</span>
<span class="n">roth</span> <span class="mi">8</span> <span class="bp">&lt;=</span> <span class="mi">4</span>
<span class="mi">5</span> <span class="bp">&lt;=</span> <span class="n">roth</span> <span class="mi">9</span>
<span class="bp">...</span>
</code></pre></div>
<p>Now consider the proof of <code>roth 8 &lt;= 4</code>, assuming we have the previous lines as lemmas. We don't have a proof that <code>roth 7 &lt;= 4</code> because we are skipping steps, so if it comes up that we need <code>roth 7 &lt;= 4</code> or <code>roth 6 &lt;= 4</code> when evaluating <code>roth_ub_aux₁_left</code>, we can just take the <code>roth_ub_aux₁_right</code> branch instead.</p>



<a name="263906091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263906091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263906091">(Dec 06 2021 at 19:37)</a>:</h4>
<p>So you don't mean to actually compute here? But rather to skip branches of the actual computation?</p>



<a name="263918091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/263918091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#263918091">(Dec 06 2021 at 20:17)</a>:</h4>
<p>Depends on what you mean by "actual computation". The proof term encodes a witness for a nondeterministic computation, while the tactic that produces the proof term executes a deterministic computation (in a significantly more efficient machine model). Depending on how things go even the tactic computation might skip some steps if we choose to evaluate it only at certain values or seed it with witnesses from the paper or some other data constructed e.g. in a CAS. Putting these approaches together you can get significantly further than you would otherwise</p>



<a name="271704827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271704827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271704827">(Feb 12 2022 at 19:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, are you sure you didn't make an off by one error in the set of lemma? I think <code>roth_aux_succ</code> is false for <code>a = 0</code>, <code>m = 0</code>, <code>d = 0</code>, <code>l = [0]</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">roth_aux_succ</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">roth_aux₁</span> <span class="n">a</span> <span class="n">m</span> <span class="n">d</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">roth_aux₂</span> <span class="n">a</span> <span class="n">m</span> <span class="n">d</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">roth_aux</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="n">d</span> <span class="n">l</span> <span class="o">:=</span>
</code></pre></div>



<a name="271705926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271705926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271705926">(Feb 12 2022 at 19:34)</a>:</h4>
<p>Update: I'm not so sure anymore, but I still fail to understand what made you choose those definitions.</p>



<a name="271709587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709587">(Feb 12 2022 at 21:02)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> The idea behind <code>roth_aux</code> deferring to <code>roth_aux₁</code> and <code>roth_aux₂</code> is that the successor case (that is, <code>roth_aux (a+1)</code>) for <code>roth_aux</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">roth_aux</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="n">d</span> <span class="n">l</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">d</span> <span class="bp">≥</span> <span class="n">roth_number_nat</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">roth_aux</span> <span class="n">a</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d</span> <span class="n">l</span><span class="o">)</span> <span class="bp">∧</span>
  <span class="o">(</span><span class="bp">¬</span> <span class="n">three_free</span> <span class="n">m</span> <span class="n">l</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">d'</span><span class="o">,</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">d'</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">roth_aux</span> <span class="n">a</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">d'</span> <span class="o">(</span><span class="n">m</span> <span class="o">::</span> <span class="n">l</span><span class="o">))</span>
</code></pre></div>



<a name="271709611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709611">(Feb 12 2022 at 21:03)</a>:</h4>
<p>How immediate is it to rewrite it as such?</p>



<a name="271709692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709692">(Feb 12 2022 at 21:05)</a>:</h4>
<p>In the original algorithm, this was by definition and the hard part with proving that the algorithm's result is in fact constraining the roth number; in this version the result is correct by definition but this equality (actually we only need one direction of implication here) is the hard part</p>



<a name="271709738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709738">(Feb 12 2022 at 21:06)</a>:</h4>
<p>But it shouldn't be too hard, assuming I got the definition of <code>roth_aux</code> (the algorithm's invariant) correct</p>



<a name="271709821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709821">(Feb 12 2022 at 21:08)</a>:</h4>
<p>My draft proof is getting longer and longer... and mostly I do not see this head <code>∧</code> in what I'm doing.</p>



<a name="271709842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709842">(Feb 12 2022 at 21:09)</a>:</h4>
<p>I forget all the details, but I believe that we are trying to prove something about all bit sequences starting with <code>l</code>, and one part of the <code>/\</code> is proving stuff about the <code>ff::l</code> sequences and the other part is <code>tt::l</code> sequences</p>



<a name="271709907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709907">(Feb 12 2022 at 21:10)</a>:</h4>
<p>So I should case on whether <code>m ∈ l</code> or something.</p>



<a name="271709914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709914">(Feb 12 2022 at 21:11)</a>:</h4>
<p>er, I guess we encoded them as strictly decreasing lists of numbers instead of bit strings, hence by the second part has <code>m::l</code> and the other has <code>l</code></p>



<a name="271709929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709929">(Feb 12 2022 at 21:11)</a>:</h4>
<p>Currently, I'm casing on <code>roth_aux₁ a m d l</code> and <code>roth_aux₂ a m d l</code>, which yields four cases looking quite distinctly different.</p>



<a name="271709932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709932">(Feb 12 2022 at 21:11)</a>:</h4>
<p>what's in the context?</p>



<a name="271709940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709940">(Feb 12 2022 at 21:11)</a>:</h4>
<p>Here's the context before casing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span>
<span class="n">adm</span><span class="o">:</span> <span class="n">ℕ</span>
<span class="n">h₁</span><span class="o">:</span> <span class="n">roth_aux₁</span> <span class="n">a</span> <span class="n">m</span> <span class="n">d</span> <span class="n">l</span>
<span class="n">h₂</span><span class="o">:</span> <span class="n">roth_aux₂</span> <span class="n">a</span> <span class="n">m</span> <span class="n">d</span> <span class="n">l</span>
<span class="n">hl</span><span class="o">:</span> <span class="n">chain</span> <span class="n">gt</span> <span class="n">m</span> <span class="n">l</span>
<span class="n">s</span><span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span>
<span class="n">hs₀</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">m</span>
<span class="n">hs₁</span><span class="o">:</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">_x</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">l.to_finset</span>
<span class="n">hs₂</span><span class="o">:</span> <span class="n">add_salem_spencer</span> <span class="bp">↑</span><span class="n">s</span>
<span class="n">hl₃</span><span class="o">:</span> <span class="n">l.nodup</span>
<span class="n">hls</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">⦄,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="n">finset.filter</span> <span class="o">(</span><span class="n">not</span> <span class="bp">∘</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">_x</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="n">d</span>
</code></pre></div>



<a name="271709998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271709998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271709998">(Feb 12 2022 at 21:12)</a>:</h4>
<p>Note that I simplified the definition of <code>roth_aux</code> because the first assumption was redundant.</p>



<a name="271710010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710010">(Feb 12 2022 at 21:13)</a>:</h4>
<p>?</p>



<a name="271710018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710018">(Feb 12 2022 at 21:13)</a>:</h4>
<p>which assumption did you drop</p>



<a name="271710024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710024">(Feb 12 2022 at 21:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">old_roth_aux</span> <span class="o">(</span><span class="n">a</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">add_salem_spencer</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">}</span> <span class="bp">→</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">m</span> <span class="n">l</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s.filter</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l.to_finset</span> <span class="bp">→</span>
    <span class="n">add_salem_spencer</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s.card</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">l.length</span>
<span class="c1">-- VS</span>
<span class="kd">def</span> <span class="n">roth_aux</span> <span class="o">(</span><span class="n">a</span> <span class="n">m</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">m</span> <span class="n">l</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s.filter</span> <span class="o">(</span><span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">l.to_finset</span> <span class="bp">→</span>
  <span class="n">add_salem_spencer</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s.card</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">l.length</span>
</code></pre></div>



<a name="271710075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710075">(Feb 12 2022 at 21:14)</a>:</h4>
<p>I think you still need to know <code>add_salem_spencer {n | n ∈ l}</code> because it's used in the correctness proof for three_free</p>



<a name="271710142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710142">(Feb 12 2022 at 21:16)</a>:</h4>
<p>it's fine if you derive it from the other hypotheses, although I can't tell if it's shorter than having the redundant assumption and using <code>three_free_spec</code> to extend it</p>



<a name="271710162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710162">(Feb 12 2022 at 21:17)</a>:</h4>
<p>Yes, I can derive it</p>



<a name="271710443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710443">(Feb 12 2022 at 21:24)</a>:</h4>
<p>Yes, I think you want to case on <code>m ∈ l</code>. If it is true, then you case on <code>roth_aux₂</code> and ignore <code>roth_aux₁</code>, and vice versa if it is false</p>



<a name="271710455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271710455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271710455">(Feb 12 2022 at 21:25)</a>:</h4>
<p>That makes more sense. I was deriving <code>m ∈ l</code> from casing on <code>roth_aux₁</code> and <code>roth_aux₂</code>.</p>



<a name="271712325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271712325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271712325">(Feb 12 2022 at 22:13)</a>:</h4>
<p>It works much better when you understand what's happening. Who would have thought <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="271715053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271715053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271715053">(Feb 12 2022 at 23:18)</a>:</h4>
<p>Aaand, it's done!</p>



<a name="271715972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271715972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271715972">(Feb 12 2022 at 23:41)</a>:</h4>
<p>When I started with lean I'd just leap into every proof on the basis that I was a good puzzle-solver so I should just be able to follow my nose and do everything first try. I soon learnt that this wasn't always the case. I remember trying Scott Morrison's category theory exercises in LFTCM20 and realising very quickly that paper and pencil was going to be essential :-)</p>



<a name="271716120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computing%20Roth%20numbers/near/271716120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computing.20Roth.20numbers.html#271716120">(Feb 12 2022 at 23:45)</a>:</h4>
<p>People keep asking me whether Lean requires rather maths or programming, and the answer is clear, unless you get into metaprogramming or the typeclass hierarchy.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
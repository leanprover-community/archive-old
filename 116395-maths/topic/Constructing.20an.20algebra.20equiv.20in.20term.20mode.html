---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html">Constructing an algebra equiv in term mode</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215925868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215925868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215925868">(Nov 07 2020 at 02:02)</a>:</h4>
<p>Is there a term mode construction for this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">Y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span>
</code></pre></div>
<p>I've gotten the impression that definitions shouldn't be done in tactic mode.</p>



<a name="215926644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215926644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215926644">(Nov 07 2020 at 02:18)</a>:</h4>
<p>If you really want:<br>
You can always go all the way down the rabbit hole:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">property</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span><span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">x.2</span><span class="o">}</span> <span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">property</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">x.2</span><span class="o">}</span> <span class="o">},</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span> <span class="o">}</span>
</code></pre></div>



<a name="215926928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215926928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215926928">(Nov 07 2020 at 02:25)</a>:</h4>
<p>True, although is this what <code>rw</code> is doing?</p>



<a name="215926979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215926979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215926979">(Nov 07 2020 at 02:26)</a>:</h4>
<p>I don't think so.</p>



<a name="215926982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215926982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215926982">(Nov 07 2020 at 02:26)</a>:</h4>
<p>no, <code>rw</code> produces a term of the form <code>eq.rec &lt;equality proof&gt; &lt;subproof&gt;</code></p>



<a name="215927068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927068">(Nov 07 2020 at 02:28)</a>:</h4>
<p>For example, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">property</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span><span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">x.2</span><span class="o">}</span> <span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">property</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">x.2</span><span class="o">}</span> <span class="o">},</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">equiv_of_eq</span> <span class="n">R</span> <span class="n">S</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">h</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="215927075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927075">(Nov 07 2020 at 02:29)</a>:</h4>
<p>we use definitions like <code>equiv_of_eq</code> so that the constructed object is definitionally of the form <code>constructor &lt;args&gt;</code> rather than <code>eq.rec ...</code>, so that you can reduce <code>(equiv_of_eq X Y h).to_fun x = x := rfl</code>, which doesn't work for <code>eq.rec</code> terms</p>



<a name="215927077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927077">(Nov 07 2020 at 02:29)</a>:</h4>
<p>I don't think the same example would work with the <code>by rw h</code></p>



<a name="215927234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927234">(Nov 07 2020 at 02:33)</a>:</h4>
<p>This seems like something where automation could help, though I'm not sure how.</p>



<a name="215927254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927254">(Nov 07 2020 at 02:33)</a>:</h4>
<p>here's the compressed version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="n">tidy</span>
</code></pre></div>



<a name="215927292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927292">(Nov 07 2020 at 02:34)</a>:</h4>
<p>There was some discussion a while back about some version of tidy that can add simple data like <code>\lam x, x</code>. I guess something like that would work here</p>



<a name="215927401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215927401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215927401">(Nov 07 2020 at 02:36)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="110087">@Scott Morrison</span> mentioned a <code>follow your nose</code> tactic?</p>



<a name="215942944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215942944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215942944">(Nov 07 2020 at 07:31)</a>:</h4>
<p><span class="user-mention" data-user-id="253861">@Thomas Browning</span> you're right to be very wary of your initial definition using the rewrite. If you want to see the relative merits of your definition vs Adam/Mario's, try proving something like transitivity. Given X=Y and Y=Z try proving that the equiv you get between X and Z is equal to the composite of equivs from X to Y and Y to Z. With the tidy definition you should be able to reduce this to checking that the two maps are the same and it should be easy. With the rewrite definition you might find that the goal becomes completely intractible. I might be wrong but it might be worth spending five minutes trying.</p>



<a name="215953483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Constructing%20an%20algebra%20equiv%20in%20term%20mode/near/215953483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Constructing.20an.20algebra.20equiv.20in.20term.20mode.html#215953483">(Nov 07 2020 at 12:48)</a>:</h4>
<p>I have seen tidy fill in some basic data sometimes, usually when the goal contains the data as well as a proposition about the data, where tidy splits, makes inconclusive progress on the data, but then uses solve by elim on the proposition, which fills in the metavariable for the data</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
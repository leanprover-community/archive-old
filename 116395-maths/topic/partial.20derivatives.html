---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/partial.20derivatives.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html">partial derivatives</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="170727198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/170727198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#170727198">(Jul 12 2019 at 14:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">mv_polynomial</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">σ</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partial_deriv</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span> <span class="o">:=</span>
<span class="c1">-- p.sum $ λ v r, C r * (add_monoid.smul (v i) (X i ^ (v i - 1)) * v.prod (λ j n, if i = j then 1 else (mv_polynomial.X j)^n))</span>
<span class="n">p</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">r</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">n</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="n">j</span> <span class="o">(</span><span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="n">n</span><span class="bp">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul</span> <span class="o">(</span><span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span>

<span class="c1">-- #exit</span>
<span class="kn">theorem</span> <span class="n">partial_deriv_add</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">q</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_add_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span> <span class="err">$</span>
<span class="bp">λ</span> <span class="n">v</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_add</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_add</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_zero</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_zero_index</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_C</span> <span class="o">:</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span> <span class="err">$</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">zero_apply</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_X</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">j</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">X</span><span class="o">,</span> <span class="n">monomial</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_self</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hji</span> <span class="n">hij</span> <span class="n">hij</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">one_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hji</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hij</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hij</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hji</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hji</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">zero_sub</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">C_1</span><span class="o">,</span> <span class="n">partial_deriv_C</span><span class="o">]</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">α</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">to_semimodule</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">theorem</span> <span class="n">C_mul&#39;&#39;</span> <span class="o">:</span> <span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">induction</span> <span class="n">p</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">mul_zero</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">smul_zero</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">s</span> <span class="n">f</span> <span class="n">hfv</span> <span class="n">hs</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">C</span><span class="o">,</span> <span class="n">monomial</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mul_def</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">smul_single</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">]</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">zero_mul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_smul</span> <span class="o">:</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_smul_index&#39;</span><span class="o">,</span> <span class="n">partial_deriv</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mul_sum</span><span class="o">],</span> <span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_congr</span> <span class="n">rfl</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">,</span> <span class="err">←</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="err">←</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">smul_single</span><span class="o">,</span> <span class="n">C_mul&#39;&#39;</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_mul</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span><span class="err">₀</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">v</span> <span class="bp">+</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="n">j</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">v</span> <span class="bp">+</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span> <span class="n">w</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="n">j</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span> <span class="n">ext</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_single</span> <span class="n">j</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_single</span> <span class="n">j</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hij</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">subst</span> <span class="n">hij</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_assoc</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">one_le_of_lt</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="n">hw</span><span class="o">)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">hk</span> <span class="n">hkj</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">hkj</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">hjw</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">not_mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hjw</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">hk</span> <span class="n">hkj</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">hkj</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">hjw</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">not_mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hjw</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">induction</span> <span class="n">p</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span> <span class="n">r</span> <span class="n">p</span> <span class="n">hpv</span> <span class="n">hr</span> <span class="n">ihp</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">erw</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">rw</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">erw</span> <span class="n">partial_deriv_zero</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_zero</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">],</span> <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="bp">_</span> <span class="n">ihp</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">induction</span> <span class="n">q</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span> <span class="n">s</span> <span class="n">q</span> <span class="n">hqw</span> <span class="n">hs</span> <span class="n">ihq</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">erw</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">rw</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">erw</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">rw</span> <span class="n">partial_deriv_zero</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">],</span> <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="bp">_</span> <span class="n">ihq</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_mul_single</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_eq_smul_one</span> <span class="n">v</span> <span class="n">r</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_eq_smul_one</span> <span class="n">w</span> <span class="n">s</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_eq_smul_one</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span><span class="bp">*</span><span class="n">s</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv_smul</span><span class="o">,</span> <span class="n">partial_deriv_smul</span><span class="o">,</span> <span class="n">partial_deriv_smul</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm₄</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul</span><span class="o">,</span> <span class="n">mul_comm₄</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">s</span> <span class="n">r</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_add</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">],</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">],</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">],</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_mul_single</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_mul_single</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span>
  <span class="n">by_cases</span> <span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hv</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">erw</span> <span class="n">add_zero</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hw</span> <span class="o">:</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hw</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hw</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hw</span> <span class="o">:</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hw</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span> <span class="n">erw</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">this</span> <span class="n">w</span> <span class="n">v</span> <span class="n">hv</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">add_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_add</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hw</span> <span class="o">},</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">this</span> <span class="n">w</span> <span class="n">v</span> <span class="n">hv</span><span class="o">]</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">vars_add</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">vars</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">vars</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_union</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span>
<span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_add</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span>
  <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">degrees_add</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="err">$</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">sup_le</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">le_add_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="n">hi</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">vars_mul</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">vars</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">vars</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_union</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span>
<span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_add</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="o">(</span><span class="n">degrees_mul</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="n">hi</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">vars_X_subset</span> <span class="o">:</span> <span class="n">vars</span> <span class="o">(</span><span class="n">X</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="o">(</span><span class="n">degrees_X</span> <span class="n">i</span><span class="o">)</span> <span class="err">$</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hj</span>

<span class="kn">theorem</span> <span class="n">of_not_mem_vars</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="err">∉</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span><span class="err">₀</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finsupp</span><span class="bp">.</span><span class="n">not_mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hiv</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_multiset</span> <span class="bp">≤</span> <span class="n">p</span><span class="bp">.</span><span class="n">degrees</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">le_sup</span> <span class="n">hv</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">_</span> <span class="bp">≤</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_multiset</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">single_le_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">zero_le</span> <span class="bp">_</span><span class="o">)</span> <span class="n">hiv</span><span class="o">,</span>
<span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="n">h1</span> <span class="err">$</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="n">h2</span> <span class="err">$</span>
<span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_pred_eq_of_pos</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="err">$</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hiv</span><span class="o">)</span><span class="bp">;</span> <span class="n">exact</span>
<span class="n">multiset</span><span class="bp">.</span><span class="n">mem_cons_self</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_of_not_mem_vars</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="err">∉</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_zero</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">of_not_mem_vars</span> <span class="n">i</span> <span class="n">p</span> <span class="n">h</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">end</span> <span class="n">mv_polynomial</span>
</pre></div>



<a name="170727214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/170727214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#170727214">(Jul 12 2019 at 14:43)</a>:</h4>
<p>PR-ready?</p>



<a name="170728887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/170728887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#170728887">(Jul 12 2019 at 15:03)</a>:</h4>
<p>Looks pretty good to me. Maybe <code>C_mul''</code> can be called <code>C_mul_eq_smul</code>?</p>



<a name="212204845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212204845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212204845">(Oct 04 2020 at 04:17)</a>:</h4>
<p>I've started thinking about a proper way to introduce partial derivatives into <code>mathlib</code>.</p>



<a name="212205074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212205074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212205074">(Oct 04 2020 at 04:24)</a>:</h4>
<p>It's clear how to define <code>pderiv</code> for a function <code>f : (fin n → k) → E</code></p>



<a name="212205083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212205083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212205083">(Oct 04 2020 at 04:25)</a>:</h4>
<p>But this definition won't work, e.g., for <code>f : k × k → E</code> or <code>f : k → E</code>, and this doesn't sound good for a mathematician.</p>



<a name="212205205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212205205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212205205">(Oct 04 2020 at 04:29)</a>:</h4>
<p>I suggest introducing something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_canonical_basis</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">hfin</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span>
<span class="o">(</span><span class="n">iso</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">→</span> <span class="n">k</span><span class="o">)</span> <span class="bp">≃</span><span class="n">L</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">E</span><span class="o">)</span>
</code></pre></div>



<a name="212205257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212205257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212205257">(Oct 04 2020 at 04:30)</a>:</h4>
<p>With instances for <code>σ → k</code>, <code>euclidean_space</code>, <code>E × F</code> (using <code>σ = σE ⊕ σF</code>), <code>k</code> (using <code>σ = unit</code>).</p>



<a name="212205276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212205276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212205276">(Oct 04 2020 at 04:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> What do you think?</p>



<a name="212207352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207352">(Oct 04 2020 at 05:41)</a>:</h4>
<p>We have the same problem in the omin repository. We introduced a <code>has_coordinates</code> typeclass.</p>



<a name="212207353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207353">(Oct 04 2020 at 05:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Do you think it is ready for PR?</p>



<a name="212207406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207406">(Oct 04 2020 at 05:42)</a>:</h4>
<p>(Of course it doesn't assume any <code>normed*</code> stuff. So we'll have to think whether it is good enough, or maybe you need some <code>has_normed_coordinates</code> extending it.</p>



<a name="212207478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207478">(Oct 04 2020 at 05:45)</a>:</h4>
<p>Actually, we can just upgrade from <code>linear_equiv</code> to <code>continuous_linear_equiv</code> using finiteness of <code>σ</code>.</p>



<a name="212207505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207505">(Oct 04 2020 at 05:46)</a>:</h4>
<p>Could you please post a link to your <code>has_coordinates</code> code?</p>



<a name="212207598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207598">(Oct 04 2020 at 05:48)</a>:</h4>
<p><a href="https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/coordinates.lean">https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/coordinates.lean</a></p>



<a name="212207670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207670">(Oct 04 2020 at 05:50)</a>:</h4>
<p>There is also Patrick's <code>has_uncurry</code> class in mathlib, which might be the right solution for your use case</p>



<a name="212207864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207864">(Oct 04 2020 at 05:56)</a>:</h4>
<p>No, it will uncurry <code>f : k × k → E</code> to <code>k → k → E</code>, not to <code>(fin 2 → k) → E</code>.</p>



<a name="212207874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207874">(Oct 04 2020 at 05:57)</a>:</h4>
<p>Or <code>(unit ⊕ unit → k) → E</code></p>



<a name="212207942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207942">(Oct 04 2020 at 05:59)</a>:</h4>
<p>I would prefer to have any <code>(σ : Type*) [fintype σ]</code> as an index type, not necessarily <code>fin n</code>.</p>



<a name="212207971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212207971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212207971">(Oct 04 2020 at 06:00)</a>:</h4>
<p>Because for <code>E × F</code> it's easier to deal with <code>sum.inl k</code> than some <code>fin</code> magic.</p>



<a name="212208020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212208020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212208020">(Oct 04 2020 at 06:01)</a>:</h4>
<p>And I need coordinates to be linear. So, probably I'll add another typeclass.</p>



<a name="212210858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212210858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212210858">(Oct 04 2020 at 07:31)</a>:</h4>
<p>There is still the issue that, on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊕</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E \oplus F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>, some people call partial derivative the derivative with respect to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> (so, it's not a number, it's really a matrix). But it is impossible to get a notion that covers all these variants, so I think your idea is a very nice one to cover one-dimensional partial derivatives.</p>



<a name="212211037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212211037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212211037">(Oct 04 2020 at 07:37)</a>:</h4>
<p>We can mention that <code>∂f/∂x : E →L[k] G</code> for <code>f : E × F → G</code> can be written as <code>fderiv (λ x, f (x, y))</code>.</p>



<a name="212211038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212211038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212211038">(Oct 04 2020 at 07:37)</a>:</h4>
<p>Yes, sure!</p>



<a name="212226947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212226947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212226947">(Oct 04 2020 at 15:06)</a>:</h4>
<p>In general, the problem is how to replace a given fin.dim. R-vector space with some fixed model R^ι (ι a finite type) or R^n in a conventional way. For some purposes the order of coordinates is irrelevant, and then R^ι is enough, but for other purposes the order really matters and you need R^n. For example, consider row reduction of the matrices that represent linear maps, or classifying subspaces by how they meet the standard flag inside R^n. Likewise in model theory, quantifier elimination works by eliminating one variable at a time, say, the "last" one, and for this it's again better to work with R^(n+1) than with fintypes. (Actually row reduction of matrices is basically a special case of this, I think.)</p>



<a name="212227059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227059">(Oct 04 2020 at 15:10)</a>:</h4>
<p>So, unless we think it makes sense to have both concepts, I think the R^n version is better.</p>



<a name="212227168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227168">(Oct 04 2020 at 15:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/116395-maths/topic/partial.20derivatives/near/212207971">said</a>:</p>
<blockquote>
<p>Because for <code>E × F</code> it's easier to deal with <code>sum.inl k</code> than some <code>fin</code> magic.</p>
</blockquote>
<p>With some version of the "<a href="https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/coordinates.lean#L116">reindexing</a>" concept you can hide the details of exactly how the coordinates of <code>(x, y) : E × F</code> are related to those of <code>x : E</code> and <code>y : F</code>.</p>



<a name="212227556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227556">(Oct 04 2020 at 15:24)</a>:</h4>
<p>The main advantage of a <code>fintype</code> version would be that you can have an instance for <code>ι → R</code> itself whose coordinates are given by the identity and so, in particular, the coordinates for <code>(ι ⊕ ι') → R</code> are related to those for <code>ι → R</code> and <code>ι' → R</code> specifically by composing with <code>sum.inl</code> and <code>sum.inr</code>. In lean-omin this has never come up because we have actually never had a use for specifically <code>ι → R</code> with <code>[fintype ι]</code>. But, you could have an instance which uses <code>choice</code> to pick an ordering on <code>ι</code> and uses it to define coordinates. In that case, there would be no specific relationship between the coordinates for <code>(ι ⊕ ι') → R</code> and <code>ι → R</code> and <code>ι' → R</code>. I claim this doesn't really matter because you can describe the coordinate change as a reindexing, anyways. However, probably a sensible thing to do would be to only have a global instance when <code>ι</code> is an instance of <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_enum">docs#fin_enum</a> and then ensure that <code>ι ⊕ ι'</code> has a sensible <code>fin_enum</code> instance.</p>



<a name="212227561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227561">(Oct 04 2020 at 15:24)</a>:</h4>
<p>Is <code>R^ι</code> with a <code>decidable_linear_order</code> on <code>ι</code> any worse than <code>fin n</code>?</p>



<a name="212227586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227586">(Oct 04 2020 at 15:25)</a>:</h4>
<p>Another consideration about the <code>fintype</code> version is that either you introduce a second universe variable, or in the <code>ι → R</code> instance you only handle <code>ι</code> in <code>Type 0</code>.</p>



<a name="212227628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227628">(Oct 04 2020 at 15:26)</a>:</h4>
<p>It is worse because <code>fin n</code> has a bunch of API that is not conveniently available on an arbitrary finite decidable linear order, as well as somewhat better definitional behavior.</p>



<a name="212227687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227687">(Oct 04 2020 at 15:28)</a>:</h4>
<p>(Also, conceptually the point of this whole construction is to reduce some problem/construction from general fin.dim. vector spaces to specific model spaces, so why stop at <code>R^ι</code> when you could go all the way to <code>R^n</code>?)</p>



<a name="212227894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227894">(Oct 04 2020 at 15:34)</a>:</h4>
<p>Once you're working in this setting, the general objects are like <code>(V : Type*) [has_coordinates R V]</code> and the specific objects are like <code>fin n -&gt; R</code>, so there's no longer any special significance to <code>ι → R</code> with <code>[fintype ι]</code>.</p>



<a name="212227914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212227914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212227914">(Oct 04 2020 at 15:35)</a>:</h4>
<p>It only comes up if you have a <code>[fintype ι]</code> that comes from outside, so to speak. And then perhaps it would be better to have <code>[fin_enum ι]</code> which is basically the non-linear analogue of this setup.</p>



<a name="212228022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212228022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212228022">(Oct 04 2020 at 15:38)</a>:</h4>
<p>OK, I'll try <code>fin n</code>. Thank you for the explanation.</p>



<a name="212228598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212228598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212228598">(Oct 04 2020 at 15:53)</a>:</h4>
<p>I should probably also add that in lean-omin this reindexing stuff is only ever used to prove <code>Prop</code>s, but you would probably also want to for example say what the partial derivatives of <code>prod.fst : E \x F -&gt; E</code> are, so that might affect the design.</p>



<a name="212228754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/212228754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#212228754">(Oct 04 2020 at 15:56)</a>:</h4>
<p>I'll just declare an instance on <code>E × F</code> using <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.sum_fin_sum_equiv">docs#equiv.sum_fin_sum_equiv</a>.</p>



<a name="261640749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261640749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261640749">(Nov 16 2021 at 13:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> and <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> what is the current status of partial derivatives and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">C^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> functions? Say for instance I have a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">C^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>E</mi><mo>×</mo><mi>F</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F : E \times F \to G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>. How am I meant to express that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>F</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\partial F/\partial e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">e</span></span></span></span> is a continuous function?</p>



<a name="261640895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261640895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261640895">(Nov 16 2021 at 13:36)</a>:</h4>
<p>And how should I prove this? Is it already somewhere?</p>



<a name="261707076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261707076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261707076">(Nov 16 2021 at 21:08)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi><mi>F</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\partial F / \partial e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">e</span></span></span></span> is just the composition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">DF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> with the injection of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E \times F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. I don't think we have a special notation for it (unless Yury has introduced something when doing the implicit function theorem, where this kind of thing is used all the time).</p>



<a name="261707314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261707314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261707314">(Nov 16 2021 at 21:10)</a>:</h4>
<p>I had a look in the implicit function file, having exactly this idea in mind, but I didn't see anything relevant.</p>



<a name="261707519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261707519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261707519">(Nov 16 2021 at 21:12)</a>:</h4>
<p>The continuity issue is related to the trichotomy of <code>has_fderiv</code> <code>fderiv</code> and <code>times_cont_diff</code> which complicates everything.</p>



<a name="261707624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261707624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261707624">(Nov 16 2021 at 21:13)</a>:</h4>
<p>And actually I think what I needed when I posted this message was the continuity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>↦</mo><mi mathvariant="normal">∂</mi><mi>F</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∂</mi><mi>x</mi><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e \mapsto \partial F/\partial x(e, x_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> or something like this which makes things even more complicated in Lean (but still obvious on paper).</p>



<a name="261861314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/partial%20derivatives/near/261861314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/partial.20derivatives.html#261861314">(Nov 17 2021 at 22:40)</a>:</h4>
<p>I did not introduce any notation. Probably you need something like <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map.compL">docs#continuous_linear_map.compL</a> with <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map.inl">docs#continuous_linear_map.inl</a>. To make things worse, you might need to use <code>flip</code> on <code>compL</code>.</p>
<p>Do other proof assistants have automation for things like this? How does it work?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
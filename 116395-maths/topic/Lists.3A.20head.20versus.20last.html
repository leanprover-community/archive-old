---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html">Lists: head versus last</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219222252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219222252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219222252">(Dec 08 2020 at 15:47)</a>:</h4>
<p>Why, conceptually, are <code>list.head</code> and <code>list.last</code> different?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.last</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l</span> <span class="bp">≠</span> <span class="n">list.nil</span> <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>
<p>Reasonable - given a list of some type and proof the list isn't empty, give its last element.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.head</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>
<p>Given a list of some inhabited type, give either the first element of the list, or if the list is empty, default α. This means we have <code>list.last_mem</code>, but there isn't (and cannot be?) any <code>list.head_mem</code>. I don't really understand why these work in two different ways.</p>



<a name="219222487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219222487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219222487">(Dec 08 2020 at 15:49)</a>:</h4>
<p>It is a bit of a headache as the head is quite natural to work with, more so than the last element, and I'm in a context where I'm dealing with non-empty lists.</p>



<a name="219223266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219223266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219223266">(Dec 08 2020 at 15:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.head_mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">≠</span> <span class="n">list.nil</span><span class="o">)</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">l.head</span> <span class="bp">∈</span> <span class="n">l</span> <span class="o">:=</span>
<span class="n">list.mem_of_mem_head'</span> <span class="bp">$</span> <span class="n">list.head_mem_head'</span> <span class="n">h</span>
</code></pre></div>



<a name="219223376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219223376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219223376">(Dec 08 2020 at 15:55)</a>:</h4>
<p>Although that doesn't answer the question of why they're defined differently</p>



<a name="219223522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219223522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219223522">(Dec 08 2020 at 15:56)</a>:</h4>
<p>Indeed, not so hard to whip up my own custom lemma, but seemed a bit odd that they were defined like this to me!</p>



<a name="219224248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224248">(Dec 08 2020 at 16:01)</a>:</h4>
<p><code>list.tail</code>  has the following type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.tail</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span>
</code></pre></div>
<p>(With<code>list.nil</code> sent to <code>list.nil</code>.)</p>
<p>With <code>list.init</code> defined in a similar way. So there's sort of a symmetry here which isn't present for the "other" operations.</p>



<a name="219224552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224552">(Dec 08 2020 at 16:02)</a>:</h4>
<p>There's also <code>head'</code> which gives an <code>option α</code>, with <code>none</code> is the list is empty.</p>



<a name="219224648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224648">(Dec 08 2020 at 16:03)</a>:</h4>
<p>Aye, indeed: and a corresponding last'. Which is reasonable!</p>



<a name="219224754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224754">(Dec 08 2020 at 16:04)</a>:</h4>
<p>And perhaps the <code>list.nil</code> case would already be taken care of by something upstream.</p>



<a name="219224822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224822">(Dec 08 2020 at 16:04)</a>:</h4>
<p><code>list.ilast</code> is the symmetric version of <code>list.head</code></p>



<a name="219224830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224830">(Dec 08 2020 at 16:04)</a>:</h4>
<p>So you'd have a <code>l ≠ list.nil</code> hypothesis, and an <code>l = a :: l'</code> hypothesis.</p>



<a name="219224858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224858">(Dec 08 2020 at 16:04)</a>:</h4>
<p>So you wouldn't even need <code>head</code>, you'd just use <code>a</code>.</p>



<a name="219224870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219224870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219224870">(Dec 08 2020 at 16:05)</a>:</h4>
<p><code>list.cons_head_tail</code> and <code>list.init_append_last</code> both require the <code>l ≠ list.nil</code> hypothesis.</p>



<a name="219225074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219225074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219225074">(Dec 08 2020 at 16:06)</a>:</h4>
<p>Proofs about lists often use <code>induction</code> so that the empty and <code>hd :: tl</code> cases are dealt with separately.</p>



<a name="219225145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219225145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219225145">(Dec 08 2020 at 16:06)</a>:</h4>
<p>Mmm.</p>



<a name="219225336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219225336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219225336">(Dec 08 2020 at 16:08)</a>:</h4>
<p>Since I missed this - worth noting that there are two doc pages for these basic list definitions: <a href="https://leanprover-community.github.io/mathlib_docs/init/data/list/basic.html#list.last">core</a> and <a href="https://leanprover-community.github.io/mathlib_docs/data/list/defs.html">mathlib</a></p>



<a name="219225470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219225470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219225470">(Dec 08 2020 at 16:09)</a>:</h4>
<p>So whatever API you're building with lists, you could phrase it instead as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">something_about_lists</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="219225521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219225521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219225521">(Dec 08 2020 at 16:09)</a>:</h4>
<p>Aye, I've been consulting them. Essentially I am defining something (the chains stuff I was talking about previously) - I am trying to decide "which way round" to put my chain. At some point in a proof I am going to want to add an element to the start/end of the chain and I'm trying to decide what the best way to orientate things is.</p>



<a name="219225625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219225625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219225625">(Dec 08 2020 at 16:10)</a>:</h4>
<p>So my type in question looks like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">prime_ideal_chain</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">carrier</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">))</span>
<span class="o">(</span> <span class="n">primes</span> <span class="o">{</span><span class="n">I</span><span class="o">}</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">ideal.is_prime</span> <span class="n">I</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">is_chain</span> <span class="o">:</span> <span class="n">list.chain'</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">carrier</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">not_nil</span> <span class="o">:</span> <span class="n">carrier</span> <span class="bp">≠</span> <span class="n">list.nil</span> <span class="o">)</span>
</code></pre></div>



<a name="219226302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219226302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219226302">(Dec 08 2020 at 16:13)</a>:</h4>
<p>I'm getting the biggest element of some C of this type (in this formulation, the head of C.carrier), using C.primes to show that's prime, and then constructing a bigger element and adjoining it to C.carrier and creating a new <code>prime_ideal_chain</code>.</p>



<a name="219226465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219226465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219226465">(Dec 08 2020 at 16:15)</a>:</h4>
<p>Obviously I could flip everything (then I'd be using <code>last</code> instead) - but I thought this would be nicer; as <code>head</code> isn't symmetrical to <code>last</code>, however, I got to wondering the thought that started the OP.</p>



<a name="219226504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219226504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219226504">(Dec 08 2020 at 16:15)</a>:</h4>
<p>You might like <code>list.sorted</code></p>



<a name="219226536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219226536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219226536">(Dec 08 2020 at 16:15)</a>:</h4>
<p>Oh that's nice.</p>



<a name="219226567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219226567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219226567">(Dec 08 2020 at 16:15)</a>:</h4>
<p>sorted (&gt;) l or something.</p>



<a name="219227490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219227490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219227490">(Dec 08 2020 at 16:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">prime_ideal_chain.cons</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">bigger</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">bigger</span> <span class="o">::</span> <span class="n">pic.carrier</span><span class="o">,</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">bigger.is_prime</span><span class="o">,</span> <span class="n">pic.primes</span><span class="o">]</span> <span class="o">},</span> <span class="c1">--uses list.mem_cons_iff</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="k">show</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic.carrier</span><span class="o">),</span> <span class="n">bigger</span> <span class="bp">&gt;</span> <span class="n">I</span><span class="o">),</span> <span class="k">from</span> <span class="n">bigger.is_bigger</span><span class="o">,</span> <span class="n">pic.is_sorted</span><span class="o">]</span> <span class="o">}</span> <span class="c1">--uses list.sorted_cons,</span>
<span class="kd">by</span> <span class="n">simp</span>
<span class="o">⟩</span>
</code></pre></div>



<a name="219227503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219227503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219227503">(Dec 08 2020 at 16:22)</a>:</h4>
<p>Very rough sketch</p>



<a name="219228471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219228471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219228471">(Dec 08 2020 at 16:30)</a>:</h4>
<p>Why do you think <code>sorted</code> is better than <code>chain'</code>, incidentally?</p>



<a name="219228591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219228591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219228591">(Dec 08 2020 at 16:31)</a>:</h4>
<p>(I only have that my bigger element is definitely bigger than the previously-biggest element, y'see.)</p>



<a name="219228690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219228690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219228690">(Dec 08 2020 at 16:32)</a>:</h4>
<p>I can get quite far using <code>chain'</code> although I'm not sure how to deal with a hypothesis of the form <code>hy: y ∈ C.carrier.head'</code></p>



<a name="219228717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219228717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219228717">(Dec 08 2020 at 16:32)</a>:</h4>
<p>Is there a lemma to convert <code>chain' r</code> to <code>pairwise r</code> given the fact that <code>r</code> is transitive?</p>



<a name="219228803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219228803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219228803">(Dec 08 2020 at 16:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.ideal.prod</span>
<span class="kn">import</span> <span class="n">data.list.sort</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">prime_ideal_chain</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">carrier</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">))</span>
<span class="o">(</span> <span class="n">primes</span> <span class="o">{</span><span class="n">I</span><span class="o">}</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">ideal.is_prime</span> <span class="n">I</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">is_chain</span> <span class="o">:</span> <span class="n">list.sorted</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">carrier</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">not_nil</span> <span class="o">:</span> <span class="n">carrier</span> <span class="bp">≠</span> <span class="n">list.nil</span> <span class="o">)</span>

<span class="kd">def</span> <span class="n">prime_ideal_chain.mem</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">I</span> <span class="bp">∈</span> <span class="n">pic.carrier</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">prime_ideal_chain.mem</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">prime_ideal_chain.mem_def</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic</span> <span class="bp">↔</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic.carrier</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">def</span> <span class="n">prime_ideal_chain.cons</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">bigger</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hprime</span> <span class="o">:</span> <span class="n">bigger.is_prime</span><span class="o">)</span> <span class="o">(</span><span class="n">hbig</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic</span><span class="o">,</span> <span class="n">I</span> <span class="bp">&lt;</span> <span class="n">bigger</span><span class="o">):</span>
  <span class="n">prime_ideal_chain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">bigger</span> <span class="o">::</span> <span class="n">pic.carrier</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">hprime</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">pic.primes</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">pic.is_chain</span><span class="o">,</span> <span class="n">list.sorted_cons</span><span class="o">,</span> <span class="n">and_true</span><span class="o">]</span> <span class="n">using</span> <span class="n">hbig</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">]⟩</span>
</code></pre></div>



<a name="219228895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219228895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219228895">(Dec 08 2020 at 16:33)</a>:</h4>
<p>Yes, <a href="https://leanprover-community.github.io/mathlib_docs/find/list.chain'_iff_pairwise">docs#list.chain'_iff_pairwise</a></p>



<a name="219229002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219229002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219229002">(Dec 08 2020 at 16:34)</a>:</h4>
<p>What are you using <code>ring_theory.ideal.prod</code> for?</p>



<a name="219229037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219229037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219229037">(Dec 08 2020 at 16:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.sorted_of_sorted_cons">docs#list.sorted_of_sorted_cons</a> might also work here.</p>



<a name="219229057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219229057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219229057">(Dec 08 2020 at 16:35)</a>:</h4>
<p>Just wanted an import that worked</p>



<a name="219229084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219229084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219229084">(Dec 08 2020 at 16:35)</a>:</h4>
<p>Fair.</p>



<a name="219229344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219229344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219229344">(Dec 08 2020 at 16:37)</a>:</h4>
<p>Maybe I want to pre-write a way to get the head of a chain along with the fact it's prime also.</p>



<a name="219232403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219232403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219232403">(Dec 08 2020 at 17:02)</a>:</h4>
<p>Then perhaps your structure can store what the <code>head</code> is and use <code>list.chain</code> instead?</p>



<a name="219232997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219232997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219232997">(Dec 08 2020 at 17:06)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.ideal.prod</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">prime_ideal_chain</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">largest</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>
<span class="o">(</span><span class="n">rest</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">))</span>
<span class="o">(</span><span class="n">primes</span> <span class="o">{</span><span class="n">I</span><span class="o">}</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">largest</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ideal.is_prime</span> <span class="n">I</span> <span class="o">)</span>
<span class="o">(</span><span class="n">is_chain</span> <span class="o">:</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">largest</span> <span class="n">rest</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">prime_ideal_chain.mem</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">I</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">pic.largest</span> <span class="o">::</span> <span class="n">pic.rest</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">prime_ideal_chain.mem</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">prime_ideal_chain.mem_def</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic</span> <span class="bp">↔</span> <span class="n">I</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">pic.largest</span> <span class="o">::</span> <span class="n">pic.rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">def</span> <span class="n">prime_ideal_chain.cons</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">bigger</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hprime</span> <span class="o">:</span> <span class="n">bigger.is_prime</span><span class="o">)</span> <span class="o">(</span><span class="n">hbig</span> <span class="o">:</span> <span class="n">pic.largest</span> <span class="bp">&lt;</span> <span class="n">bigger</span><span class="o">):</span>
  <span class="n">prime_ideal_chain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">bigger</span><span class="o">,</span>
  <span class="n">pic.largest</span> <span class="o">::</span> <span class="n">pic.rest</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">hprime</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">pic.primes</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">pic.is_chain</span><span class="o">,</span> <span class="n">and_true</span><span class="o">,</span> <span class="n">list.chain_cons</span><span class="o">]</span> <span class="n">using</span> <span class="n">hbig</span><span class="o">⟩</span>
</code></pre></div>



<a name="219233143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219233143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219233143">(Dec 08 2020 at 17:07)</a>:</h4>
<p>mhm. That does work, though I suppose in a sense it would be nice if rest was itself a prime_ideal_chain (because of course it is).</p>



<a name="219233189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219233189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219233189">(Dec 08 2020 at 17:08)</a>:</h4>
<p>But I like the way you did it.</p>



<a name="219233629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219233629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219233629">(Dec 08 2020 at 17:11)</a>:</h4>
<p>Well under this definition, that wouldn't be possible because <code>[]</code> is not a valid chain.</p>



<a name="219233650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219233650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219233650">(Dec 08 2020 at 17:11)</a>:</h4>
<p>RIght.</p>



<a name="219235869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219235869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219235869">(Dec 08 2020 at 17:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.ideal.prod</span>

<span class="kn">section</span> <span class="n">prime_ideal_chain</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">prime_ideal_chain</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">largest</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>
<span class="o">(</span><span class="n">rest</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">))</span>
<span class="o">(</span><span class="n">primes</span> <span class="o">{</span><span class="n">I</span><span class="o">}</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">largest</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ideal.is_prime</span> <span class="n">I</span> <span class="o">)</span>
<span class="o">(</span><span class="n">is_chain</span> <span class="o">:</span> <span class="n">list.chain</span> <span class="o">(</span><span class="bp">&gt;</span><span class="o">)</span> <span class="n">largest</span> <span class="n">rest</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">prime_ideal_chain</span>

<span class="kn">namespace</span> <span class="n">prime_ideal_chain</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">pic</span> <span class="o">:</span> <span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">mem</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">I</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">pic.largest</span> <span class="o">::</span> <span class="n">pic.rest</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">I</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">prime_ideal_chain</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mem</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">mem_def</span> <span class="o">:</span>
  <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic</span> <span class="bp">↔</span> <span class="n">I</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">pic.largest</span> <span class="o">::</span> <span class="n">pic.rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">def</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hprime</span> <span class="o">:</span> <span class="n">I.is_prime</span><span class="o">)</span> <span class="o">(</span><span class="n">hbig</span> <span class="o">:</span> <span class="n">pic.largest</span> <span class="bp">&lt;</span> <span class="n">I</span><span class="o">):</span>
  <span class="n">prime_ideal_chain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">pic.largest</span> <span class="o">::</span> <span class="n">pic.rest</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">hprime</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">pic.primes</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">pic.is_chain</span><span class="o">,</span> <span class="n">and_true</span><span class="o">,</span> <span class="n">list.chain_cons</span><span class="o">]</span> <span class="n">using</span> <span class="n">hbig</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">is_prime_largest</span> <span class="o">:</span> <span class="n">pic.largest.is_prime</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">pic.primes</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">true_or</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_prime_of_rest</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">∈</span> <span class="n">pic.rest</span><span class="o">)</span> <span class="o">:</span> <span class="n">I.is_prime</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">pic.primes</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">or_true</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">of_rest</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">xs</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ideal</span> <span class="n">R</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">pic.rest</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">prime_ideal_chain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">,</span>
  <span class="bp">λ</span> <span class="n">I</span> <span class="n">hI</span><span class="o">,</span> <span class="n">pic.is_prime_of_rest</span> <span class="o">(</span><span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">hI</span><span class="o">),</span>
  <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">list.chain_of_chain_cons</span><span class="o">,</span> <span class="n">convert</span> <span class="n">pic.is_chain</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h.symm</span> <span class="o">}⟩</span>

<span class="kd">end</span> <span class="n">prime_ideal_chain</span>

<span class="kd">end</span> <span class="n">prime_ideal_chain</span>
</code></pre></div>



<a name="219236093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219236093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219236093">(Dec 08 2020 at 17:28)</a>:</h4>
<p>Thank you.</p>



<a name="219236157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219236157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219236157">(Dec 08 2020 at 17:29)</a>:</h4>
<p>Think it is a little easier to have <code>(primes : largest.is_prime ∧ ∀ I ∈ rest, ideal.is_prime I )</code>.</p>



<a name="219236353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219236353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219236353">(Dec 08 2020 at 17:30)</a>:</h4>
<p>However you write it (and your way is definitely easier to deconstruct), you might still have an API lemma like <code>is_prime_largest</code>, the proof of which will be just <code>_.1</code> in your case.</p>



<a name="219236517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lists%3A%20head%20versus%20last/near/219236517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lists.3A.20head.20versus.20last.html#219236517">(Dec 08 2020 at 17:32)</a>:</h4>
<p>Aye.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
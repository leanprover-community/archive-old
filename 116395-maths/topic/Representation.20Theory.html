---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Representation.20Theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html">Representation Theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198297535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198297535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> orlando <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198297535">(May 21 2020 at 08:31)</a>:</h4>
<p>Hello, That good <span class="user-mention" data-user-id="110087">@Scott Morrison</span> , i  have also a version of Maschke theorem.  </p>
<p>But for me the big step is really to make the application over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> ! </p>
<p>For example, the decomposition of a representation in irreducible representation.</p>
<p>I think the decomposition in irrducible part is ok for field (not algebraically closed).</p>



<a name="198307212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198307212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198307212">(May 21 2020 at 10:42)</a>:</h4>
<p>Could we move this thread to the math stream?</p>



<a name="198341355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198341355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198341355">(May 21 2020 at 16:18)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/Representation.20Theory">#new members &gt; Representation Theory</a> by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span></p>



<a name="198346016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198346016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198346016">(May 21 2020 at 16:52)</a>:</h4>
<p>Thanks Mario.</p>



<a name="198419189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198419189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Syx Pek <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198419189">(May 22 2020 at 08:54)</a>:</h4>
<p>I am very new to Lean (Ive checked it in the past many years ago but I had deemed it to unwieldy to get started). I am just curious why the PR for Maschke's Thm don't define the notion of semisimplicity, and just state that k[G] is semisimple, which I think would be how most people would think Maschke's Thm actually looks like. (It unpacks the notion of semisimplicity into the notion of every submodule has a complementary subspace, which I think its equivalent?, though I only work with algebra over (commutative unital) rings, so I don't know the subtleties.)</p>



<a name="198421905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198421905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198421905">(May 22 2020 at 09:29)</a>:</h4>
<p><span class="user-mention" data-user-id="128818">@Syx Pek</span> Welcome! The reason is only that the definitions are not there yet. This PR does all the "real work", and we can easily repackage it in a follow-up PR. I agree that this should be done. We cannot claim that it's completely done yet (-;</p>



<a name="198422199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198422199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198422199">(May 22 2020 at 09:32)</a>:</h4>
<p>In particular, the design decisions around "which definition of semisimplicity should we use" are probably harder than the actual calculation I did in that PR.</p>



<a name="198422220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198422220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198422220">(May 22 2020 at 09:33)</a>:</h4>
<p>There are a lot of ways to talk about semisimplicity!</p>



<a name="198422229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198422229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198422229">(May 22 2020 at 09:33)</a>:</h4>
<p>Yes, I think the issue will be that nobody has defined semisimple algebras yet. I wonder if this is one of those situations where mathematicians are quite happy with several definitions of the same thing but computer scientists can't have this. Is the definition of a semisimple algebra something like "finite sum of simple algebras" or "its representation theory is semisimple"? There are theorems to be proved here and nobody has got round to it yet</p>



<a name="198422268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198422268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198422268">(May 22 2020 at 09:33)</a>:</h4>
<p>Yeah what Scott said</p>



<a name="198422340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198422340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198422340">(May 22 2020 at 09:34)</a>:</h4>
<p>They won't be hard</p>



<a name="198422381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/198422381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#198422381">(May 22 2020 at 09:34)</a>:</h4>
<p>It's just that we are understaffed right now because the universities aren't teaching this stuff</p>



<a name="231378582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231378582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231378582">(Mar 22 2021 at 20:22)</a>:</h4>
<p>Hello,</p>
<p>I'm an incoming freshman student in California, USA, interested in mathematics and computer science. In particular, I'm interested in developing the representation theory library in mathlib. I'm looking for guidance, perhaps in the form of a summer internship, or someone who would be willing to oversee me in a project in representation theory. </p>
<p>I was wondering if anyone here could be looking for interns or knew of such opportunities.</p>
<p>I have experience contributing elementary results to mathlib. I'm comfortable with basic concepts in type theory, abstract algebra, and category theory. I'm not knowledgable in the fine details of representation theory, so there would be some inertia for me to contribute mathlib-level material--I would essentially be learning as I go. I know there's already a significant amount of un-PR'ed code spread out everywhere; I'm fine doing code transfer, but would prefer if I could prove something new. </p>
<p>I'm excited to learn, and I would be happy to talk about this in more detail. Thanks for reading!</p>



<a name="231378705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231378705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231378705">(Mar 22 2021 at 20:23)</a>:</h4>
<p>There's a ton of basic representation theory which is do-able but not done yet. You'd be welcome to join my group of students who will be meeting on Tuesdays throughout July and August.</p>



<a name="231389370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231389370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231389370">(Mar 22 2021 at 21:43)</a>:</h4>
<p>As a suggestion for source material: I like <a href="https://www-math.mit.edu/~etingof/repb.pdf">Pavel Etingof's notes</a> (it's an AMS book, but also freely available from his webpage), which I think should be pretty readily formalisable.</p>



<a name="231389657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231389657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231389657">(Mar 22 2021 at 21:45)</a>:</h4>
<p>I would love to see more rep th too. I did a little (the core fact of Maschke's theorem is at <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.is_semisimple_module/src">src#monoid_algebra.is_semisimple_module</a>), but it didn't seem like there were others wanting to work on it in the near future, so paused again.</p>



<a name="231390356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231390356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231390356">(Mar 22 2021 at 21:50)</a>:</h4>
<p>It would be wonderful to see the proof that the character table of a finite group is square.</p>



<a name="231409432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231409432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231409432">(Mar 23 2021 at 01:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Thank you for the response! I would love to join your group over the summer--could I DM you on Zulip or Discord to talk about more details?</p>



<a name="231418262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231418262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231418262">(Mar 23 2021 at 03:42)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/is_semisimple_module">docs#is_semisimple_module</a> now. I think I see two directions from here:</p>



<a name="231418287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231418287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231418287">(Mar 23 2021 at 03:43)</a>:</h4>
<ul>
<li>Continuing on the abstract algebra of semisimplicity towards Artin-Wedderburn (maybe the Jacobson Density Theorem first)?</li>
</ul>



<a name="231418396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231418396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231418396">(Mar 23 2021 at 03:45)</a>:</h4>
<ul>
<li>Defining the setoid of conjugacy (if it isn't already lurking somewhere) and its quotient, the type of conjugacy classes of a group/monoid. From there, it's probably not such a long road to the basics of character theory.</li>
</ul>



<a name="231433809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231433809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231433809">(Mar 23 2021 at 08:05)</a>:</h4>
<p>I'd be happy to contribute at some point especially if someone wants to collaborate towards the first bullet point. A tricky point for the second bullet point is potentially to determine the correct set of assumptions on the ground field (because presumably one doesn't want to just work over the complex numbers).</p>



<a name="231437287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231437287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231437287">(Mar 23 2021 at 08:40)</a>:</h4>
<p>The work I did on Mashke only assumes the characteristic doesn't divide the order of the field.</p>



<a name="231496296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231496296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231496296">(Mar 23 2021 at 16:04)</a>:</h4>
<p>Speaking of that, I feel like eventually whole files will assume that the characteristic doesn’t divide the order of the group, so we probably want to make that a <code>fact</code> instance</p>



<a name="231906728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231906728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231906728">(Mar 26 2021 at 02:43)</a>:</h4>
<p>Hi. I'm trying to go through the code in <a href="https://github.com/leanprover-community/mathlib/tree/representation">branch#representation</a> and make it work with the current version of lean again. I've run into this universe problem which I don't really understand. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basic</span>
<span class="kn">import</span> <span class="n">algebra.monoid_algebra</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">module_of_monoid_algebra_module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">k</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">restrict_scalars</span> <span class="n">k</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span>
<span class="c1">-- universe levels don't match</span>
</code></pre></div>
<p>Clicking on each thing in the viewer window tells me that <code>restrict_scalars</code> is a function <code>Type u_1 → Type u_2 → Type u_3 → Type u_3</code>. So I think the problem has to do with the final <code>u_3</code> not matching with the universe of <code>module k M</code>, but how do I fix this?<br>
(cc <span class="user-mention" data-user-id="110087">@Scott Morrison</span> because this is basically a copy of his code.)</p>



<a name="231906790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231906790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231906790">(Mar 26 2021 at 02:44)</a>:</h4>
<p>Oh dear, that branch is very old. :-) I wouldn't believe it's a good idea...</p>



<a name="231906852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231906852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231906852">(Mar 26 2021 at 02:45)</a>:</h4>
<p>Oh. What's wrong with this branch? I only needed to make minor changes up to this point, and everything seemed to work pretty well.</p>



<a name="231909047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231909047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231909047">(Mar 26 2021 at 03:19)</a>:</h4>
<p>I'll have a look. Do you want to push what you have?</p>



<a name="231909132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231909132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231909132">(Mar 26 2021 at 03:20)</a>:</h4>
<p>From memory there was still significant uncertainty about how best to represent the simultaneous actions of k and G. There are potentially 3 different <code>has_smul</code> instances available: <code>k</code>, <code>G</code> and <code>monoid_algebra k G</code>.</p>



<a name="231910802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231910802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231910802">(Mar 26 2021 at 03:46)</a>:</h4>
<p>Does the existence of <code>smul_comm_class</code> help with that?</p>



<a name="231911110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231911110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231911110">(Mar 26 2021 at 03:51)</a>:</h4>
<p>Pushed here: <a href="https://github.com/leanprover-community/mathlib/tree/acxxa/representation">branch#acxxa/representation</a></p>



<a name="231911231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231911231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231911231">(Mar 26 2021 at 03:53)</a>:</h4>
<p>It doesn't look like that branch has any commits that aren't on master?</p>



<a name="231911428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231911428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231911428">(Mar 26 2021 at 03:55)</a>:</h4>
<p>Oops. It should be there now.</p>



<a name="231912045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231912045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231912045">(Mar 26 2021 at 04:03)</a>:</h4>
<p>This is pointed out in the docs for <code>restrict_scalars</code>, but how about using <code>module k M</code>, <code>module (monoid_algebra k G) M</code>, and <code>is_scalar_tower k (monoid_algebra k G) M</code>? Then there's a <code>smul_comm_class</code> from the tower instance. </p>
<p>Is there anything that says if <code>A</code> is an <code>R</code>-algebra and <code>M</code> an <code>A</code>-monoid, then <code>is_scalar_tower R A M</code>?</p>



<a name="231914243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231914243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231914243">(Mar 26 2021 at 04:37)</a>:</h4>
<p>(I think my last work on this predates <code>is_scalar_tower</code>, and I've not yet got my head around it yet...)</p>



<a name="231916578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231916578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231916578">(Mar 26 2021 at 05:16)</a>:</h4>
<p>Yes, this probably should use both <code>is_scalar_tower</code> and <code>smul_comm_class</code></p>



<a name="231932529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231932529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231932529">(Mar 26 2021 at 09:00)</a>:</h4>
<p><code>is_scalar_tower R A M</code> requires a <code>has_scalar R M</code> instance to be used</p>



<a name="231932824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231932824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231932824">(Mar 26 2021 at 09:02)</a>:</h4>
<p>So I guess your question is "is there a pair of definitions that produce a <code>has_scalar R M</code> instance and a corresponding <code>is_scalar_tower R A M</code>?"</p>



<a name="231935234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231935234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231935234">(Mar 26 2021 at 09:27)</a>:</h4>
<p>If a group <code>G</code> acts on an abelian group <code>M</code> then this can also be viewed as a <code>k[G]</code>-module on <code>M</code>.</p>



<a name="231935252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231935252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231935252">(Mar 26 2021 at 09:27)</a>:</h4>
<p>And <code>G</code> also acts on <code>k[G]</code></p>



<a name="231935272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231935272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231935272">(Mar 26 2021 at 09:27)</a>:</h4>
<p>So we want <code>is_scalar_tower G (monoid_algebra k G) M</code></p>



<a name="231939071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231939071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231939071">(Mar 26 2021 at 10:01)</a>:</h4>
<p>And also one for k and k[G] and M?</p>



<a name="231939945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231939945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231939945">(Mar 26 2021 at 10:08)</a>:</h4>
<p>I still don't understand the concrete problem statement, but the error originally was confusing <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars">docs#restrict_scalars</a> with <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.semimodule">docs#restrict_scalars.semimodule</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basic</span>
<span class="kn">import</span> <span class="n">algebra.monoid_algebra</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">module_of_monoid_algebra_module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">k</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">k</span> <span class="bp">$</span> <span class="n">restrict_scalars</span> <span class="n">k</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>



<a name="231940084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940084">(Mar 26 2021 at 10:09)</a>:</h4>
<p>You also want a distrib mul action of G on M</p>



<a name="231940091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940091">(Mar 26 2021 at 10:09)</a>:</h4>
<p>This type of thing is IMO a bad idea though, and safer is to not unfold <code>restrict_scalars</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">module_of_monoid_algebra_module</span> <span class="o">:</span>
  <span class="n">module</span> <span class="n">k</span> <span class="o">(</span><span class="n">restrict_scalars</span> <span class="n">k</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">infer_instance</span>
</code></pre></div>



<a name="231940228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940228">(Mar 26 2021 at 10:10)</a>:</h4>
<p>Alternatively just make M a module for the monoid algebra and deduce the k module structure and the distrib mul action structure from that</p>



<a name="231940465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940465">(Mar 26 2021 at 10:12)</a>:</h4>
<p>I think that to talk about a representation in a flexible way, we might need 4 lines of <code>variables</code></p>



<a name="231940484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940484">(Mar 26 2021 at 10:12)</a>:</h4>
<p>To give commuting k and G actions on M is to give an action of the monoid algebra</p>



<a name="231940528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940528">(Mar 26 2021 at 10:13)</a>:</h4>
<p>Mathematicians pass freely between the two points of view</p>



<a name="231940679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940679">(Mar 26 2021 at 10:14)</a>:</h4>
<p>I think the <code>restrict_scalars</code>-free way to set this up is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">k</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">G</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
</code></pre></div>



<a name="231940686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940686">(Mar 26 2021 at 10:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">k</span><span class="o">]</span>  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">G</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">k</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
</code></pre></div>



<a name="231940729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940729">(Mar 26 2021 at 10:15)</a>:</h4>
<p>And probably an <code>is_smul_comm_class</code> for good measurer?</p>



<a name="231940753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940753">(Mar 26 2021 at 10:15)</a>:</h4>
<p>That's inferred from <code>is_scalar_tower</code> <del>I think?</del> via <a href="https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower.to_smul_comm_class">docs#is_scalar_tower.to_smul_comm_class</a></p>



<a name="231940928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231940928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231940928">(Mar 26 2021 at 10:17)</a>:</h4>
<p>aah, right. So that should be fine</p>



<a name="231941042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231941042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231941042">(Mar 26 2021 at 10:18)</a>:</h4>
<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>



<a name="231941106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231941106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231941106">(Mar 26 2021 at 10:18)</a>:</h4>
<p>You just want to say: "Let <code>M</code> be a <code>k</code>-linear <code>G</code>-module."</p>



<a name="231942405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231942405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231942405">(Mar 26 2021 at 10:29)</a>:</h4>
<p>Wait, actually I think you can do that</p>



<a name="231942453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231942453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231942453">(Mar 26 2021 at 10:29)</a>:</h4>
<p><del>Certainly the <code>module (monoid_algebra k G) M</code> instance is inferred already</del></p>



<a name="231942537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231942537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231942537">(Mar 26 2021 at 10:30)</a>:</h4>
<p>(my orange bars conspired against me again)</p>



<a name="231942708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231942708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231942708">(Mar 26 2021 at 10:31)</a>:</h4>
<p>Of course ideally we would abstract of <code>monoid_algebra k G</code>, and introduce a <code>k</code>-algebra <code>A</code> together with a predicate <code>is_monoid_algebra k G A</code>.</p>



<a name="231942811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231942811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231942811">(Mar 26 2021 at 10:32)</a>:</h4>
<p>Because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo><msub><mo>⊗</mo><mi>k</mi></msub><mi>R</mi><mo>=</mo><mi>R</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G] \otimes_k R = R[G]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span>, but Lean will not believe that equality.</p>



<a name="231942983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231942983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231942983">(Mar 26 2021 at 10:33)</a>:</h4>
<p>I think perhaps this instance should exist and is missing?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="231943915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231943915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231943915">(Mar 26 2021 at 10:40)</a>:</h4>
<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>



<a name="231943934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231943934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231943934">(Mar 26 2021 at 10:41)</a>:</h4>
<p>Maybe Eric's suggestion is better.</p>



<a name="231943976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231943976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231943976">(Mar 26 2021 at 10:41)</a>:</h4>
<p>That's goes in the reverse direction to most of mathlib, so is likely to form loops</p>



<a name="231944044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231944044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231944044">(Mar 26 2021 at 10:42)</a>:</h4>
<p>In practice, I have a Galois group <code>G</code> that acts on a field <code>L</code> that is an extension of <code>K</code>, and maybe I now want to view <code>L</code> as a <code>K[G]</code>-module.</p>



<a name="231944126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231944126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231944126">(Mar 26 2021 at 10:42)</a>:</h4>
<p>So I don't want to derive the action of the Galois group <code>G</code> on <code>L</code> from the <code>K[G]</code>-module on <code>L</code>.</p>



<a name="231944939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231944939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231944939">(Mar 26 2021 at 10:49)</a>:</h4>
<p>I assume the instance you want is something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">kG</span> <span class="n">m</span><span class="o">,</span> <span class="n">finsupp.lift_add_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">k</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•</span> <span class="n">m</span><span class="o">))</span> <span class="n">kG</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_monoid_hom.map_add</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_monoid_hom.map_zero</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="231944942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231944942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231944942">(Mar 26 2021 at 10:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/231941042">said</a>:</p>
<blockquote>
<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>
</blockquote>
<p>I think they hit that limit in analysis some time ago!</p>



<a name="231945115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231945115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231945115">(Mar 26 2021 at 10:51)</a>:</h4>
<p>I'm pretty sure there's a clever way to build a bundled hom in <code>smul</code> such that all the <code>sorry</code>s are as trivial as the first two proofs</p>



<a name="231949820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/231949820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#231949820">(Mar 26 2021 at 11:34)</a>:</h4>
<p>This gets two more proofs for free:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">kG</span> <span class="n">m</span><span class="o">,</span>
    <span class="o">((</span><span class="n">finsupp.lift_add_hom</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">≃+</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">M</span><span class="o">))</span><span class="bp">.</span><span class="n">to_add_monoid_hom.comp</span>
      <span class="o">(</span><span class="n">add_monoid_hom.pi</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">g</span> <span class="bp">•</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">k</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span><span class="o">))</span><span class="bp">.</span><span class="n">flip</span> <span class="n">kG</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_monoid_hom.map_add</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_monoid_hom.map_zero</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span> <span class="n">add_monoid_hom.map_add</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_monoid_hom.map_zero</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>
<p>but needs <a href="https://github.com/leanprover-community/mathlib/issues/6891">#6891</a> for the <code>g  •</code>, and a definition of <code>add_monoid_hom.pi</code> which appears to be missing.</p>



<a name="236115794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236115794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236115794">(Apr 26 2021 at 03:38)</a>:</h4>
<p>Hi, I went back to trying stuff out with this and I've written up a representation theory version of <span class="user-mention" data-user-id="110087">@Scott Morrison</span>'s Maschke's lemma. It's pushed to <a href="https://github.com/leanprover-community/mathlib/tree/acxxa/representation">branch#acxxa/representation</a>. I've also copy pasted a whole bunch of stuff from <code>submodule</code> to create API for a<code>subrepresentation</code> structure I defined. There's also a lattice isomorphism between subrepresentations and submodules of the induced monoid algebra. (The equivalence between the module/representation theoretic versions of Maschke is easy after that.)</p>
<p>I'm not really looking to push any of this into mathlib yet, since I mostly followed my nose and copy pasted along. I could very possibly have done something terribly wrong without realizing it. So, I just wanted to ask here for thoughts and suggestions from everybody. Also, I'm willing to put a lot more effort into this, but I thought it'd be best to tell everyone here first.</p>
<p>Anything is welcome! :)</p>



<a name="236121930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236121930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236121930">(Apr 26 2021 at 05:21)</a>:</h4>
<p>Looks promising! Presumably we should tweak <code>maschke.lean</code> so that it uses <code>representation</code>, rather than <code>module (monoid_algebra _ _)</code>.</p>



<a name="236121934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236121934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236121934">(Apr 26 2021 at 05:21)</a>:</h4>
<p>Do you see any obstacle to doing that?</p>



<a name="236122000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236122000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236122000">(Apr 26 2021 at 05:22)</a>:</h4>
<p>I'm about to PR Schur's lemma in any linear category over an algebraically closed field. I really hope we can use that statement to directly infer the group theoretical statement of Schur's lemma. (And, similarly, the Lie-theoretic statement.)</p>



<a name="236124815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236124815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236124815">(Apr 26 2021 at 06:08)</a>:</h4>
<p>(This is now up as <a href="https://github.com/leanprover-community/mathlib/issues/7366">#7366</a>, but it has some dependent PRs so may take a little while.)</p>



<a name="236286551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236286551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236286551">(Apr 27 2021 at 05:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/236121934">said</a>:</p>
<blockquote>
<p>Do you see any obstacle to doing that?</p>
</blockquote>
<p>No, it should be pretty easy. I've started to phase the <code>monoid_algebra k G</code> out and so far the proofs look exactly the same.</p>



<a name="236286699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236286699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236286699">(Apr 27 2021 at 05:49)</a>:</h4>
<p>Since you're also working with this stuff, you can always tell me about possible conflicting work, or maybe possible converging work. I'm always happy to coordinate  :)</p>
<p>(But I'm probably going into the finite groups, character theory direction -- I don't know much about category theory)</p>



<a name="236287912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236287912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236287912">(Apr 27 2021 at 06:08)</a>:</h4>
<p>I think character theory is a lovely direction, and I don't have anything in progress there.</p>



<a name="236287955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236287955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236287955">(Apr 27 2021 at 06:08)</a>:</h4>
<p>I would like to make sure my recent general statement of Schur's lemma is actually usable in representation theory.</p>



<a name="236289133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236289133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236289133">(Apr 27 2021 at 06:26)</a>:</h4>
<p>Ok. I don't really know what that connection should look like, but I can make sure to set up most of the concrete instances on the ground</p>



<a name="236297404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236297404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236297404">(Apr 27 2021 at 07:58)</a>:</h4>
<p>Again this would be a really nice example showing that we can get theorems about concrete structures of interest from "abstract nonsense".</p>



<a name="236299032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236299032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236299032">(Apr 27 2021 at 08:15)</a>:</h4>
<p>I don't think Schur's lemma for linear categories exactly counts as abstract nonsense...</p>



<a name="236312110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236312110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236312110">(Apr 27 2021 at 10:13)</a>:</h4>
<p>By "abstract nonsense" I just mean "any theorem about categories"! We've already proved that categories are useful for mathematical definitions, because of schemes. The next step is to prove they're useful for theorems not in category theory and it looks like right now we have two great candidates for this (this and profinite stuff). Homological algebra will be a third.</p>



<a name="236313520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236313520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236313520">(Apr 27 2021 at 10:26)</a>:</h4>
<p>I'd love to start using the category theory stuff we have. I don't expect to get to this for some time but getting Schur's lemma for Lie modules as a dividend is just the motivation I need.</p>



<a name="236365846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236365846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236365846">(Apr 27 2021 at 16:11)</a>:</h4>
<p><span class="user-mention" data-user-id="355764">@Hanting Zhang</span>, I like that you're moving forward on actually defining <code>representation</code>s and <code>rep_hom</code>s, but of course I have opinions on which definition should be the basic definition.</p>



<a name="236366039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236366039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236366039">(Apr 27 2021 at 16:12)</a>:</h4>
<p>Personally, I'd choose the definition currently used in the library (a <code>module (monoid_algebra k G) V</code>), and I'm about to say why, but ultimately as long as that instance, the <code>smul_comm</code> instance, and the <code>to_monoid_hom/of_monoid_hom</code> structure are still there at the end of the day, I don't think it matters that much what the underlying definition is.</p>



<a name="236366454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236366454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236366454">(Apr 27 2021 at 16:15)</a>:</h4>
<p>I vote for <code>representation k G V</code> to be defined as an <code>abbreviation</code> of <code>module (monoid_algebra k G) V</code>, because then <code>subrepresentation</code> can be an abbreviation of <code>submodule (monoid_algebra k G) V</code> and <code>rep_hom</code> can be an abbreviation of <code>linear_map</code>, again over <code>monoid_algebra k G</code>.</p>



<a name="236366833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236366833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236366833">(Apr 27 2021 at 16:17)</a>:</h4>
<p>You have to define all of the extra structure on <code>representation, subrepresentation, rep_hom</code> one way or another, but this way you don't have to copy and paste all the basic API just to define them and get the basic instances on them.</p>



<a name="236366955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236366955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236366955">(Apr 27 2021 at 16:18)</a>:</h4>
<p>Ok. Actually I think I agree with sticking to <code>monoid_algebra k G</code>; it would prevent all the duplication I've been doing.</p>



<a name="236367068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236367068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236367068">(Apr 27 2021 at 16:19)</a>:</h4>
<p>It is not the definition we give to undergraduates, but experience has shown us that the fewer definitions we have, the better.</p>



<a name="236367170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236367170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236367170">(Apr 27 2021 at 16:19)</a>:</h4>
<p>If I had seen the "burn <code>vector_space</code>" PR I would have suggested that it lived on as an <code>abbreviation</code></p>



<a name="236367383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236367383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236367383">(Apr 27 2021 at 16:21)</a>:</h4>
<p>If you abbreviate these things, and provide the <code>smul_comm</code> instances and so on, it should still be possible to work entirely with those other approaches (although even my undergrad class eventually switched to mostly using group-ring-modules...)</p>



<a name="236367518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236367518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236367518">(Apr 27 2021 at 16:22)</a>:</h4>
<p>As we move further into the library, it should also be possible to make <code>irreducible_representation</code> an abbreviation for <code>simple_module</code> and so on</p>



<a name="236367562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236367562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236367562">(Apr 27 2021 at 16:22)</a>:</h4>
<p>Yes, the way I was taught it was all G-actions on k-vector spaces and then suddenly this bombshell half way through that it's just R-modules for R=k[G] and about 3/4 of the lemmas we'd proved until that point were true in far greater generality</p>



<a name="236367787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236367787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236367787">(Apr 27 2021 at 16:24)</a>:</h4>
<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>



<a name="236368254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236368254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236368254">(Apr 27 2021 at 16:26)</a>:</h4>
<p>It'd also be nice if there's a short-and-sweet notation that approximates the <code>ρ g</code> notation that you use when talking about the group homomorphism</p>



<a name="236368493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236368493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236368493">(Apr 27 2021 at 16:28)</a>:</h4>
<p>Perhaps as simple as <code>ρ k M g</code>...</p>



<a name="236368832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236368832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236368832">(Apr 27 2021 at 16:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/236367787">said</a>:</p>
<blockquote>
<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>
</blockquote>
<p>I think this is what I've done indirectly. <code>representation</code> extends <code>smul_comm_class</code> for the <code>G</code> and <code>k</code> actions. Then I derive a <code>module</code> instance. </p>
<p>I could just cut out defining a <code>representation</code> and do this directly</p>



<a name="236369236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236369236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236369236">(Apr 27 2021 at 16:33)</a>:</h4>
<p>But I didn't seem to hit any problems with the type class inference after I defined the <code>module</code> instance; is there an explicit loop we should be worried about?</p>



<a name="236371894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236371894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236371894">(Apr 27 2021 at 16:50)</a>:</h4>
<p>Presumably you want to provide a <code>smul_comm_class</code> given a <code>module (monoid_algebra _ _)</code> AND vice versa, but only one can be an instance</p>



<a name="236373177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236373177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236373177">(Apr 27 2021 at 17:00)</a>:</h4>
<p>Without having followed earlier conversation - the <code>of'</code> in <code>representation_theory/basic.lean</code> in your branch is <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom">docs#monoid_algebra.single_one_ring_hom</a></p>



<a name="236373373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236373373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236373373">(Apr 27 2021 at 17:01)</a>:</h4>
<p>Ok. I might be missing the point, but why do we want both directions?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">blah</span> <span class="n">blah...</span> <span class="c1">-- define this</span>
</code></pre></div>
<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>



<a name="236373901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236373901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236373901">(Apr 27 2021 at 17:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373177">said</a>:</p>
<blockquote>
<p>Without having followed earlier conversation - the <code>of'</code> in your branch is <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom">docs#monoid_algebra.single_one_ring_hom</a></p>
</blockquote>
<p>Oh oops, I missed this. But the name is so long...</p>



<a name="236373979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236373979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236373979">(Apr 27 2021 at 17:05)</a>:</h4>
<p>Well, you can always define <code>of' := monoid_algebra.single_one_ring_hom</code> and sort out the name later - but there's no need to prove it again!</p>



<a name="236374100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236374100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236374100">(Apr 27 2021 at 17:06)</a>:</h4>
<p>Yeah, that's going to be the first thing I do</p>



<a name="236377716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236377716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236377716">(Apr 27 2021 at 17:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373373">said</a>:</p>
<blockquote>
<p>Ok. I might be missing the point, but why do we want both directions?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">blah</span> <span class="n">blah...</span> <span class="c1">-- define this</span>
</code></pre></div>
<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>
</blockquote>
<p>If we define a representation as <code>module (monoid_algebra k G) M</code>, then whenever we want to use a representation, we'll assume <code>[representation k G M]</code> which will be equivalent to <code>[module (monoid_algebra k G) M]</code>. Once we're there, we'll sometimes want to refer directly to the <code>k</code>-action, and sometimes to the <code>G</code>-action, so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. We'll also want to know that those commute with each other and with the action of <code>monoid_algebra k G</code>, hence you'll want <code>smul_comm_class</code> and <code>is_scalar_tower</code> instances</p>



<a name="236378169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378169">(Apr 27 2021 at 17:35)</a>:</h4>
<blockquote>
<p>so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. </p>
</blockquote>
<p>This doesn't make any sense, because you're not allowed to write <code>[representation k G M]</code> without writing <code>[module k M] [distrib_mul_action G M]</code> first</p>



<a name="236378228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378228">(Apr 27 2021 at 17:36)</a>:</h4>
<p>It's like saying you want an instance to go from <code>module k M</code> to <code>add_comm_monoid M</code></p>



<a name="236378299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378299">(Apr 27 2021 at 17:36)</a>:</h4>
<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>



<a name="236378308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378308">(Apr 27 2021 at 17:37)</a>:</h4>
<p>Ohh, I understand. I'm also realizing that all of this was basically said before in this thread, I just didn't get it before (<span class="user-mention" data-user-id="310045">@Eric Wieser</span>  even wrote down the <code>module</code> instance explicitly right above my first comment <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> )</p>



<a name="236378451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378451">(Apr 27 2021 at 17:38)</a>:</h4>
<p>Oh, I hadn't realized this thread had older replies from me in it!</p>



<a name="236378555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378555">(Apr 27 2021 at 17:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/236378299">said</a>:</p>
<blockquote>
<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>
</blockquote>
<p>Yes, I've been suggesting that we define it as <code>module (monoid_algebra k G) M</code>, which means basically flipping everything <span class="user-mention" data-user-id="355764">@Hanting Zhang</span> ' been doing backwards...</p>



<a name="236378757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236378757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236378757">(Apr 27 2021 at 17:41)</a>:</h4>
<p>That's perfectly fine with me btw -- actually less work in the long run because there's no duplication</p>



<a name="236379929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236379929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236379929">(Apr 27 2021 at 17:48)</a>:</h4>
<p>Based on the recent <code>vector_space</code> removal, I think that is a definition that belongs only in a docstring</p>



<a name="236380009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236380009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236380009">(Apr 27 2021 at 17:49)</a>:</h4>
<p>Although I guess that argument applies to the definition in the branch too</p>



<a name="236380037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236380037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236380037">(Apr 27 2021 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>
<span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915">said</a>:</p>
<blockquote>
<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>
</blockquote>



<a name="236380234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236380234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236380234">(Apr 27 2021 at 17:50)</a>:</h4>
<p>I think the usual way to handle this is add instances in the forwards direction (the branch), and type aliases like <code>restrict_scalars</code> in the backwards direction (that suggestion)</p>



<a name="236381558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236381558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236381558">(Apr 27 2021 at 17:58)</a>:</h4>
<p>Ok. It seems like I will follow the main mathlib direction with this setup then:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">M</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">blah</span> <span class="n">blah...</span> <span class="c1">-- a representation</span>
</code></pre></div>
<p>And we can go backwards with <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.module">docs#restrict_scalars.module</a> and, err, hopefully <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.distrib_mul_action">docs#restrict_scalars.distrib_mul_action</a></p>



<a name="236426228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236426228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236426228">(Apr 27 2021 at 23:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/236380037">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>
<span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915">said</a>:</p>
<blockquote>
<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?<br>
</p>
</blockquote>
</blockquote>
<p>I definitely mean this.</p>



<a name="236488008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236488008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236488008">(Apr 28 2021 at 11:09)</a>:</h4>
<p>Looking at the branch, this instance worries me a bit:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">has_group_scalar</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">G</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">monoid_algebra.of</span> <span class="n">k</span> <span class="n">G</span> <span class="n">g</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">}</span>
</code></pre></div>
<p>because when <code>k = G</code> you end up with two <code>has_scalar G (monoid_algebra G G)</code> instances which have different actions.</p>



<a name="236488210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236488210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236488210">(Apr 28 2021 at 11:11)</a>:</h4>
<p>Perhaps no one ever uses <code>monoid_algebra G G</code> so it doesn't really matter</p>



<a name="236488328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236488328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236488328">(Apr 28 2021 at 11:12)</a>:</h4>
<p>You'll have things like <code>G = units k</code>. But <code>G = k</code> is unlikely, I think.</p>



<a name="236489458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236489458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236489458">(Apr 28 2021 at 11:23)</a>:</h4>
<p>I think I've seen <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[\mathbb{Z}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathbb">Z</span><span class="mclose">]</span></span></span></span> before, but this is the integers as an additive monoid.</p>



<a name="236489696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236489696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236489696">(Apr 28 2021 at 11:25)</a>:</h4>
<p>To avoid the issue we could create a type alias and instead declare the action <code>has_scalar (foo G) (monoid_algebra k G)</code></p>



<a name="236490390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490390">(Apr 28 2021 at 11:31)</a>:</h4>
<p>I think that in the additive setting, this is more likely to be a problem.</p>



<a name="236490426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490426">(Apr 28 2021 at 11:31)</a>:</h4>
<p>Are we trying to do representation theory of additive monoid/groups as well?</p>



<a name="236490505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490505">(Apr 28 2021 at 11:32)</a>:</h4>
<p>Otherwise Kevin's example would end up begin <code>monoid_algebra int (multiplicative int)</code> and there wouldn't be a problem anyway.</p>



<a name="236490720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490720">(Apr 28 2021 at 11:34)</a>:</h4>
<p>I am playing with <code>monoid_algebra</code> for the LTE, and I indeed suggest to avoid <code>add_monoid_algebra</code> if possible</p>



<a name="236490789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490789">(Apr 28 2021 at 11:34)</a>:</h4>
<p>It really makes things confusing</p>



<a name="236490830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490830">(Apr 28 2021 at 11:34)</a>:</h4>
<p>Is that a good reason to avoid it?</p>



<a name="236490918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490918">(Apr 28 2021 at 11:35)</a>:</h4>
<p>I tried to prove the Riemann hypothesis but it really got confusing</p>



<a name="236490955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490955">(Apr 28 2021 at 11:35)</a>:</h4>
<p>I mean, one can prove everything for <code>monoid_algebra</code>, and at the end translate the results for <code>add_monoid_algebra</code> using the fact that they are isomorphic</p>



<a name="236490999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236490999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236490999">(Apr 28 2021 at 11:36)</a>:</h4>
<p>Yes, that's a fair point.</p>



<a name="236491066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/236491066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#236491066">(Apr 28 2021 at 11:36)</a>:</h4>
<p>Or, if you have an additive group <code>A</code> that you want to do representation theory with, just apply the theory to <code>multiplicative A</code></p>



<a name="239917151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239917151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239917151">(May 23 2021 at 02:28)</a>:</h4>
<p>Hi a third time,</p>
<p>So I didn't do anything with representation theory for awhile, because I kind of sidetracked onto a project to prove the Artin-Wedderburn Theorem, which is finally coming along in <a href="https://github.com/leanprover-community/mathlib/tree/acxxa/representation">branch#acxxa/representation</a>. It took 1500 loc though, so knowing me it will probably be another while before I can clean it up fully. </p>
<p>Just posting this out here in case anyone else is planning (or already! -- that would be awkward) working on this.</p>



<a name="239919422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239919422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239919422">(May 23 2021 at 03:15)</a>:</h4>
<p>I was working toward this, but I PRed all the work I did manage. I’ll take a look at what you’ve done.</p>



<a name="239921043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239921043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239921043">(May 23 2021 at 03:52)</a>:</h4>
<p>What is the maths-statement of the version of Artin-Wedderburn you're aiming at?</p>



<a name="239922346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239922346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239922346">(May 23 2021 at 04:19)</a>:</h4>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> be a semi-simple ring. Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> decomposes as a direct sum of simple modules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>⨁</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bigoplus_{i = 1}^k n_i S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and there is an ring isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant="script">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy="false">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{End}_R R \simeq \prod_{i = 1}^k \mathcal {M}_{n_i} (\text{End}_R (S_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span>. Here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">M</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal M_{n} (-)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mclose">)</span></span></span></span> is the ring of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> matrices. Actually we want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mtext>op</mtext></msup><mo>≃</mo><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant="script">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy="false">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R^\text{op} \simeq \text{End}_R R \simeq \prod_{i = 1}^k \mathcal {M}_{n_i} (\text{End}_R (S_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">op</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> but I haven't thought too hard about how the <code>op</code>'s go yet.</p>
<p>The tricky part was to figure out how to write the sum properly. Because letting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> range from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1, \dots, k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> really means something like going through the isomorphism classes of the set of simple submodules that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> decomposes into. Furthermore, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> quantifies the number of submodules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">S&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>≃</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S&#x27; \simeq S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, which is the size of each isomorphism class containing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>In <code>direct_sum_stuff.lean</code>, <code>isomorphism_quot R R</code> is the quotient of <code>decomposition R R</code> by an isomorphism relation. Then for any <code>i : isomorphism_quot R R</code>, we define <code>quotient.class i</code> as the class of <code>i</code>'s representative. So <code>isomorphism_quot R R</code> is supposed to be <code>1,...,k</code> and <code>quotient.class i</code> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. The isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant="script">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy="false">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{End}_R R \simeq \prod_{i = 1}^k \mathcal {M}_{n_i} (\text{End}_R (S_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathcal">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span> looks like this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">something</span> <span class="o">[</span><span class="n">is_semisimple_module</span> <span class="n">R</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">isomorphism_quot</span> <span class="n">R</span> <span class="n">R</span><span class="o">),</span>
    <span class="n">matrix</span> <span class="o">(</span><span class="n">quotient.class</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">quotient.class</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">module.End</span> <span class="n">R</span> <span class="n">i.out</span><span class="o">))</span> <span class="bp">≃+*</span> <span class="n">module.End</span> <span class="n">R</span> <span class="n">R</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="239922692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239922692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239922692">(May 23 2021 at 04:27)</a>:</h4>
<p>Hopefully this looks correct and understandable. (and sane?) I would be very happy to take any suggestions and/or talk about my code!</p>



<a name="239922994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239922994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239922994">(May 23 2021 at 04:32)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Thanks in advance! Sorry everything is in the wrong place right now. I will be organizing code, files, and docstrings in the next few days so it should be much clearer then</p>



<a name="239923135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239923135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239923135">(May 23 2021 at 04:34)</a>:</h4>
<p>Oh and it shouldn't be too hard to go from the above and prove the version where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is also an algebra over some field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>.</p>



<a name="239929435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239929435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239929435">(May 23 2021 at 06:42)</a>:</h4>
<p>The first statement "R decomposes as a direct sum" is just the definition of semisimple, right? Or are you using "Jacobson radical is trivial"?</p>



<a name="239929499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239929499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239929499">(May 23 2021 at 06:44)</a>:</h4>
<p>The second statement "there is a ring isomorphism ..." has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>



<a name="239929519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239929519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239929519">(May 23 2021 at 06:44)</a>:</h4>
<p>I think an important part of Artin-Wedderburn is that this decomposition is unique up to relabelling.</p>



<a name="239929606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239929606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239929606">(May 23 2021 at 06:46)</a>:</h4>
<p>I had been proving this on a branch a while ago --- the version I wanted was that if you had a collection of objects so that homs between them were either zero or isomorphisms (e.g. the set of all simple objects), then decompositions into direct sums of these objects were unique (before we even come to the question of existence).</p>



<a name="239982586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239982586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239982586">(May 23 2021 at 22:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929435">said</a>:</p>
<blockquote>
<p>The first statement "R decomposes as a direct sum" is just the definition of semisimple, right? Or are you using "Jacobson radical is trivial"?</p>
</blockquote>
<p>Yes, I'm just using the definition.</p>



<a name="239982885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239982885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239982885">(May 23 2021 at 22:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929499">said</a>:</p>
<blockquote>
<p>The second statement "there is a ring isomorphism ..." has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>
</blockquote>
<p>As for the second part, I think I agree that the two parts are really separate things. I'm very out of depth on your first sentence though. What more general objects are you talking about when you say "nothing to do with rings and modules"?</p>



<a name="239983496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239983496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239983496">(May 23 2021 at 22:46)</a>:</h4>
<p>To be honest I wasn't even thinking about the unique part but now I'm realizing that it should also be a part of the proof. It shouldn't be too hard to prove from my approach just working concretely with the modules. May I ask how you've been approaching it? I guess which way do you think is more important?</p>



<a name="239989405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239989405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239989405">(May 24 2021 at 00:33)</a>:</h4>
<p>So we have the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.simple/src">src#category_theory.simple</a>, which hopefully is enough to do the endomorphism ring calculation.</p>



<a name="239989732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239989732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239989732">(May 24 2021 at 00:39)</a>:</h4>
<p>Say you have a collection of objects <code>X i</code> in a preadditive category such that <code>(X i ⟶ X j) = 0</code> when <code>i \ne j</code>. Then if you have a direct sum of these objects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo>⨁</mo><msub><mi>n</mi><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A = \bigoplus n_i X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (quite how to state that hypothesis is actually the trickiest thing here), then it should be easy to provide the ring isomorphism from <code>End A</code> to the direct sum of matrices over the <code>End (X i)</code>.</p>



<a name="239989939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239989939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239989939">(May 24 2021 at 00:42)</a>:</h4>
<p>Then the next step is to assume something a little stronger: every nonzero morphism <code>X i ⟶ X i</code> is an isomorphism (e.g. this holds if you take <code>X i</code> to be the collection of simples). (I don't think we even need Schur's lemma yet, which says that if the category is linear over an algebraically closed field then every morphisms <code>X i ⟶ X i</code> is actually a multiple of the identity.)</p>
<p>Now you can prove inductively, by a "Gaussian elimination" type argument, that if you have <span class="tex-error">$$\bigoplus n_i X_i \iso \bigoplus m_i X_i$$</span> then in fact <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i = m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="239989975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239989975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239989975">(May 24 2021 at 00:43)</a>:</h4>
<p>I should say I haven't actually done this. I made one aborted attempt that was unnecessarily complicated, but I would like to do this at some point.</p>



<a name="239990403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/239990403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#239990403">(May 24 2021 at 00:50)</a>:</h4>
<p>A final thing that would be nice to prove: </p>
<p>Let's give a name to the two above conditions on a collection of <code>X i</code> (that <code>(X i ⟶ X j) = 0</code> when <code>i \ne j</code>, and any nonzero endomorphism of an <code>X i</code> is invertible), "<code>X</code> are mutually simple". (Notice that the <code>X</code> aren't necessarily simple in this definition!)</p>
<p>Then you can prove that if every object <code>Z</code> is isomorphic to some direct sum of the <code>X i</code> (in fact, in a unique way by the claim above), in fact the category is semisimple, and the <code>X i</code> are a set of representatives of the isomorphism classes of simples.</p>
<p>This approach is useful for example in quantum topology: e.g. typically any "diagrammatic algebra", like the Temperley-Lieb algebra underlying the Jones polynomial, is awkward to prove semisimplicity "via algebra", and the best approach is to produce this family of mutually simple objects first, then conclude afterwards the category is semisimple. In the quantum topology literature this approach sometimes goes by the name "Müger semisimplicity", as he explained how to use it.</p>



<a name="240006782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240006782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240006782">(May 24 2021 at 05:09)</a>:</h4>
<p>In the literature "mutually simple" is called a "semibrick". There is a related condition of a "simple-minded collection" in a triangulated category.</p>



<a name="240013032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240013032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240013032">(May 24 2021 at 06:52)</a>:</h4>
<p>Oh, interesting, where do people use "semibrick"? I hadn't heard that one.</p>



<a name="240014896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240014896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240014896">(May 24 2021 at 07:17)</a>:</h4>
<p>In representation theory of finite dimensional algebras, most recently in a generalisation of the classical theory of tilting modules called tau-tilting theory, see e.g. <a href="https://arxiv.org/abs/1610.05860">https://arxiv.org/abs/1610.05860</a></p>



<a name="240309657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240309657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240309657">(May 26 2021 at 11:29)</a>:</h4>
<p>Here's a first cut at proving that morphisms between direct sums of hom-orthogonal objects can be decomposed into direct sums of matrix blocks:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.preadditive</span>
<span class="kn">import</span> <span class="n">category_theory.limits.shapes.biproducts</span>
<span class="kn">import</span> <span class="n">data.matrix.basic</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kn">open</span> <span class="n">category_theory.limits</span>

<span class="kd">universes</span> <span class="n">v</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">hom_orthogonal</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">s</span> <span class="n">j</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">C</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">hom_orthogonal.eq_zero</span> <span class="o">[</span><span class="n">has_zero_morphisms</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">hom_orthogonal</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">⟶</span> <span class="n">s</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">o</span> <span class="n">i</span> <span class="n">j</span> <span class="n">w</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subsingleton.elim</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">has_zero_morphisms</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">has_finite_biproducts</span> <span class="n">C</span><span class="o">]</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">hom_orthogonal.matrix_decomposition</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">ι</span><span class="o">)</span>
  <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">hom_orthogonal</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨁</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="bp">⟶</span> <span class="bp">⨁</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">))</span> <span class="bp">≃</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="n">g</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="n">End</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">eq_to_hom</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">j</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="o">⟨⟩⟩,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">})</span> <span class="bp">≫</span>
      <span class="n">biproduct.components</span> <span class="n">z</span> <span class="n">j</span> <span class="n">k</span> <span class="bp">≫</span> <span class="n">eq_to_hom</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">k</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="o">⟨⟩⟩,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">}),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">biproduct.matrix</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span> <span class="n">k</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">k</span> <span class="k">then</span>
      <span class="n">z</span> <span class="o">(</span><span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]⟩</span> <span class="bp">≫</span> <span class="n">eq_to_hom</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>
    <span class="k">else</span>
      <span class="mi">0</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">j</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category.assoc</span><span class="o">,</span> <span class="n">biproduct.lift_π</span><span class="o">,</span> <span class="n">biproduct.ι_matrix</span><span class="o">],</span>
    <span class="n">split_ifs</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">apply</span> <span class="n">o.eq_zero</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">i</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="o">⟨⟩⟩</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">w</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_preimage</span><span class="o">,</span> <span class="n">set.mem_singleton_iff</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">w.symm</span><span class="o">],</span> <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span> <span class="o">}</span>

<span class="c1">-- TODO additive version? linear version?</span>
</code></pre></div>



<a name="240309823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240309823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240309823">(May 26 2021 at 11:31)</a>:</h4>
<p>unique decomposition in a semibrick (a <code>hom_orthogonal</code> family where each object's nonzero endomorphisms are invertible) is going to be a little bit more involved, but I'll try it soon.</p>



<a name="240422417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422417">(May 27 2021 at 05:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks for all your replies! Since you're planning to work on this, I don't think my approach really makes sense anymore. Especially because mine seems to be strictly less general. Would you mind though if I tried to redo some of my work following your thoughts on the category theoretic version? To be clear I would like to try as more of a learning project rather than a <code>for mathlib</code> project, in case you don't want interference.</p>



<a name="240422426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422426">(May 27 2021 at 05:37)</a>:</h4>
<p>Although a side effect may be that I start asking a lot of random category theory questions here.</p>



<a name="240422498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422498">(May 27 2021 at 05:38)</a>:</h4>
<p>Oops, sorry, I don't mean to stop you doing anything. I've been thinking about doing this for a while but haven't actually done it, so I don't want to discourage you!</p>



<a name="240422583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422583">(May 27 2021 at 05:40)</a>:</h4>
<p>I just didn't want to wait until you had a PR to make suggestions about how to decouple AW into smaller pieces. :-)</p>



<a name="240422632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422632">(May 27 2021 at 05:41)</a>:</h4>
<p>One possibility would be to clean up what I posted above and get that ready for a PR. There are obvious next steps: show the equivalence I constructed is compatible with the obvious compositions on both sides, and then deduce the ring isomorphism for an endomorphism.</p>



<a name="240422680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422680">(May 27 2021 at 05:42)</a>:</h4>
<p>Would you be interested in doing that?</p>



<a name="240422685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422685">(May 27 2021 at 05:43)</a>:</h4>
<p>Ah, my bad for misunderstanding. I kind of read too much into what you said lol</p>



<a name="240422699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422699">(May 27 2021 at 05:43)</a>:</h4>
<p>You've seen all the work I've done so far! :-)</p>



<a name="240422707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422707">(May 27 2021 at 05:43)</a>:</h4>
<p>Now I'm thinking I should definitely get my original code PR out so people can actually see what I'm trying to put into mathlib</p>



<a name="240422765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422765">(May 27 2021 at 05:44)</a>:</h4>
<p>I would be very interested in doing a general version of Artin-Wedderburn as a follow up!</p>



<a name="240422772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422772">(May 27 2021 at 05:45)</a>:</h4>
<p>Yes -- it's also no problem I think if first versions of things in mathlib are not in maximal generality. If someone upgrades your content later with something more general, you shouldn't feel sad about it, but happy that you provoked someone into doing work. :-)</p>



<a name="240422876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/240422876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#240422876">(May 27 2021 at 05:47)</a>:</h4>
<p>I think I just have a bad habit of writing too much code without PRing any of it. <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> Time too clean up all of my code...</p>



<a name="241665540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665540">(Jun 06 2021 at 01:36)</a>:</h4>
<p>I mentioned in <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> wanting to add more representation theory to mathlib. While I only learned it from Fulton &amp; Harris, <span class="user-mention" data-user-id="110087">@Scott Morrison</span> suggested Etingof. Just starting a thread here to gather some opinions and advice.</p>



<a name="241665598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665598">(Jun 06 2021 at 01:38)</a>:</h4>
<p>Others have certainly been thinking about this recently: e.g. <span class="user-mention" data-user-id="355764">@Hanting Zhang</span>, myself (very slowly, sorry). I'm looking forward to more representation theory!</p>
<p>I'm actually doing a bunch of low-level work at the moment, generalising a lot of our code about dimensions and bases to arbitrary noetherian and/or commutative rings (where previously it was just done over a field). I'm hoping this will be useful in representation theory per se soon.</p>



<a name="241665601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665601">(Jun 06 2021 at 01:38)</a>:</h4>
<p>Higher up in this same thread there is discussion about Artin-Wedderburn.</p>



<a name="241665653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665653">(Jun 06 2021 at 01:40)</a>:</h4>
<p>We already have Maschke's theorem (<a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.submodule.is_complemented/src">src#monoid_algebra.submodule.is_complemented</a>) and Schur's lemma.</p>



<a name="241665664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665664">(Jun 06 2021 at 01:41)</a>:</h4>
<p>Although the current statement of Maschke's theorem is the "core" fact, and often you see it stated in a form that also gives various corollaries, so this might be a good first step. (i.e. find all the statements of Maschke's theorem you can in books, and make sure they follow from the version of Maschke's theorem already in mathlib!)</p>



<a name="241665801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665801">(Jun 06 2021 at 01:45)</a>:</h4>
<p>I was actually having trouble finding Schur's lemma. Could you point me to it? I was actually trying to work up to proving it myself as practice. I'm not familiar with Maschke's theorem.</p>



<a name="241665803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665803">(Jun 06 2021 at 01:45)</a>:</h4>
<p>We actually have two independent proofs of versions of Schur's lemma!</p>



<a name="241665808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665808">(Jun 06 2021 at 01:45)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.bijective_of_ne_zero/src">src#linear_map.bijective_of_ne_zero</a>, which states that a nonzero morphism between simple R modules is bijective.</p>



<a name="241665810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665810">(Jun 06 2021 at 01:46)</a>:</h4>
<p>(for <code>R</code> any ring)</p>



<a name="241665853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665853">(Jun 06 2021 at 01:46)</a>:</h4>
<p>There is also <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso_of_hom_simple/src">src#category_theory.is_iso_of_hom_simple</a></p>



<a name="241665860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665860">(Jun 06 2021 at 01:47)</a>:</h4>
<p>which is much more general, saying that any nonzero morphism between simple objects in a preadditive category with kernels is an isomorphism.</p>



<a name="241665864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665864">(Jun 06 2021 at 01:47)</a>:</h4>
<p>We should unify these. I hadn't realised until today that the special case theorem existed in mathlib.</p>



<a name="241665865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665865">(Jun 06 2021 at 01:47)</a>:</h4>
<p>There there are also various stronger versions of Schur's lemma.</p>



<a name="241665921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665921">(Jun 06 2021 at 01:49)</a>:</h4>
<p>in a <code>k</code>-linear category (<code>k</code> an algebraically closed field), <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.finrank_hom_simple_simple_le_one/src">src#category_theory.finrank_hom_simple_simple_le_one</a> says the dimension of the hom space between two simples is at most one.</p>



<a name="241665941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665941">(Jun 06 2021 at 01:50)</a>:</h4>
<p>and two lemmas immediately afterwards say that it is 1 or 0 depending on whether the simple objects are isomorphic or not.</p>



<a name="241665984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241665984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241665984">(Jun 06 2021 at 01:51)</a>:</h4>
<p>(Also --- if you're having trouble finding Schur's lemma, you haven't learnt how to use the right search tools: you should have the mathlib folder open in VSCode, and in the search bar type <code>Schur</code>. You can't miss it.)</p>



<a name="241666045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241666045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241666045">(Jun 06 2021 at 01:53)</a>:</h4>
<p>I did not know there are these generalisations to Schur's lemma! As a theoretical physics person, I only know it for matrix representations.</p>



<a name="241666050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241666050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241666050">(Jun 06 2021 at 01:54)</a>:</h4>
<p>Ah no wonder. I've been using the documentation site's search function.</p>



<a name="241666149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241666149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241666149">(Jun 06 2021 at 01:56)</a>:</h4>
<p>I'll take a look at Etingof and compare with mathlib.</p>



<a name="241669742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/241669742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#241669742">(Jun 06 2021 at 03:37)</a>:</h4>
<p>I'm working on the Artin-Wedderburn theorem (also very slowly!) with the far-away goal to prove that character tables for finite groups are square.</p>



<a name="242457084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242457084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242457084">(Jun 12 2021 at 15:40)</a>:</h4>
<p>I wrote about 600 lines for some basic definitions and lemmas regarding representations of algebras, following the first few pages of Etingof. Would anyone like to give some advice/feedback? I'm getting stuck at defining the direct sum of representations and showing that decomposable representations are reducible.</p>



<a name="242457096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242457096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242457096">(Jun 12 2021 at 15:41)</a>:</h4>
<p><a href="/user_uploads/3121/lsULBUVPUtkKrbXpHVGyKJt1/representation.lean">representation.lean</a></p>



<a name="242457172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242457172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242457172">(Jun 12 2021 at 15:43)</a>:</h4>
<p>The proofs are certainly not efficient, so I welcome suggestions for improvement or tricks I should know</p>



<a name="242457457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242457457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242457457">(Jun 12 2021 at 15:48)</a>:</h4>
<p>I have some reservation regarding the notation. Currently, <code>representation</code> has a <code>coe_fn</code> from an algebra to an endomorphism of modules, which means the representation is identified with the function. Usually however, we say "let vector space V be a representation of the algebra A", so a representation is identified with the target space. I don't have enough experience to tell which one is better for mathlib.</p>



<a name="242458440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242458440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242458440">(Jun 12 2021 at 16:08)</a>:</h4>
<p>Also, sorry in advance if the names don’t obey the convention</p>



<a name="242458558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242458558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242458558">(Jun 12 2021 at 16:11)</a>:</h4>
<p>Winston, just in case you missed it (zulip doesn't mention if your topic title already exists), there is lots of discussion above your message</p>



<a name="242458642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242458642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242458642">(Jun 12 2021 at 16:13)</a>:</h4>
<p>Also, rather than uploading the txt file to zulip, could you create a gist on github? I get encoding issues when trying to read your text file on Android, which won't be true of a gist</p>



<a name="242458947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242458947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242458947">(Jun 12 2021 at 16:19)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I’ll do that in the morning (midnight here). Never done gist before</p>



<a name="242459381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242459381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242459381">(Jun 12 2021 at 16:26)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="416472">@Winston Yin</span>, cool! Here are some thoughts from just looking at the file (I didn't actually run lean, so some of my suggestions might be wrong, let me know if I can clarify anything). Its easier for people to look at if you open a PR (tagged WIP for example) or at least make a git branch on mathlib so people can check the branch out more easily, let us know if you need assistance setting that up and we can help.</p>
<ul>
<li>If you have multiple rewrites in a row you can combine them so</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="n">a</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">b</span><span class="o">,</span>
</code></pre></div>
<p>becomes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rw</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">]</span>
</code></pre></div>
<ul>
<li>If you just run one tactic with <code>by {simp}</code> the curly braces <code>{}</code> aren't needed.</li>
<li>The character <code>ᾰ</code> is awkward to type on purpose, the idea is that you shouldn't use it! Instead give a name to the thing you want to refer to, for <code>has_bot</code>:</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">intros</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">submodule.mem_bot</span> <span class="n">at</span> <span class="n">ᾰ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ᾰ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">linear_map.map_zero</span> <span class="o">(</span><span class="n">ρ</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">submodule.mem_bot</span>
</code></pre></div>
<p>you can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">intros</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">submodule.mem_bot</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">linear_map.map_zero</span> <span class="o">(</span><span class="n">ρ</span> <span class="n">a</span><span class="o">),</span> <span class="n">submodule.mem_bot</span><span class="o">]</span>
</code></pre></div>
<p>I believe.</p>
<ul>
<li>You apply theorems like <code>  apply linear_map.ext</code> you could likely replace this with just calling the <code>ext</code> tactic. Likewise for <code>    apply funext</code></li>
<li>If you have multiple goals its easier to read and manage them if you separate each goal into a block with braces, so whenever you have <code>split</code> the next line should start with a brace <code>{</code> to focus the first goal only.</li>
<li>There are some nice tactics for reducing repetition like <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#all_goals">tactic#all_goals</a> or <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#repeat">tactic#repeat</a>, for example you have</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">split</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="n">direct_sum</span> <span class="n">ι</span> <span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="n">V</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">direct_sum_repr.to_fun</span> <span class="n">ρ</span><span class="o">,</span>

  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">direct_sum_repr.map_one</span><span class="o">,</span>

  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">direct_sum_repr.map_mul</span><span class="o">,</span>

  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">direct_sum_repr.map_zero</span><span class="o">,</span>

  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">direct_sum_repr.map_add</span><span class="o">,</span>

  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">direct_sum_repr.commutes</span>
</code></pre></div>
<p>which could probably become</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">split</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="n">direct_sum</span> <span class="n">ι</span> <span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="n">V</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">direct_sum_repr.to_fun</span> <span class="n">ρ</span><span class="o">,</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">direct_sum_repr.map_one</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">direct_sum_repr.map_mul</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">direct_sum_repr.map_zero</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">direct_sum_repr.map_add</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">direct_sum_repr.commutes</span> <span class="o">}</span>
</code></pre></div>
<ul>
<li>You have a line</li>
</ul>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">change</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">V</span> <span class="n">i</span><span class="o">)</span> <span class="k">with</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">change</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">V</span> <span class="n">i</span><span class="o">)</span> <span class="k">with</span> <span class="n">V</span><span class="o">,</span>
</code></pre></div>
<p>probably <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp">tactic#dsimp</a> will do this for you</p>



<a name="242459695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242459695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242459695">(Jun 12 2021 at 16:33)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> those are great suggestions. Thank you!</p>



<a name="242460159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242460159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242460159">(Jun 12 2021 at 16:44)</a>:</h4>
<p>A coule more: </p>
<ul>
<li>
<p><code>Type _</code> is more usually done as <code>Type *</code>,</p>
</li>
<li>
<p><code>simp</code> not at the end of the line is usually considered bad form, as it's hard to debug when you add more <code>@[simp]</code> lemmata. You should <code>squeeze_simp</code> them, or if you can put them at the end (potentially using <code>simpa</code>). You can also give <code>simp</code> bonus lemmata in the same sort of form that you pile up lemmata on <code>rw</code>, e.g. <code>simp [representation.smul_add]</code>.</p>
</li>
<li>
<p>Some of your lemmas should definitely be tagged with <code>@[simp]</code>.</p>
</li>
<li>
<p>You may be able to get away with reusing some lemmata from <code>linear_map</code> instead of having to re-prove them; you may have to put <code>local attribute [reducible] representation</code> in order to do this, though.</p>
</li>
<li>
<p>You usually don't have to put <code>{ name . field := ... }</code> in the definitions of things; Lean will figure it out most of the time, and if it doesn't, it'll shout at you.</p>
</li>
<li>
<p>I <em>think</em> the standard approach for sub-objects now is <a href="https://leanprover-community.github.io/mathlib_docs/find/set_like">docs#set_like</a>.</p>
</li>
<li>
<p>Lean usually prefers working backwards; proofs with a lot of <code>at this</code> tend to be a red flag that you could write it "more idiomatically".</p>
</li>
</ul>
<p>There's some specific thoughts, too, that would be a lot easier to talk about in a github PR (e.g. the <code>rw</code> is unnecessary in <code>one_smul</code>). Have you got an invite to contribute to <code>mathlib</code>?</p>



<a name="242461842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242461842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242461842">(Jun 12 2021 at 17:23)</a>:</h4>
<p>Not yet. I’ll try a GitHub PR in the morning and maybe get some help here</p>



<a name="242462375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242462375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242462375">(Jun 12 2021 at 17:39)</a>:</h4>
<p>Before you go to sleep, drop your github username and maintainers should be able to give you an invite for the morning ^^</p>



<a name="242464386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242464386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242464386">(Jun 12 2021 at 18:24)</a>:</h4>
<p>If you haven't already seen it, check out our page with tips for contributors: <a href="https://leanprover-community.github.io/contribute/index.html">https://leanprover-community.github.io/contribute/index.html</a></p>



<a name="242486001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242486001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242486001">(Jun 13 2021 at 02:53)</a>:</h4>
<p>If somebody could invite me to GitHub: <a href="mailto:winstonyin@gmail.com">winstonyin@gmail.com</a> Got too tired last night after all!</p>



<a name="242486534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242486534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242486534">(Jun 13 2021 at 03:10)</a>:</h4>
<p>I just sent an invite to that email. You'll need to create a GitHub account if you don't already have one.</p>



<a name="242497905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242497905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242497905">(Jun 13 2021 at 08:18)</a>:</h4>
<p>I've pushed my commit: <a href="https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9">https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9</a> (&lt;---- this is a mistake)</p>



<a name="242497913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242497913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242497913">(Jun 13 2021 at 08:18)</a>:</h4>
<p>I only added representation.lean, so I'm not sure why there are all these other changed files.</p>



<a name="242498028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242498028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242498028">(Jun 13 2021 at 08:22)</a>:</h4>
<p>I think I see the issue. There's an existing branch called <code>representation</code>, which I've just pushed to... I'm sorry! Please help me fix this mistake, as I'm not good with git. It also looks like that branch is trying to do some of the same things I'm doing but differently.</p>



<a name="242499506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/242499506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#242499506">(Jun 13 2021 at 09:06)</a>:</h4>
<p>Ok the correct branch I've just created: <a href="https://github.com/leanprover-community/mathlib/compare/winstonyin/representation">https://github.com/leanprover-community/mathlib/compare/winstonyin/representation</a></p>



<a name="260792262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260792262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260792262">(Nov 09 2021 at 12:46)</a>:</h4>
<p>Hi,<br>
I would like to try to contribute to the extent of my knowledge to the representation theory project in mathlib, but I am unsure where to starts since it looks like a few people are already working on this but there's not a lot in mathlib itself. I was wondering what is the state of the project right now.<br>
I found the pull request <a href="https://github.com/leanprover-community/mathlib/issues/2431">#2431</a>, which seems to introduce a definition of group representations and prove equivalences with other usual definitions; it seems like a good starting point, but it has been closed without merging. Why is that so, were there fundamental flaws in the approach of this PR?</p>



<a name="260792855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260792855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260792855">(Nov 09 2021 at 12:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span></p>



<a name="260796972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260796972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260796972">(Nov 09 2021 at 13:29)</a>:</h4>
<p><span class="user-mention" data-user-id="329754">@Antoine Labelle</span> Is there a particular thing in repn thy that you would like to work on?</p>



<a name="260797537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260797537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260797537">(Nov 09 2021 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I think that working towards orthogonality for characters of finite groups could be interesting. But I don't know if there are other things we'd need to get out of the way before working on that.</p>



<a name="260800758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260800758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260800758">(Nov 09 2021 at 14:00)</a>:</h4>
<p><span class="user-mention" data-user-id="329754">@Antoine Labelle</span> Sounds good. Maybe create a little mind map of the topics you would need?</p>



<a name="260800793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260800793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260800793">(Nov 09 2021 at 14:00)</a>:</h4>
<p>E.g., mathlib doesn't have class functions at the moment. I guess you would want to have those</p>



<a name="260800833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260800833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260800833">(Nov 09 2021 at 14:01)</a>:</h4>
<p>If you have a list of things, we can quickly tell you what is there and what is not</p>



<a name="260803019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260803019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260803019">(Nov 09 2021 at 14:15)</a>:</h4>
<p>I remember from a past discussion of representation theory is that one difficulty is the variety of different ways a representation can be expressed.  As a <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action">docs#mul_action</a>, as a homomomorphism of the group into the automorphism group of the vector space, and as a module over the <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra">docs#monoid_algebra</a> of <code>G</code>.  I don't even think we have glue among these different notions.  Did we ever decide which one should be primary?</p>



<a name="260813460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260813460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260813460">(Nov 09 2021 at 15:23)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span>  Yeah, that's why I asked about <a href="https://github.com/leanprover-community/mathlib/issues/2431">#2431</a>. The primary definition it takes is a <code>distrib_mul_action</code> such that the action of <code>G</code> commutes with that of <code>k</code> and it proves the equivalence with the two other definitions you mention. So it seems like it's already done, but have never been merged into mathlib.</p>



<a name="260813664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260813664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260813664">(Nov 09 2021 at 15:24)</a>:</h4>
<p>And yeah, I could try to create a little list of needed topics</p>



<a name="260854918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260854918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260854918">(Nov 09 2021 at 20:20)</a>:</h4>
<p>The direction mathlib has gone since is to avoid things like <code>representation</code> which bundles together both actions and their compatibility, and instead chooses to have three separate typeclasses for these facts.</p>



<a name="260855034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260855034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260855034">(Nov 09 2021 at 20:21)</a>:</h4>
<p>i.e. use the <code>smul_comm_class</code> (which quite possibly didn't even exist when I closed that PR??).</p>



<a name="260855176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260855176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260855176">(Nov 09 2021 at 20:22)</a>:</h4>
<p>Certainly it would be good to replace <a href="https://github.com/leanprover-community/mathlib/issues/2431">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>



<a name="260855288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260855288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260855288">(Nov 09 2021 at 20:22)</a>:</h4>
<p>Personally I hope that we will also make a bundled version, perhaps as <code>Rep k G</code>, and provide a categorical API for everything, too.</p>



<a name="260855373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260855373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260855373">(Nov 09 2021 at 20:23)</a>:</h4>
<p>There are a lot of functors used early on in representation theory (induction and restriction, particularly), and it seems to me a great shame if we do not express these as functors!</p>



<a name="260874886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260874886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260874886">(Nov 09 2021 at 22:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/260855176">said</a>:</p>
<blockquote>
<p>Certainly it would be good to replace <a href="https://github.com/leanprover-community/mathlib/issues/2431">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>
</blockquote>
<p>Ok, maybe I think I could try to do that first, since these equivalences seem to me like a necessary thing to get out of way before being able to work on interesting character theory.<br>
I am not yet very comfortable with typeclasses and their subtleties, so would you mind explaining why it is a better approach to have separate typeclasses for the actions and their compatibilities? To make it concrete, how would you write "let V be a representation of G over k" in Lean with this approach?</p>



<a name="260880171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260880171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260880171">(Nov 09 2021 at 23:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
</code></pre></div>



<a name="260880378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260880378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260880378">(Nov 09 2021 at 23:55)</a>:</h4>
<p>So you'd want definitions (perhaps instances in one direction) translating between <code>[module k V] [distrib_mul_action G V] [smul_comm_class k G V]</code> and <code>[module (monoid_algebra k G) V]</code>.</p>



<a name="260880460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260880460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260880460">(Nov 09 2021 at 23:56)</a>:</h4>
<p>Some of these hopefully already exist, in the files that develop <code>monoid_algebra</code>.</p>



<a name="260880539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260880539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260880539">(Nov 09 2021 at 23:57)</a>:</h4>
<p>But then I'd also define <code>Rep k G</code> to be a structure, (parametrised also be the ring structure on <code>k</code> and the group structure on <code>G</code>), which has as fields the carrier type <code>V</code> and the remaining type classes. Then put a category instance on that.</p>



<a name="260880684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260880684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260880684">(Nov 09 2021 at 23:58)</a>:</h4>
<p>Given the way we do bundled morphisms, there is not really a good way to say "a function V to W which is both <code>k</code> linear and <code>G</code> linear". So I suspect the <code>module (monoid_algebra k G) V</code> version is going to be important, because we <em>can</em> easily talk about a function which is <code>monoid_algebra k G</code>-linear.</p>



<a name="260886632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260886632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260886632">(Nov 10 2021 at 01:06)</a>:</h4>
<p>Thanks! So, for the backward direction (from <code>[module (monoid_algebra k G) V]</code>), would we have 3 definitions, one giving <code>[module k V]</code>, one giving <code>[distrib_mul_action G V]</code> and one giving <code>[smul_comm_class k G V]</code>, or should this be all bundled together somehow? In the first case, how would we formulate that the two parts pf the correspondence are inverses of each other?</p>



<a name="260888128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260888128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260888128">(Nov 10 2021 at 01:28)</a>:</h4>
<p>There would be 3 definitions. (Almost surely the first one already exists.)</p>



<a name="260888215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260888215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260888215">(Nov 10 2021 at 01:29)</a>:</h4>
<p>I guess we could write an equivalence with lots of <code>letI := ...</code> statements on one side of the equivalence, to specifying explicitly using the instance that has gone back and forth through the equivalence.</p>



<a name="260943866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260943866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260943866">(Nov 10 2021 at 04:12)</a>:</h4>
<p>Another quick question : how can I make Lean figure out what the <code>distrib_mul_action</code> is in the definition of <code>[smul_comm_class k G V]</code>?<br>
In other words, how to avoid the error in the second definition here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>
<span class="kn">import</span> <span class="n">algebra.module.linear_map</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">distrib_mul_action_of_monoid_hom</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_mul_action</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">to_has_scalar</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">v</span><span class="o">,</span> <span class="n">ρ</span> <span class="n">g</span> <span class="n">v</span> <span class="o">},</span>
                     <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
                     <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">h</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">smul_comm_class_of_monoid_hom</span> <span class="o">:</span> <span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260944446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944446">(Nov 10 2021 at 04:25)</a>:</h4>
<p><span class="user-mention" data-user-id="329754">@Antoine Labelle</span> One option is to use a type synonym for <code>V</code>, something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>
<span class="kn">import</span> <span class="n">algebra.module.linear_map</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">))</span>

<span class="kd">@[derive [add_comm_monoid, module k]</span><span class="o">]</span> <span class="kd">def</span> <span class="n">rep_space</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kd">instance</span> <span class="n">distrib_mul_action_of_monoid_hom</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="o">(</span><span class="n">rep_space</span> <span class="n">ρ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">v</span><span class="o">,</span> <span class="n">ρ</span> <span class="n">g</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">h</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">smul_comm_class_of_monoid_hom</span> <span class="o">:</span> <span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="o">(</span><span class="n">rep_space</span> <span class="n">ρ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260944497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944497">(Nov 10 2021 at 04:26)</a>:</h4>
<p>(The type synonym is when I rename <code>V</code> as <code>rep_space ρ</code>.)</p>



<a name="260944511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944511">(Nov 10 2021 at 04:27)</a>:</h4>
<p>By the way, I rearranged your <code>distrib_mul_action_of_monoid_hom</code> a little for conciseness, but the only substantive change was from <code>def</code> to <code>instance</code>.</p>



<a name="260944587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944587">(Nov 10 2021 at 04:28)</a>:</h4>
<p>What's the advantage of <code>instance</code> over <code>def</code>?</p>



<a name="260944607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944607">(Nov 10 2021 at 04:29)</a>:</h4>
<p><code>instance</code> can be found by "typeclass inference", <code>def</code> can't.  So, for example, the fact that a metric space is in a natural way a topological space is found by typeclass inference.</p>



<a name="260944624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944624">(Nov 10 2021 at 04:29)</a>:</h4>
<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>



<a name="260944673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944673">(Nov 10 2021 at 04:30)</a>:</h4>
<p>Should <code>smul_comm_class_of_monoid_hom</code> also be an instance then?</p>



<a name="260944684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944684">(Nov 10 2021 at 04:30)</a>:</h4>
<p>Yes!</p>



<a name="260944760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944760">(Nov 10 2021 at 04:32)</a>:</h4>
<p>Btw, <span class="user-mention" data-user-id="310045">@Eric Wieser</span> is the person to talk to when it comes to scalar actions in mathlib. I'm sure he knows the best way for moving back and forth between </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>
</code></pre></div>
<p>and modules over <code>monoid_algebra k G</code>.</p>



<a name="260944792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260944792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260944792">(Nov 10 2021 at 04:33)</a>:</h4>
<p>He has been adding a lot of homomorphisms of the form <code>G -&gt; Aut _</code> or <code>R -&gt; End _</code> derived from scalar actions. So this might already be there.</p>



<a name="260945191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260945191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260945191">(Nov 10 2021 at 04:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/260944624">said</a>:</p>
<blockquote>
<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>
</blockquote>
<p>OK, I got it working without typeclass inference (but as you can see, it's painful!).  Not even sure if I've missed some tricks:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>
<span class="kn">import</span> <span class="n">algebra.module.linear_map</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">distrib_mul_action_of_monoid_hom</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">v</span><span class="o">,</span> <span class="n">ρ</span> <span class="n">g</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">h</span> <span class="n">v</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">smul_comm_class_of_monoid_hom</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="n">_</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">mul_action.to_has_scalar</span> <span class="n">G</span> <span class="n">V</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">distrib_mul_action.to_mul_action</span> <span class="n">G</span> <span class="n">V</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">distrib_mul_action_of_monoid_hom</span> <span class="n">ρ</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260945790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260945790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260945790">(Nov 10 2021 at 04:54)</a>:</h4>
<p>Oof indeed, it seems like it's much better to use typeclass inference</p>



<a name="260964520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260964520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260964520">(Nov 10 2021 at 09:32)</a>:</h4>
<p>Note that we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.of_End_hom">docs#mul_action.of_End_hom</a>; so we <em>could</em> have something called <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.of_add_monoid_End_hom">docs#distrib_mul_action.of_add_monoid_End_hom</a> similar to the <code>distrib_mul_action_of_monoid_hom</code> above</p>



<a name="260964705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260964705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260964705">(Nov 10 2021 at 09:33)</a>:</h4>
<p>Having said that, the implementation would just be <code>distrib_mul_action.comp_hom _ ρ</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">distrib_mul_action_of_module_End_hom</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">distrib_mul_action.comp_hom</span> <span class="n">_</span> <span class="n">ρ</span>

<span class="kd">def</span> <span class="n">smul_comm_class_of_monoid_hom</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="n">_</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">mul_action.to_has_scalar</span> <span class="n">G</span> <span class="n">V</span> <span class="n">_</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">distrib_mul_action.to_mul_action</span> <span class="n">G</span> <span class="n">V</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">distrib_mul_action_of_module_End_hom</span> <span class="n">ρ</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="260982846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260982846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260982846">(Nov 10 2021 at 12:39)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Thanks! Is there a reason you used def instead of instance as Heather suggested?<br>
Also is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>



<a name="260988228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260988228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260988228">(Nov 10 2021 at 13:26)</a>:</h4>
<p>The first one can't be an instance because it depends on <code>ρ</code>, while the second one already exists so you don't need it anyway</p>



<a name="260988265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260988265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260988265">(Nov 10 2021 at 13:27)</a>:</h4>
<blockquote>
<p>Also is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>
</blockquote>
<p>Can you give me the lean statement?</p>



<a name="260988453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260988453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260988453">(Nov 10 2021 at 13:28)</a>:</h4>
<p>Is this the forward statement?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">V</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- are these the defining properties of the action you want?</span>
<span class="kd">lemma</span> <span class="n">of_smul</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">monoid_algebra.of</span> <span class="n">k</span> <span class="n">G</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">algebra_map_smul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">algebra_map</span> <span class="n">k</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="260990340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260990340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260990340">(Nov 10 2021 at 13:44)</a>:</h4>
<p>What do you think of the proposition of Heather which is to define a vector space which is just a copy of <code>V</code> and put <code>distrib_mul_action</code> and <code>smul_comm_class</code> instances on it? And yes, that would be the forward statement .</p>



<a name="260992095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/260992095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#260992095">(Nov 10 2021 at 13:58)</a>:</h4>
<p>I think that's a reasonable idea</p>



<a name="261003750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261003750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261003750">(Nov 10 2021 at 15:14)</a>:</h4>
<p>Whether it's necessary depends on whether <code>V = monoid_algebra k G</code> would create ambiguity</p>



<a name="261006106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261006106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261006106">(Nov 10 2021 at 15:30)</a>:</h4>
<p>I don't think I understand what you mean, <code>V</code> is the module, not the monoid algebra</p>



<a name="261008694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261008694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261008694">(Nov 10 2021 at 15:48)</a>:</h4>
<p>V is any type that satisfies the module axioms. <code>V = monoid_algebra k G</code> is one such type.</p>



<a name="261008980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261008980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261008980">(Nov 10 2021 at 15:51)</a>:</h4>
<p>If your instance can be parameterized to give a <code>has_scalar (monoid_algebra k G) (monoid_algebra k G)</code> instance, it must definitionally satisfy <code>a • b = a * b</code> to avoid diamonds</p>



<a name="261025294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261025294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261025294">(Nov 10 2021 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/260874886">said</a>:</p>
<blockquote>
<p>To make it concrete, how would you write "let V be a representation of G over k" in Lean with this approach?</p>
</blockquote>
<p>In addition to the great advice, examples already provided you could also look at some of our Lie theory, at least to see one way to set things like this up in terms of typeclasses. E.g., <a href="https://leanprover-community.github.io/mathlib_docs/find/lie_module">docs#lie_module</a> is the definition of a representation of a Lie algebra.</p>



<a name="261293336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261293336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261293336">(Nov 12 2021 at 18:35)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Do you know if we have the equivalence, for an algebra <code>A</code> over <code>k</code>, of <code>module A M</code> with <code>is_scalar_tower k A M</code> and algebra maps from <code>A</code> to <code>M →ₗ[k] M</code></p>



<a name="261294067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261294067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261294067">(Nov 12 2021 at 18:41)</a>:</h4>
<p>I would guess that would be <a href="https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom">docs#module.to_module_End_hom</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End">docs#module.to_module_End</a></p>



<a name="261294169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261294169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261294169">(Nov 12 2021 at 18:42)</a>:</h4>
<p>It seems we have neither</p>



<a name="261294863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261294863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261294863">(Nov 12 2021 at 18:48)</a>:</h4>
<p>Oh, it's <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.to_linear_map">docs#distrib_mul_action.to_linear_map</a>, if you just want <code>A → M →ₗ[R] M</code></p>



<a name="261295133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295133">(Nov 12 2021 at 18:51)</a>:</h4>
<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">module.to_module_End_hom</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_scalar</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">A</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→+*</span> <span class="n">module.End</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">distrib_mul_action.to_linear_map</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">linear_map.ext</span> <span class="bp">$</span> <span class="n">one_smul</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">linear_map.ext</span> <span class="bp">$</span> <span class="n">mul_smul</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">linear_map.ext</span> <span class="bp">$</span> <span class="n">zero_smul</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">linear_map.ext</span> <span class="bp">$</span> <span class="n">add_smul</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="261295173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295173">(Nov 12 2021 at 18:51)</a>:</h4>
<p>I never PR'd that because I couldn't find a good place to put it where I had all the typeclasses available</p>



<a name="261295580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295580">(Nov 12 2021 at 18:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/261294067">said</a>:</p>
<blockquote>
<p>I would guess that would be <a href="https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom">docs#module.to_module_End_hom</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End">docs#module.to_module_End</a></p>
</blockquote>
<p>Actually I mostly want the other direction</p>



<a name="261295690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295690">(Nov 12 2021 at 18:55)</a>:</h4>
<p>That's <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.apply_module">docs#linear_map.apply_module</a></p>



<a name="261295709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295709">(Nov 12 2021 at 18:56)</a>:</h4>
<p>Which probably should be renamed to <code>module.End.apply_module</code></p>



<a name="261295782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295782">(Nov 12 2021 at 18:56)</a>:</h4>
<p>Or at least, it's that if you combine it with <code>module.comp_hom f</code> where <code>f : A →+* module.End R M</code></p>



<a name="261295952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261295952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261295952">(Nov 12 2021 at 18:58)</a>:</h4>
<p>Note that <code>is_scalar_tower</code> was the wrong condition, <code>smul_comm_class</code> is what you need</p>



<a name="261296811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261296811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261296811">(Nov 12 2021 at 19:05)</a>:</h4>
<p>Thanks!</p>



<a name="261298706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/261298706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#261298706">(Nov 12 2021 at 19:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/261295133">said</a>:</p>
<blockquote>
<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>
</blockquote>
<p>PR'd as <a href="https://github.com/leanprover-community/mathlib/issues/10300">#10300</a></p>



<a name="265624146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/265624146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#265624146">(Dec 20 2021 at 22:37)</a>:</h4>
<p><span class="user-mention" data-user-id="329754">@Antoine Labelle</span> are you still working on this?</p>



<a name="265624695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/265624695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#265624695">(Dec 20 2021 at 22:44)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span>  I've put it on hold a little bit to do other stuff including some linear algebra which I felt would be needed for rep theory, but yes I have some stuff done and I have the intention to come back to it soonish.</p>



<a name="274453119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274453119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274453119">(Mar 07 2022 at 20:32)</a>:</h4>
<p>Hi,<br>
I was wondering if anyone understand why the scalar action is not recognized in <code>smul_single</code>. It works with <code>of k G g</code> but not with <code>finsupp.single g 1</code>, which is quite annoying.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>
<span class="kn">import</span> <span class="n">data.equiv.module</span>
<span class="kn">import</span> <span class="n">algebra.module.linear_map</span>
<span class="kn">import</span> <span class="n">algebra.monoid_algebra.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.trace</span>

<span class="kn">open</span> <span class="n">monoid_algebra</span>

<span class="kn">namespace</span> <span class="n">representation</span>

<span class="kn">section</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">as_monoid_hom</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">distrib_mul_action.to_linear_map</span> <span class="n">k</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">g'</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">},</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">as_monoid_hom_apply_apply</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">as_monoid_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">)</span> <span class="n">g</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">as_algebra_hom</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">G</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">as_monoid_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">as_algebra_hom_def</span> <span class="o">:</span>
  <span class="n">as_algebra_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="bp">=</span> <span class="o">(</span><span class="n">lift</span> <span class="n">k</span> <span class="n">G</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">as_monoid_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">as_algebra_hom_single</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">):</span>
  <span class="o">(</span><span class="n">as_algebra_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">g</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">as_monoid_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">)</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">as_algebra_hom_def</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">as_module</span> <span class="o">:</span> <span class="n">module</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">V</span> <span class="o">:=</span>
  <span class="n">module.comp_hom</span> <span class="n">V</span> <span class="o">(</span><span class="n">as_algebra_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">to_ring_hom</span>

<span class="kd">lemma</span> <span class="n">as_module_apply</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">):</span>
  <span class="n">a</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span> <span class="o">(</span><span class="n">as_algebra_hom</span> <span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="n">a</span><span class="o">)</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">smul_single</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">g</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span>  <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">as_module_apply</span><span class="o">]</span>
</code></pre></div>



<a name="274453442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274453442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274453442">(Mar 07 2022 at 20:35)</a>:</h4>
<p>Here's a hacky fix:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="o">(</span><span class="n">G</span> <span class="bp">→₀</span> <span class="n">k</span><span class="o">)</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="c1">-- fails</span>
<span class="kd">noncomputable</span> <span class="kd">example</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="o">(</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="c1">-- works</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">smul_single</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">g</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span>  <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">as_module_apply</span><span class="o">]</span>
</code></pre></div>



<a name="274453907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274453907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274453907">(Mar 07 2022 at 20:40)</a>:</h4>
<p>Even though <code>monoid_algebra k G</code> and <code>G →₀ k</code> are definitionally equal, they are not syntactically equal, and type class inference works up to syntactic equality. What is happening in <code>(finsupp.single g 1 : monoid_algebra k G)</code> is that the syntactic type of <code>finsupp.single g 1</code> is <code>G →₀ k</code>, and <code>(finsupp.single g 1 : monoid_algebra k G)</code> means "check <code>finsupp.single g 1</code> has type <code>monoid_algebra k G</code> and then continue" -- but it doesn't actually <em>syntactically change</em> the type, so <code>has_scalar (G →₀ k) V</code> is what Lean ends up searching for, and it can't find it. However adding that little <code>id</code> hack actually does syntactically change the type of the term to <code>monoid_algebra k G</code> and then type class inference works. The "correct" thing to do here would be to use the appropriate <code>monoid_algebra</code> constructor for <code>monoid_algebra k G</code> as opposed to <code>finsupp.single g 1</code> which is the <code>finsupp</code> constructor.</p>



<a name="274454254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274454254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274454254">(Mar 07 2022 at 20:42)</a>:</h4>
<p>Will the simplifier still simplify <code>(finsupp.single g 1) •  v</code> to <code>g •  v</code> if I add <code>id</code>?</p>



<a name="274454386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274454386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274454386">(Mar 07 2022 at 20:43)</a>:</h4>
<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">smul_single</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">of_magma</span> <span class="n">k</span> <span class="n">G</span> <span class="n">g</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span>  <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">as_module_apply</span><span class="o">]</span>
</code></pre></div>



<a name="274455018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274455018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274455018">(Mar 07 2022 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274454386">said</a>:</p>
<blockquote>
<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">smul_single</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">of_magma</span> <span class="n">k</span> <span class="n">G</span> <span class="n">g</span> <span class="o">:</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="bp">•</span> <span class="n">v</span> <span class="bp">=</span>  <span class="n">g</span> <span class="bp">•</span> <span class="n">v</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">as_module_apply</span><span class="o">]</span>
</code></pre></div><br>
</p>
</blockquote>
<p>My first intention was to state it as <code>(of k G g) • v = g • v</code> but the linter complained that the LHS simplifies to <code>(finsupp.single g 1) •  v</code>. Won't the same problem happen with <code>of_magma</code>?</p>



<a name="274455552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274455552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274455552">(Mar 07 2022 at 20:53)</a>:</h4>
<p>oh I see!</p>



<a name="274456417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274456417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274456417">(Mar 07 2022 at 21:00)</a>:</h4>
<p>Yes you're absolutely right, the simp linter doesn't like it. I think that it's a bad idea to have <code>of = single</code> and <code>of_magma = single</code> as global <code>@[simp]</code> lemmas. I can quite understand why one might want them locally to be <code>simp</code> lemmas when making the API, but for a "user" like you who doesn't ever want to see <code>finsupp</code>s but still wants to use the simplifier, the strategy of making <code>of = single</code> a <code>simp</code> lemma is preventing you from doing this.</p>
<p>I saw the same phenomenon showing up in the <a href="https://github.com/ImperialCollegeLondon/complex-number-game">complex number game</a>. I wanted to make <code>complex.ext</code> a <code>simp</code> lemma, so that whenever Lean was faced with a goal <code>z = w</code> it would replace it with <code>z.re = w.re</code> and <code>z.im = w.im</code>. This worked <em>great</em> for me when I was making the API for complex numbers, because to e.g. prove that multiplication of complex numbers is associative you <em>absolutely</em> want to check this on real and imaginary parts. However when you go deeper into the theory and are developing complex analysis, the last thing you want the simplifier to do is to keep taking real and imaginary parts of things; you want this to be available to you as an option, but definitely <em>not</em> be the "this is the only sensible way to proceed" option, which is kind of what <code>simp</code> lemmas are.</p>
<p>So I would suggest that (perhaps after getting the nod from one or more maintainers) that you make a PR removing the global simp tags from the lemmas which are causing the trouble and then adding them again with <code>local attribute [simp] of_eq_single</code> (or whatever it's called) so that they're there for API development of <code>monoid_algebra</code> but don't leak out.</p>



<a name="274456898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274456898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274456898">(Mar 07 2022 at 21:03)</a>:</h4>
<p>In my opinion <code>monoid_algebra</code> should be irreducible and <code>finsupp.single G 1 : monoid_algebra</code> should not even typecheck. I mean, it should typecheck in the file making the API for <code>monoid_algebra</code>, and then it should stop typechecking and the simplifier should stop trying to flow in that direction.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">37</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="274456955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274456955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274456955">(Mar 07 2022 at 21:03)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> am I talking nonsense?</p>



<a name="274457169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274457169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274457169">(Mar 07 2022 at 21:05)</a>:</h4>
<p>I've not read the whole of today's discussion, but yes, we shouldn't be writing <code>finsupp.single</code> about <code>monoid_algebra</code></p>



<a name="274457220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274457220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274457220">(Mar 07 2022 at 21:05)</a>:</h4>
<p>The problem is that the alternative is copying over all the lemmas about <code>finsupp.single</code> to a new <code>monoid_algebra.single</code></p>



<a name="274458555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274458555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274458555">(Mar 07 2022 at 21:14)</a>:</h4>
<p>So <span class="user-mention" data-user-id="310045">@Eric Wieser</span> should I make a PR to remove the global simp tag to lemmas like <code>monoid_algebra.of_apply</code>?</p>



<a name="274458632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274458632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274458632">(Mar 07 2022 at 21:15)</a>:</h4>
<p>I'm not sure. I guess you could open one with the WIP tag and see what breaks</p>



<a name="274458657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274458657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274458657">(Mar 07 2022 at 21:15)</a>:</h4>
<p>I am not convinced that there is too much stuff to be said about <code>monoid_algebra.single</code>. One could even get away with not having it, and just sticking with <code>of</code>. The big advantage of <code>single</code> over <code>of</code> is that <code>single</code> span <code>G -&gt;_0 k</code> as an abelian group so you can use simpler induction principles, but I wonder whether we ever see these in practice.</p>



<a name="274458855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274458855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274458855">(Mar 07 2022 at 21:16)</a>:</h4>
<blockquote>
<p>I am not convinced that there is too much stuff to be said about monoid_algebra.single. </p>
</blockquote>
<p>(edit: we would need lemmas saying what the) Behavior of 0, 1, addition, subtraction, negation, multiplication, nsmul, zsmul, pow, and maybe some stuff about summation is?</p>



<a name="274458925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274458925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274458925">(Mar 07 2022 at 21:17)</a>:</h4>
<p>Also I think <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_algebra.of">docs#add_monoid_algebra.of</a> is nasty due to <code>multiplicative</code></p>



<a name="274458941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274458941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274458941">(Mar 07 2022 at 21:17)</a>:</h4>
<p>I don't know what you mean by all this.</p>



<a name="274459054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459054">(Mar 07 2022 at 21:18)</a>:</h4>
<p>Also <code>of</code> doesn't work on magma algebras, which is annoying</p>



<a name="274459073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459073">(Mar 07 2022 at 21:18)</a>:</h4>
<p>sure define <code>0</code> and <code>1</code> and etc in the <code>monoid_algebra.lean</code> API file using <code>single</code>, and then close it off, giving the user access to <code>of</code>, and a proof that <code>of (g * h) = of g * of h</code></p>



<a name="274459076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459076">(Mar 07 2022 at 21:18)</a>:</h4>
<p>I think if we want to remove <code>of_apply</code>, we need to unbundle <code>of</code></p>



<a name="274459151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459151">(Mar 07 2022 at 21:19)</a>:</h4>
<p>Things like addition are not about <code>of</code> or <code>single</code></p>



<a name="274459163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459163">(Mar 07 2022 at 21:19)</a>:</h4>
<p>Ah, you're talking about the "One could even get away with not having [monoid_algebra.single]" option, which is where we are today minus the finsupp mess</p>



<a name="274459202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459202">(Mar 07 2022 at 21:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274459151">said</a>:</p>
<blockquote>
<p>Things like addition are not about <code>of</code> or <code>single</code></p>
</blockquote>
<p><code>single g r + single g s = single g (r + s)</code> is the type of thing I'm describing</p>



<a name="274459293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459293">(Mar 07 2022 at 21:19)</a>:</h4>
<p>But we only want <code>single x 1</code> so I'm not interested in this</p>



<a name="274459403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459403">(Mar 07 2022 at 21:20)</a>:</h4>
<p>I disagree, we need <code>single x r</code> for <code>polynomial.monomial</code></p>



<a name="274459439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459439">(Mar 07 2022 at 21:20)</a>:</h4>
<p>Unless you also want to kill <code>monomial</code> at the same time</p>



<a name="274459447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459447">(Mar 07 2022 at 21:20)</a>:</h4>
<p>I'm well aware that we need it for <code>G -&gt;0 k</code></p>



<a name="274459522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459522">(Mar 07 2022 at 21:21)</a>:</h4>
<p>I'm suggesting that we forego it only for <code>monoid_algebra</code> because to me it looks a bit useless when we're thinking about group representation theory.</p>



<a name="274459544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459544">(Mar 07 2022 at 21:21)</a>:</h4>
<p><code>polynomial</code> is <code>(add_)monoid_algebra</code> not <code>-&gt;0</code> though</p>



<a name="274459644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459644">(Mar 07 2022 at 21:22)</a>:</h4>
<p>Right. I'm suggesting we don't need <code>single</code> for <code>monoid_algebra</code> (only).</p>



<a name="274459712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459712">(Mar 07 2022 at 21:22)</a>:</h4>
<p>Are you suggesting we should have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>?</p>



<a name="274459884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274459884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274459884">(Mar 07 2022 at 21:23)</a>:</h4>
<p>What I learnt when working on a multivariable polynomial project was that it's really handy to have <code>single</code> because then you can prove stuff about <code>G -&gt;_0 k</code> by checking it's true on <code>single x y</code> and then checking that the subset where it's true is a subgroup. I'm suggesting that this is not a common method of proof for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span>.</p>



<a name="274460048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274460048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274460048">(Mar 07 2022 at 21:24)</a>:</h4>
<p>If I call it <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> then you can figure out what I mean in Lean, but I mean "the group ring". I'm not talking about subtle differences between additive and multiplicative structures. I just mean that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">tg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> doesn't show up much in this theory when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t\not=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>



<a name="274460260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274460260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274460260">(Mar 07 2022 at 21:26)</a>:</h4>
<p>So I don't care if I not only can't coerce <code>finsupp.single x y</code> into <code>monoid_algebra</code> but that there's no substitute in monoid_algebra world, because I will just do <code>of_ring x * of_group y</code> for the appropriate <code>of</code>s (one from the ring, one from the group).</p>



<a name="274460395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274460395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274460395">(Mar 07 2022 at 21:27)</a>:</h4>
<p>I think multivariate polynomials are confusing things here, since they are of type <code>add_monoid_algebra R (σ →₀ ℕ)</code> which has both things you're talking about in it</p>



<a name="274460535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274460535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274460535">(Mar 07 2022 at 21:28)</a>:</h4>
<p>My polynomial remarks are about <code>polynomial R = add_monoid_algebra R ℕ</code> where <code>polynomial.monomial = add_monoid_algebra.single</code> (modulo structure eta)</p>



<a name="274460602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274460602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274460602">(Mar 07 2022 at 21:29)</a>:</h4>
<p>If we forbid using <code>finsupp.single</code> with <code>add_monoid_algebra</code> and don't add a <code>add_monoid_algebra.single</code> to replace it, then we're pulling the rug out from under <code>polynomial</code>.</p>



<a name="274460651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274460651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274460651">(Mar 07 2022 at 21:29)</a>:</h4>
<p>And if we have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>, then we're being inconsistent</p>



<a name="274463333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274463333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274463333">(Mar 07 2022 at 21:52)</a>:</h4>
<p>I see. Do you understand <a href="https://github.com/leanprover-community/mathlib/pull/11574">#11574</a>?</p>



<a name="274463782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274463782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274463782">(Mar 07 2022 at 21:56)</a>:</h4>
<p>Yes, but unrelated to the <code>single</code> topic, I don't yet know how to avoid the diamonds that PR creates</p>



<a name="274464196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464196">(Mar 07 2022 at 21:59)</a>:</h4>
<p>do we have any diamonds that don't get fixed with definitional eta? i've often said how little I like the current diamond-fixing approach as much as I understand it's necessary</p>



<a name="274464224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464224">(Mar 07 2022 at 21:59)</a>:</h4>
<p>Yeah, these are straight-up non-equal diamonds</p>



<a name="274464383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464383">(Mar 07 2022 at 22:00)</a>:</h4>
<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>



<a name="274464426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464426">(Mar 07 2022 at 22:00)</a>:</h4>
<p>(there are some equal-but-not-defeq diamonds that appear in that PR too, but they're not so big a deal)</p>



<a name="274464525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464525">(Mar 07 2022 at 22:01)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138">https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138</a> is the proof of the non-equal diamond</p>



<a name="274464673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464673">(Mar 07 2022 at 22:02)</a>:</h4>
<p>But it amounts to saying that the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">K^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K^\times]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> is ambiguous, as is the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>K</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">]</span></span></span></span></p>



<a name="274464904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274464904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274464904">(Mar 07 2022 at 22:04)</a>:</h4>
<p>(I bring up the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K^\times]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> example to avoid the "well we only care about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is a group" counterargument)</p>



<a name="274465037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465037">(Mar 07 2022 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274464383">said</a>:</p>
<blockquote>
<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>
</blockquote>
<p>I think this would solve the problem, but I suspect it will be very annoying for what Kevin wants to do.</p>



<a name="274465074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465074">(Mar 07 2022 at 22:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- If this were an instance, it would conflict with the natural</span>
<span class="c1">-- action of `k[k]` on itself given by multiplication.</span>
</code></pre></div>
<p>The thing is that <code>k[k]</code> doesn't happen except in pathological computer science land (edit: just seen your comment on k[k^*]). In fact if <code>R</code> is a nontrivial ring (which it always is) and <code>G</code> is a group (which it always is, except when you're making polynomials) then <code>R</code> can never be <code>G</code> because nontrivial rings can never be groups. However they can certainly be additive groups.</p>
<p>So there is something interesting going on here with <code>monoid_algebra</code> v <code>add_monoid_algebra</code>. I claim that they are in some sense different beasts, because <code>monoid_algebra</code> eats a ring and a monoid, and <code>add_monoid_algebra</code> eats a ring and an add_monoid. Problems with scalar actions might occur with one if the ring is the monoid and with the other if the ring is the add_monoid. In particular the two problems are not "reflected" by <code>to_additive</code>.</p>



<a name="274465283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465283">(Mar 07 2022 at 22:06)</a>:</h4>
<p>I don't think we need to worry about <code>add_monoid_algebra k A</code> much here, since it's just <code>monoid_algebra k (multiplicative A)</code> so the same arguments apply</p>



<a name="274465293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465293">(Mar 07 2022 at 22:06)</a>:</h4>
<p>OK so it really is true that there are two distinct actions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">K^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K^\times]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</p>



<a name="274465367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465367">(Mar 07 2022 at 22:07)</a>:</h4>
<p>So we just make the important one (the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span>) the instance</p>



<a name="274465391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465391">(Mar 07 2022 at 22:07)</a>:</h4>
<p>and then just use <code>of k * x</code> for the other one</p>



<a name="274465511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465511">(Mar 07 2022 at 22:08)</a>:</h4>
<p>The other action is the one that says <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>-algebra though, which is also important</p>



<a name="274465571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465571">(Mar 07 2022 at 22:09)</a>:</h4>
<p>Sure, but that's the K-action not the K^*-action. Or does every R-action on a thing induce an R^*-action?</p>



<a name="274465632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465632">(Mar 07 2022 at 22:09)</a>:</h4>
<p>When this sort of thing happens in lectures, mathematicians just introduce two different notations for the two actions</p>



<a name="274465634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465634">(Mar 07 2022 at 22:09)</a>:</h4>
<blockquote>
<p>Or does every R-action on a thing induce an R^*-action?</p>
</blockquote>
<p>Yes (<a href="https://leanprover-community.github.io/mathlib_docs/find/units.mul_action">docs#units.mul_action</a>). This turns out to be useful, because it means we can turn every monoid action into a group action if we know we're working with the units</p>



<a name="274465723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465723">(Mar 07 2022 at 22:10)</a>:</h4>
<p>It can absolutely happen that X can act on Y in more than one way.</p>



<a name="274465894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465894">(Mar 07 2022 at 22:11)</a>:</h4>
<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>



<a name="274465952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465952">(Mar 07 2022 at 22:12)</a>:</h4>
<p>One way out of the problem is to just use <code>f : X →* perm Y</code> and <code>f x y</code> instead of <code>x • y</code></p>



<a name="274465999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274465999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274465999">(Mar 07 2022 at 22:12)</a>:</h4>
<p>Or even <code>f x • y</code> if you like your <code>•</code>s, since we have <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.apply_mul_action">docs#equiv.perm.apply_mul_action</a></p>



<a name="274466114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274466114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274466114">(Mar 07 2022 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274465894">said</a>:</p>
<blockquote>
<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>
</blockquote>
<p>This would be more appealing if we could tell lean to emit an error if someone tries to work with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K^\times]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> rather than giving them rope to hang themselves with</p>



<a name="274466172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274466172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274466172">(Mar 07 2022 at 22:14)</a>:</h4>
<p>That is, a means of blacklisting instances</p>



<a name="274472578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274472578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274472578">(Mar 07 2022 at 23:10)</a>:</h4>
<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>



<a name="274473440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473440">(Mar 07 2022 at 23:20)</a>:</h4>
<p>Do people ever actually think about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>K</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">]</span></span></span></span> and/or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K^\times]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> in real life?</p>



<a name="274473445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473445">(Mar 07 2022 at 23:20)</a>:</h4>
<p>I once wrote a paper in a scenario where this on this sort of thing, and I did use a type synonym. I had a Lie group G and was doing representation theory over the complex numbers. An example of the Lie group could have been <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">C</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">\mathbb{C}^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathbb">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> but I called it <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi mathvariant="double-struck">R</mi><mo stretchy="true">‾</mo></mover><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">\overline{\R}^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0501em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8889em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span><span style="top:-3.8089em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0501em;"><span style="top:-3.3418em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> because the mathematics was telling me that it was a "different <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span>" to the one in the coefficient field.</p>



<a name="274473465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473465">(Mar 07 2022 at 23:20)</a>:</h4>
<p>Adam -- yes. Representation theory of real reductive groups.</p>



<a name="274473475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473475">(Mar 07 2022 at 23:20)</a>:</h4>
<p>Ah right</p>



<a name="274473512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473512">(Mar 07 2022 at 23:21)</a>:</h4>
<p>But as I say, they're in some sense "two different copies of the complex numbers"; one of them is just an abstract algebraic closure of the reals (or at least it was in the paper of Langlands I was using).</p>



<a name="274473535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473535">(Mar 07 2022 at 23:21)</a>:</h4>
<p>I should say that Langlands didn't explicitly say this, it came out of me trying to make what was happening in the paper more functorial.</p>



<a name="274473544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274473544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274473544">(Mar 07 2022 at 23:21)</a>:</h4>
<p>But anyway I agree with you Kevin, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> inside of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><mi>K</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">]</span></span></span></span> should really be thought of as different from the scalars</p>



<a name="274474089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274474089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274474089">(Mar 07 2022 at 23:28)</a>:</h4>
<p>The correct spelling of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[K^\times]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> should be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">[</mo><msub><mi mathvariant="double-struck">G</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">K[\mathbb{G}_m(K)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">[</span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)]</span></span></span></span> anyway.</p>



<a name="274475980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274475980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274475980">(Mar 07 2022 at 23:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274473465">said</a>:</p>
<blockquote>
<p>Adam -- yes. Representation theory of real reductive groups.</p>
</blockquote>
<p>I'm surprised that the case I constructed to prove a point actually turns out to be a thing people care about</p>



<a name="274476865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274476865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274476865">(Mar 08 2022 at 00:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274472578">said</a>:</p>
<blockquote>
<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>
</blockquote>
<p>This seems like a reasonable argument to me as long as we're only talking about <code>K[G]</code> on groups and not monoids (which is why we probably need separate <code>group_algebra</code> and <code>monoid_algebra</code></p>



<a name="274503456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274503456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274503456">(Mar 08 2022 at 06:59)</a>:</h4>
<p>I know that in Iwasawa theory people talk about the completion of the group ring <span class="tex-error">$$\Z_p{\Z_p^\times]$$</span> too. I would like to argue that this diamond is there independent of this whole group ring business. If we just have a group G and a field k acting on an object (which can happen independent of whether one has made the group ring) then the units of the field act on the object so if the units of the field happen to be the group then you have two actions and already this is a diamond in some sense. The fix here should be a type synonym eg <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">GL_1(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> instead of <code>units R</code>. What I'm saying is that the monoid algebra definition is not creating any <em>new</em> diamonds, it's just bringing to the fore an issue which was already there because if we use typeclasses then we're only allowed one action of X on Y, just like we're only allowed one monoid structure on X (which is an action of X on X). So I propose we ignore this issue as I don't believe it will impede progress.  With this in mind do we still need this type synonym in the group algebra PR?</p>



<a name="274503631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274503631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274503631">(Mar 08 2022 at 07:01)</a>:</h4>
<p>An easier way of seeing the problem might be that if we have the statement "if G \times H acts on X then we get induced actions of G and H on X" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>



<a name="274503842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274503842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274503842">(Mar 08 2022 at 07:04)</a>:</h4>
<p>I agree that this is probably just a diamond that we have to live with.</p>



<a name="274503866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274503866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274503866">(Mar 08 2022 at 07:04)</a>:</h4>
<p>But it would be good to record it somewhere, so that we don't forget when it exists.</p>



<a name="274503957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274503957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274503957">(Mar 08 2022 at 07:06)</a>:</h4>
<p>It's because it's there in reality! The complex representation theory of real reductive groups really does give you two different actions of C^* on a vector space</p>



<a name="274504315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274504315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274504315">(Mar 08 2022 at 07:12)</a>:</h4>
<p>Sure, but the question is how to deal with it later on. This could be via a type synonym for the group, or via specialized notation to distinguish the two actions. But we can figure that out when we get there.</p>



<a name="274505789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274505789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274505789">(Mar 08 2022 at 07:37)</a>:</h4>
<blockquote>
<p>An easier way of seeing the problem might be that if we have the statement "if G \times H acts on X then we get induced actions of G and H on X" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>
</blockquote>
<p>This situation doesn't arise in mathlib though: we don't have instances that go in this direction, precisely because they would create diamonds. Instances build data for "big" types (like <code>G × H</code>) out of instances on the pieces, not vice versa.</p>



<a name="274506085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506085">(Mar 08 2022 at 07:40)</a>:</h4>
<p>Does <code>G</code> act on <code>G \times H</code>? I can imagine we would have an instance for that in mathlib.</p>



<a name="274506139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506139">(Mar 08 2022 at 07:41)</a>:</h4>
<p>Well then I claim we shouldn't have an induced action of <code>units K</code> on V given an action of K on V for the same reason</p>



<a name="274506205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506205">(Mar 08 2022 at 07:42)</a>:</h4>
<p>Because <code>units K</code> is obviously smaller than K (although the type theorists are going to argue that it's bigger)</p>



<a name="274506242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506242">(Mar 08 2022 at 07:42)</a>:</h4>
<p>Yes, I mean "big" in the type theory sense</p>



<a name="274506350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506350">(Mar 08 2022 at 07:44)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> But if we have an action of <code>G</code> on <code>G \times H</code>, and also an action of <code>H</code> on <code>G \times H</code>, then we have a diamond. That's the same problem as we have with <code>monoid_algebra</code>.</p>



<a name="274506485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506485">(Mar 08 2022 at 07:46)</a>:</h4>
<p>And the fix is not yet another type ascription, it's to just leave it alone and let people fix it if they run into it. Mathematicians will know if they're running into it, their Spidey senses go off if they have two actions of X on Y</p>



<a name="274506493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506493">(Mar 08 2022 at 07:46)</a>:</h4>
<p>We have no global instance for <code>has_scalar G (G × H)</code> though (unless G acts on H too, then it's <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.has_scalar">docs#prod.has_scalar</a>), nor would it be safe to add one</p>



<a name="274506508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506508">(Mar 08 2022 at 07:46)</a>:</h4>
<p>Oh boo</p>



<a name="274506603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506603">(Mar 08 2022 at 07:48)</a>:</h4>
<p>How about bimodules? Do we have these yet?</p>



<a name="274506704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506704">(Mar 08 2022 at 07:50)</a>:</h4>
<p>Over two different rings? Yes, <code>[module R M] [module Sᵐᵒᵖ M] [smul_comm_class R Sᵐᵒᵖ M]</code></p>



<a name="274506769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506769">(Mar 08 2022 at 07:50)</a>:</h4>
<p>Modules for group rings are a situation in real mathematics where two (generically) distinct objects act on the same side on an object. We have to support this and worry about "what if the objects are the same" later</p>



<a name="274506782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506782">(Mar 08 2022 at 07:51)</a>:</h4>
<p>Why don't we add an action of <code>G^mop</code> on <code>monoid_algebra K G</code>? Does that solve all our problems?</p>



<a name="274506851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506851">(Mar 08 2022 at 07:52)</a>:</h4>
<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there. But that doesn't mean that we can't develop a theory of bimodules. It just means we ignore the issue</p>



<a name="274506874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506874">(Mar 08 2022 at 07:52)</a>:</h4>
<blockquote>
<p>Does that solve all our problems</p>
</blockquote>
<p>Not after <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> it doesn't, which adds the kᵐᵒᵖ action</p>



<a name="274506961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274506961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274506961">(Mar 08 2022 at 07:54)</a>:</h4>
<blockquote>
<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there.</p>
</blockquote>
<p>Why can't we use the spelling above for bimodules over the same ring?</p>



<a name="274507002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507002">(Mar 08 2022 at 07:54)</a>:</h4>
<p>Fair enough. But it will certainly make the problems very tiny.</p>



<a name="274507045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507045">(Mar 08 2022 at 07:55)</a>:</h4>
<p>If we're going to use this with a type synonym like <code>mul_opposite</code>, we could also solve it with a dedicated synonym</p>



<a name="274507077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507077">(Mar 08 2022 at 07:55)</a>:</h4>
<p><code>mul_opposite</code> would be natural: On <code>k[G]</code> there is an action of <code>k</code> on the left, and an action of <code>G</code> on the right.</p>



<a name="274507137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507137">(Mar 08 2022 at 07:56)</a>:</h4>
<p>Lean forces us to accept an action of <code>k</code> on the right. But maybe <em>that</em> shouldn't be a global instance.</p>



<a name="274507152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507152">(Mar 08 2022 at 07:56)</a>:</h4>
<p>I agree that algebras are bimodules, but should that be a <code>def</code> or an <code>instance</code>?</p>



<a name="274507196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507196">(Mar 08 2022 at 07:57)</a>:</h4>
<p>It could <del>certainly</del> maybe be an instance only in a locale</p>



<a name="274507472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507472">(Mar 08 2022 at 08:00)</a>:</h4>
<p>Although if algebras must be bimodules (and therefore carry a right action), then the <code>algebra R (A →ₗ [R] A)</code> instance requires lean to find the right action on <code>A</code></p>



<a name="274507545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274507545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274507545">(Mar 08 2022 at 08:01)</a>:</h4>
<p>I could still be persuaded that <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> is a bad idea, but am like 80% sure we probably want it</p>



<a name="274508053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274508053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274508053">(Mar 08 2022 at 08:08)</a>:</h4>
<p>So how do you suggest we deal with the <code>G</code>-action on <code>k[G]</code>?</p>



<a name="274508072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274508072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274508072">(Mar 08 2022 at 08:08)</a>:</h4>
<p>Just multiply with <code>of g</code>, where <code>of : G -&gt; k[G]</code>?</p>



<a name="274508210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274508210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274508210">(Mar 08 2022 at 08:10)</a>:</h4>
<p>In representation theory you absolutely want that action because it's the regular representation. Already you have this pathological "what if G is syntactically k^*" question</p>



<a name="274509871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274509871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274509871">(Mar 08 2022 at 08:32)</a>:</h4>
<p>What's the downside of the <code>of g * x</code> approach? (Other than being less appealing visually)</p>



<a name="274510006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274510006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274510006">(Mar 08 2022 at 08:34)</a>:</h4>
<p>Presumably there are bits of the action API you want access to; do you know which bits?</p>



<a name="274510759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274510759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274510759">(Mar 08 2022 at 08:43)</a>:</h4>
<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> decomposes as a sum of irreducibles.</p>



<a name="274510900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274510900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274510900">(Mar 08 2022 at 08:44)</a>:</h4>
<p>For me, you saying "well perhaps we have to completely avoid making the action because of the extremely unlikely event that G is syntactically k^*" is like you saying "well I think we should stop using typeclasses for groups because of the extremely unlikely event that we want two distinct groups structures on a type"</p>



<a name="274511444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274511444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274511444">(Mar 08 2022 at 08:50)</a>:</h4>
<p>To be clear, I'm begrudgingly ok with the action as long as it's on the <code>group_algebra</code> where it's less likely to cause harm than the <code>(add_) monoid_algebra</code></p>



<a name="274511507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274511507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274511507">(Mar 08 2022 at 08:51)</a>:</h4>
<p>But I'd also like to understand what actually changes in practice if we say "let's not use • syntax for this action, let's just use a suitably bundled function"</p>



<a name="274511813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274511813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274511813">(Mar 08 2022 at 08:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759">said</a>:</p>
<blockquote>
<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> decomposes as a sum of irreducibles.</p>
</blockquote>
<p>This can be phrased as how the <code>k[G]</code>-module <code>k[G]</code> over itself decomposes as sum of irreducibles.</p>



<a name="274512020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512020">(Mar 08 2022 at 08:57)</a>:</h4>
<p>Often, the action is also written as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding="application/x-tex">L_g a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal">a</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding="application/x-tex">R_g a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal">a</span></span></span></span> if you want to act on the left or on the right. This could be easily mimicked by using a type synonym <code>foo G</code> for <code>G</code>, acting on whatever you want, and calling the identity map from <code>G</code> to <code>foo G</code> as <code>L</code>, and then writing <code>L g \bu a</code> is totally non-ambiguous, diamond free, and close enough to common mathematical practice.</p>



<a name="274512203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512203">(Mar 08 2022 at 08:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759">said</a>:</p>
<blockquote>
<p>one of the big theorems in representation theory of finite groups is how the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> decomposes as a sum of irreducibles.</p>
</blockquote>
<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>



<a name="274512205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512205">(Mar 08 2022 at 08:59)</a>:</h4>
<p>Another solution would be a pretty way of writing "<code>g</code> viewed as element of <code>k[G]</code>". I'm not sure a coercion will do. In maths, it is common to write <code>[g]</code>.</p>



<a name="274512369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512369">(Mar 08 2022 at 09:00)</a>:</h4>
<p>We discussed having the quotient brackets work for free constructions like that in another thread</p>



<a name="274512400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512400">(Mar 08 2022 at 09:01)</a>:</h4>
<p>I think there was general agreement but no one volunteered to do the work</p>



<a name="274512414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512414">(Mar 08 2022 at 09:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274512203">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759">said</a>:</p>
<blockquote>
<p>one of the big theorems in representation theory of finite groups is how the action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> decomposes as a sum of irreducibles.</p>
</blockquote>
<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>
</blockquote>
<p>As Johan says, it should probably be a statement of the form "The R-module R is R-isomorphic to a certain exterior direct sum"</p>



<a name="274512446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512446">(Mar 08 2022 at 09:01)</a>:</h4>
<p>Where did R come from?</p>



<a name="274512510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512510">(Mar 08 2022 at 09:02)</a>:</h4>
<p>It's k[G]</p>



<a name="274512747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512747">(Mar 08 2022 at 09:04)</a>:</h4>
<p>It doesn't sound like the lean statement even mentions a G action then?</p>



<a name="274512898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274512898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274512898">(Mar 08 2022 at 09:06)</a>:</h4>
<p>The thing is that a k-linear G-action on a k-vector space is the same thing as a k[G]-action. We already have a good theory of module actions, so if we could get the group algebra merged somehow (and right now I'm really confused about whether it needs to be different from the module algebra) then the theory of G-modules could just be developed as a theory of k[G]-modules.</p>



<a name="274513365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274513365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274513365">(Mar 08 2022 at 09:11)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> how about making <code>monoid_algebra</code> and <code>add_monoid_algebra</code> irreducible and not making <code>group_algebra</code> at all, and disregarding the issue that G could in theory syntactically be <code>units k</code> because mathematicians are only too well aware when they have two distinct actions of A on B and will know to take evasive action via a type synonym (which can be described to them in some docstring). Does this solve the problems which started this thread and the problems with <a href="https://github.com/leanprover-community/mathlib/pull/11574">#11574</a>?</p>



<a name="274513478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274513478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274513478">(Mar 08 2022 at 09:12)</a>:</h4>
<p>The examples which have been flagged before have had <code>G</code> definitionally <code>k^*</code> but not syntactically.</p>



<a name="274618062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274618062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274618062">(Mar 08 2022 at 22:38)</a>:</h4>
<p>The main problem I had that started this thread was <code>monoid_algebra.of</code> simplifying to <code>finsupp.single</code> even though that's not really wanted. I suppose this wouldn't be the case anymore if <code>monoid_algebra</code> was made irreducible?</p>



<a name="274618820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274618820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274618820">(Mar 08 2022 at 22:46)</a>:</h4>
<p>Making <code>monoid_algebra</code> irreducible is orthogonal to your issue</p>



<a name="274618851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274618851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274618851">(Mar 08 2022 at 22:47)</a>:</h4>
<p>Removing the simp lemma is enough, but right now that creates more problems that it solves</p>



<a name="274618919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274618919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274618919">(Mar 08 2022 at 22:47)</a>:</h4>
<p>Because we can't choose <code>of</code> as the canonical spelling (right now) because it doesn't work on magma algebras</p>



<a name="274619026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274619026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274619026">(Mar 08 2022 at 22:48)</a>:</h4>
<p>So until we introduce something better, the only suitable spelling right now is <code>finsupp.single</code>, even though that had the wrong type.</p>



<a name="274619862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/274619862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#274619862">(Mar 08 2022 at 22:57)</a>:</h4>
<p>I see, so for now I guess I'll just make my problematic lemma use <code>of</code> but not make it a <code>simp</code> lemma</p>



<a name="279021918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279021918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279021918">(Apr 14 2022 at 21:14)</a>:</h4>
<p>Hi! I want to define the tensor product of two representations of a monoid <code>G</code> by <code>g • (v ⊗ₜ w) = (g • v) ⊗ₜ (g • w)</code>, but I noticed that there is already <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.left_has_scalar">docs#tensor_product.left_has_scalar</a> which defines the action by letting <code>G</code> act only on the left factor. What are the reasons for this definition of an action on the left only, and is it possible to define the action I want on <code>V ⊗ W</code> without ambiguity with the other definition? Do I need to use a type synonym?</p>



<a name="279022137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279022137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279022137">(Apr 14 2022 at 21:16)</a>:</h4>
<p>I suspect the action on the left is useful when you want to consider the base-change of an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> to some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, which is defined as the tensor product <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">B \otimes_A M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>.</p>



<a name="279024322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279024322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279024322">(Apr 14 2022 at 21:36)</a>:</h4>
<p>The action on the left is the obvious one when the action is by the field of the two vector spaces (and equal to the equivalent action on the right), which is why it's the default</p>



<a name="279024399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279024399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279024399">(Apr 14 2022 at 21:37)</a>:</h4>
<p>So I have to use a type synonym?</p>



<a name="279024627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279024627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279024627">(Apr 14 2022 at 21:40)</a>:</h4>
<p>If you want to use <code> •</code> notation and not something like <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.map">docs#tensor_product.map</a>, yes</p>



<a name="279024744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279024744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279024744">(Apr 14 2022 at 21:41)</a>:</h4>
<p>I don't know whether it makes more sense to put the type synonym on the tensor type or the action type</p>



<a name="279024931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279024931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279024931">(Apr 14 2022 at 21:43)</a>:</h4>
<p>You might be able to get away without the synonym... What would the typeclass requirements for such an action be?</p>



<a name="279025054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279025054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279025054">(Apr 14 2022 at 21:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024931">said</a>:</p>
<blockquote>
<p>You might be able to get away without the synonym... What would the requirements for such an action be?</p>
</blockquote>
<p>Something like that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">W</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">W</span><span class="o">]</span>
</code></pre></div>



<a name="279025205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279025205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279025205">(Apr 14 2022 at 21:46)</a>:</h4>
<p>Is that enough for <code>distrib_mul_action G (V ⊗[R] W)</code>?</p>



<a name="279025363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279025363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279025363">(Apr 14 2022 at 21:48)</a>:</h4>
<p>I think it is, yes</p>



<a name="279025548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279025548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279025548">(Apr 14 2022 at 21:50)</a>:</h4>
<p>Yeah, you definitely need a type synonym then</p>



<a name="279025891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279025891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279025891">(Apr 14 2022 at 21:55)</a>:</h4>
<p>I would guess putting the type synonym on G works out better</p>



<a name="279028773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279028773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279028773">(Apr 14 2022 at 22:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/279025891">said</a>:</p>
<blockquote>
<p>I would guess putting the type synonym on G works out better</p>
</blockquote>
<p>Why is that? Putting the type synonym on the tensor product seems more natural to me since otherwise we can't compare the tensor representation to other representations of <code>G</code>.</p>



<a name="279038375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279038375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279038375">(Apr 15 2022 at 00:40)</a>:</h4>
<p>Youch. Yes both the diagonal action for a tensor product group rep and the left action for base extension are pretty important :-/</p>



<a name="279043388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279043388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279043388">(Apr 15 2022 at 02:21)</a>:</h4>
<p>shame our subscript options are so limited, or we could use  •_D and  •_L</p>



<a name="279043389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279043389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279043389">(Apr 15 2022 at 02:21)</a>:</h4>
<p>or the like</p>



<a name="279054053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279054053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279054053">(Apr 15 2022 at 06:39)</a>:</h4>
<p>It's not really a matter of notation but a matter of API. If you start using <code>•_D</code> and <code>•_L</code>, then all the lemmas about <code>•</code> don't apply anymore.</p>



<a name="279056734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279056734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279056734">(Apr 15 2022 at 07:29)</a>:</h4>
<p>Is this evidence that we should <em>not</em> define a G-representation over a field k as being definitionally a k[G]-module?</p>



<a name="279059055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279059055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279059055">(Apr 15 2022 at 08:09)</a>:</h4>
<p>I thought <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/260880171">we already decided</a> that <code>[module (monoid_algebra k G) X]</code> was definitely the wrong way to go anyway (and instead to go via the separate actions of <code>k</code> and <code>G</code>)</p>



<a name="279059110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279059110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279059110">(Apr 15 2022 at 08:10)</a>:</h4>
<p>Perhaps a type alias <code>representation</code> used as <code>representation G</code> solves most of the issues</p>



<a name="279068370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279068370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279068370">(Apr 15 2022 at 10:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024399">said</a>:</p>
<blockquote>
<p>So I have to use a type synonym?</p>
</blockquote>
<p>Yes.</p>
<p>I thought about this in some detail a while back and shared some details here: <a href="#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318</a> which may or may not be useful.</p>



<a name="279115715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279115715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279115715">(Apr 15 2022 at 19:40)</a>:</h4>
<p>I am  trying to implement the type synonym following <span class="user-mention" data-user-id="240862">@Oliver Nash</span>'s suggestions, as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">tensor_product</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">k</span> <span class="n">G</span> <span class="n">V</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">W</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">G</span> <span class="n">k</span> <span class="n">W</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">W</span><span class="o">)</span>

<span class="kd">@[derive [add_comm_monoid, module k]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">tensor_rep</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">W</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">V</span> <span class="bp">`</span> <span class="bp">⊗</span><span class="o">[</span><span class="bp">`</span> <span class="n">k</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">G</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span> <span class="n">W</span> <span class="o">:=</span> <span class="n">tensor_rep</span> <span class="n">k</span> <span class="n">V</span> <span class="n">W</span>
<span class="kd">notation</span> <span class="n">v</span> <span class="bp">`</span> <span class="bp">⊗ₜ</span><span class="o">[</span><span class="bp">`</span> <span class="n">k</span> <span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">G</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span> <span class="n">w</span> <span class="o">:=</span> <span class="o">(</span><span class="n">tensor_product.tmul</span> <span class="n">k</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">k</span><span class="o">,</span><span class="n">G</span><span class="o">]</span> <span class="n">W</span><span class="o">)</span>
</code></pre></div>
<p>The last line is problematic because I reference <code>V</code> and <code>W</code>. This shouldn't be a problem since I think there should be a way to infer <code>V</code> and <code>W</code> as the types of <code>v</code> and <code>w</code>. Is there a way to do that?</p>



<a name="279115876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279115876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279115876">(Apr 15 2022 at 19:41)</a>:</h4>
<p>You should define a <code>to_rep</code> function that changes a tensor product to your type</p>



<a name="279115940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279115940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279115940">(Apr 15 2022 at 19:42)</a>:</h4>
<p>Like <a href="https://leanprover-community.github.io/mathlib_docs/find/to_lex">docs#to_lex</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/order_dual.to_dual">docs#order_dual.to_dual</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/conj_act.to_conj_act">docs#conj_act.to_conj_act</a>, etc</p>



<a name="279115978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279115978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279115978">(Apr 15 2022 at 19:42)</a>:</h4>
<p>Then use that definition in your notation</p>



<a name="279117268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279117268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279117268">(Apr 15 2022 at 19:57)</a>:</h4>
<p>Thanks!</p>



<a name="279432277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279432277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279432277">(Apr 19 2022 at 16:17)</a>:</h4>
<p>Hi! After working for a bit on representation theory, I noticed that the approach I took to define <code>k</code>-linear representations of <code>G</code> on a vector space <code>V</code> as <code>distrib_mul_action G V</code> + <code>smul_comm_class G k V</code>causes a lot of issues due to ambiguity between different actions and potential diamonds. After some discussion with <span class="user-mention" data-user-id="310045">@Eric Wieser</span> , we came to the conclusion that it might be better to avoid entirely scalar multiplication when doing representation theory and stick with the definition <code>G →* (V →ₗ [k] V)</code>, writing <code>φ g v</code> everywhere we previously wrote <code>g • v</code>, where <code>φ </code> is the name of the representation (which is slightly less convenient, especially when  <code>φ </code> is actually a long name, but seems like the least worst solution).<br>
Before I start refactoring all I did so far, I was wondering what were the opinions of other people interested in representation theory in mathlib on this matter. Does anyone see downsides of this approach that we might have missed?</p>



<a name="279433648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279433648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279433648">(Apr 19 2022 at 16:27)</a>:</h4>
<p>I think we should be able to obtain a situation similar to informal mathematics: when there is a single (or distinguished) action on a space then we can use the scalar multiplication notation. However when we are considering several actions simultaneously, and do not wish to distinguish any of them, (as happens quite a bit in representation theory) then we will be explicit and give the action a name.</p>



<a name="279433866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279433866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279433866">(Apr 19 2022 at 16:29)</a>:</h4>
<p>If you've been talking with Eric about this then it's very likely the approach you have in mind is sound.</p>



<a name="279434138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279434138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279434138">(Apr 19 2022 at 16:30)</a>:</h4>
<p>To elaborate on that idea, the outline was something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">representation</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">representation.trivial</span> <span class="o">:</span> <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span> <span class="o">:=</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">representation.tprod</span> <span class="o">(</span><span class="n">rV</span> <span class="o">:</span> <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">rW</span> <span class="o">:</span> <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="n">W</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="o">(</span><span class="n">V</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">W</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">tensor_product.map</span> <span class="o">(</span><span class="n">rV</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">rW</span> <span class="n">g</span><span class="o">),</span> <span class="bp">..</span><span class="gr">sorry</span><span class="o">}</span>

<span class="c1">-- I have no idea what a good name is</span>
<span class="kd">def</span> <span class="n">representation.on_monoid_algebra</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="n">G</span> <span class="bp">→+*</span> <span class="o">(</span><span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="sd">/-- notation something like `rV →R rW` -/</span>
<span class="kd">structure</span> <span class="n">representation_map</span> <span class="o">(</span><span class="n">rV</span> <span class="o">:</span> <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">rW</span> <span class="o">:</span> <span class="n">representation</span> <span class="n">G</span> <span class="n">k</span> <span class="n">W</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">V</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">W</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_repr</span> <span class="o">:</span> <span class="bp">\</span><span class="k">forall</span> <span class="n">g</span> <span class="n">x</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">rV</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">rW</span> <span class="n">g</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">))</span>
</code></pre></div>



<a name="279434321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279434321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279434321">(Apr 19 2022 at 16:32)</a>:</h4>
<p>My feeling generally was that this would generate less boilerplate than the equivalent approach with type synonyms</p>



<a name="279435049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279435049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279435049">(Apr 19 2022 at 16:37)</a>:</h4>
<p>I think we'll probably want both approaches eventually but I am certain that we'll want something similar to the above whatever we do.</p>



<a name="279494087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279494087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279494087">(Apr 20 2022 at 03:23)</a>:</h4>
<p>For what it's worth, I also much prefer this approach over using <code>has_scalar</code>, there are just too many scalar actions around in this context.</p>



<a name="279695863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/279695863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#279695863">(Apr 21 2022 at 15:29)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13573">#13573</a></p>



<a name="280033231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280033231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280033231">(Apr 25 2022 at 07:43)</a>:</h4>
<p>I've defined <code>Rep k G</code>, the category of (bundled) representations of <code>G</code> over <code>k</code>. It seems to be nicely compatible with the new design.</p>



<a name="280033274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280033274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280033274">(Apr 25 2022 at 07:44)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13683">#13683</a></p>



<a name="280033334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280033334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280033334">(Apr 25 2022 at 07:44)</a>:</h4>
<p>I was pleased to find that verifying it has (co)limits and a natural monoidal structure was very smooth!</p>



<a name="280033706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280033706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280033706">(Apr 25 2022 at 07:48)</a>:</h4>
<p>The PR doesn't include preparing the <code>preadditive</code> and <code>abelian</code> instances, but this shouldn't be too hard now.</p>



<a name="280033812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280033812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280033812">(Apr 25 2022 at 07:49)</a>:</h4>
<p>Cool! Unfortunately you're hitting a timeout here: <a href="https://github.com/leanprover-community/mathlib/pull/13683/files">https://github.com/leanprover-community/mathlib/pull/13683/files</a></p>



<a name="280033990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280033990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280033990">(Apr 25 2022 at 07:51)</a>:</h4>
<p>I'm still a bit sad that it looks like we can't use scalar multiplication in rep'n theory. But I guess that's life in lean, for now.</p>



<a name="280035459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280035459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280035459">(Apr 25 2022 at 08:04)</a>:</h4>
<p>Fixed the timeouts.</p>



<a name="280088170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280088170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280088170">(Apr 25 2022 at 15:45)</a>:</h4>
<p>Nice, that's definitely gonna be very useful! If we prove enough properties of this category we're gonna be able to use <code>category_theory.preadditive.schur</code>, which is great since I'll need Schur's lemma to get to the orthogonality of characters.</p>



<a name="280089298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280089298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280089298">(Apr 25 2022 at 15:53)</a>:</h4>
<p>I've added PRs</p>
<ul>
<li><a href="https://github.com/leanprover-community/mathlib/pull/13685">#13685</a>: <code>Rep k G</code> is symmetric monoidal</li>
<li><a href="https://github.com/leanprover-community/mathlib/pull/13689">#13689</a>: <code>Rep k G</code> is abelian</li>
</ul>



<a name="280089393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280089393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280089393">(Apr 25 2022 at 15:53)</a>:</h4>
<p>I guess showing that it is a <code>k</code>-linear category should be done as well (easy?), and also that it is monoidal closed (not sure).</p>



<a name="280093222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280093222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280093222">(Apr 25 2022 at 16:21)</a>:</h4>
<p>For monoidal closed, I think the internal hom should be what I called <code>lin_hom</code> in <a href="https://github.com/leanprover-community/mathlib/pull/13573">#13573</a>, and I don't think it should be too hard to prove that it's adjoint to the tensor product.</p>



<a name="280095000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280095000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280095000">(Apr 25 2022 at 16:35)</a>:</h4>
<p>Another TODO:</p>
<ul>
<li>Equivalence with <code>Module k[G]</code>.</li>
</ul>



<a name="280144176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280144176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280144176">(Apr 25 2022 at 23:40)</a>:</h4>
<p>Another to-do: Tannakian?</p>



<a name="280162585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280162585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280162585">(Apr 26 2022 at 05:18)</a>:</h4>
<p>I've never really dared to say it. But Tannaka duality would be a wonderful milestone.</p>



<a name="280206399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280206399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280206399">(Apr 26 2022 at 13:04)</a>:</h4>
<p>I did the equivalence with <code>Module k[G]</code> in <a href="https://github.com/leanprover-community/mathlib/pull/13713">#13713</a>. (Still needs some linting, and one declaration is mysteriously incredibly slow; if anyone wants to have a look at <code>counit_iso</code> in <code>src/representation_theory/Rep.lean</code>?)</p>



<a name="280206464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280206464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280206464">(Apr 26 2022 at 13:04)</a>:</h4>
<p>This is a bit painful as we have to grapple with all the different actions and fight the typeclass system as we convert between them. But it seems to work out okay.</p>



<a name="280206623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280206623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280206623">(Apr 26 2022 at 13:05)</a>:</h4>
<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>



<a name="280206726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280206726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280206726">(Apr 26 2022 at 13:06)</a>:</h4>
<p>More immediately important is to hook up the existing work on schur's lemma and maschke's theorem, and show <code>Rep k G</code> is semisimple when it is.</p>



<a name="280332358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280332358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280332358">(Apr 27 2022 at 10:53)</a>:</h4>
<p>I've added <code>fdRep k G</code> in <a href="https://github.com/leanprover-community/mathlib/pull/13740">#13740</a>, which acquires cheaply a rigid structure when <code>G</code> is a group.</p>



<a name="280333854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280333854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280333854">(Apr 27 2022 at 11:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/280206623">said</a>:</p>
<blockquote>
<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>
</blockquote>
<p>Maybe we can actually get Tannaka <em>reconstruction</em> fairly quickly in the case of <em>finite groups</em>. After all, the general case requires algebraic groups, and I don't think we are anywhere near those.</p>



<a name="280580666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280580666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280580666">(Apr 29 2022 at 02:56)</a>:</h4>
<p>Here's a summary of the current stack of PR's on representation theory.</p>
<ul>
<li><code>Rep k G</code> in <a href="https://github.com/leanprover-community/mathlib/pull/13683">#13683</a></li>
<li><code>Rep k G</code> is symmetric monoidal in <a href="https://github.com/leanprover-community/mathlib/pull/13685">#13685</a>, depending on a PR about braidings in <a href="https://github.com/leanprover-community/mathlib/pull/13684">#13684</a></li>
<li><code>Rep k G</code> is abelian in <a href="https://github.com/leanprover-community/mathlib/pull/13689">#13689</a></li>
<li><code>fdRep k G</code> in <a href="https://github.com/leanprover-community/mathlib/pull/13740">#13740</a>, depending on <a href="https://github.com/leanprover-community/mathlib/pull/13738">#13738</a> which in turn depends on two PRs about rigid structures in <a href="https://github.com/leanprover-community/mathlib/pull/13736">#13736</a> and <a href="https://github.com/leanprover-community/mathlib/pull/13707">#13707</a>.</li>
<li><code>Rep k G ≌ Module (monoid_algebra k G)</code> in <a href="https://github.com/leanprover-community/mathlib/pull/13713">#13713</a>, depending on refactoring PRs in <a href="https://github.com/leanprover-community/mathlib/pull/13760">#13760</a> and <a href="https://github.com/leanprover-community/mathlib/pull/13759">#13759</a>.</li>
</ul>



<a name="280580748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280580748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280580748">(Apr 29 2022 at 02:58)</a>:</h4>
<p>In particular currently needing review are <a href="https://github.com/leanprover-community/mathlib/pull/13683">#13683</a>, <a href="https://github.com/leanprover-community/mathlib/pull/13684">#13684</a>, <a href="https://github.com/leanprover-community/mathlib/pull/13736">#13736</a>, <a href="https://github.com/leanprover-community/mathlib/pull/13707">#13707</a>, and <a href="https://github.com/leanprover-community/mathlib/pull/13760">#13760</a>. (<a href="https://github.com/leanprover-community/mathlib/pull/13759">#13759</a> is back to me after a helpful review from Eric.)</p>



<a name="280583593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280583593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280583593">(Apr 29 2022 at 03:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks for all those PRs. I finally had some time to look at them. They're great.</p>



<a name="280594717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280594717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280594717">(Apr 29 2022 at 07:18)</a>:</h4>
<p>Added:</p>
<ul>
<li><code>Rep k G</code> is <code>k</code>-linear and <code>k</code>-linear monoidal, waiting on <a href="https://github.com/leanprover-community/mathlib/pull/13689">#13689</a>.</li>
</ul>



<a name="280636687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280636687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280636687">(Apr 29 2022 at 14:01)</a>:</h4>
<p>and</p>
<ul>
<li><code>FinVect k</code> has all finite limits, <a href="https://github.com/leanprover-community/mathlib/pull/13793">#13793</a> depending on <a href="https://github.com/leanprover-community/mathlib/pull/13792">#13792</a></li>
</ul>



<a name="280640690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280640690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280640690">(Apr 29 2022 at 14:31)</a>:</h4>
<p>I'm very satisfied by the last one. We've had Schur's lemma in mathlib for over a year, but stated in maximal generality: it holds for any linear category over an algebraically closed field, with finite dimensional hom spaces, and kernels.</p>
<p>Finally, <code>fdRep k G</code> satisfies those hypotheses, so we can write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Verify that Schur's lemma applies out of the box.</span>
<span class="kd">lemma</span> <span class="n">finrank_hom_simple_simple</span> <span class="o">[</span><span class="n">is_alg_closed</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">V</span> <span class="n">W</span> <span class="o">:</span> <span class="n">fdRep</span> <span class="n">k</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">simple</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">simple</span> <span class="n">W</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">finrank</span> <span class="n">k</span> <span class="o">(</span><span class="n">V</span> <span class="bp">⟶</span> <span class="n">W</span><span class="o">)</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">V</span> <span class="bp">≅</span> <span class="n">W</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">category_theory.finrank_hom_simple_simple</span> <span class="n">k</span> <span class="n">V</span> <span class="n">W</span>
</code></pre></div>



<a name="280641174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280641174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280641174">(Apr 29 2022 at 14:35)</a>:</h4>
<p>That's wonderful! I think we're not very far from the orthogonality of characters, though there's still some linear algebra missing.</p>



<a name="280641252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280641252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280641252">(Apr 29 2022 at 14:36)</a>:</h4>
<p>Sometime over the weekend I'll hook up Maschke's theorem with the new setup.</p>



<a name="280641351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280641351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280641351">(Apr 29 2022 at 14:37)</a>:</h4>
<p>After that, I think if I keep working on representation theory I might take an excursion into semisimple categories, and decompositions into simple objects.</p>



<a name="280650353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280650353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280650353">(Apr 29 2022 at 15:45)</a>:</h4>
<p>For Schur's lemma applied to endomorphisms, there's a generalization due to Dixmier (and generalized further by <a href="https://www.ams.org/journals/proc/1969-021-01/S0002-9939-1969-0238892-4/home.html">Quillen</a>) that if you have a simple <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is an algebra over an algebraically closed field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>, if  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|k|&gt;\dim_k(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">dim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">End</mi><mo>⁡</mo></mrow><mi>A</mi></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\operatorname{End}_A(M)\cong k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">End</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>. (If you drop "algebraically closed" then instead the conclusion is that endomorphisms are all algebraic over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>). For example, the space of endomorphisms of a countable-dimensional simple representation of a group over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span> is one-dimensional.</p>
<p>If somebody were to try to formalize this, where would be a good place for it? (still src/category_theory/preadditive/schur.lean?) Potentially it would pull in things about transcendence degree.</p>



<a name="280678849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280678849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280678849">(Apr 29 2022 at 19:37)</a>:</h4>
<blockquote>
<p>For example, the space of endomorphisms of a countable-dimensional simple representation of a group over \mathbb{C}C is one-dimensional.</p>
</blockquote>
<p>This result is used in the basic theory of smooth admissible representations of p-adic groups, which we will have all the ingredients for when we've figured out how to do continuous representations of topological groups.</p>



<a name="280698947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280698947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280698947">(Apr 29 2022 at 22:52)</a>:</h4>
<p>This would be great to have. If it pulls in transcendence degrees then just make a new file for it.</p>



<a name="280699162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280699162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280699162">(Apr 29 2022 at 22:55)</a>:</h4>
<p>Does the proof really use that it is an A-module? I've never looked at these generalisations. Schur's lemma is usually stated for modules, but in fact this is irrelevant for the version in mathlib.</p>



<a name="280703983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280703983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280703983">(Apr 30 2022 at 00:08)</a>:</h4>
<p>It seems like it's important that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module, but maybe there's some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>-linear category trick. There's a step where you give <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> the structure of a vector space over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> using the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module structure. You also need that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is a vector space over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> to get its dimension.</p>
<p>Here's the proof I know: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">f:M\to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> be an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-linear endomorphism. Suppose for sake of contradiction that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is not algebraic over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>. Then by Schur's lemma, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is an isomorphism since it's not zero.  We have that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is a vector space over the field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> of rational functions, with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> acting by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>. Since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is nonzero we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msub><mi>M</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\dim_{k(t)}M\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0496em;vertical-align:-0.3552em;"></span><span class="mop"><span class="mop">dim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>M</mi><mo>≥</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\dim_k M \geq \dim_k k(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop">dim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">dim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>. Since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mi>c</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∣</mo><mi>c</mi><mo>∈</mo><mi>k</mi><mo stretchy="false">}</mo><mo>⊂</mo><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{ (t-c)^{-1} \mid c\in k\}\subset k(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> is a linearly independent set over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> (since, clearing denominators, a linear dependence would be that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> is algebraic over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>), we also have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>≥</mo><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\dim_k k(t) \geq |k|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">dim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">∣</span></span></span></span>. But, we assumed that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>k</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|k|&gt;\dim_k(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">dim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>, so we have a contradiction, hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is algebraic over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.</p>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> is algebraically closed, then you use the minimal polynomial to get an eigenvalue for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and do the usual algebraically closed Schur's lemma proof.</p>



<a name="280709008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280709008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280709008">(Apr 30 2022 at 01:40)</a>:</h4>
<p>That proof doesn't actually use the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>



<a name="280714084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280714084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280714084">(Apr 30 2022 at 03:44)</a>:</h4>
<p>This this is the proof Taylor taught me :-) I thought the 1/(t-c) trick was brilliant.</p>



<a name="280716318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280716318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280716318">(Apr 30 2022 at 04:40)</a>:</h4>
<p>That same trick is also used for what I've seen referred to as a "quick and dirty" proof of the Nullstellensatz.  You can see the trick in the highest scoring answer <a href="https://mathoverflow.net/questions/15226/elementary-interesting-proofs-of-the-nullstellensatz">here</a>.</p>



<a name="280744646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280744646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280744646">(Apr 30 2022 at 16:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/280709008">said</a>:</p>
<blockquote>
<p>That proof doesn't actually use the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>
</blockquote>
<p>Oh, yeah, that's all you need. I got confused and forgot <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> was just an endomorphism, so the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module structure is not used. (If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> acts on the right, then I like to think of the morphisms as acting on the left since then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>x</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fxa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mord mathnormal">a</span></span></span></span> suggests the usual <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">af(x)=f(ax)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.  The proof only uses the left action by the category and some things about dimension.)</p>
<p>It's interesting how this is true no matter the faithful k-linear functor. Over an algebracially closed field, is it true that there's always one that sends simple modules to 1D vector spaces? I know that's true for semisimple algebras over an algebraically closed field.</p>



<a name="280875885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280875885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280875885">(May 02 2022 at 13:51)</a>:</h4>
<p>Hi! I need to talk about equivalence of representations, and I was wondering if I should use for that the isomorphisms provided by the category <code>Rep k G</code> defined by <span class="user-mention" data-user-id="110087">@Scott Morrison</span> or if I should define independently types <code>rep_hom</code> and <code>rep_equiv</code> which would extend <code>linear_map</code> and <code>linear_equiv</code>. I'm not very familiar with how category theory is used in mathlib, so I'd appreciate some advice on this.</p>



<a name="280941829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280941829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280941829">(May 02 2022 at 22:13)</a>:</h4>
<p>We're potentially on new ground here... I'm tempted to suggest we try and proceed "within" the category theory API for now, and only bail out and define everything "unbundled" as necessary. But we will have to be careful trip interpret "necessary" liberally: the first sign of your theoretic troubles caused by using the category theory library should cause us to retreat.</p>



<a name="280941856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280941856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280941856">(May 02 2022 at 22:13)</a>:</h4>
<p>But this is only one opinion, and a biased one.</p>



<a name="280941956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280941956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280941956">(May 02 2022 at 22:14)</a>:</h4>
<p>But I do like the idea of finally being able to stop defining the same basic ideas (isomorphism, etc), and using the polymorphic model provide by category theory. Worth a try, as an experiment?</p>



<a name="280942100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280942100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280942100">(May 02 2022 at 22:16)</a>:</h4>
<p>This all said, I think most of the future work on representation theory for a while should be developing the representation theory of (finite dimensional) algebras.</p>



<a name="280942201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280942201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280942201">(May 02 2022 at 22:17)</a>:</h4>
<p>The main representations-of-groups specific fact is already there in <code>maschke.lean</code>, and most of what is needed to hook that up to decomposition into irreducibles and character theory is true more generally.</p>



<a name="280942370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280942370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280942370">(May 02 2022 at 22:19)</a>:</h4>
<p>I was thinking that perhaps we should just plough through Etingof's notes on representation theory. They are a bit nonlinear, but if we just do whatever subset is on the minimal path to his treatment of representations of finite groups I think we'd get a very pretty, and appropriately generalized, treatment.</p>



<a name="280942479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280942479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280942479">(May 02 2022 at 22:20)</a>:</h4>
<p>This is actually why I wrote my "simple implies indecomposable" PR last night: it was the first statement I could find in his notes that we didn't have.</p>



<a name="280943437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280943437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280943437">(May 02 2022 at 22:31)</a>:</h4>
<p>So far I focused on group representations because my goal was to get orthogonality of characters. I'm not really aware of how character theory generalizes to finite-dimensional algebras, is there a more general version of orthogonality of characters for finite groups?</p>



<a name="280945611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280945611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280945611">(May 02 2022 at 22:55)</a>:</h4>
<p>Something that comes to mind is finite-dimensional Hopf algebras. These have a one-dimensional space of "integrals" that you can use to generalize averaging-over-the-group arguments.  (Group algebras are Hopf algebras, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><mi>g</mi></mrow><annotation encoding="application/x-tex">\sum_{g\in G}g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">G</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is an integral.) I'm pretty sure these are all you need to get that characters of non-isomorphic simple representations are orthogonal, where you define something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>V</mi><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">⟩</mo><mo>=</mo><msub><mrow><mi mathvariant="normal">tr</mi><mo>⁡</mo></mrow><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">(</mo><mo>∫</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\langle V, W\rangle = \operatorname{tr}_{V\otimes W^*}(\Delta(\int))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mbin mtight">⊗</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6183em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">Δ</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mclose">))</span></span></span></span> (the trace of the action of the comultiplication of the integral on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">V\otimes W^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>). That can be rewritten in terms of characters for V and W.</p>
<p>The way that formula expands for groups using the un-scaled integral is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>V</mi><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">⟩</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><msub><mrow><mi mathvariant="normal">tr</mi><mo>⁡</mo></mrow><mi>V</mi></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><msub><mrow><mi mathvariant="normal">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\langle V,W\rangle = \sum_{g\in G} \operatorname{tr}_V(g)\operatorname{tr}_W(g^{-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2499em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">G</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, using the fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">tr</mi><mo>⁡</mo></mrow><msup><mi>W</mi><mo>∗</mo></msup></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi mathvariant="normal">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{tr}_{W^*}(g)=\operatorname{tr}_{W}(g^{-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6183em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> (for Hopf algebras in general, the antipode can be used to put things in terms of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname{tr}_W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tr</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</p>



<a name="280949933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280949933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280949933">(May 02 2022 at 23:52)</a>:</h4>
<p>even if we don't go via hopf algebras, while orthogonality of characters doesn't hold generally, there are interesting statements. e.g. Theorem 3.6.2 of <a href="https://klein.mit.edu/~etingof/repb.pdf">https://klein.mit.edu/~etingof/repb.pdf</a></p>
<blockquote>
<p>(i) Characters of (distinct) irreducible finite dimensional representations of A are linearly independent.<br>
(ii) If A is a finite dimensional semisimple algebra, then these characters form a basis of (A/[A, A])^∗</p>
</blockquote>



<a name="280950147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950147">(May 02 2022 at 23:56)</a>:</h4>
<p>But I guess for just checking orthogonality there's no point knowing anything about the relationship with characters of algebras.</p>



<a name="280950171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950171">(May 02 2022 at 23:57)</a>:</h4>
<p>But the facts the characters span, and determine the representation, come from more general facts, and ideally we would deduce these facts in the Rep G setting from the more general statements.</p>



<a name="280950406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950406">(May 03 2022 at 00:00)</a>:</h4>
<p>but don't hesitate to do whatever work on orthogonality you like</p>



<a name="280950458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950458">(May 03 2022 at 00:00)</a>:</h4>
<p>if we want to relate the characters you define for G and the characters for k[G], we can retrofit that later</p>



<a name="280950592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950592">(May 03 2022 at 00:02)</a>:</h4>
<p>Anyway for now I've been mostly doing linear algebra and proving stuff about traces of linear maps, which will be useful both for algebras and for groups</p>



<a name="280950644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950644">(May 03 2022 at 00:02)</a>:</h4>
<p>I forget -- do you need anything beyond semisimplicity to get that A/[A,A] is isomorphic to the center Z(A) as a vector space?</p>



<a name="280950783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280950783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280950783">(May 03 2022 at 00:04)</a>:</h4>
<p>But I'll try to get more familiar with the category theory API soon</p>



<a name="280956826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280956826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280956826">(May 03 2022 at 01:48)</a>:</h4>
<p><span class="user-mention" data-user-id="329754">@Antoine Labelle</span> has open PRs defining several natural maps involving dual modules, contractions and traces (<a href="https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR147-R157">for example</a>), and I am wondering whether all this stuff (including definition of trace) should be rewritten in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact_pairing">docs#category_theory.exact_pairing</a>. I'm not suggesting to simply adopt the categorical formalism, but at least we would like to easily convert between both formalisms. And the current definition of trace (which landed in mathlib two years ago <a href="https://github.com/leanprover-community/mathlib/pull/3125">#3125</a>) only works for finite free modules, but I think we eventually want it for finite projective modules as well, for K-theory or whatever, and <code>exact_pairing</code> probably offers us greatest generality. I'd appreciate comments from <span class="user-mention" data-user-id="110087">@Scott Morrison</span> on this.</p>



<a name="280956912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280956912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280956912">(May 03 2022 at 01:50)</a>:</h4>
<p>Yes, I hope this can be aligned as closely as possible, so that "bundling" statements up as statements about rigid categories is as trivial as possible.</p>



<a name="280956947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280956947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280956947">(May 03 2022 at 01:51)</a>:</h4>
<p>Is it true that <code>dual_tensor_hom R M N</code> is an equivalence whenever <code>M</code> is a finite projective module?</p>



<a name="280957013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280957013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280957013">(May 03 2022 at 01:52)</a>:</h4>
<p>I believe so. (Here is a "reference": <a href="https://mathoverflow.net/a/156274/3332">https://mathoverflow.net/a/156274/3332</a>)</p>



<a name="280957056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280957056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280957056">(May 03 2022 at 01:53)</a>:</h4>
<p>It seems in the module case, you can derive all isomorphisms involving duals from <code>(module.dual R M) ⊗[R] M →ₗ[R] module.End R M</code> being an isomorphism, which seems a simpler statement than exact_pairing. Is there some advanced theory that I can look into?</p>



<a name="280957224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280957224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280957224">(May 03 2022 at 01:57)</a>:</h4>
<p>Can you derive the more general <code>(module.dual R M) ⊗[R] N →ₗ[R] (M →ₗ[R] N)</code> from this?</p>



<a name="280957542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280957542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280957542">(May 03 2022 at 02:02)</a>:</h4>
<p>It's pretty easy to define <code>Mᵛ → M → (M → N) → Mᵛ ⊗ N</code> which <code>lift</code> to <code>Mᵛ ⊗ M → (M → N) → Mᵛ ⊗ N</code>, and if you have the canonical element in <code>Mᵛ ⊗ M</code> that corresponds to <code>1 : End M</code> then you get <code>(M → N) → Mᵛ ⊗ N</code>. (I'm using <code>ᵛ</code> to denote the dual; I think this is a common notation but forget where I saw it; Wikipedia uses <code>*</code>.)</p>



<a name="280958372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280958372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280958372">(May 03 2022 at 02:13)</a>:</h4>
<p>I see, that's nice!</p>



<a name="280958856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/280958856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#280958856">(May 03 2022 at 02:20)</a>:</h4>
<p>The check notation is particularly nice for duals once you reach dagger categories and start interacting with operator algebras. At that point <code>*</code> is so massively overloaded that no one is allowed to use it. :-)</p>



<a name="281160272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281160272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281160272">(May 04 2022 at 14:08)</a>:</h4>
<p>It seems that the following are all equivalent:<br>
(1) The identity is in the image of the natural map <code>Mᵛ ⊗ M → End M</code>.<br>
(2) <code>M</code> is a <a href="https://en.wikipedia.org/wiki/Rigid_category">rigid object</a> in the category of <code>R</code>-modules, with <code>M</code> and <code>Mᵛ</code> forming an exact_pairing ((1) is basically one of the "triangle" identities saying <code>M → M</code> is id, and the other one follows (the proof invokes extensionality, showing that two linear functionals agree on every element of <code>M</code>, and doesn't seem to follow from axioms of symmetric closed monoidal categories)).<br>
(3) The natural map <code>Mᵛ ⊗ M → End M</code> is an isomorphism (with inverse given by the construction <code>(M → N) → Mᵛ ⊗ N</code> above (also on the Wikipedia page)).<br>
(4) <code>M</code> is a finite projective module (finiteness is trivial; projectivity follows from <a href="https://en.wikipedia.org/wiki/Projective_module#Dual_basis">https://en.wikipedia.org/wiki/Projective_module#Dual_basis</a>, <a href="https://math.stackexchange.com/a/22403/12932">proof</a>).</p>
<p>So we can just work with finite projective modules for maximal generality.<br>
Notice that <code>M → Mᵛᵛ</code> being an isomorphism (<code>M</code> reflexive) is strictly weaker, as <code>M</code> doesn't have to be finite or projective (e.g. the direct sum of countably many Z).</p>
<p>One may be tempted to construct all natural maps involving tensor and Hom and prove identities between them using the axioms of symmetric closed monoidal categories and rigid objects, but that's likely cumbersome (though a ramped up <code>coherence</code> tactic might help); simply using extensionality would be easier: if the identity doesn't involve the inverse of <code>Mᵛ ⊗ M → End M</code> it's probably <code>rfl</code>, but I think we need to figure out a better (and uniform) way to do <a href="https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR159">proofs like this</a> where the inverse is involved.</p>



<a name="281218942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281218942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281218942">(May 04 2022 at 21:02)</a>:</h4>
<p>In the categorical language, when the inverse is involved can't we just use <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso.inv_comp_eq">docs#category_theory.is_iso.inv_comp_eq</a> to get rid of the inverse, just as I used <code>linear_map.cancel_right</code> when doing these kinds of proofs in the linear algebra language?</p>



<a name="281507930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281507930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281507930">(May 07 2022 at 00:20)</a>:</h4>
<p>Could I just ping on a few PRs on the <a href="https://bit.ly/3zVLgqR">#queue</a>: <a href="https://github.com/leanprover-community/mathlib/pull/13713">#13713</a> <a href="https://github.com/leanprover-community/mathlib/pull/13870">#13870</a> <a href="https://github.com/leanprover-community/mathlib/pull/13908">#13908</a> <a href="https://github.com/leanprover-community/mathlib/pull/13967">#13967</a> <a href="https://github.com/leanprover-community/mathlib/pull/13933">#13933</a> (and hopefully <a href="https://github.com/leanprover-community/mathlib/pull/13740">#13740</a>, it's just linting now after a merge conflict)?</p>



<a name="281620148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281620148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281620148">(May 08 2022 at 21:54)</a>:</h4>
<p>I started trying to work with <span class="user-mention" data-user-id="110087">@Scott Morrison</span> 's <code>Rep k G</code> category, and one issue I noticed is that it assumes that <code>k</code> is a ring (due to <code>Module k</code> assuming a ring), while so far I've tried to only assume <code>semiring</code> when possible. Is there any reason why <code>Module k</code> isn't defined for semirings?</p>



<a name="281620224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281620224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281620224">(May 08 2022 at 21:56)</a>:</h4>
<p>I don't know if there's really any interesting case in which we have a semiring which is not a ring, but if there are some things that we can state in this generality I guess that it's better to do so?</p>



<a name="281622233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281622233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281622233">(May 08 2022 at 22:51)</a>:</h4>
<p>Probably this can be generalized. I suspect that at the time Module was defined the library was less generalized than it is now. If you'd like to have a go at this please do, otherwise I can try soon.</p>



<a name="281622306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281622306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281622306">(May 08 2022 at 22:53)</a>:</h4>
<p>And yes, I think it's good if results are stated as generally as possible. It seems to pay off later in a mathlib style library. :-) Also often it's helpful for understanding proofs when the hypotheses are as weak as possible --- fewer misleading clues about wrong directions you might take!</p>



<a name="281627211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281627211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281627211">(May 09 2022 at 00:59)</a>:</h4>
<p>I tried quickly to check what happens what happens if I replace <code>ring</code> by <code>semiring</code> in <code>Module</code>, and the problem is that we also need to replace <code>add_comm_group</code> by <code>add_comm_monoid</code> for the underlying abelian group of the module, which causes some problems for example in <code>has_forget_to_AddCommGroup</code> since <code>M</code> doesn't have an <code>add_comm_group</code> instance anymore.</p>



<a name="281627327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281627327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281627327">(May 09 2022 at 01:00)</a>:</h4>
<p>There's <a href="https://leanprover-community.github.io/mathlib_docs/find/module.add_comm_monoid_to_add_comm_group">docs#module.add_comm_monoid_to_add_comm_group</a> but it's a def and not an instance so I'm not sure how to use it.</p>



<a name="281632116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632116">(May 09 2022 at 02:48)</a>:</h4>
<p>Okay, I spent a while on this, and I think it is sadly impossible.</p>



<a name="281632149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632149">(May 09 2022 at 02:48)</a>:</h4>
<p>I can get <code>Module/basic.lean</code> to compile, but only be constructing dubious instances, which later break everything.</p>



<a name="281632163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632163">(May 09 2022 at 02:49)</a>:</h4>
<p>Hm, that's unfortunate...</p>



<a name="281632281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632281">(May 09 2022 at 02:51)</a>:</h4>
<p>I'd been worried that we would need a different <code>Module</code> to handle modules over <code>k</code>-algebras, but so far I can get away with just the one.</p>



<a name="281632284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632284">(May 09 2022 at 02:51)</a>:</h4>
<p>But this seems worse.</p>



<a name="281632377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632377">(May 09 2022 at 02:53)</a>:</h4>
<p>What did you want to do over semirings? Maybe looking at a concrete statement will lead to inspiration. :-)</p>



<a name="281632572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281632572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281632572">(May 09 2022 at 02:57)</a>:</h4>
<p>As an example, I was thinking of restating <a href="https://leanprover-community.github.io/mathlib_docs/find/representation.lin_hom">docs#representation.lin_hom</a> in the category theory language using <code>Rep k G</code>. Currently this definition works for semirings, but <code>Rep k G</code> requires a ring.</p>



<a name="281635261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281635261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281635261">(May 09 2022 at 03:51)</a>:</h4>
<p>I see. It would be nice to construct the closed monoidal instance on <code>Rep k G</code>.</p>



<a name="281635265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281635265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281635265">(May 09 2022 at 03:51)</a>:</h4>
<p>I propose that for now we just proceed with the restriction that <code>k</code> is a ring in <code>Rep k G</code>...</p>



<a name="281635321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281635321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281635321">(May 09 2022 at 03:52)</a>:</h4>
<p>I don't think I've ever met someone who does representation theory over semirings.</p>



<a name="281635593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/281635593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#281635593">(May 09 2022 at 03:58)</a>:</h4>
<p>Fair enough</p>



<a name="282393704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/282393704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#282393704">(May 15 2022 at 06:51)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a>, <a href="https://github.com/leanprover-community/mathlib/pull/13845">#13845</a>, <a href="https://github.com/leanprover-community/mathlib/pull/13933">#13933</a> would like some review, and are on the "representation theory queue", if anyone reading here would like to take a look. :-)</p>



<a name="282393819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/282393819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#282393819">(May 15 2022 at 06:54)</a>:</h4>
<p>I'm hoping that soon I will have the equivalence of "is a sum of simple objects" and "every subobject is complemented" in any preadditive category (with a few bits and pieces), and after that the density theorem (the map <code>A ⟶ End V</code> is surjective for any irreducible f.d. representation V of a <code>k</code>-algebra A).</p>



<a name="283176767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283176767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283176767">(May 21 2022 at 14:38)</a>:</h4>
<p>I  see that we have a <code>right_rigid_category</code> instance for <code>fdRep k G</code>, but we don't have <code>left_rigid_category</code>. This is very annoying since we need the left version in order to get the <code>monoidal_closed</code> structure (<a href="https://leanprover-community.github.io/mathlib_docs/find/monoidal_closed_of_left_rigid_category">docs#monoidal_closed_of_left_rigid_category</a>). <br>
I looked at <code>FinVect</code> and noticed that here also we weirdly only have the right rigid structure but not the left one. Is there any reason for that?  If I want to access the monoidal structure of <code>fdRep k G</code>, should I go back to <code>FinVect</code> and add the left rigid structure there, or is it available in another way that I am missing?</p>



<a name="283176870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283176870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283176870">(May 21 2022 at 14:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>



<a name="283176887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283176887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283176887">(May 21 2022 at 14:41)</a>:</h4>
<p>I think no good reason this is missing. Maybe it would be nice to show that if you're braided one implies the other?</p>



<a name="283176888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283176888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283176888">(May 21 2022 at 14:41)</a>:</h4>
<p>Or just do it directly for FinVect.</p>



<a name="283176934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283176934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283176934">(May 21 2022 at 14:42)</a>:</h4>
<p>The PR that did this was just plugging together immediately available pieces.</p>



<a name="283177291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283177291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283177291">(May 21 2022 at 14:50)</a>:</h4>
<p>I don't think we even have that <code>FinVect</code> is braided so for now I think the second option is simpler.</p>



<a name="283178197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283178197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283178197">(May 21 2022 at 15:09)</a>:</h4>
<p>Though proving braiding for <code>FinVect</code> shouldn't be too hard. The natural way to do it would be to prove it more generally for <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.monoidal_category.full_monoidal_subcategory">docs#category_theory.monoidal_category.full_monoidal_subcategory</a>. By the way, is there a reason why this is not an instance?</p>



<a name="283179780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283179780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283179780">(May 21 2022 at 15:45)</a>:</h4>
<p>Ok, so trying to prove that <code>FinVect</code> is symmetric, I figured I should probably use <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.braided_category_of_fully_faithful">docs#category_theory.braided_category_of_fully_faithful</a>, but for that I need a monoidal version of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.full_subcategory_inclusion">docs#category_theory.full_subcategory_inclusion</a>. How do I get lean to figure out the monoidal structure on <code>{X : C // P X}</code> here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">full_monoidal_subcategory_inclusion</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h_id</span> <span class="o">:</span> <span class="n">P</span> <span class="o">(</span><span class="mi">𝟙</span><span class="n">_</span> <span class="n">C</span><span class="o">))</span> <span class="o">(</span><span class="n">h_tensor</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">},</span> <span class="n">P</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⊗</span> <span class="n">Y</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">monoidal_functor</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">//</span> <span class="n">P</span> <span class="n">X</span><span class="o">}</span> <span class="n">C</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="283208421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283208421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283208421">(May 22 2022 at 03:45)</a>:</h4>
<p>I think the best approach here will be to introduce <code>monoidal_subcategory P  h_id h_tensor</code> as a synonym for <code>{X : C // P X}</code> and put a monoidal_category instance on that.</p>



<a name="283208428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283208428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283208428">(May 22 2022 at 03:45)</a>:</h4>
<p>Perhaps even add <code>monoidal_predicate</code> which bundles together <code>P</code>, <code>h_id</code> and <code>h_tensor</code>.</p>



<a name="283208487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283208487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283208487">(May 22 2022 at 03:46)</a>:</h4>
<p>Does that make sense / seem plausible?</p>



<a name="283247112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283247112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283247112">(May 22 2022 at 19:17)</a>:</h4>
<p>Sounds good, done in <a href="https://github.com/leanprover-community/mathlib/pull/14311">#14311</a>. Let me know what you think.</p>



<a name="283256290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283256290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283256290">(May 22 2022 at 22:53)</a>:</h4>
<p>Left a few comments. Mostly looks promising, thanks for doing this!</p>



<a name="283320796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283320796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283320796">(May 23 2022 at 13:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> What are your thoughts on <a href="https://github.com/leanprover-community/mathlib/pull/14311#discussion_r878940321">that comment</a>?</p>



<a name="283697414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/283697414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#283697414">(May 24 2022 at 04:52)</a>:</h4>
<p>Yes, this looks good.</p>



<a name="286095492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/286095492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#286095492">(Jun 14 2022 at 16:05)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13794">#13794</a> (depending on <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a>.</p>



<a name="307566451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307566451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Remy van Dobben de Bruyn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307566451">(Nov 02 2022 at 16:31)</a>:</h4>
<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>



<a name="307566748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307566748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Remy van Dobben de Bruyn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307566748">(Nov 02 2022 at 16:32)</a>:</h4>
<p>(deleted)</p>



<a name="307566857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307566857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Remy van Dobben de Bruyn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307566857">(Nov 02 2022 at 16:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/116395-maths/topic/Representation.20Theory/near/286095492">said</a>:</p>
<blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13794">#13794</a> (depending on <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a>.</p>
</blockquote>
<p>(I am also a new user, so maybe I'm doing something wrong, but I think this commit is not in my local copy yet...)</p>



<a name="307567981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307567981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307567981">(Nov 02 2022 at 16:38)</a>:</h4>
<p>All those commits are on a branch (<a href="https://github.com/leanprover-community/mathlib/tree/orthogonality">branch#orthogonality</a>) which is not yet merged into master so your local version of master won't have them yet.</p>



<a name="307568538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307568538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307568538">(Nov 02 2022 at 16:41)</a>:</h4>
<p>It looks like the first thing that needs to happen to get the ball rolling on these again is to fix the merge conflicts in <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a> with master</p>



<a name="307579089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307579089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307579089">(Nov 02 2022 at 17:29)</a>:</h4>
<p>I just tried to fix <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a> lets see if the other branches also work now</p>



<a name="307585217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307585217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307585217">(Nov 02 2022 at 17:58)</a>:</h4>
<p>Ok and I've merged branch 'semorrison/fdRep-linear' into semorrison/fdRep-schur and it looks like it builds ok, so <a href="https://github.com/leanprover-community/mathlib/pull/13794">#13794</a> will hopefully turn green after a while and be ready for review when the first PR is merged</p>



<a name="307625238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307625238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307625238">(Nov 02 2022 at 21:58)</a>:</h4>
<blockquote>
<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>
</blockquote>
<p>Yes, we basically have orthgonality of characters modulo the merging of these old PRs. We don't have yet that the characters span the class functions though, that would be a next natural step.</p>



<a name="307625365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307625365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307625365">(Nov 02 2022 at 21:59)</a>:</h4>
<p>Or incorporating this in a more general setting of representations of algebras.</p>



<a name="307650969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307650969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307650969">(Nov 03 2022 at 03:21)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="127136">@Alex J. Best</span> for fixing <a href="https://github.com/leanprover-community/mathlib/pull/13789">#13789</a>. It's merged now, and I've just updated <a href="https://github.com/leanprover-community/mathlib/pull/13794">#13794</a> (Schur's lemma applies to fdRep) and it looks good. Hopefully someone can approve it shortly.</p>



<a name="307730132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307730132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Remy van Dobben de Bruyn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307730132">(Nov 03 2022 at 13:38)</a>:</h4>
<p><span class="user-mention" data-user-id="329754">@Antoine Labelle</span> Oh great! Should I pick it up somewhere, or are you rolling with these representations?</p>



<a name="307730213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307730213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Remy van Dobben de Bruyn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307730213">(Nov 03 2022 at 13:38)</a>:</h4>
<p>(Our local Lean workshop is working towards Burnside's p^aq^b theorem, so there are many other parts that I could start working on.)</p>



<a name="307730476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307730476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Remy van Dobben de Bruyn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307730476">(Nov 03 2022 at 13:40)</a>:</h4>
<p>But I love thinking about general finite dimensional representation theory too, so I'm more than happy to dive in here as well.</p>



<a name="307730711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307730711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307730711">(Nov 03 2022 at 13:41)</a>:</h4>
<p>I haven't worked on that for a few months, so feel free to start working on any result that we don't currently have.</p>



<a name="307731021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307731021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307731021">(Nov 03 2022 at 13:42)</a>:</h4>
<p>Let me know if you have any questions on the current API.</p>



<a name="307818092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Representation%20Theory/near/307818092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Representation.20Theory.html#307818092">(Nov 03 2022 at 19:06)</a>:</h4>
<p>I've updated <a href="https://github.com/leanprover-community/mathlib/pull/16043">#16043</a>, it's now ready to be reviewed.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
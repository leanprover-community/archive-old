---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Group.20cohomology.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html">Group cohomology</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240735484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735484">(May 30 2021 at 03:27)</a>:</h4>
<p>I thought I'd test out the new API we have for homological algebra, by doing a test case: building a model for group cohomology. There are competing topologists who I believe want to build a totally different model involving these exotic <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(G,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> spaces or whatever they're called, but my version with homogeneous cocycles and coboundaries is on the <code>group-cohomology</code> branch of mathlib and <a href="https://github.com/leanprover-community/mathlib/blob/ce56c4f6fa5913563abfc09b85a06e4962846e0e/src/algebra/group/cohomology.lean#L170-L171">I just proved</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d^2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.</p>
<p>People have said various things to me in DMs about how building a model via cocycles is somehow "not the right thing to do" for some reason. However I have, in a sense, written down an explicit implementation of a projective resolution for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Z[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span>, and used it to calculate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>x</mi><msup><mi>t</mi><mi>i</mi></msup><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><msup><mi>H</mi><mi>i</mi></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ext^i(\Z[G],M):=H^i(G,M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>.</p>
<p>Given that I have proved that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d^2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> I would like to claim my free "short-exact-sequence-implies-long-exact-sequence" and "Hochschild-Serre spectral sequence" theorems, or at least the "Inf-res" long exact sequence for group cohomology in low degree. What API do you category people require? <span class="user-mention" data-user-id="132893">@Ken Lee</span> ?</p>



<a name="240735536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735536">(May 30 2021 at 03:29)</a>:</h4>
<p>I haven't looked at this yet, but can you show that you've produced a projective resolution in the sense of <a href="https://github.com/leanprover-community/mathlib/issues/7486">#7486</a>? This might be a good fit test.</p>



<a name="240735676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735676">(May 30 2021 at 03:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">cochain_succ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_apply'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">),</span> <span class="n">s</span> <span class="bp">•</span> <span class="n">to_fun</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>
<p>I guess we don't have a type for bundled <code>distrib_mul_action</code>-compatible maps.</p>



<a name="240735743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735743">(May 30 2021 at 03:35)</a>:</h4>
<p>Maybe it's better to quickly develop that, i.e. just replacing <code>fin n → G</code> with some arbitrary <code>distrib_mul_action G N</code>. Presumably everything up to line 148 holds in that setting.</p>



<a name="240735853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735853">(May 30 2021 at 03:39)</a>:</h4>
<p>The point of <a href="https://github.com/leanprover-community/mathlib/issues/7486">#7486</a> (projective resolutions) <a href="https://github.com/leanprover-community/mathlib/issues/7487">#7487</a> (derived functors) and <a href="https://github.com/leanprover-community/mathlib/issues/7525">#7525</a> (Ext) is to provide you with a single "chosen" <code>left_derived n F</code>, for each functor <code>F</code>, and also to provide the API so you can bring your own favourite resolution, and know that <code>(left_derived n F).obj X</code> is isomorphic to the n-th homology of <code>F</code> applied to that resolution.</p>



<a name="240735925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735925">(May 30 2021 at 03:41)</a>:</h4>
<p>I think the DMs saying building the model via cocycles is not the right thing to do (not from me) are just pointing out that your calculation of <code>d^2 = 0</code> here can likely be factored without much additional work into constructing a simplicial object, and then computing the alternating face complex of that simplicial object --- but that second piece of work only ever needs to be done once (and has been done in LTE).</p>



<a name="240735931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735931">(May 30 2021 at 03:42)</a>:</h4>
<p>But I haven't actually tried building the relevant simplicial object here, so I can't really promise that you get a reduction in work by using the alternately face complex.</p>



<a name="240735968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240735968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240735968">(May 30 2021 at 03:42)</a>:</h4>
<p>I would hope that you can even get something that is pretty close to definitionally equal to what you've done!</p>



<a name="240736025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240736025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240736025">(May 30 2021 at 03:44)</a>:</h4>
<p>Oh, sorry, scratch those last three comments. Maybe they only apply with the usual model of group cohomology. Maybe there's some augmentation trick, I'm not sure, to fit the homogeneous model into this picture, I'd have to think about it.</p>



<a name="240736473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240736473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240736473">(May 30 2021 at 03:56)</a>:</h4>
<p>I'm fairly sure the homogeneous cochain complex is defeq to the alternating face map cochain complex associated to such a cosimplicial object, and furthermore this cosimplicial object can be built from K(pi,1) as a simplicial set (not a topological space! It's just the combinatorics that encapsulate the usual differential). I certainly wasn't suggesting constructing anything via any actual topological spaces <span aria-label="fear" class="emoji emoji-1f628" role="img" title="fear">:fear:</span></p>



<a name="240736760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240736760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240736760">(May 30 2021 at 04:04)</a>:</h4>
<p>I don't know if the simplicial construction of this might be helpful <a href="https://ncatlab.org/nlab/show/group+cohomology">nlab#group+cohomology</a></p>



<a name="240736816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240736816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240736816">(May 30 2021 at 04:06)</a>:</h4>
<p>Looks like this describes modules with the trivial action, but I'm sure the general construction is written down somewhere...</p>



<a name="240737546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240737546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240737546">(May 30 2021 at 04:27)</a>:</h4>
<p>Do we have this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finsupp.equiv_congr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">β</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
<span class="c1">-- by rw e</span>
</code></pre></div>
<p>I'm making the projective resolution using <code>finsupp</code>.</p>



<a name="240737797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240737797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240737797">(May 30 2021 at 04:35)</a>:</h4>
<p>If you use <code>map_domain</code> you need <code>M</code> to be (unnecessarily) an <code>add_comm_monoid</code> and if you use <code>comap_domain</code> you end up noncomputable.</p>



<a name="240737810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240737810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240737810">(May 30 2021 at 04:35)</a>:</h4>
<p>I think you want to use <code>emb_domain</code> instead</p>



<a name="240737852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240737852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240737852">(May 30 2021 at 04:36)</a>:</h4>
<p>actually that one is noncomputable too</p>



<a name="240737879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240737879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240737879">(May 30 2021 at 04:37)</a>:</h4>
<p>yeah I guess the computable version only works with an equiv, since the support maps and the function comaps</p>



<a name="240738422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240738422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240738422">(May 30 2021 at 04:56)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7755">#7755</a></p>



<a name="240755149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240755149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240755149">(May 30 2021 at 13:11)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action_hom">docs#distrib_mul_action_hom</a> - isn't that the bundled type you ask for above?</p>



<a name="240776967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240776967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ken Lee <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240776967">(May 30 2021 at 22:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Group.20cohomology/near/240735853">said</a>:</p>
<blockquote>
<p>The point of <a href="https://github.com/leanprover-community/mathlib/issues/7486">#7486</a> (projective resolutions) <a href="https://github.com/leanprover-community/mathlib/issues/7487">#7487</a> (derived functors) and <a href="https://github.com/leanprover-community/mathlib/issues/7525">#7525</a> (Ext) is to provide you with a single "chosen" <code>left_derived n F</code>, for each functor <code>F</code>, and also to provide the API so you can bring your own favourite resolution, and know that <code>(left_derived n F).obj X</code> is isomorphic to the n-th homology of <code>F</code> applied to that resolution.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> what Scott said here sounds like what's needed in the usual pen-and-paper maths construction of LES-from-SES for group cohomology. I remember inhomogeneous cocycles/coboundaries being very confusing, though great for computation, and I don't know much about the homogeneous ones. I also only know Inf-Res for <code>H^1</code>, and it always seemed quite strange to me because somehow it's about cohomologies in three different abelian categories rather than one. I don't know enough category theory to see this in a nice way.</p>



<a name="240871086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240871086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240871086">(May 31 2021 at 21:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, I think <code>finsupp.equiv_congr</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.dom_congr">docs#finsupp.dom_congr</a>.</p>



<a name="240871146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240871146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240871146">(May 31 2021 at 21:07)</a>:</h4>
<p><code>dom_congr</code> also only works for <code>add_comm_monoid</code>s</p>



<a name="240871338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240871338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240871338">(May 31 2021 at 21:10)</a>:</h4>
<p>It's also badly named since the similar defs use <code>domain</code> instead of <code>dom</code></p>



<a name="240872440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240872440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240872440">(May 31 2021 at 21:24)</a>:</h4>
<p>The definitions in <code>equiv</code> call this <code>congr_left</code></p>



<a name="240876456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/240876456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#240876456">(May 31 2021 at 22:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.Pi_congr_left">docs#equiv.Pi_congr_left</a>?</p>



<a name="241430418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/241430418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#241430418">(Jun 03 2021 at 18:10)</a>:</h4>
<p>I'm a few days late to the party, but staring at this type</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">cochain_succ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_apply'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">),</span> <span class="n">s</span> <span class="bp">•</span> <span class="n">to_fun</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>
<p>and thinking about <span class="user-mention" data-user-id="110087">@Scott Morrison</span>'s suggestion about <code>distrib_mul_action</code>, it seems like if you were to generalize <code>fin n → G</code> to an arbitrary <code>G</code>-module <code>N</code>, then this is exactly the definition of the type of <code>G</code>-module homomorphisms <code>N → M</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group_action_hom</span>
<span class="kn">import</span> <span class="n">algebra.module.pi</span>

<span class="kd">universes</span> <span class="n">uG</span> <span class="n">uM</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uG</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uM</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">abbreviation</span> <span class="n">cochain_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="bp">→</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">M</span>
</code></pre></div>
<p>For my own education, I tried updating <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s implementation of <code>d</code> to use this type, hoping there was enough automatic stuff in mathlib already.  There were some missing instances and simp lemmas, but it wasn't so bad:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group_action_hom</span>
<span class="kn">import</span> <span class="n">algebra.module.pi</span>
<span class="kn">import</span> <span class="n">data.fin</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">uG</span> <span class="n">uM</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uG</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uM</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">abbreviation</span> <span class="n">cochain_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="bp">→</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">M</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">S</span> <span class="bp">→</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">b</span> <span class="n">s</span><span class="o">,</span>
                  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">c</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
            <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">c</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="bp">-</span><span class="n">a</span> <span class="n">s</span><span class="o">,</span>
                <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">c</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">add_comm</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">zero_add</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">add_zero</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">ext</span><span class="o">,</span> <span class="n">apply</span> <span class="n">add_left_neg</span><span class="o">,</span> <span class="kd">end</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">ev_zero</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mul_action_hom.coe_eta_ev</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">ax</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">mul_action_hom.mk</span> <span class="n">f</span> <span class="n">ax</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mul_action_hom.add_ev</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- Copied from data.fin_simplicial_complex to make this code block self contained.</span>
<span class="kn">namespace</span> <span class="n">fin</span>
<span class="sd">/-- The function denoted `δᵖ` by Riehl-Verity, sending`t` to `t` if `t&lt;p` and</span>
<span class="sd">  `t.succ` otherwise.`-/</span>
<span class="kd">def</span> <span class="n">delta</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">j</span> <span class="o">:=</span>
<span class="c1">-- fin.succ_above expects p : fin i.succ for some reason</span>
<span class="o">⟨</span><span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="k">then</span> <span class="n">t</span> <span class="k">else</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">hj</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">t</span> <span class="k">with</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">ht.trans</span> <span class="o">(</span><span class="n">nat.lt_succ_self</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">nat.succ_lt_succ</span> <span class="n">ht</span> <span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">delta_eval</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">delta</span> <span class="n">hj</span> <span class="n">p</span> <span class="n">t</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="k">then</span> <span class="n">t</span> <span class="k">else</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">delta_comm_apply</span>  <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">j.succ</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hpq</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">delta</span> <span class="n">hk</span> <span class="n">q.succ</span> <span class="o">(</span><span class="n">delta</span> <span class="n">hj</span> <span class="n">p</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">delta</span> <span class="n">hk</span> <span class="n">p</span> <span class="o">(</span><span class="n">delta</span> <span class="n">hj</span> <span class="n">q</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">hk</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">hj</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">t</span> <span class="k">with</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">delta_eval</span><span class="o">],</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">split_ifs</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat.succ_eq_add_one</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span><span class="n">push_neg</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat.succ_eq_add_one</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span><span class="n">linarith</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">delta_comm_apply.symm</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">j.succ</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="n">q_succ</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hpq</span> <span class="o">:</span> <span class="n">q_succ</span> <span class="bp">≤</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">delta</span> <span class="n">hk</span> <span class="n">p.succ</span> <span class="o">(</span><span class="n">delta</span> <span class="n">hj</span> <span class="n">q_succ</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">delta</span> <span class="n">hk</span> <span class="n">q_succ</span> <span class="o">(</span><span class="n">delta</span> <span class="n">hj</span> <span class="n">p</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">delta_comm_apply</span> <span class="n">hj</span> <span class="n">hk</span> <span class="n">hpq</span> <span class="n">t</span>

<span class="kd">end</span> <span class="n">fin</span>

<span class="kd">def</span> <span class="n">d</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hj</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">cochain_succ</span> <span class="n">G</span> <span class="n">M</span> <span class="n">i</span> <span class="bp">→+</span> <span class="n">cochain_succ</span> <span class="n">G</span> <span class="n">M</span> <span class="n">j</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.range</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span><span class="bp">^</span><span class="n">p</span> <span class="bp">•</span> <span class="n">c</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">fin.delta</span> <span class="n">hj</span> <span class="n">p</span> <span class="n">t</span><span class="o">)),</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span> <span class="n">g</span><span class="o">,</span> <span class="kd">begin</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finset.smul_sum</span><span class="o">],</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">congr</span><span class="o">,</span>
      <span class="n">ext</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">mul_action_hom.map_smul</span><span class="o">,</span>
      <span class="n">congr</span><span class="o">,</span>
    <span class="kd">end</span> <span class="o">},</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">smul_add</span><span class="o">,</span> <span class="n">finset.sum_add_distrib</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
</div></div>
<p>I don't know if it's worth it, but that type is equivalent to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">cochain_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free_abelian_group</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="bp">→</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">M</span>
</code></pre></div>
<p>and then <code>d</code> comes from dualizing the chain complex of <code>free_abelian_group (fin n → G)</code> groups, which is essentially what others have already said.  It might be worth factoring it like this if someone wanted to do group homology, too, but it seems like in the short term it would be work to develop the API for <code>G</code>-module homomorphisms from free abelian groups without any real payoff, assuming it doesn't already exist somewhere.</p>



<a name="241431270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/241431270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#241431270">(Jun 03 2021 at 18:17)</a>:</h4>
<p>Note also that you don't need to take a free abelian group of anything, by the universal property of the free abelian group... It's just G-equivariant functions from n-tuples in G to N.</p>



<a name="241431461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/241431461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#241431461">(Jun 03 2021 at 18:18)</a>:</h4>
<p>Oh sorry that's exactly what you wrote in the spoiler, Kyle <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="241431537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/241431537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#241431537">(Jun 03 2021 at 18:19)</a>:</h4>
<p>Anyway, this is already essentially the simplicial approach I was hoping for above.</p>



<a name="241432095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/241432095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#241432095">(Jun 03 2021 at 18:23)</a>:</h4>
<p>For group homology you can replace functions with finsupp, and still avoid free abelian groups</p>



<a name="241434989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/241434989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#241434989">(Jun 03 2021 at 18:46)</a>:</h4>
<p>Oh, and I just noticed Reid’s comment about <code>EG/G</code> from 2019…</p>



<a name="268753639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268753639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268753639">(Jan 20 2022 at 20:35)</a>:</h4>
<p>I have a bunch of files showing that the explicit description of group cohomology in terms of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mi>G</mi><mi>n</mi></msup><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Fun(G^n, M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> is the same as Ext.<br>
At some point while writing them I learned about delta functors and checked out the work on them &amp; LES's in LTE. I got worried that my files are redundant and I should've been making the LTE stuff PR'able instead.<br>
But I'm thinking there'd be a lot more work to do after that; stuff about universal delta functors would give you a correspondence with the right derived functors of the left exact functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mi>G</mi></msup></mrow><annotation encoding="application/x-tex">M^G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">G</span></span></span></span></span></span></span></span></span></span></span>, and that's not what you want, really, because the cocycles etc in terms of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mi>G</mi><mi>n</mi></msup><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Fun(G^n, M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> "come from" a projective resolution. So you'd need balancing of Ext or something, too, which seems like it might be hard.<br>
So if I am thinking straight, I am hoping my work is still worth PR'ing. But I wanted to check.<br>
Many thanks!</p>



<a name="268754012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268754012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268754012">(Jan 20 2022 at 20:38)</a>:</h4>
<p>I think it's certainly worthwhile to have an explicit projective resolution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> as a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>-module (with the trivial action) in terms of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mi>G</mi><mi>n</mi></msup><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Fun(G^n,M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> (which is essentially what the whole (in)homogeneous cocycle definition is all about).</p>



<a name="268754090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268754090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268754090">(Jan 20 2022 at 20:39)</a>:</h4>
<p>That's the easiest way I know of showing, for example, that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^1(G,A) = Hom(G,A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> has a trivial action, relating <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^2(G,M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> to extensions, etc.</p>



<a name="268754237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268754237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268754237">(Jan 20 2022 at 20:40)</a>:</h4>
<p>We should have the ability to "compute" Ext groups in terms of an explicit projective resolution (at least eventually).</p>



<a name="268754369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268754369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268754369">(Jan 20 2022 at 20:41)</a>:</h4>
<p>Fair play. Thank you!</p>



<a name="268755137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268755137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268755137">(Jan 20 2022 at 20:47)</a>:</h4>
<p><span class="user-mention" data-user-id="118107">@Amelia Livingston</span> do you think it might be worthwhile to generalize a bit, and obtain a projective resolution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> as a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span>-module where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is any commutative ring?</p>



<a name="268756026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/268756026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#268756026">(Jan 20 2022 at 20:54)</a>:</h4>
<p>Sure - I wasn't sure whether to do this. Could we just tensor by A instead?</p>



<a name="284790295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/284790295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#284790295">(Jun 02 2022 at 19:06)</a>:</h4>
<p>Hello - I want to open another PR for my group cohomology stuff; I'm not sure of the future of <a href="https://github.com/leanprover-community/mathlib/pull/14308">my current one</a> because it could be done in better generality, as can be seen <a href="https://github.com/leanprover-community/mathlib/pull/14372">here</a>.<br>
I decided the complex of inhomogeneous cochains would be the best place to start right now. Would this be ok? And for the proof that d^2 = 0, should I make use of <a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebraic_topology/alternating_face_map_complex.lean">this</a> (except I need the cochain version)?  </p>
<p>Next PR after that could be some API for the cohomology in low degree, or the isomorphism of the complex of inhomog cochains with Hom(-, M) of a projective resolution. Also have a little file with Hilbert 90 in which doesn't technically rely on anything else.</p>



<a name="284940448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/284940448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#284940448">(Jun 03 2022 at 22:36)</a>:</h4>
<p>There are certainly different ways to do this. An approach could be to construct a resolution of <code>A</code> as an <code>A[G]</code>-module by starting from the construction of <code>EG</code> (which is a simplicial object in the category of <code>G</code>-sets). This could be done directly, or as a particular case of <code>algebraic_topology.cech_nerve</code> (applied to the map from the tautological <code>G</code>-set <code>G</code> to the terminal object); alternatively, this is also the nerve (now in mathlib) of a specific category. Then, the free <code>A</code>-module functor from sets to <code>A</code>-modules can be transformed into a functor <code>F</code> from <code>G</code>-sets to <code>A</code>-modules equipped with a <code>G</code>-action (i.e. <code>A[G]</code>-modules). Applying this functor <code>F</code> termwise gives a functor from simplicial <code>G</code>-sets to simplicial <code>A[G]</code>-modules. Applying this to <code>EG</code>, we get a certain simplicial <code>A[G]</code>-module, which we may denote <code>A[EG]</code>, and then take the alternate face map complex attached to <code>A[EG]</code>, which is a complex of <code>A[G]</code>-modules: it is a projective resolution of <code>A</code> as a <code>A[G]</code>-module. Using this resolution to compute Ext and by doing computations in appropriate bases, it should be possible to identify the differential to the usual differential on the usual cochain complex which computes group cohomology. (Note that I have not used cosimplicial objects, only simplicial objets! Even though at some point the alternate <em>co</em>face map complex should also be formalised.)</p>
<p>In this way, the explicit formulas for the differentials on the cochains would appear as a computation rather than as a definition, and it would save the penance of checking <code>d^2=0</code>.</p>
<p>However, I have skipped the details of some important step, which is why it is so that <code>A[EG]</code> is homotopic to <code>A</code> (in degree 0) <em>when we forget the action of <code>G</code></em>. There are various ways to do that. The most direct approach I see would be to use an argument which appears in Goerss-Jardine, <em>Simplicial Homotopy Theory</em>, p. 190. (It is basically a sufficient condition for a simplicial set to be homotopy equivalent to a discrete set, and this condition of "having an extra degeneracy" is preserved when we apply the free <code>A</code>-module functor, and in the case of additive categories, the condition gives a chain complex homotopy. I could certainly help implementing this part.)</p>



<a name="285026889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285026889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285026889">(Jun 05 2022 at 09:18)</a>:</h4>
<p>I am still unproud to say that we have 0 cohomology theories in mathlib, although we're clearly getting close, and my instinct would be to choose the path of least resistance, which would be homogeneous cochains, where d^2=0 is pretty easy, so they are in my view the shortest route to an actual definition of an object <code>group_cohomolology.H n G M</code> which we can then actually say exists. The moment we have existence, we can go on to prove that this object is all the other objects which we also call group cohomology, e.g. unhomogeneous cocycles/coboundaries, singular cohomology of these exotic spaces, derived functor cohomology etc, and opening the door to explicit computations in low degree such as "the answer to this question in group theory/field theory is an H^1" or "this theorem says that H^1 vanishes". Right now we can't do any of this stuff because we have no definition.</p>
<p><span class="user-mention" data-user-id="118107">@Amelia Livingston</span> Shenyang Wu developed group cohomology using unhomogeneous cocycles <a href="https://github.com/Shenyang1995/M4R">here</a> and d^2=0 was painful. That's why I'm suggesting homogeneous cocycles.</p>



<a name="285034837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285034837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285034837">(Jun 05 2022 at 12:39)</a>:</h4>
<p>The model I suggested using the simplicial <code>G</code>-set <code>EG</code> gives exactly the homogeneous cochains! The <code>n</code>-simplices of <code>EG</code> are elements of <code>G^{n+1}</code> equipped with the obvious action of <code>G</code>. In <code>mathlib</code> terms, these are just <code>fin (n+1) → G</code>. Then, we need the free <code>A</code>-module functor, as a functor <code>F</code> from <code>G-sets</code> to <code>A[G]-modules</code>. Applying <code>F</code> to <code>EG</code> gives a simplicial <code>A[G]-module</code> whose alternate face map complex is the projective resolution of <code>A</code> which allows us to compute <code>Ext</code> as homogeneous cochains. That it is a complex of projective modules comes from the fact that <code>F</code> of a <code>free G-set</code> is a free <code>A[G]-module</code>. That it is a resolution follows that the argument I mentionned from the book by Goerss-Jardine. (Comparison with inhomogeneous cochains would presumably correspond to a particular choice of basis...)</p>



<a name="285040777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285040777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285040777">(Jun 05 2022 at 15:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459699">Joël Riou</span> <a href="#narrow/stream/116395-maths/topic/Group.20cohomology/near/285034837">said</a>:</p>
<blockquote>
<p>Comparison with inhomogeneous cochains would presumably correspond to a particular choice of basis...</p>
</blockquote>
<p>If I remember correctly, if homogeneous cochains correspond to putting group elements at the vertices of simplices, then inhomogeneous cochains correspond to putting group elements along the spine of a simplex (the edges 0-&gt;1, 1-&gt;2, ..., n-1-&gt;n). Then, given a choice <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> and an inhomogeneous cochain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g_1,\dots,g_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, one can get a homogeneous cochain by "integrating", getting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>g</mi><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>g</mi><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>g</mi><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><mo>…</mo><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g,gg_1,gg_1g_2,\dots,gg_1g_2\dots g_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. Inhomogeneous cochains factor out the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> action, sort of pre-quotienting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">EG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">EG</span></span></span></span> to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">BG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">BG</span></span></span></span>, and each choice of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> gives a different lift of a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">BG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">BG</span></span></span></span> simplex to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">EG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">EG</span></span></span></span>.</p>



<a name="285129273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285129273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285129273">(Jun 06 2022 at 15:42)</a>:</h4>
<p>In a draft branch <a href="https://github.com/leanprover-community/mathlib/blob/extra_degeneracy/src/algebraic_topology/extra_degeneracy.lean">https://github.com/leanprover-community/mathlib/blob/extra_degeneracy/src/algebraic_topology/extra_degeneracy.lean</a> I have formalised the notion of extra degeneracy for an augmented simplicial object. The main definitions are</p>
<ul>
<li>the structure <code>extra_degeneracy X</code> for any <code>X : simplicial_object.augmented C</code></li>
<li>
<p><code>extra_degeneracy.map</code>: extra degeneracies are preserved by the application of any<br>
functor <code>C ⥤ D</code></p>
</li>
<li>
<p><code>extra_degeneracy.for_cech_nerve_of_split_epi</code>: the augmented Čech nerve of a split<br>
epimorphism has an extra degeneracy</p>
</li>
<li>
<p><code>extra_degeneracy.preadditive.homotopy_equivalence</code>: when the category <code>C</code> is<br>
preadditive and has a zero object, and <code>X : simplicial_object.augmented C</code> has an extra<br>
degeneracy, then the augmentation <code>alternating_face_map_complex.ε.app X</code> is a homotopy<br>
equivalence of chain complexes</p>
</li>
</ul>
<p>Using this, one may easily get that <code>A[EG]</code> is a resolution of <code>A</code> as an <code>A</code>-module. Taking into account the <code>A[G]</code>-modules structures, one may deduce that <code>A[EG]</code> is a (projective) resolution of <code>A</code> as an <code>A[G]</code>-module, and then that the homogeneous cochains can be used to compute <code>Ext</code> groups.</p>



<a name="285141323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285141323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285141323">(Jun 06 2022 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="118107">@Amelia Livingston</span> After more thinking, it seems that as you suggested, you may need the dual version of the functor <code>alternating_face_map_complex</code>. It should be easy to define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alternating_coface_map_complex</span> <span class="o">:</span> <span class="n">cosimplicial_object</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">cochain_complex</span> <span class="n">C</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>by using <code>alternating_face_map_complex</code> for the opposite category and the duality equivalences for simplicial objects or functors (in mathlib) and for homological complexes (it seems that <code>homological_complex.op_equivalence {ι : Type*} (c : complex_shape ι) : (homological_complex Cᵒᵖ c)ᵒᵖ ≌ homological_complex C c.symm</code> is not in mathlib yet).</p>
<p>Then, in order to get the homogeneous cochain complex, you would have to define a cosimplicial <code>A</code>-module attached to any <code>A[G]</code>-module <code>M</code> by sending the integer <code>(n : simplex_category)</code> to <code>G</code>-equivariant maps <code>(fin (n+1) → G) → M</code>, and apply <code>alternating_coface_map_complex</code>. Definitionally speaking, this might be better than using <code>cech_nerve</code> (which would involve taking <code>wide_pullbacks</code> of <code>n+1</code> copies to the map <code>G → *</code>. The machinery I have suggested above would then enable us to do a comparison with Ext groups in the category of <code>A[G]</code>-modules.</p>



<a name="285143304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285143304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285143304">(Jun 06 2022 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459699">Joël Riou</span> <a href="#narrow/stream/116395-maths/topic/Group.20cohomology/near/285141323">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="118107">Amelia Livingston</span> After more thinking, it seems that as you suggested, you may need the dual version of the functor <code>alternating_face_map_complex</code>. It should be easy to define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alternating_coface_map_complex</span> <span class="o">:</span> <span class="n">cosimplicial_object</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">cochain_complex</span> <span class="n">C</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>by using <code>alternating_face_map_complex</code> for the opposite category and the duality equivalences for simplicial objects or functors (in mathlib) and for homological complexes (it seems that <code>homological_complex.op_equivalence {ι : Type*} (c : complex_shape ι) : (homological_complex Cᵒᵖ c)ᵒᵖ ≌ homological_complex C c.symm</code> is not in mathlib yet).</p>
</blockquote>
<p>This is done in LTE: <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_op.lean">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_op.lean</a><br>
Feel free to copy it elsewhere (eg mathlib).</p>



<a name="285143395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285143395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285143395">(Jun 06 2022 at 17:23)</a>:</h4>
<p>Also, <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean</a> contains that coface cochain complex.</p>



<a name="285144723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285144723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285144723">(Jun 06 2022 at 17:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Group.20cohomology/near/285143395">said</a>:</p>
<blockquote>
<p>Also, <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean</a> contains that coface cochain complex.</p>
</blockquote>
<p>It is nice that the dualisation of homological complexes is in LTE <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span><br>
As the <code>alternating_face_map_complex</code>functor  is already in <code>mathlib</code>, I would suggest not duplicating all the definitions and proofs (as it is done for limits/colimits, projectives/injectives), but rather obtain the <em>co</em>face version by dualising the functor <code>alternating_face_map_complex</code> and stating an appropriate simp lemma for the calculation of the differential (which may not be a definitional equality ?).</p>



<a name="285145202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285145202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285145202">(Jun 06 2022 at 17:39)</a>:</h4>
<p>I did that for <code>coboundary</code>. So the fact that <code>d² = 0</code> is deduced from the other version.</p>



<a name="285145219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285145219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285145219">(Jun 06 2022 at 17:39)</a>:</h4>
<p>But it can probably be optimised a bit.</p>



<a name="285145374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285145374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285145374">(Jun 06 2022 at 17:40)</a>:</h4>
<p>In fact, I think both versions should be refactored: every (co)simplicial object in <code>C</code> should give rise to a (co)chain complex in <code>free ℤ C</code> (the category with the same objects as <code>C</code>, but all the homsets replaced by their freely-generated ab groups).</p>



<a name="285208183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285208183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285208183">(Jun 07 2022 at 06:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Group.20cohomology/near/285145374">said</a>:</p>
<blockquote>
<p>In fact, I think both versions should be refactored: every (co)simplicial object in <code>C</code> should give rise to a (co)chain complex in <code>free ℤ C</code> (the category with the same objects as <code>C</code>, but all the homsets replaced by their freely-generated ab groups).</p>
</blockquote>
<p>I do not think so, because the construction you describe can be very easily deduced from the existing one: <code>whisker</code> your (co)simplicial object in <code>C</code> with the functor <code>C ⥤ free ℤ C</code> and then apply the alternating (co)face map complex functor.</p>



<a name="285228141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/285228141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#285228141">(Jun 07 2022 at 10:06)</a>:</h4>
<p>I have just PRed <a href="https://github.com/leanprover-community/mathlib/pull/14588">#14588</a> the definition of the alternating coface map complex.</p>



<a name="290503272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Group%20cohomology/near/290503272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Group.20cohomology.html#290503272">(Jul 22 2022 at 13:05)</a>:</h4>
<p>The definition of the alternating coface map complex is now in mathlib.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
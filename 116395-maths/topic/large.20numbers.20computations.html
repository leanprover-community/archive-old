---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/large.20numbers.20computations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html">large numbers computations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="304453379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304453379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304453379">(Oct 17 2022 at 12:54)</a>:</h4>
<p>Are there tactics to deal with goals like <code>10 ^ 18 &lt; 3618502788666131213697322783095070105623107215331596699973092056135872020483</code>?</p>



<a name="304454000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304454000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304454000">(Oct 17 2022 at 12:57)</a>:</h4>
<p><code>norm_num</code> is quite fast for me on this precise example</p>



<a name="304456316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304456316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304456316">(Oct 17 2022 at 13:08)</a>:</h4>
<p>Thanks!</p>



<a name="304456357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304456357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304456357">(Oct 17 2022 at 13:08)</a>:</h4>
<p>Do we have a fast prime checker as well?</p>



<a name="304457610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304457610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304457610">(Oct 17 2022 at 13:15)</a>:</h4>
<p>This is really non trivial, right? I mean, even Pari/GP, or similar software, is very fast because it checks psudoprimality</p>



<a name="304457963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304457963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304457963">(Oct 17 2022 at 13:17)</a>:</h4>
<p>We'll, no one ever really implements AKS, but PRIMES is in P.</p>



<a name="304458492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304458492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304458492">(Oct 17 2022 at 13:20)</a>:</h4>
<p>Sure, but AFAIK AKS is totally useless in practice. I think that in practice if one as primality certificate (given by Pari or whatever) it shouldn't be too hard to formalize primality in Lean. But of course asking Lean to find the certificate is different.</p>



<a name="304459206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304459206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304459206">(Oct 17 2022 at 13:23)</a>:</h4>
<p>Sure would be good to have a decision procedure that's at least faster than just brute force</p>



<a name="304459659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304459659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304459659">(Oct 17 2022 at 13:26)</a>:</h4>
<p><code>norm_num</code> also knows about primes, so you can use it, but it is not very fast.</p>



<a name="304460233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304460233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304460233">(Oct 17 2022 at 13:29)</a>:</h4>
<p>On the other hand we have a good implementation of the Jacobi symbol, so checking for example if <code>2</code>, <code>3</code> and <code>5</code> (say) are witness of nonprimality should be fast. And this is already a good pseudoprimality test.</p>



<a name="304461046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304461046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304461046">(Oct 17 2022 at 13:33)</a>:</h4>
<p>Especially if one implements Miller-Rabin rather than Solovay–Strassen. According to <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Testing_against_small_sets_of_bases">Wikipedia</a>, <code>2</code>, <code>3</code> and <code>5</code> are enough up to <code>25326001</code>.</p>



<a name="304463557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304463557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304463557">(Oct 17 2022 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/304461046">said</a>:</p>
<blockquote>
<p>Especially if one implements Miller-Rabin rather than Solovay–Strassen. According to <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Testing_against_small_sets_of_bases">Wikipedia</a>, <code>2</code>, <code>3</code> and <code>5</code> are enough up to <code>25326001</code>.</p>
</blockquote>
<p>sure, but then we have to prove that it's enough :)</p>



<a name="304463702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304463702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304463702">(Oct 17 2022 at 13:44)</a>:</h4>
<p>we do have lucas lehmer if you want a mersenne prime though!</p>



<a name="304465000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304465000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304465000">(Oct 17 2022 at 13:50)</a>:</h4>
<p>Yes, I was talking about psuedoprimality. If we want primality I am more or less sure the best we can do is prove that something like a <a href="https://en.wikipedia.org/wiki/Primality_certificate#Pratt_certificates">Pratt certificate</a> implies primality (this is surely almost already in mathlib) and then use something else to find the witness.</p>



<a name="304465083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304465083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304465083">(Oct 17 2022 at 13:51)</a>:</h4>
<p>Like what <code>polyrith</code> does</p>



<a name="304465658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304465658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304465658">(Oct 17 2022 at 13:53)</a>:</h4>
<p>ah, that's a good idea. indeed we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/lucas_primality">docs#lucas_primality</a>; in Lean4 I imagine this can be done quite fast</p>



<a name="304465690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304465690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304465690">(Oct 17 2022 at 13:53)</a>:</h4>
<p>maybe with some cached tactics too</p>



<a name="304666130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304666130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304666130">(Oct 18 2022 at 12:19)</a>:</h4>
<p>ECPP prime certificates would be an alternative. Might be a fun project to see what mathematics about elliptic curves is missing to implement a checker</p>



<a name="304900476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304900476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304900476">(Oct 19 2022 at 08:13)</a>:</h4>
<p>Hasse's theorem seems to be the main result it relies on</p>



<a name="304911923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304911923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304911923">(Oct 19 2022 at 09:26)</a>:</h4>
<p>We can't even prove the points form a group. There is a low-level proof of Hasse's theorem due to Manin I think, but only valid in characteristic &gt;= 5 IIRC</p>



<a name="304948918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304948918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304948918">(Oct 19 2022 at 12:54)</a>:</h4>
<p>Well characteristic &gt;= 5 would be enough for the primality check, but it's probably better to go a high-level way and build a good library of elliptic curves first</p>



<a name="304965350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304965350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304965350">(Oct 19 2022 at 14:16)</a>:</h4>
<p>I tried writing a verifier using norm_num and Pratt certificates, the summary was essentially that it works but doesn't seem to be much better than what norm_num already does - in particular it gets a bit further before timing out but not significantly so</p>



<a name="304965808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/304965808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#304965808">(Oct 19 2022 at 14:18)</a>:</h4>
<p>Even using Pratt certificates recursively? I mean, to prove that all the factors are prime.</p>



<a name="305040810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305040810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305040810">(Oct 19 2022 at 20:55)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>  does it at least work for primes like <code>15 * 2^27 + 1</code>? It would be convenient for a project I'm working on to verify this prime in particular.</p>



<a name="305050636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305050636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305050636">(Oct 19 2022 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/304965808">said</a>:</p>
<blockquote>
<p>Even using Pratt certificates recursively? I mean, to prove that all the factors are prime.</p>
</blockquote>
<p>Yes!</p>



<a name="305050696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305050696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305050696">(Oct 19 2022 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/305040810">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span>  does it at least work for primes like <code>15 * 2^27 + 1</code>? It would be convenient for a project I'm working on to verify this prime in particular.</p>
</blockquote>
<p>I will check</p>



<a name="305055034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305055034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305055034">(Oct 19 2022 at 22:54)</a>:</h4>
<p>Another comment on primality testing, obviously there are several different approaches - brute force calculation, Pratt certificates, AKS, and all of these are going to have different performance on different number sizes (this is yet another thing that was <a href="#narrow/stream/113488-general/topic/norm_num.20for.20real.20exponentiation/near/249615218">first pointed out to me</a> by <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ). It would be cool if we could eventually have a primality tester that selectively applies different tests based on the size of the number being proven, in the same way that big-integer multiplication libraries use different algorithms on different sizes of integers.</p>



<a name="305109155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305109155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305109155">(Oct 20 2022 at 09:17)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> I don't really get why it should be that slow? Because the modulo calculations are?</p>



<a name="305115601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305115601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305115601">(Oct 20 2022 at 10:02)</a>:</h4>
<p>One factor to bear in mind is that in computation, Pratt certificates are an improvement because you replace many divisions in the trial division algorithm with multiplication and powmod operations. But when verifying, the cost of a natural division is practically the same as a multiplication, since a proof of division amounts to an inequality proof, addition proof and multiplication proof. So the usual benefit from Pratt certificates is lessened greatly</p>



<a name="305142474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305142474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305142474">(Oct 20 2022 at 12:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/305040810">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span>  does it at least work for primes like <code>15 * 2^27 + 1</code>? It would be convenient for a project I'm working on to verify this prime in particular.</p>
</blockquote>
<p>This number is not that big. It would be sad if we're not able to prove it's prime...</p>



<a name="305144166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305144166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305144166">(Oct 20 2022 at 12:57)</a>:</h4>
<p>If you really want this specific number I don't see any problem. I just tested and <code>norm_num</code> is able to compute <code>31^15</code>, then one only have to take squares (I hope not by hand...).  The prime factors of <code>p-1</code> are super small so exploiting the condition <code>nat.prime q → q ∣ p - 1</code> is probably easy (one may need a general result here, unrelated to this number).</p>



<a name="305144738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305144738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305144738">(Oct 20 2022 at 13:00)</a>:</h4>
<p>I think it's more helpful to prove <a href="https://leanprover-community.github.io/mathlib_docs/find/lucas_primality">docs#lucas_primality</a> using  <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.factorization">docs#nat.factorization</a></p>



<a name="305152026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305152026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305152026">(Oct 20 2022 at 13:40)</a>:</h4>
<p>Is <a href="https://en.wikipedia.org/wiki/Proth%27s_theorem">https://en.wikipedia.org/wiki/Proth%27s_theorem</a> the general result you are thinking of?</p>



<a name="305152294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305152294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305152294">(Oct 20 2022 at 13:41)</a>:</h4>
<p>Ah, this is even better, but I was just thinking that if <code>3*5*2^27 = n</code> then we know all prime factors of <code>n</code>.</p>



<a name="305209226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305209226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305209226">(Oct 20 2022 at 18:10)</a>:</h4>
<p>Unfortunately, <code>norm_num</code> times out on the goal <code>2 ^ (2 ^ 27 * 15) = 1</code> in <code>zmod (2 ^ 27 * 15 + 1)</code>. I think the issue is that exponentiation was not performant. Mario gave us a definition to get around this when we were working on Miller-Rabin (unfortunately that branch has been left hanging for a while, I don't have time to finish it up) </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">binpow</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">nat.binary_rec</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">_</span> <span class="n">ih</span><span class="o">,</span> <span class="k">let</span> <span class="n">ih2</span> <span class="o">:=</span> <span class="n">ih</span> <span class="bp">*</span> <span class="n">ih</span> <span class="k">in</span> <span class="n">cond</span> <span class="n">b</span> <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">ih2</span><span class="o">)</span> <span class="n">ih2</span><span class="o">)</span>
</code></pre></div>



<a name="305210504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305210504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305210504">(Oct 20 2022 at 18:17)</a>:</h4>
<p>I think you can do it using <code>pow_mul</code>, helping Lean a little bit.</p>



<a name="305210643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305210643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305210643">(Oct 20 2022 at 18:17)</a>:</h4>
<p>This is of course not the right way of doing it, but a least it should work in this precise case.</p>



<a name="305229746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305229746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305229746">(Oct 20 2022 at 20:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282271">Bolton Bailey</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/305209226">said</a>:</p>
<blockquote>
<p>Unfortunately, <code>norm_num</code> times out on the goal <code>2 ^ (2 ^ 27 * 15) = 1</code> in <code>zmod (2 ^ 27 * 15 + 1)</code>. I think the issue is that exponentiation was not performant. Mario gave us a definition to get around this when we were working on Miller-Rabin (unfortunately that branch has been left hanging for a while, I don't have time to finish it up) </p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">binpow</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">nat.binary_rec</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">_</span> <span class="n">ih</span><span class="o">,</span> <span class="k">let</span> <span class="n">ih2</span> <span class="o">:=</span> <span class="n">ih</span> <span class="bp">*</span> <span class="n">ih</span> <span class="k">in</span> <span class="n">cond</span> <span class="n">b</span> <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">ih2</span><span class="o">)</span> <span class="n">ih2</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Yes, the first thing I did when trying to verify using Pratt certificates was convince norm_num to do efficient modular exponentiation</p>



<a name="305234663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305234663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305234663">(Oct 20 2022 at 20:44)</a>:</h4>
<p><span class="user-mention" data-user-id="282271">@Bolton Bailey</span> update: I can prove that number is prime, and it's relatively fast - around 5 seconds</p>



<a name="305234766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305234766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305234766">(Oct 20 2022 at 20:45)</a>:</h4>
<p>Hehe, sweet!</p>



<a name="305234952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305234952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305234952">(Oct 20 2022 at 20:46)</a>:</h4>
<p>Is the proof fully automatic, or do you need to hand-solve some goals?</p>



<a name="305235005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305235005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305235005">(Oct 20 2022 at 20:46)</a>:</h4>
<p>bad news is that the original setup I had to do primes in general was pretty dodgy - I adapted it from <a href="https://www.isa-afp.org/browser_info/current/AFP/Pratt_Certificate/outline.pdf">https://www.isa-afp.org/browser_info/current/AFP/Pratt_Certificate/outline.pdf</a>, namely rules 1 and 2 from page 2, and it seems to be really inefficient in the case of a prime factor appearing multiple times (unsure if this is from the isabelle version or my translation of it)</p>



<a name="305235143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305235143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305235143">(Oct 20 2022 at 20:47)</a>:</h4>
<p>The proof is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">second_bit</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">nat.factors</span> <span class="o">(</span><span class="mi">15</span> <span class="bp">*</span> <span class="mi">2</span><span class="bp">^</span><span class="mi">27</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">norm_num</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">boltons_prime</span> <span class="o">:</span> <span class="n">prime</span> <span class="o">(</span><span class="mi">15</span> <span class="bp">*</span> <span class="mi">2</span><span class="bp">^</span><span class="mi">27</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">pratt_rule_2'</span> <span class="mi">31</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pratt_predicate</span><span class="o">,</span> <span class="n">second_bit</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span> <span class="n">forall_eq</span><span class="o">],</span>
  <span class="n">change</span> <span class="n">my_pow_mod</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">my_pow_mod</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">my_pow_mod</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>with about 100 lines of other stuff before it which I'd written a few months ago</p>



<a name="305235260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305235260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305235260">(Oct 20 2022 at 20:48)</a>:</h4>
<p>what I have right now definitely isn't correctly designed to be usable, which is why I haven't tried to PR it anywhere!</p>



<a name="305235697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305235697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305235697">(Oct 20 2022 at 20:51)</a>:</h4>
<p>Still, very cool to have primality proofs for cryptographically important primes.</p>



<a name="305236189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305236189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305236189">(Oct 20 2022 at 20:54)</a>:</h4>
<p>Thought about it a bit more, and the problem with what I had originally is precisely in the case where a prime factor q of p-1 has high multiplicity - the isabelle pratt certificate (and hence mine) do k powmod calculations if q^k | p-1, but it should be enough to only do 1 for each prime</p>



<a name="305236248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305236248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305236248">(Oct 20 2022 at 20:54)</a>:</h4>
<p>(So my original attempt for your prime timed out, but the modified version above is shorter and doesn't time out!)</p>



<a name="305236705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305236705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305236705">(Oct 20 2022 at 20:57)</a>:</h4>
<p>Here are the (average of 1) benchmarks for the four primes I've tested: 199999 takes 2s, 2013265921 (Bolton's prime) takes 3s, 1000000007 takes 5s (despite being smaller than Bolton's prime - maybe because this has the multiplicity problem) and 23509285402367 times out very early</p>



<a name="305236852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305236852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305236852">(Oct 20 2022 at 20:58)</a>:</h4>
<p>The "Goldilocks prime" <code>2^64 -2^32 + 1</code> is another prime people often use for the convenient hardware properties, which is one more than <code>18446744069414584320 = 2^32×3×5×17×257×65537</code>. I imagine your approach be able to prove this relatively quickly as well?</p>



<a name="305237454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305237454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305237454">(Oct 20 2022 at 21:02)</a>:</h4>
<p>Do those numbers include finding the certificate?</p>



<a name="305237537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305237537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305237537">(Oct 20 2022 at 21:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/305237454">said</a>:</p>
<blockquote>
<p>Do those numbers include finding the certificate?</p>
</blockquote>
<p>No, I found the primitive root <code>31</code> here by using wolfram alpha, and the <code>pratt_rule_2' 31</code> is where I input it</p>



<a name="305237759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305237759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305237759">(Oct 20 2022 at 21:04)</a>:</h4>
<p>so the calculation is just a powmod?</p>



<a name="305237809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305237809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305237809">(Oct 20 2022 at 21:05)</a>:</h4>
<p>It's a number of powmods, but yeah - really there's not much more than the powmod implementation I showed you in messages a while back</p>



<a name="305237901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305237901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305237901">(Oct 20 2022 at 21:05)</a>:</h4>
<p>are the auxiliary computations all inexpensive?</p>



<a name="305238013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305238013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305238013">(Oct 20 2022 at 21:06)</a>:</h4>
<p>e.g. <code>31</code> is prime, those <code>_</code> arguments (which are presumably divisions of the target number by powers of the factors or something)</p>



<a name="305238089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305238089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305238089">(Oct 20 2022 at 21:07)</a>:</h4>
<p>I think so, but I haven't benchmarked - all the norm_num calls which aren't pow_mod are natural division (of a very large number by a very small prime factor), natural subtraction, and a natural non zero proof (or some combination)</p>



<a name="305238099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305238099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305238099">(Oct 20 2022 at 21:07)</a>:</h4>
<p>try splitting the powmods into their own lemmas</p>



<a name="305238529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305238529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305238529">(Oct 20 2022 at 21:09)</a>:</h4>
<p>Sorry one second - I just realised I was using a worse powmod implementation one than what I actually did, let me check properly with the better version. It seems that <code>18446744069414584321</code> is too big</p>



<a name="305240578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305240578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305240578">(Oct 20 2022 at 21:23)</a>:</h4>
<p><a href="/user_uploads/3121/vRRgk11cvaoByJdVPEOYf5vL/image.png">image.png</a> Here's the breakdown for the goldilocks prime</p>
<div class="message_inline_image"><a href="/user_uploads/3121/vRRgk11cvaoByJdVPEOYf5vL/image.png" title="image.png"><img src="/user_uploads/3121/vRRgk11cvaoByJdVPEOYf5vL/image.png"></a></div>



<a name="305240735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305240735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305240735">(Oct 20 2022 at 21:24)</a>:</h4>
<p>In each case the 'tactic execution took' is very close to 80% of the elaboration time showed, so I only showed that</p>



<a name="305240977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305240977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305240977">(Oct 20 2022 at 21:26)</a>:</h4>
<p><code>thing0</code> is where any benefit of 'recursive' certificates might give an improvement, but all the factors here are small so I didn't bother optimising that</p>



<a name="305241059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305241059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305241059">(Oct 20 2022 at 21:26)</a>:</h4>
<p>Oh, changing thing2 to use <code>18446744069414584320</code> rather than <code>18446744069414584321 - 1</code> seems to speed it up by 2x... that's not what I expected!</p>



<a name="305242289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305242289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305242289">(Oct 20 2022 at 21:35)</a>:</h4>
<p>Here's my scratch file: <a href="https://github.com/leanprover-community/mathlib/blob/pow_mod/src/pow_mod.lean">https://github.com/leanprover-community/mathlib/blob/pow_mod/src/pow_mod.lean</a></p>



<a name="305522124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305522124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305522124">(Oct 22 2022 at 11:35)</a>:</h4>
<p>That's great, I'll try that on <code>0x800000000000011000000000000000000000000000000000000000000000001</code></p>



<a name="305564389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305564389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305564389">(Oct 22 2022 at 17:30)</a>:</h4>
<p>Instead of proving the thing about <code>nat.factors</code> by <code>norm_num</code> like I did, for that prime you're probably better off showing that the particular list of factors does multiply to p-1, and that each element is a prime, because I guess norm_num might be too slow to verify the larger prime factors of p-1</p>



<a name="305719293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305719293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305719293">(Oct 23 2022 at 22:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/305144738">said</a>:</p>
<blockquote>
<p>I think it's more helpful to prove <a href="https://leanprover-community.github.io/mathlib_docs/find/lucas_primality">docs#lucas_primality</a> using  <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.factorization">docs#nat.factorization</a></p>
</blockquote>
<p>I guess you mean it would be better if the condition <a href="https://leanprover-community.github.io/mathlib_docs/find/lucas_primality">docs#lucas_primality</a> were stated as <code>∀ q ∈ p.factors, ...</code>, I agree this would look a bit better, and I wouldn't object to someone changing it (although I think <a href="https://leanprover-community.github.io/mathlib_docs/find/factors">docs#factors</a> should probably be named <code>prime_factors</code>).</p>



<a name="305862530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305862530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305862530">(Oct 24 2022 at 16:47)</a>:</h4>
<p>Why not both? (also <code>∀ q ∈ (p - 1).factors</code>)</p>



<a name="305895165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/305895165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#305895165">(Oct 24 2022 at 19:04)</a>:</h4>
<p>I just mean a formulation such that it's easy to list, in Lean, all the cases.</p>



<a name="308916163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/308916163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#308916163">(Nov 10 2022 at 04:09)</a>:</h4>
<p>With quite a bit of effort and broken up lemmas, I proved <code>47867742232066880047611079</code> is prime. This prime is interesting because it can't be written as the sum or difference of prime powers (from a 1999 result of Sun), and I verified it's not the sum or difference of a power of two and a prime (a 1975 result)</p>



<a name="308916353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/308916353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#308916353">(Nov 10 2022 at 04:11)</a>:</h4>
<p>Perhaps also worth noting that p-1 here also has a large prime factor <code>q = 90101681149415123</code>, and q-1 also has a large prime factor <code>1123145497</code>, and bare <code>norm_num</code> can't do this one either, so the certificate starts there</p>



<a name="308927609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/308927609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#308927609">(Nov 10 2022 at 06:31)</a>:</h4>
<p>Nice work ! Is it somewhere?</p>



<a name="308932840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/308932840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#308932840">(Nov 10 2022 at 07:30)</a>:</h4>
<p>That's a very philosophical question!</p>



<a name="308936239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/308936239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#308936239">(Nov 10 2022 at 08:02)</a>:</h4>
<p>I mean, on some repository <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="308991555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/large%20numbers%20computations/near/308991555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/large.20numbers.20computations.html#308991555">(Nov 10 2022 at 13:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/large.20numbers.20computations/near/308927609">said</a>:</p>
<blockquote>
<p>Nice work ! Is it somewhere?</p>
</blockquote>
<p>Not yet - if my primality verifying code from earlier is bad, this is atrocious :D</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
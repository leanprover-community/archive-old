---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Geometric.20group.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html">Geometric group theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="290390971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290390971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290390971">(Jul 21 2022 at 15:28)</a>:</h4>
<p><span class="user-mention" data-user-id="466209">@Georgi Kocharyan</span>, <span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span>, <span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span>, <span class="user-mention" data-user-id="466727">@Jim Fowler</span>, let's coordinate in this thread.</p>



<a name="290391065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290391065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290391065">(Jul 21 2022 at 15:29)</a>:</h4>
<p>I just refactored marked groups to be type synonyms (rather than classes). I am now copying over Georgi's material and adapting it to the new paradigm.</p>



<a name="290394898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290394898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290394898">(Jul 21 2022 at 15:57)</a>:</h4>
<p>Wow, that's contentful! <br>
Personally, I'd like to try and cover the ends of graphs first, and use that as a stepping stone for the ends of groups hopefully; and Bass-Serre at some point in the near future.<br>
Other than that I'd be happy to collaborate on whatever should come first, but there is some (a lot of) getting up to speed for me I see (even more so after seeing your transformation up there!).</p>
<p>[Re ends of graphs: I have some code <a href="https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends.lean">here</a> but it's very messy and I have a feeling it's not headed in the right direction; I'd welcome some coaching on the coding side!]</p>
<p>(I'm heading off for today)</p>



<a name="290395644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290395644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290395644">(Jul 21 2022 at 16:01)</a>:</h4>
<p>Link to other threads:</p>
<p><a href="#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt</a></p>
<p><a href="#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F</a></p>



<a name="290415873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290415873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290415873">(Jul 21 2022 at 18:36)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/15594">#15594</a> for group seminorms.</p>



<a name="290469766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290469766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290469766">(Jul 22 2022 at 06:19)</a>:</h4>
<p>Is it all-right if I bring <a href="https://github.com/leanprover-community/mathlib/blob/quasi_isometry/src/topology/metric_space/coarse/basic.lean">my file on nets and separated subsets</a> here?</p>



<a name="290476163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290476163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290476163">(Jul 22 2022 at 07:59)</a>:</h4>
<p>Please do!</p>



<a name="290496046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290496046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290496046">(Jul 22 2022 at 11:56)</a>:</h4>
<p>Done. The theorem therein might be useful when/if one wants to show that from a quasi-isometry one can get a bilipschitz bijection between nets contained in the spaces.</p>



<a name="290496589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290496589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290496589">(Jul 22 2022 at 12:01)</a>:</h4>
<p>By the way, about quasi-isometries: Is it worth it to also define coarsely Lipschitz maps and closeness for two maps into a metric space and have equivalence between all possible notions of equivalences, or should one stick to only talking about quasi-isometries for now?<br>
One definition I liked was: X and Y are QI if there exists a pair f:X -&gt;Y, g:Y-&gt;X, both coarsely Lipschitz, and such that both f o g and g o f are close to the identity.</p>
<p><a href="https://github.com/bottine/mathlib/tree/11ed62ddb3d6c6db743365856184dcd93337b951/src/topology/metric_space/coarse">here</a> I've got stuff about close maps and coarse Lipschitz maps.</p>



<a name="290608216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290608216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290608216">(Jul 23 2022 at 11:11)</a>:</h4>
<p>Would it make sense to set up some variation of a <code>roadmap.txt</code> file with a list of goals and subgoals and who is working on what?</p>



<a name="290609255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290609255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anand Rao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290609255">(Jul 23 2022 at 11:37)</a>:</h4>
<p>I have been following this and related threads for a while and would also like to contribute to building geometric group theory in mathlib. I have a nearly complete proof of the fact that the Cayley graph is connected (modulo two very easy <code>sorry</code>s), and I would like to push the changes to the <code>geometric-group-theory</code> branch. Can I please have write access to the non-master branches of mathlib? My GitHub username is <code>0art0</code>. Thanks!</p>



<a name="290610082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290610082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290610082">(Jul 23 2022 at 11:57)</a>:</h4>
<p><span class="user-group-mention" data-user-group-id="2494">@maintainers</span></p>



<a name="290610164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290610164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290610164">(Jul 23 2022 at 11:59)</a>:</h4>
<p><span class="user-mention" data-user-id="303675">@Anand Rao</span> I sent you an invitation</p>



<a name="290610629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290610629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anand Rao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290610629">(Jul 23 2022 at 12:11)</a>:</h4>
<p>Got it, thanks. I have pushed my code.</p>



<a name="290611893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290611893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290611893">(Jul 23 2022 at 12:40)</a>:</h4>
<p>I've been trying to make some progress on my code for ends of graphs, and am getting sort of lost starting from <a href="https://github.com/bottine/mathlib/blob/5fd6076d47a5dd5a0860fe96a4d85ca071a43aab/src/combinatorics/simple_graph/ends.lean#L763">here</a>.<br>
The point is that I want to show that given any finite set of vertices and infinite connected component outside this set, I can define an end that corresponds to this component. My problem is that I have to do some transports along equalities for it to make sense, and I feel like I'm not going in the right direction.</p>
<p>For instance, the definition <code>extend_along_fam</code> seems quite complicated, and the lemma <code>extend_along_const</code> needs transport even just to get correctly stated.<br>
I believe I'm missing some theoretical/technical aspect here.</p>
<p>Any idea on how I should proceed to make sense of this all? I'd welcome some structuring insights too!</p>



<a name="290624570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290624570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290624570">(Jul 23 2022 at 17:28)</a>:</h4>
<p>I'm not sure it would simplify anything, but I thought I'd mention we now have <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.delete_verts">docs#simple_graph.subgraph.delete_verts</a> so you can define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">simple_graph.connected_outside</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">((</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">G.subgraph</span><span class="o">)</span><span class="bp">.</span><span class="n">delete_verts</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">coe.connected</span>
</code></pre></div>
<p>and if you have <code>s : finset V</code> you can write <code>G.connected_outside s</code>.  (This definition means "G as a subgraph itself, once you delete the vertices from s, it is connected.")</p>



<a name="290624806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290624806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290624806">(Jul 23 2022 at 17:33)</a>:</h4>
<p>For ends of graphs, I imagined that one might take the poset of finite sets, which is closed under intersections, then define an inverse system over finite sets <code>s</code> of the types <code>((⊤ : G.subgraph).delete_verts s).coe.connected_component</code>. The limit of this inverse system consists of the ends.</p>
<p>We have a theorem that if these types are always finite and nonempty then this limit is nonempty too (<a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system">docs#nonempty_sections_of_fintype_inverse_system</a>) so in that case you'd have the graph has at least one end.</p>
<p>I'm not sure how good this definition of ends would be to work with, but it at least wouldn't be too much work to set up. (Modulo some missing API around <code>delete_verts</code> and <code>connected_component</code>.)</p>



<a name="290651911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290651911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290651911">(Jul 24 2022 at 04:32)</a>:</h4>
<p>Thanks! I'm wary of swapping out my constructions for the alternatives you provided though since as of now, my definitions do sort of work… but yeah, the inverse system theorem is a nice tool.</p>



<a name="290657481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290657481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290657481">(Jul 24 2022 at 07:02)</a>:</h4>
<p>Would you go with something like this ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.sym.sym2</span>
<span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.simple_graph.connectivity</span>
<span class="kn">import</span> <span class="n">topology.metric_space.basic</span>
<span class="kn">import</span> <span class="n">data.setoid.partition</span>
<span class="kn">import</span> <span class="n">category_theory.functor.basic</span>

<span class="kn">open</span> <span class="n">function</span>
<span class="kn">open</span> <span class="n">finset</span>
<span class="kn">open</span> <span class="n">set</span>
<span class="kn">open</span> <span class="n">classical</span>
<span class="kn">open</span> <span class="n">simple_graph.walk</span>
<span class="kn">open</span> <span class="n">relation</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>



<span class="kd">noncomputable theory</span>

<span class="c1">--local attribute [instance] prop_decidable</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>


<span class="kd">variables</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
           <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">ends</span>

<span class="kd">def</span> <span class="n">conn_comp_outside</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">((</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">G.subgraph</span><span class="o">)</span><span class="bp">.</span><span class="n">delete_verts</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">coe.connected_component</span>

<span class="kd">lemma</span> <span class="n">conn_comp_outside.finite</span> <span class="o">[</span><span class="n">locally_finite</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">preconnected</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype</span> <span class="o">(</span><span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">conn_comp_outside.nonempty</span>  <span class="o">[</span><span class="n">locally_finite</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">preconnected</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">Ginf</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">set.univ</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">infinite</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nonempty</span> <span class="o">(</span><span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">conn_comp_outside.to_set</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">v</span> <span class="bp">∉</span> <span class="n">s</span><span class="o">),</span> <span class="o">((</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">G.subgraph</span><span class="o">)</span><span class="bp">.</span><span class="n">delete_verts</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">coe.connected_component_mk</span> <span class="o">(⟨</span><span class="n">v</span><span class="o">,</span><span class="kd">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span><span class="n">exact</span> <span class="n">p</span><span class="o">}⟩)</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">conn_comp_outside_back_unique</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">t</span><span class="o">,</span>
  <span class="bp">∃!</span> <span class="n">d</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">(</span><span class="n">conn_comp_outside.to_set</span> <span class="n">G</span> <span class="n">t</span> <span class="n">c</span><span class="o">)</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">conn_comp_outside.to_set</span> <span class="n">G</span> <span class="n">s</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">conn_comp_outside_back</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span> <span class="o">:=</span>
  <span class="n">classical.some</span> <span class="o">(</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">conn_comp_outside_back.iff</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span><span class="o">):</span>
  <span class="n">conn_comp_outside_back</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">conn_comp_outside.to_set</span> <span class="n">G</span> <span class="n">t</span> <span class="n">c</span><span class="o">)</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">conn_comp_outside.to_set</span> <span class="n">G</span> <span class="n">s</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">equ</span><span class="o">,</span> <span class="n">induction</span> <span class="n">equ</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">some_spec</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">some_spec</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">conn_comp_outside_back.refl</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">conn_comp_outside_back</span> <span class="n">G</span> <span class="o">(</span><span class="n">finset.subset.refl</span> <span class="n">s</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
<span class="n">unique_of_exists_unique</span>
  <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="o">(</span><span class="n">finset.subset.refl</span> <span class="n">s</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="o">(</span><span class="n">finset.subset.refl</span> <span class="n">s</span><span class="o">)</span> <span class="n">c</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">set.subset.refl</span> <span class="o">(</span><span class="n">conn_comp_outside.to_set</span> <span class="n">G</span> <span class="n">s</span> <span class="n">c</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">conn_comp_outside_back.comm</span>  <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">conn_comp_outside</span> <span class="n">G</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">conn_comp_outside_back</span> <span class="n">G</span> <span class="n">k</span> <span class="o">(</span><span class="n">conn_comp_outside_back</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">conn_comp_outside_back</span> <span class="n">G</span> <span class="o">(</span><span class="n">k.trans</span> <span class="n">h</span><span class="o">)</span> <span class="n">c</span> <span class="o">:=</span>
<span class="n">unique_of_exists_unique</span>
  <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="o">(</span><span class="n">k.trans</span> <span class="n">h</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">((</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">some_spec.trans</span>
     <span class="o">(</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="n">k</span> <span class="o">(</span><span class="n">conn_comp_outside_back</span> <span class="n">G</span> <span class="n">h</span> <span class="n">c</span><span class="o">)))</span><span class="bp">.</span><span class="n">some_spec</span><span class="o">)</span>
  <span class="o">(</span><span class="n">classical.some_spec</span> <span class="o">(</span><span class="n">exists_of_exists_unique</span> <span class="o">(</span><span class="n">conn_comp_outside_back_unique</span> <span class="n">G</span> <span class="o">(</span><span class="n">k.trans</span> <span class="n">h</span><span class="o">)</span> <span class="n">c</span><span class="o">)))</span>


<span class="c1">-- def ends_system := category_theory.functor.mk (conn_comp_outside G) (conn_comp_outside_back G)</span>


<span class="kd">end</span> <span class="n">ends</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="290657733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290657733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290657733">(Jul 24 2022 at 07:10)</a>:</h4>
<p>mmh, or I might as well take a hybrid approach: sticking with my version of connected components, but then using the inverse systems machinery…</p>



<a name="290657799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290657799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290657799">(Jul 24 2022 at 07:12)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Do we have lemmas stating that the sections of your functor over an inverse system are in bijection with the sections over a suitably cofinite subsystem?</p>



<a name="290667125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290667125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290667125">(Jul 24 2022 at 11:17)</a>:</h4>
<p>Well, after cleaning up my code a bit <a href="https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends.lean">here</a> I think I'll stay with the elementary approach I took until now. I'll leave the surjectivity of ends onto connected components alone while I try to attack Hopf-Freudenthal and come back to it afterwards, hopefully with a clearer mind. The inverse system approach is probably better all things compared, but in the end you still have to deal with pretty much the same things, and my elementary approach is easier for me still.</p>



<a name="290679105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290679105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Georgi Kocharyan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290679105">(Jul 24 2022 at 13:10)</a>:</h4>
<p>I asked in another thread but would I be able to get writing access on the branch? I have a bunch of stuff on svarcmilnor i'd like to push! my github is GregorSamsa42</p>



<a name="290681471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290681471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290681471">(Jul 24 2022 at 13:52)</a>:</h4>
<p><span class="user-group-mention" data-user-group-id="2494">@maintainers</span></p>



<a name="290682271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290682271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290682271">(Jul 24 2022 at 14:10)</a>:</h4>
<p>Invite sent! <a href="https://github.com/leanprover-community/mathlib/invitations">https://github.com/leanprover-community/mathlib/invitations</a></p>



<a name="290686554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290686554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290686554">(Jul 24 2022 at 15:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290657799">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> Do we have lemmas stating that the sections of your functor over an inverse system are in bijection with the sections over a suitably cofinite subsystem?</p>
</blockquote>
<p>I haven't seen that in mathlib, and I presume it doesn't exist yet (but maybe I just haven't found it).</p>
<p>It's fine continuing with an elementary approach to get a better understanding of formalization issues -- that limit nonemptiness lemma started out that way as a first project, until it eventually morphed into a specialization of a statement about cofiltered limits of nonempty compact hausdorff spaces.</p>



<a name="290755254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290755254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anand Rao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290755254">(Jul 25 2022 at 12:59)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> I think the following strategy (inspired heavily by the equivalence of different characterisations of ends described on <a href="https://en.wikipedia.org/wiki/End_(graph_theory)#Definition_and_characterization">Wikipedia</a>) may work for getting a lower bound on the number of ends:</p>
<ul>
<li>To show that the number of ends of an infinite graph is bounded below by the number of infinite connected components, it suffices to show that every infinite connected graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> has at least one end.</li>
<li>Since "infinite" is defined as "not finite" in mathlib, it should be fairly easy to show the existence of arbitrarily large paths in the graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>. Consequently, it should be possible to show the existence of a ray <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> (i.e., a semi-infinite path, which can be described concretely as an embedding of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>, considered as a graph, into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>).</li>
<li>To finally construct the end, we define its value on a finite set of vertices <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> to be the unique connected component of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi mathvariant="normal">\</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G \backslash K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">\</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> containing infinitely many vertices of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>.</li>
<li>More concretely, the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>n</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mi mathvariant="normal">∣</mi><mi>R</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>K</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{n : \mathbb{N} \vert R(n) \in K\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">}</span></span></span></span> is finite, and has an upper bound <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>. The value of the end of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> can be defined to be the connected component of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(m+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. It can be proved as a theorem that the ray <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>R</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R&#x27;(n) := R((m  + 1) + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">((</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> is contained entirely within this connected component.</li>
</ul>



<a name="290760810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290760810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290760810">(Jul 25 2022 at 13:49)</a>:</h4>
<p>Mmh, I was aiming for an adaptation of the proof in the stacks project <a href="https://stacks.math.columbia.edu/tag/002Z">here</a> to my specific case.<br>
The problem I foresee with the infinite ray approach is that it's not so immediate to construct the equivalence between ends as equivalence classes of rays and as limits.</p>



<a name="290765518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290765518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anand Rao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290765518">(Jul 25 2022 at 14:27)</a>:</h4>
<p>The proof I outlined actually uses the definition of ends described in your code - as a function that takes in a finite set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> of the graph and returns a connected component of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi mathvariant="normal">\</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">G \backslash K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">\</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> and satisfying the consistency condition on subsets (I should have mentioned this earlier).</p>
<p>The definition of ends as equivalence classes of rays is not necessary here, and only the existence of a single ray in an infinite connected graph is required.</p>
<p>The inverse limit approach is fine too, and I may also contribute to the proof.</p>



<a name="290766219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290766219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290766219">(Jul 25 2022 at 14:32)</a>:</h4>
<p>That's good to hear!</p>



<a name="290766493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290766493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290766493">(Jul 25 2022 at 14:35)</a>:</h4>
<p>I've worked some more, and have a <a href="https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends.lean">rough outline of the proof of Hopf-Freudenthal</a>.</p>
<p>There are now plenty of missing pieces:</p>
<ul>
<li>The surjectivity of the <code>eval</code> map is the big one.</li>
<li>The fact that taking a finite set of vertices, one can extend it so that it is both connected, and all connected components outside of this finite set are infinite. (that's used in one of the preliminary lemmas towards Hopf-Freudenthal)</li>
<li>The fact that applying an automorphism sends connected components to connected components, etc (should be easy with enough <code>simple_graph</code>-fu).</li>
<li>Lots of small things for which I'm not good enough with lean to figure out efficiently.</li>
</ul>
<p>But all in all, I think I'm getting to something viable. <br>
The next step is probably to sort of clean up the structure a bit, reorganize as necessary, and then fill out the sorrys.<br>
<span class="user-mention" data-user-id="303675">@Anand Rao</span>: What do you think of that plan?</p>
<p>(I'm heading off for today!)</p>



<a name="290768221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290768221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anand Rao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290768221">(Jul 25 2022 at 14:47)</a>:</h4>
<p>Sounds good! I will try to familiarise myself with the code a bit more soon. I will start with some of the easier <code>sorry</code>s.</p>



<a name="290864194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290864194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290864194">(Jul 26 2022 at 08:47)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  I have a few questions about <code>simple_graph</code> if I may:</p>
<p>First, would the following lemmas fit in the api:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">walk.mem_support_iff_exists_append</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">w</span> <span class="bp">∈</span> <span class="n">p.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">w</span> <span class="n">v</span><span class="o">),</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q.append</span> <span class="n">r</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">walk.support_append_subset_left</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.support</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">p.append</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">walk.support_append</span><span class="o">,</span><span class="n">list.subset_append_left</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">walk.support_append_subset_right</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">q.support</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">p.append</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="n">walk.support_append</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">q</span><span class="o">,</span>
    <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">support_nil</span><span class="o">,</span> <span class="n">list.tail_cons</span><span class="o">,</span> <span class="n">list.append_nil</span><span class="o">,</span> <span class="n">list.cons_subset</span><span class="o">,</span> <span class="n">end_mem_support</span><span class="o">,</span> <span class="n">list.nil_subset</span><span class="o">,</span> <span class="n">and_self</span><span class="o">],},</span>
    <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">support_cons</span><span class="o">,</span> <span class="n">list.tail_cons</span><span class="o">,</span> <span class="n">list.cons_subset</span><span class="o">,</span> <span class="n">list.mem_append</span><span class="o">,</span> <span class="n">end_mem_support</span><span class="o">,</span> <span class="n">true_or</span><span class="o">,</span> <span class="n">list.subset_append_right</span><span class="o">,</span><span class="n">and_self</span><span class="o">],},</span>
  <span class="o">}</span>
</code></pre></div>
<p>Second, is there a nice way to deal with walks and their images via an automorphism and such?<br>
Finally, is there something like <code> lemma {V : Type *} {G : simple_graph V} [locally_finite G] [preconnected G] (v : V) (n : nat) : (ball v n).finite  := sorry </code> ?</p>



<a name="290865687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290865687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290865687">(Jul 26 2022 at 09:04)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> Yes, these would be nice to have. The first one seems like it might be more convenient in many cases than using <code>take_until</code> and <code>drop_until</code> manually.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- right after `walk.take_spec`?</span>
<span class="kd">lemma</span> <span class="n">walk.mem_support_iff_exists_append</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">w</span> <span class="bp">∈</span> <span class="n">p.support</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">w</span> <span class="n">v</span><span class="o">),</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q.append</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="o">(</span><span class="n">p.take_spec</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- right after `walk.mem_support_append_iff`?</span>

<span class="kd">lemma</span> <span class="n">walk.subset_support_append_left</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.support</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">p.append</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">walk.support_append</span><span class="o">,</span> <span class="n">list.subset_append_left</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">walk.subset_support_append_right</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">q.support</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">p.append</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="290865864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290865864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290865864">(Jul 26 2022 at 09:07)</a>:</h4>
<p>Shall I just copy, insert, and do a PR?</p>



<a name="290868740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290868740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290868740">(Jul 26 2022 at 09:38)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> The function for mapping walks over a graph equivalence has some dependent type complexity, and I'm not really sure the best way to deal with it. Here's most of one possibility:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≃</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">≃</span> <span class="n">G'.walk</span> <span class="o">(</span><span class="n">f</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">walk.map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">p.map</span> <span class="o">(</span><span class="n">f.symm</span> <span class="o">:</span> <span class="n">G'</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G</span><span class="o">)</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">p</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">},</span> <span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">nil</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nil</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">b</span> <span class="n">b</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">rintros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
      <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="n">b</span> <span class="n">b'</span> <span class="n">c</span> <span class="n">c'</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b'</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">c'</span><span class="o">)</span>
        <span class="o">{</span><span class="n">he</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">b</span> <span class="n">c</span><span class="o">},</span>
        <span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hc</span><span class="o">])</span> <span class="o">(</span><span class="n">cons</span> <span class="n">he</span> <span class="n">p</span><span class="o">)</span>
          <span class="bp">=</span> <span class="n">cons</span> <span class="o">(</span><span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">])</span> <span class="n">he</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">a'</span> <span class="n">b'</span><span class="o">)</span> <span class="o">(</span><span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hb</span><span class="o">,</span> <span class="n">hc</span><span class="o">])</span> <span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">b'</span> <span class="n">c'</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">rintros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="n">rfl</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">congr'</span> <span class="o">},</span>
      <span class="n">all_goals</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="290869041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290869041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290869041">(Jul 26 2022 at 09:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290864194">said</a>:</p>
<blockquote>
<p>Finally, is there something like <code> lemma {V : Type *} {G : simple_graph V} [locally_finite G] [preconnected G] (v : V) (n : nat) : (ball v n).finite  := sorry </code> ?</p>
</blockquote>
<p>The "walks of a given length" section of simple_graph/connectivity could be generalized to this situation. I think you can drop the <code>preconnected</code> assumption.</p>



<a name="290869383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290869383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290869383">(Jul 26 2022 at 09:44)</a>:</h4>
<p>Ah, yeah, right, I was thinking of something else for the preconnected assumption: namely that in this case the graph is countable.</p>



<a name="290869435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290869435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290869435">(Jul 26 2022 at 09:45)</a>:</h4>
<p>Could elaborate on the use of <code>contextual := tt</code> ? The docs aren't very helpful as far as I could find.</p>



<a name="290869572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290869572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290869572">(Jul 26 2022 at 09:46)</a>:</h4>
<p>There's a little bit at <a href="https://leanprover-community.github.io/extras/simp.html">https://leanprover-community.github.io/extras/simp.html</a></p>
<p>When it simplifies <code>a -&gt; b</code>, it simplifies <code>b</code> with <code>a</code> added as a simp lemma.</p>



<a name="290869917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290869917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290869917">(Jul 26 2022 at 09:50)</a>:</h4>
<p>Thanks, I'm sort of mystified that you made the <code>append_right</code> version shorter than the <code>append_left</code> one, given that it's not as direct as far as I understood.</p>



<a name="290870069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290870069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290870069">(Jul 26 2022 at 09:52)</a>:</h4>
<p>Here's a locally finite version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">locally_finite</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>

<span class="sd">/-- The `finset` of length-`n` walks from `u` to `v`.</span>
<span class="sd">This is used to give `{p : G.walk u v | p.length = n}` a `fintype` instance, and it</span>
<span class="sd">can also be useful as a recursive description of this set when `V` is finite.</span>

<span class="sd">See `simple_graph.coe_finset_walk_length_eq` for the relationship between this `finset` and</span>
<span class="sd">the set of length-`n` walks. -/</span>
<span class="kd">def</span> <span class="n">finset_walk_length</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">finset</span> <span class="o">(</span><span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">u</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span>
           <span class="k">then</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">u</span><span class="o">,</span> <span class="n">exact</span> <span class="o">{</span><span class="n">walk.nil</span><span class="o">}</span> <span class="o">}</span>
           <span class="k">else</span> <span class="bp">∅</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">u</span> <span class="n">v</span> <span class="o">:=</span> <span class="o">(</span><span class="n">G.neighbor_finset</span> <span class="n">u</span><span class="o">)</span><span class="bp">.</span><span class="n">attach.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">G.neighbor_finset</span> <span class="n">u</span><span class="o">),</span>
                  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">w</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">w.2</span><span class="o">,</span>
                  <span class="o">(</span><span class="n">finset_walk_length</span> <span class="n">n</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">walk.cons</span> <span class="n">h</span> <span class="n">p</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩)</span>

<span class="kd">lemma</span> <span class="n">coe_finset_walk_length_eq</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G.finset_walk_length</span> <span class="n">n</span> <span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="bp">=</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">|</span> <span class="n">p.length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">huv</span> <span class="o">:=</span> <span class="n">eq_or_ne</span> <span class="n">u</span> <span class="n">v</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">finset_walk_length</span><span class="o">,</span> <span class="n">set_walk_length_zero_eq_of_ne</span><span class="o">,</span> <span class="bp">*</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset_walk_length</span><span class="o">,</span> <span class="n">set_walk_length_succ_eq</span><span class="o">,</span>
      <span class="n">finset.coe_bUnion</span><span class="o">,</span> <span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">finset.mem_univ</span><span class="o">,</span> <span class="n">set.Union_true</span><span class="o">],</span>
    <span class="n">ext</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">set.mem_image</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_neighbor_finset</span><span class="o">,</span> <span class="n">finset.mem_attach</span><span class="o">,</span> <span class="n">finset.mem_map</span><span class="o">,</span> <span class="n">embedding.coe_fn_mk</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_true_left</span><span class="o">,</span>
  <span class="n">subtype.exists</span><span class="o">],</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">congr'</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">congr'</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">huw</span><span class="o">,</span>
    <span class="n">congr'</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">p'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.ext_iff</span><span class="o">,</span> <span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">ih</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="290870103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290870103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290870103">(Jul 26 2022 at 09:53)</a>:</h4>
<p>The proof of <code>coe_finset_walk_length_eq</code> isn't pretty -- I was just trying to get it to work quickly</p>



<a name="290870217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290870217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290870217">(Jul 26 2022 at 09:54)</a>:</h4>
<p>If you wanted to PR this sort of generalization (with a nicer proof), that'd be great! If not, I'll get around to it at some point.</p>



<a name="290870454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290870454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290870454">(Jul 26 2022 at 09:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290869917">said</a>:</p>
<blockquote>
<p>I'm sort of mystified that you made the <code>append_right</code> version shorter than the <code>append_left</code> one</p>
</blockquote>
<p>You can actually use the <code>append_right</code> proof for <code>append_left</code> too, but I left it since your proof was a <code>simp only</code>. It's too bad that <code>walk.support_append</code> has that asymmetry...</p>



<a name="290870601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290870601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290870601">(Jul 26 2022 at 09:58)</a>:</h4>
<p>right, I originally planned it by way of enough <code>reverse</code>s, but it felt ugly.</p>



<a name="290871167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290871167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290871167">(Jul 26 2022 at 10:04)</a>:</h4>
<p>As for contributing to the ball and other lemmas, I hope to do at some point. But I also would like to sort of stay focused on my <code>ends</code> code for now, and every little things takes lots of time still, so it may not be so soon.</p>



<a name="290871227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290871227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290871227">(Jul 26 2022 at 10:05)</a>:</h4>
<p>PR here: <a href="https://github.com/leanprover-community/mathlib/pull/15687">https://github.com/leanprover-community/mathlib/pull/15687</a></p>



<a name="290871579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290871579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290871579">(Jul 26 2022 at 10:09)</a>:</h4>
<p>I made your <code>simp</code> into <code>simp only</code> since I believe it's what should be done but maybe I was mistaken. I also made the two <code>subset</code> lemmas into <code>@[simp]</code>.</p>



<a name="290872634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290872634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290872634">(Jul 26 2022 at 10:21)</a>:</h4>
<p>huh, I don't understand why the bulid fails :(</p>



<a name="290873070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290873070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290873070">(Jul 26 2022 at 10:25)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> Here's the finite ball. It's intended to go right after <code>fintype_set_walk_length</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ball_finset</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">finset</span> <span class="n">V</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">∪</span> <span class="o">(</span><span class="n">G.neighbor_finset</span> <span class="n">u</span><span class="o">)</span><span class="bp">.</span><span class="n">bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">ball_finset</span> <span class="n">n</span> <span class="n">w</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">coe_ball_finset_eq</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G.ball_finset</span> <span class="n">n</span> <span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span> <span class="n">p.length</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">u</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ball_finset</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">ball_finset</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">(</span><span class="n">rfl</span> <span class="bp">|</span> <span class="n">h</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">walk.nil</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">huw</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="n">w</span><span class="o">),</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">obtain</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">[</span><span class="n">walk.cons</span> <span class="n">huw</span> <span class="n">p</span><span class="o">],</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">nat.succ_eq_add_one</span><span class="o">],</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
      <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
        <span class="n">use</span> <span class="o">[</span><span class="n">p_v</span><span class="o">,</span> <span class="n">p_h</span><span class="o">],</span>
        <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="n">p_v</span><span class="o">),</span>
        <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">p_p</span><span class="o">,</span>
        <span class="n">simpa</span> <span class="o">[</span><span class="n">nat.succ_eq_add_one</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">ball</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">locally_finite</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span> <span class="n">p.length</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">ball_finite</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">locally_finite</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">G.ball</span> <span class="n">u</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ball</span><span class="o">,</span> <span class="bp">←</span> <span class="n">coe_ball_finset_eq</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">set.to_finite</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="290873338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290873338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290873338">(Jul 26 2022 at 10:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290872634">said</a>:</p>
<blockquote>
<p>huh, I don't understand why the bulid fails :(</p>
</blockquote>
<p>I just retriggered the linting job. Sometimes things fail for no discernible reason.</p>



<a name="290873612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290873612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290873612">(Jul 26 2022 at 10:31)</a>:</h4>
<p>It might be easier to prove that set is finite by induction on n more directly than by going through finsets. The algorithm I wrote for <code>ball_finset</code> is really bad -- it doesn't need to be exponential like that -- so it's not useful having that as a computable definition.</p>



<a name="290874103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290874103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290874103">(Jul 26 2022 at 10:36)</a>:</h4>
<p>and it might make sense to use the induced metric directly, so that the balls really are the metric ball, I guess?</p>



<a name="290874996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290874996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290874996">(Jul 26 2022 at 10:46)</a>:</h4>
<p>Ah, that's where <code>connected</code> comes in, for <code>simple_graph.dist</code> to be meaningful here.</p>



<a name="290970850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290970850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290970850">(Jul 26 2022 at 23:56)</a>:</h4>
<p>I just opened <a href="https://github.com/leanprover-community/mathlib/pull/15705">#15705</a> for multiplicative normed groups.</p>



<a name="290988358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290988358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290988358">(Jul 27 2022 at 04:53)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> thanks for correcting the PR :) Can you tell me how you knew what made the linter unhappy ? I ran <code>scripts/lint-style.sh</code> but that didn't spot anything iirc.</p>



<a name="290989481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290989481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290989481">(Jul 27 2022 at 05:13)</a>:</h4>
<p>Once the linter finally ran, it gave some error messages that you can see inline in the code view on GitHub.  It's derived from this output: <a href="https://github.com/leanprover-community/mathlib/runs/7518225899?check_suite_focus=true">https://github.com/leanprover-community/mathlib/runs/7518225899?check_suite_focus=true</a></p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>/- The `dup_namespace` linter reports: -/
/- DUPLICATED NAMESPACES IN NAME: -/
-- combinatorics/simple_graph/connectivity.lean
#check @simple_graph.walk.walk.subset_support_append_left /- The namespace `walk` is duplicated in the name -/
Error: simple_graph.walk.walk.subset_support_append_left - The namespace `walk` is duplicated in the name
... etc. ...
</code></pre></div>



<a name="290989609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/290989609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#290989609">(Jul 27 2022 at 05:15)</a>:</h4>
<p>Ah, thanks, I tried to see the output on the first run but somehow it seemed to be empty. Is there a way to do it locally?</p>



<a name="291031199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291031199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291031199">(Jul 27 2022 at 13:11)</a>:</h4>
<p>You can add <code>#lint</code> to the end of every file you touch to see the output, make sure you remove it before committing though!</p>



<a name="291042796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291042796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Georgi Kocharyan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291042796">(Jul 27 2022 at 14:31)</a>:</h4>
<p>My proof of svarc-milnor is now (virtually) complete, along with an example that proves Z quasi-isometric to R.<br>
It relies on a few easy lemmas about marked_group which i've added to the file now (I think most should be one liners, but my knowledge doesn't suffice). <br>
If anyone is bored you're welcome to have a look at them :)</p>



<a name="291164464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291164464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291164464">(Jul 28 2022 at 10:27)</a>:</h4>
<p>We're making some progress on the Freundenthal-Hopf theorem, but have some trouble dealing with instances/typeclasses, as typically shown <a href="https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends/reachable_outside.lean#L334">here</a>. How should I proceed to assume throughout (without the need to reference it explicitely) that my graph is locally finite and preconnected?<br>
In the same vein, under the hypotheses, I would like to assume everywhere that a specific set is finite (as shown <a href="https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends/reachable_outside.lean#L477">here</a> but the instance doesn't "take", it seems.</p>



<a name="291165566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291165566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291165566">(Jul 28 2022 at 10:43)</a>:</h4>
<p>Are you writing instances that depend on a <code>locally_finite</code> assumption? If not, I would stick with passing it around explicitly.</p>



<a name="291165805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291165805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291165805">(Jul 28 2022 at 10:46)</a>:</h4>
<p>I am, yeah: I need <code>locally_finite G</code> to say that removing a finite set of vertices yield a finite number of connected components.</p>



<a name="291165875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291165875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291165875">(Jul 28 2022 at 10:47)</a>:</h4>
<p>That's the type <code>inf_ro_components G K</code>. I'd like to have <code>[fintype (inf_ro_components G K)]</code> everywhere (well, once I actually prove it).</p>



<a name="291165912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291165912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291165912">(Jul 28 2022 at 10:47)</a>:</h4>
<p>Yes but again do you need to go through typeclass inference for this?</p>



<a name="291166167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291166167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291166167">(Jul 28 2022 at 10:50)</a>:</h4>
<p>Mmh, I admit I don't understand the question: I'm not sure what typeclass inference is. Maybe it's time to look at the docs instead of blindly swapping out <code>()</code> for <code>[]</code> and see what sticks</p>



<a name="291166365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291166365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291166365">(Jul 28 2022 at 10:53)</a>:</h4>
<p>Basically you shouldn't treat TC inference as a big theorem bookkeeper. Instead (at least for Prop-valued stuff), it should be used for assumptions that are derived structurally (typically, <code>p ∧ q ∨ r</code> will be decidable because <code>p</code>, <code>q</code>, <code>r</code> is).</p>



<a name="291166725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291166725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291166725">(Jul 28 2022 at 10:57)</a>:</h4>
<p>Mmh, I see, and what's the rationale for this? "structurally derived" theorems are easier for lean to understand/bookkeep?</p>



<a name="291168943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291168943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291168943">(Jul 28 2022 at 11:23)</a>:</h4>
<p>TC inference is not meant to nor can be used as a SMT solver.</p>



<a name="291169064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291169064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291169064">(Jul 28 2022 at 11:24)</a>:</h4>
<p>Alright, thanks! I'll try and look at the docs in a bit more depth.</p>



<a name="291184559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291184559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291184559">(Jul 28 2022 at 13:53)</a>:</h4>
<p>Isn't <code>gen_norm_le_one</code> in <code>marked_group</code> wrong for exactly the reason <span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> mentionned above: a generator might be mapped to the identity ?</p>



<a name="291210994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291210994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291210994">(Jul 28 2022 at 15:40)</a>:</h4>
<p>For what it's worth, my motivation for slipping in <code>locally_finite</code> was to support different limiting arguments on subgraphs, for instance defining ends of graphs or lifting properties about finite graphs to infinite graphs (like how you can lift the 4-color theorem of finite planar graphs to infinite planar graphs).</p>
<p>Generally you'd be looking at the instances <code>[locally_finite G]</code> giving <code>[locally_finite (G.delete_verts s)]</code> or <code>[locally_finite (G.induce s)]</code> (or however those graphs are written), and you won't be doing any algebraic manipulation of <code>G</code> itself -- it's being used more like a type than a term, so to speak.</p>
<p>That's not to say I knew what I was doing back when I slipped it in, but given what I've learned in the meantime I think <code>locally_finite</code>instances are still justifiable for this application.</p>



<a name="291211656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291211656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291211656">(Jul 28 2022 at 15:45)</a>:</h4>
<p>Actually, <code>locally_finite</code> is not the worst offender here (lean seems to like it being an instance well enough), but <code>preconnected G</code> and the diverse <code>fintype X</code> are.</p>



<a name="291267419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291267419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291267419">(Jul 28 2022 at 23:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290868740">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> The function for mapping walks over a graph equivalence has some dependent type complexity, and I'm not really sure the best way to deal with it. Here's most of one possibility:</p>
</blockquote>
<p>I've made a definitionally better version of the walk equiv but unfortunately it requires a re-definition of <code>simple_graph.walk</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">namespace</span> <span class="n">simple_graph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V'</span><span class="o">}</span>

<span class="kd">inductive</span> <span class="n">walk</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">u</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">u</span> <span class="n">w</span>

<span class="kd">def</span> <span class="n">walk.map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u'</span> <span class="n">v'</span> <span class="o">:</span> <span class="n">V'</span><span class="o">}</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">f</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v'</span><span class="o">),</span>
  <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">G'.walk</span> <span class="n">u'</span> <span class="n">v'</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">u'</span> <span class="n">v'</span> <span class="n">hu</span> <span class="n">hv</span> <span class="o">(</span><span class="n">walk.nil</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="n">walk.nil</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hu</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">hv</span><span class="o">])</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">u'</span> <span class="n">v'</span> <span class="n">hu</span> <span class="n">hv</span> <span class="o">(</span><span class="n">walk.cons</span> <span class="n">w</span> <span class="n">h</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">walk.cons</span> <span class="o">(</span><span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="bp">▸</span> <span class="n">f.map_adj</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">walk.map</span> <span class="n">rfl</span> <span class="n">hv</span> <span class="n">p</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">walk.equiv</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≃</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u'</span> <span class="n">v'</span> <span class="o">:</span> <span class="n">V'</span><span class="o">}</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">f</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">≃</span> <span class="n">G'.walk</span> <span class="n">u'</span> <span class="n">v'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">walk.map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="n">hu</span> <span class="n">hv</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">walk.map</span> <span class="o">(</span><span class="n">f.symm</span> <span class="o">:</span> <span class="n">G'</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hu</span><span class="o">])</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hv</span><span class="o">]),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">induction</span> <span class="n">p</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">u'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">p_ih</span> <span class="n">hv</span> <span class="n">rfl</span> <span class="o">},</span> <span class="n">congr</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">induction</span> <span class="n">p</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">u</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="n">walk.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="bp">@</span><span class="n">p_ih</span> <span class="n">hv</span> <span class="o">(</span><span class="n">f.symm</span> <span class="n">p_v</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">},</span> <span class="n">congr</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">walk.equiv'</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≃</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">≃</span> <span class="n">G'.walk</span> <span class="o">(</span><span class="n">f</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">walk.equiv</span> <span class="n">f</span> <span class="n">rfl</span> <span class="n">rfl</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="291267518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291267518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291267518">(Jul 28 2022 at 23:47)</a>:</h4>
<p>I'm not sure if allowing equality in <code>walk.nil</code> is really necessary; we may use <code>eq.rec (walk.nil ...)</code>, and if <code>f (g v) = v</code> definitionally then it would compute to <code>walk.nil ...</code>.</p>



<a name="291348197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291348197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291348197">(Jul 29 2022 at 16:24)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> That's a good idea. There's a trick that lets us avoid needing to modify the inductive type itself that is theoretically equivalent, which is to add in a <code>copy</code> function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">walk.copy</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v'</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u'</span> <span class="n">v'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">hu</span><span class="o">,</span> <span class="n">subst</span> <span class="n">hv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">p</span> <span class="o">}</span>
</code></pre></div>
<p>Then the modified inductive type corresponds to wrapping constructors with this <code>copy</code> function.</p>
<p>With this and some accompanying lemmas, the <code>left_inv</code> and <code>right_inv</code> proofs are <code>simp</code> (in my code below it's longer because there are still some missing lemmas).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.connectivity</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V'</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V''</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G''</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V''</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u'</span> <span class="n">v'</span> <span class="n">w'</span> <span class="n">u''</span> <span class="n">v''</span> <span class="n">w''</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="kd">def</span> <span class="n">walk.copy</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v'</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u'</span> <span class="n">v'</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">hu</span><span class="o">,</span> <span class="n">subst</span> <span class="n">hv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">p</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">walk.copy_rfl_rfl</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.copy</span> <span class="n">hu</span> <span class="n">hv</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">walk.copy_copy</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v'</span><span class="o">)</span> <span class="o">(</span><span class="n">hu'</span> <span class="o">:</span> <span class="n">u'</span> <span class="bp">=</span> <span class="n">u''</span><span class="o">)</span> <span class="o">(</span><span class="n">hv'</span> <span class="o">:</span> <span class="n">v'</span> <span class="bp">=</span> <span class="n">v''</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p.copy</span> <span class="n">hu</span> <span class="n">hv</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="n">hu'</span> <span class="n">hv'</span> <span class="bp">=</span> <span class="n">p.copy</span> <span class="o">(</span><span class="n">hu.trans</span> <span class="n">hu'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv.trans</span> <span class="n">hv'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">walk.copy_nil</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">walk.nil</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">u</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="n">hu</span> <span class="n">hu</span> <span class="bp">=</span> <span class="n">walk.nil</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">walk.copy_cons</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">w'</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">walk.cons</span> <span class="n">h</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="n">hu</span> <span class="n">hw</span> <span class="bp">=</span> <span class="n">walk.cons</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">hu</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">})</span> <span class="o">(</span><span class="n">p.copy</span> <span class="n">rfl</span> <span class="n">hw</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">walk.cons_copy</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v'</span> <span class="n">w'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v'</span> <span class="bp">=</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">w'</span> <span class="bp">=</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">walk.cons</span> <span class="n">h</span> <span class="o">(</span><span class="n">p.copy</span> <span class="n">hv</span> <span class="n">hw</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">walk.cons</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">hv</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">})</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="n">rfl</span> <span class="n">hw</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">walk.map_copy</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">u'</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">v'</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p.copy</span> <span class="n">hu</span> <span class="n">hv</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="o">(</span><span class="kd">by</span> <span class="n">subst</span> <span class="n">hu</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">subst</span> <span class="n">hv</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">p</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">u'</span> <span class="n">v'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">walk.copy_cons</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">walk.map</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">walk.copy_cons</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">walk.map_map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">G'</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G''</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p.map</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">p.map</span> <span class="o">(</span><span class="n">f'.comp</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">walk.map_id</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">p.map</span> <span class="n">hom.id</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">walk.map_of_eq</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">}</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f'</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p.map</span> <span class="n">f'</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">walk.equiv</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≃</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">≃</span> <span class="n">G'.walk</span> <span class="o">(</span><span class="n">f</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">walk.map</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">p.map</span> <span class="o">(</span><span class="n">f.symm</span> <span class="o">:</span> <span class="n">G'</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G</span><span class="o">))</span><span class="bp">.</span><span class="n">copy</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">walk.map_map</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">walk.map_of_eq</span> <span class="n">hom.id</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">walk.map_map</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">walk.map_of_eq</span> <span class="n">hom.id</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="291348392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291348392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291348392">(Jul 29 2022 at 16:26)</a>:</h4>
<p>This is somewhat like manipulating sigma types, however with this you get constant definitional control over the endpoints of walks, which is quite nice!</p>



<a name="291348637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291348637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291348637">(Jul 29 2022 at 16:28)</a>:</h4>
<p>If you <code>#print walk.copy</code> you see it's just <code>eq.rec (eq.rec p hv) hu</code> though and not of the form <code>nil</code> or <code>cons</code>. If <code>hu</code> and <code>hv</code> are not defeqs it doesn't compute/reduce.</p>



<a name="291348978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291348978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291348978">(Jul 29 2022 at 16:31)</a>:</h4>
<p>I almost wrote it as <code>eq.rec</code> directly, but I thought using <code>subst</code> was clearer.</p>



<a name="291349061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291349061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291349061">(Jul 29 2022 at 16:32)</a>:</h4>
<p>That's true they don't reduce, however having a custom <code>eq.rec</code> means it's easier to write all the supporting simp lemmas, which is a point I forgot to mention explicitly.</p>



<a name="291349153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291349153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291349153">(Jul 29 2022 at 16:33)</a>:</h4>
<p>Yeah eq_to_hom is also secretely an <code>eq.rec</code>...</p>



<a name="291349179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291349179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291349179">(Jul 29 2022 at 16:33)</a>:</h4>
<p>This lets us deal with the "evilness" of rewriting morphisms(/functors):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">walk.map_of_eq</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">}</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">G'</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f'</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p.map</span> <span class="n">f'</span><span class="o">)</span><span class="bp">.</span><span class="n">copy</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="291349308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291349308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291349308">(Jul 29 2022 at 16:34)</a>:</h4>
<p>The idea is that the simp normal form for <code>copy</code> is to be the outermost thing in an expression, so that way <code>copy_copy</code> merges them, and eventually you can (hopefully) eliminate them completely.</p>



<a name="291349726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291349726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291349726">(Jul 29 2022 at 16:38)</a>:</h4>
<p>Unlike for category theory, this evilness is a necessary evil since we aren't working with vertices up to isomorphism, but actually up to equality. There are no higher morphisms to save us.</p>



<a name="291537625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291537625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Georgi Kocharyan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291537625">(Aug 01 2022 at 06:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/291184559">said</a>:</p>
<blockquote>
<p>Isn't <code>gen_norm_le_one</code> in <code>marked_group</code> wrong for exactly the reason <span class="user-mention silent" data-user-id="263407">Laurent Bartholdi</span> mentionned above: a generator might be mapped to the identity ?</p>
</blockquote>
<p>uh yes true, the version for subsets is right but I forgot to change the original version (the name le_one is correct though ^^)</p>



<a name="291676980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/291676980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#291676980">(Aug 02 2022 at 08:02)</a>:</h4>
<p>Hey, so we've been working on Freudenthal-Hopf with <span class="user-mention" data-user-id="303675">@Anand Rao</span> for a while, and are getting sort of stuck/unsure about how to architect things. The "pure graph theoretical" part is mostly done, with a few sorries, but to prove the surjectivity of ends onto infinite connected components, we finally decided on using the lemma from mathlib about finite nonempty filtered inverse systems, and this cascaded into wanting to define ends really as limits, rather than as our own type, and then noticing that most of our code really should be stated in this more general setting. The code is <a href="https://github.com/bottine/mathlib/tree/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends">here</a> if anyone wants to chime in with some feedback. I believe the correct way wrt mathlib would be to have as much general stuff out of our code as possible, but it seems there is a pretty heavy infrastructure code to this.</p>



<a name="297186158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297186158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297186158">(Sep 05 2022 at 08:36)</a>:</h4>
<p>OK, after some more work <a href="https://github.com/bottine/mathlib/tree/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends">here</a>, we're planning on merging our work with the <code>geometric-group-theory</code> branch: anybody minds?</p>
<p>We're close to having:</p>
<ul>
<li>Ends for (locally finite, connected) graphs in <code>ends_limit_construction.lean</code>.</li>
<li>A slightly modified statement of Freudenthal-Hopf in <code>Freudenthal_Hopf.lean</code>.</li>
<li>A notion of "coarse maps" of graphs and closeness for such maps, in order to have functoriality of ends in <code>functoriality.lean</code>.</li>
<li>The fact that quasi-isometries of graphs yield bijections of ends (again, slightly modified to match our definitions).</li>
<li>Plenty of <code>sorry</code>s peppered around, but mostly stuff that we feel should be easy from (eventual) <code>mathlib</code> lemmas.</li>
<li>The set of connected components outside of a finite set is defined in <code>comp_out.lean</code>: we took a kind of hybrid approach: defining the connected components outside of <code>K</code> as <code>(G.remove_verts K).connected_component</code> made coercions sort of unmanageable. <br>
  Instead, we define a subgraph on the same vertex set that deconnects all of <code>K</code>, and then we just look at the components disjoint from <code>K</code>.<br>
  This worked well enough for us.</li>
</ul>
<p>The plan now is to do some cleanup and reorganization of the files, and then merge, assuming that's OK with people.</p>



<a name="297311453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297311453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297311453">(Sep 06 2022 at 06:43)</a>:</h4>
<p>And now I want to start working on Bass-Serre theory, and for this I'd welcome some opinions:</p>
<ul>
<li>
<p>I was thinking of starting with <em><a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/jlms/s2-13.1.145">The fundamental groupoid of a graph of groups</a></em> by Higgins. <br>
  It seems to work at a nice abstraction level, but:</p>
</li>
<li>
<p>This relies on presentations of groupoids, e.g. <em><a href="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/presentations-of-groupoids-with-applications-to-groups/BEB206703D950FA10E18DD51CB52F019">Presentations of groupoids, with applications to groups</a></em> by Higgins also.</p>
</li>
</ul>
<p>As far as I could find, there is essentially no code for presentations of groupoids in mathlib: the closest is the code for Nielsen-Schreier.<br>
Does it make sense to start this low down the hierarchy and actually take the time to define presentations of groupoids, and then go up again via Higgins' paper, to, eventually, start working on Bass-Serre, or is a hands-on approach (maybe even forsaking groupoids) more reasonable?</p>
<p>The paper <em>Presentations of groupoids…</em> actually has Nielsen-Schreier and Kurosh as applications, which makes me believe that it might not be a bad idea to start here: we can already get non-trivial stuff from that approach, and in any case, I guess presentations of groupoids might prove useful more generally than for Bass-Serre?</p>



<a name="297320797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297320797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297320797">(Sep 06 2022 at 08:02)</a>:</h4>
<p>By the way, I am still reorganising norms to defin multiplicative normed groups. It's taking ages.</p>



<a name="297461528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297461528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297461528">(Sep 06 2022 at 18:18)</a>:</h4>
<p>I think that presentations of groupoids would definitely be useful by itself, independantly of Bass-Serre theory.</p>



<a name="297962286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297962286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297962286">(Sep 09 2022 at 12:33)</a>:</h4>
<p>OK, I imported our work into the <code>geometric-group-theory</code> branch. <br>
<span class="user-mention" data-user-id="387244">@Yaël Dillies</span> before doing the (manual) import, I tried running <code>leanproject rebase</code> on the <code>ggt</code> branch, but the rebase failed because of a duplicate definition of <code>seminorm</code> (or something like that). I expect that is because you had a preliminary definition locally in the <code>ggt</code> branch and you're now comitting bits on <code>master</code>. Can I safely remove the local definition?</p>



<a name="297962442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297962442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297962442">(Sep 09 2022 at 12:34)</a>:</h4>
<p>I think so, but what definition is it exactly?</p>



<a name="297962597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297962597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297962597">(Sep 09 2022 at 12:35)</a>:</h4>
<p>oh, maybe I misread the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">&gt;</span> <span class="n">leanproject</span> <span class="n">rebase</span>
<span class="n">Checking</span> <span class="n">out</span> <span class="n">master...</span>
<span class="n">Pulling...</span>
<span class="bp">`</span><span class="n">get</span><span class="bp">-</span><span class="n">mathlib</span><span class="bp">-</span><span class="n">cache</span><span class="bp">`</span> <span class="n">is</span> <span class="n">for</span> <span class="n">projects</span> <span class="n">which</span> <span class="n">depend</span> <span class="n">on</span> <span class="n">mathlib</span><span class="o">,</span> <span class="n">not</span> <span class="n">for</span> <span class="n">mathlib</span> <span class="n">itself.</span> <span class="n">Running</span> <span class="bp">`</span><span class="n">get</span><span class="bp">-</span><span class="n">cache</span><span class="bp">`</span> <span class="n">instead.</span>
<span class="n">Looking</span> <span class="n">for</span> <span class="n">mathlib</span> <span class="n">oleans</span> <span class="n">for</span> <span class="mi">75</span><span class="n">cc1ae964</span>
  <span class="n">locally...</span>
  <span class="n">Found</span> <span class="kn">local</span> <span class="n">mathlib</span> <span class="n">oleans</span>
<span class="n">Using</span> <span class="n">matching</span> <span class="n">cache</span>
<span class="n">Applying</span> <span class="n">cache</span>
  <span class="n">files</span> <span class="n">extracted</span><span class="o">:</span> <span class="mi">2674</span> <span class="o">[</span><span class="mi">00</span><span class="o">:</span><span class="mi">14</span><span class="o">,</span> <span class="mi">179</span><span class="bp">.</span><span class="mi">97</span><span class="bp">/</span><span class="n">s</span><span class="o">]</span>
<span class="n">Checking</span> <span class="n">out</span> <span class="n">geometric</span><span class="bp">-</span><span class="n">group</span><span class="bp">-</span><span class="n">theory...</span>
<span class="n">Rebasing...</span>
<span class="n">Cmd</span><span class="o">(</span><span class="bp">'</span><span class="n">git'</span><span class="o">)</span> <span class="n">failed</span> <span class="n">due</span> <span class="n">to</span><span class="o">:</span> <span class="n">exit</span> <span class="n">code</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">cmdline</span><span class="o">:</span> <span class="n">git</span> <span class="n">rebase</span> <span class="n">master</span>
  <span class="n">stdout</span><span class="o">:</span> <span class="bp">'</span><span class="n">Auto</span><span class="bp">-</span><span class="n">merging</span> <span class="n">src</span><span class="bp">/</span><span class="n">analysis</span><span class="bp">/</span><span class="n">seminorm.lean</span>
<span class="n">CONFLICT</span> <span class="o">(</span><span class="n">content</span><span class="o">):</span> <span class="n">Merge</span> <span class="n">conflict</span> <span class="k">in</span> <span class="n">src</span><span class="bp">/</span><span class="n">analysis</span><span class="bp">/</span><span class="n">seminorm.lean'</span>
<span class="n">error</span><span class="o">:</span> <span class="n">could</span> <span class="n">not</span> <span class="n">apply</span> <span class="mi">8</span><span class="n">bbccf027f...</span> <span class="n">use</span> <span class="n">type</span> <span class="n">synonyms</span><span class="o">,</span> <span class="n">group</span> <span class="n">seminorms</span>
<span class="n">hint</span><span class="o">:</span> <span class="n">Resolve</span> <span class="n">all</span> <span class="n">conflicts</span> <span class="n">manually</span><span class="o">,</span> <span class="n">mark</span> <span class="n">them</span> <span class="n">as</span> <span class="n">resolved</span> <span class="k">with</span>
<span class="n">hint</span><span class="o">:</span> <span class="s2">"git add/rm &lt;conflicted_files&gt;"</span><span class="o">,</span> <span class="k">then</span> <span class="n">run</span> <span class="s2">"git rebase --continue"</span><span class="bp">.</span>
<span class="n">hint</span><span class="o">:</span> <span class="n">You</span> <span class="n">can</span> <span class="n">instead</span> <span class="n">skip</span> <span class="n">this</span> <span class="n">commit</span><span class="o">:</span> <span class="n">run</span> <span class="s2">"git rebase --skip"</span><span class="bp">.</span>
<span class="n">hint</span><span class="o">:</span> <span class="n">To</span> <span class="n">abort</span> <span class="n">and</span> <span class="n">get</span> <span class="n">back</span> <span class="n">to</span> <span class="n">the</span> <span class="n">state</span> <span class="n">before</span> <span class="s2">"git rebase"</span><span class="o">,</span> <span class="n">run</span> <span class="s2">"git rebase --abort"</span><span class="bp">.</span>
<span class="n">Could</span> <span class="n">not</span> <span class="n">apply</span> <span class="mi">8</span><span class="n">bbccf027f...</span> <span class="n">use</span> <span class="n">type</span> <span class="n">synonyms</span><span class="o">,</span> <span class="n">group</span> <span class="n">seminorms'</span>
</code></pre></div>



<a name="297963203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297963203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297963203">(Sep 09 2022 at 12:38)</a>:</h4>
<p>Ah yes, that's different. You will have to fix conflicts by hand. I can do it if you promise me not to touch the branch for the next half hour</p>



<a name="297963373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297963373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297963373">(Sep 09 2022 at 12:39)</a>:</h4>
<p>Alright, informing <span class="user-mention" data-user-id="303675">@Anand Rao</span> too, thanks!</p>



<a name="297964226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297964226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297964226">(Sep 09 2022 at 12:44)</a>:</h4>
<p>Done!</p>



<a name="297964331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/297964331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#297964331">(Sep 09 2022 at 12:44)</a>:</h4>
<p>quick half hour, thanks a lot!</p>



<a name="298517922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/298517922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#298517922">(Sep 13 2022 at 05:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/297311453">said</a>:</p>
<blockquote>
<p>And now I want to start working on Bass-Serre theory, and for this I'd welcome some opinions:</p>
<ul>
<li>
<p>I was thinking of starting with <em><a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/jlms/s2-13.1.145">The fundamental groupoid of a graph of groups</a></em> by Higgins. <br>
  It seems to work at a nice abstraction level, but:</p>
</li>
<li>
<p>This relies on presentations of groupoids, e.g. <em><a href="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/presentations-of-groupoids-with-applications-to-groups/BEB206703D950FA10E18DD51CB52F019">Presentations of groupoids, with applications to groups</a></em> by Higgins also.</p>
</li>
</ul>
<p>As far as I could find, there is essentially no code for presentations of groupoids in mathlib: the closest is the code for Nielsen-Schreier; but <code>category_theory.path_category</code> and <code>category_theory.quotient</code> should provide good building blocks.<br>
Does it make sense to start this low down the hierarchy and actually take the time to define presentations of groupoids, and then go up again via Higgins' paper, to, eventually, start working on Bass-Serre, or is a hands-on approach (maybe even forsaking groupoids) more reasonable?</p>
<p>The paper <em>Presentations of groupoids…</em> actually has Nielsen-Schreier and Kurosh as applications, which makes me believe that it might not be a bad idea to start here: we can already get non-trivial stuff from that approach, and in any case, I guess presentations of groupoids might prove useful more generally than for Bass-Serre?</p>
</blockquote>
<p>Chapter IV of Bourbaki's Topologie algébrique has another result on these lines, which looks more general than Higgins, at least it is framed in terms of coequalizers of groupoids. With applications to  the van Kampen theorem where they give formulas that I do not think exist at other places.</p>



<a name="298994764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/298994764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#298994764">(Sep 15 2022 at 15:30)</a>:</h4>
<p>I'll take things slow and start with trying to mimick the <code>subgroup</code> API for <code>subgroupoids</code></p>



<a name="299014323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299014323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299014323">(Sep 15 2022 at 17:08)</a>:</h4>
<p>Can't you just use <code>subobject C</code> where <code>C</code> is a groupoid ?</p>



<a name="299019424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299019424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299019424">(Sep 15 2022 at 17:38)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I imagine that word "just" is standing in for various design tradeoffs and how you imagine subobjects working in general. Would you mind elaborating? (That's <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.subobject">docs#category_theory.subobject</a> correct?)</p>



<a name="299020129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299020129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299020129">(Sep 15 2022 at 17:43)</a>:</h4>
<p>It seems to me that it's easier to work with explicit subsets rather than isomorphism classes of monomorphisms, sort of like how for simple graphs we can represent a subgraph as a subset of vertices and a sub-relation. Maybe it's workable building up API around <code>category_theory.subobject</code> for concrete categories, to let you ignore the quotient in practice.</p>



<a name="299021578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299021578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299021578">(Sep 15 2022 at 17:51)</a>:</h4>
<p>That wasn't a rhetorical question! What I have in mind, in decreasing order of preference and increasing of boilerplate, is:</p>
<ol>
<li>We can just use <code>subobject C</code> and its API</li>
<li>We can just use <code>subobject C</code> but we need specific API </li>
<li>We introduce a new structure for subgroupoids, show its equivalence to <code>subobject C</code> and use the <code>subobject</code> API through that equivalence</li>
<li>We introduce a new structure for subgroupoids, show its equivalence to <code>subobject C</code> and transfer the <code>subobject</code> API through that equivalence</li>
<li>We introduce a new structure for subgroupoids, build its API separately, and possibly show its equivalence to <code>subobject C</code></li>
<li>We introduce a new structure for subgroupoids that's not equivalent to <code>subobject C</code>, and build its API separately</li>
</ol>



<a name="299022850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299022850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299022850">(Sep 15 2022 at 17:58)</a>:</h4>
<p>uh, I was heading in <a href="https://github.com/bottine/Bass-Serre/blob/5194d4ac1f55bab3df469c9c4c3834837d4f3097/src/groupoid_presentation.lean#L137">this</a> direction. which I now understand not to be ideal.</p>



<a name="299022910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299022910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299022910">(Sep 15 2022 at 17:59)</a>:</h4>
<p>But both groups and graphs are sort of following this pattern, so I thought I was safe. Aren't I?</p>



<a name="299030921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299030921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299030921">(Sep 15 2022 at 18:46)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> That's a nice encoding trick you have, where the existence of an identity arrow corresponds to whether an object is present in the subgroupoid. I wonder if it would make sense, though, to introduce <code>subquiver</code> and have <code>subgroupoid</code> extend that? Or maybe you keep it the same but have it extend <a href="https://leanprover-community.github.io/mathlib_docs/find/wide_subquiver">docs#wide_subquiver</a>? (I'm not sure if this leads to any issues.)</p>



<a name="299031563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299031563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299031563">(Sep 15 2022 at 18:50)</a>:</h4>
<p>I think Yael's suggestion is reasonable but more on the speculative end of things -- <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Do we have much experience in mathlib with defining subobjects using <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.subobject">docs#category_theory.subobject</a>? I think we understand how to create subobjects using custom structures fairly well.</p>



<a name="299043575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299043575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299043575">(Sep 15 2022 at 20:06)</a>:</h4>
<p>Using <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.subobject">docs#category_theory.subobject</a> is great if all you care about is the lattice structure of the type of subobjects, but I think making a custom structure is a better approach whenever you want to work with <em>actual elements</em> of the subobject.</p>



<a name="299130355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299130355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299130355">(Sep 16 2022 at 10:17)</a>:</h4>
<p>What would <code>subquiver</code> bring to the table? I think in that case we would lose the "trick" you're refering to, right?</p>



<a name="299158808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/299158808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#299158808">(Sep 16 2022 at 13:19)</a>:</h4>
<p>(deleted)</p>



<a name="300116767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/300116767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#300116767">(Sep 22 2022 at 10:24)</a>:</h4>
<p>I'm working on the free groupoid and have a question:<br>
I've defined a custom inductive type of "words" on my initial quiver as <a href="https://github.com/bottine/Bass-Serre/blob/be28357e39b05f756b58bdc1e4870cde6cbcfa31/src/free_groupoid.lean#L26">here</a> but there is also <code>quiver.path</code> and <code>quiver.symmetrify</code>.<br>
The problem with using <code>quiver.path</code> and <code>quiver.symmetrify</code> is mostly that I have to deal with the type synonym introduced by <code>quiver.symmetrify</code>.</p>
<p>Should I work with what's already here anyway?</p>



<a name="300279031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/300279031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#300279031">(Sep 23 2022 at 02:14)</a>:</h4>
<p>Just wanna let you geometric group theory folks know about the <a href="https://github.com/leanprover-community/mathlib/search?q=author%3Amatthias567+is%3Apr&amp;type=issues">amenable group PRs</a> (<a href="#narrow/stream/113489-new-members/topic/Amenable.20Groups/near/300269636">Zulip discussion</a>); maybe you would be interested in helping reviewing them? The code looks like it needs to go through a lot of revisions, but firstly we need to make some design decisions. The references listed in the PRs are:</p>
<ul>
<li>[C. Löh, <em>Geometric Group Theory</em>, Definition 9.1.1][loeh17]</li>
<li><a href="https://en.wikipedia.org/wiki/Amenable_group">https://en.wikipedia.org/wiki/Amenable_group</a></li>
<li>[A.L.T. Paterson, <em>Amenability</em>, Definition 0.2][Paterson1988]</li>
</ul>



<a name="302750296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/302750296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#302750296">(Oct 06 2022 at 22:13)</a>:</h4>
<p>Heads up that <a href="https://github.com/leanprover-community/mathlib/pull/15705">#15705</a> is in, so we now can PR marked groups and such!</p>



<a name="303100218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100218">(Oct 09 2022 at 07:27)</a>:</h4>
<p>Great! For now I'm busy trying to deal with groupoids and eventually Bass-Serre hopefully. <br>
There was a discussion about marked groups perhaps not being the best place to start with the geometry of groups: is there a consensus on that?</p>
<p>By the way, I noticed I'm starting to use quivers quite extensively, and will probably use them to do graph theory: say talk about the existence of maximal trees, etc. There already was <code>[has_reverse]</code> on quivers, and I added <code>[has_involutive_reverse]</code> and now I feel this is dangerously close to simply talking of graphs. <br>
Would it make sense to take this as an opportunity to make this the official definition of "unoriented multigraph" ? (opinion, <span class="user-mention" data-user-id="306601">@Kyle Miller</span> ?)</p>



<a name="303100292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100292">(Oct 09 2022 at 07:28)</a>:</h4>
<p>Do you know about <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>?</p>



<a name="303100359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100359">(Oct 09 2022 at 07:29)</a>:</h4>
<p>I didn't, no! hum, this makes my stuff quite redundant… Why not base it on quivers?</p>



<a name="303100448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100448">(Oct 09 2022 at 07:30)</a>:</h4>
<p>There are several reasons, really. But I think both approaches are viable.</p>



<a name="303100550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100550">(Oct 09 2022 at 07:32)</a>:</h4>
<p>I like using quivers since it allows a natural "symmetrization", and <del>you have fewer equalities to deal with</del> <strong>I'm used to it already</strong>, in some sense… I assume changing the implementation of <code>multigraphs</code> isn't acceptable? What do you recommend I do, then?</p>



<a name="303100579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100579">(Oct 09 2022 at 07:33)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a> is just experimental, but I do not believe your "there are fewer equalities to deal with". Multigraphs are so that you should never need defeq on the type of edges.</p>



<a name="303100917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303100917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303100917">(Oct 09 2022 at 07:38)</a>:</h4>
<p>I see, yeah. I wanted to use the "Serre" definition of graphs to begin with, but after looking at what they do in Bass-Serre, it's always orientation-preserving actions (and the involution on edges has no fixed points), meaning you can just choose an orientation and be done with it: hence quivers.</p>



<a name="303199004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303199004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303199004">(Oct 10 2022 at 05:31)</a>:</h4>
<p>OK, so what's the way forward with this, and how can I help it making progress?</p>
<p>Note also that the quiver definition make the passage to categories very easy but with this custom definition you need to add more glue code as far as I can see.</p>



<a name="303261952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303261952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303261952">(Oct 10 2022 at 13:39)</a>:</h4>
<p>Something else I'd like to get some opinions on: I need to talk about "free products" and quotients of groupoids. My first instinct was to define this by hand, but actually I see that there is code for <code>Cats</code> and <code>Groupoids</code> talking about limits and such, and I'm wondering how much of the existing tooling I should/can use.</p>
<ul>
<li>If I'm not mistaken, I can take limits/colimits in <code>Cats</code> and they'll actually also define limits/colimits in <code>Groupoids</code> (that's a general mathematical statement, not talking about mathlib).</li>
<li>On the other hand, I actually don't see that <code>Cats</code> has coequalizers in mathlib, is that right?</li>
<li>Also, I'm wondering if defining those construction via "the category of …" will involve much more boilerplate than defining them by hand.</li>
</ul>
<p>So, in short, where should I draw the line, and what's the correct way to proceed here?</p>



<a name="303293013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303293013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303293013">(Oct 10 2022 at 16:42)</a>:</h4>
<p>Limits in Cat was done by Joseph Hua <a href="#narrow/stream/116395-maths/topic/1-limits.20in.20Cat">in this thread</a> back in February, but was added to mathlib by <span class="user-mention" data-user-id="110087">@Scott Morrison</span> in March in <a href="https://github.com/leanprover-community/mathlib/pull/12979">#12979</a>, maybe using a different approach, I didn't check. I'm pretty sure we don't have colimits yet, given that category_theory.category.Cat.limit has no siblings in the same directory.</p>



<a name="303336296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303336296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303336296">(Oct 10 2022 at 23:03)</a>:</h4>
<p>(Sorry, I had completely missed Joseph's thread, I think.)</p>



<a name="303403113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303403113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303403113">(Oct 11 2022 at 11:04)</a>:</h4>
<p>As an aside, there is something I don't totally get with the organization of mathlib. <br>
What does the organization wrt "what should be included in what order using which construction" look like?<br>
This might be a bit naive of my part, but it feels like it's some kind of a big soup of people contributing what they feel like and reviewers accepting on a case-by-case basis without much "long-term"/organizational thought. I'd expect to see some kind of hierarchy of subjects, with working groups deciding on the design and strategy of the subject in a way that makes it harder for people to work blindly on something that will be useless or already worked on. I don't want to spit in the soup, and am very grateful to everyone involved for the coaching and help in getting stuff included, but I'm wondering if these is some margin for streamlining of the process?</p>



<a name="303404023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303404023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303404023">(Oct 11 2022 at 11:11)</a>:</h4>
<p>Have you seen <a href="#narrow/stream/113488-general/topic/mathlib.20organization">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathlib.20organization</a> ?</p>



<a name="303405784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303405784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303405784">(Oct 11 2022 at 11:22)</a>:</h4>
<p>I have, but missed the "teams" part. <br>
It's indeed part of what I'm talking about, but doesn't seem to cover a more involved hierarchy of subjects and plans as for how to cover them, does it? Is having such a specified plan just too ambitious and bureaucratic, and a risk of killing the "organic" flow mathlib is currently working with?</p>



<a name="303406425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303406425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303406425">(Oct 11 2022 at 11:26)</a>:</h4>
<p>I'd think that the current canonical answer to "How to prevent oneself from working blindly on something that will be useless or already worked on" is to ask on zulip before starting.</p>



<a name="303539257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303539257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303539257">(Oct 12 2022 at 00:01)</a>:</h4>
<p>I think the answer is mostly that the "long-term organizational thought" doesn't actually come to much without someone able/willing to write the code, and so we mostly prefer to let mathlib grow organically according to what people actually want to write.</p>
<p>We're mostly extremely liberal on what counts as "appropriate to mathlib", with occasional exceptions.</p>
<p>That said, I think there is a lot of "organizational planning" that happens off in branches, and during the PR process. It's not at all unusual that it takes several developments of the same material before it actually makes it into mathlib.</p>



<a name="303550774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/303550774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#303550774">(Oct 12 2022 at 02:37)</a>:</h4>
<p>Perhaps they are underutilized, but we also have <a href="https://github.com/leanprover-community/mathlib/projects?query=is%3Aopen">projects</a> on GitHub for this sort of thing.</p>



<a name="305115200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric%20group%20theory/near/305115200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Geometric.20group.20theory.html#305115200">(Oct 20 2022 at 09:59)</a>:</h4>
<p>Hey, so I've finally managed to get the quotient construction for groupoids working, and thus presentations.<br>
My construction for the quotient is perhaps unorthodox, in that (as said above) I first quotient by the isotropy groups only, which means no collapsing of vertices, and then quotient by what remains, which is always <code>graph_like</code> i.e. has at most one edge between two vertices.</p>
<p>I'd be thankful if someone could have a look at the <a href="https://github.com/leanprover-community/mathlib/compare/master...bottine:mathlib:bottine/quotient_groupoids?expand=1">code here</a> and tell me if it's worth cleaning up to make a PR, of if this approach is considered too dirty.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
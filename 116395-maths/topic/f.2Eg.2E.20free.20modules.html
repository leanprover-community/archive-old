---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html">f.g. free modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="199358168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199358168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199358168">(Jun 01 2020 at 11:32)</a>:</h4>
<p>I'm trying to catch up with this thread. I am confused by this doesn't work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span> <span class="n">tactic</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">direct_sum_module</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="c1">--noncomputable instance foo : module R (direct_sum ι (λ _:ι, R)) := by apply_instance</span>

<span class="n">noncomputable</span> <span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>
</code></pre></div>


<p>If I comment out the instance, which apparently is already there, it works.</p>



<a name="199359297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199359297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199359297">(Jun 01 2020 at 11:47)</a>:</h4>
<p>I didn’t know I could fix this error by writing “noncomputable” before example</p>



<a name="199359916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199359916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199359916">(Jun 01 2020 at 11:56)</a>:</h4>
<p>You still get the error with the smul, but if I comment out the instance it fixes it</p>



<a name="199363492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199363492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199363492">(Jun 01 2020 at 12:39)</a>:</h4>
<p>OK so I'm catching up with the issues raised in this thread. <code>direct_sum</code> is for an arbitrary direct sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-modules (and in particular is a dependent finsupp). This specific case of free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-modules is somehow easier because it's not dependent, but there is a cost to introducing a new definition like <code>free</code>: Kenny's suggestion of just using <code>ι →₀ R</code> has advantages and disadvantages. On the other hand the concept of a free module is so ubiquitous that probably one has to make the definition. </p>
<p>The second point is that I suspect there's no coercion from <code>finset</code> to <code>Type</code> :-( </p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span> <span class="c1">-- fails</span>
</code></pre></div>


<p>There's a coercion from <code>finset X</code> to <code>set X</code> and then from there to <code>Type*</code>, but I don't seem to be able to get there directly.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="err">↑</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
</code></pre></div>


<p>Should there be a coercion from <code>finset X</code> to <code>Type</code> directly?</p>



<a name="199363632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199363632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199363632">(Jun 01 2020 at 12:41)</a>:</h4>
<p>We could define <code>free</code> in terms of <code>ι →₀ R</code></p>



<a name="199363665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199363665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199363665">(Jun 01 2020 at 12:41)</a>:</h4>
<p>I often write <code>{ x // x \in s }</code>. But of course that's a very roundabout way to make a Type out of a finset</p>



<a name="199366220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199366220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199366220">(Jun 01 2020 at 13:09)</a>:</h4>
<p>Kevin, how should I think about the "cost" of introducing a new definition? Is the point that this is just one more thing that needs to be unfolded, so it introduces some fixed amount of overhead for <code>simp</code> etc in all downstream code?</p>



<a name="199366747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199366747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199366747">(Jun 01 2020 at 13:14)</a>:</h4>
<p>I guess another question I had was whether all the free constructions in algebra.* should be special cases of a general definition (involving adjoints to forgetful functors), and their concrete descriptions (e.g. free module = direct sum or finitely supported functions or whatever) should be lemmas rather than definitions</p>



<a name="199371940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199371940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199371940">(Jun 01 2020 at 13:54)</a>:</h4>
<p>Why is this conversation in "new members" rather than maths? It seems to be far beyond the newbie  question about proving <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∧</mo><mi>Q</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>Q</mi><mo>∧</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">P \wedge Q \implies Q \wedge P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>.</p>



<a name="199372241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199372241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199372241">(Jun 01 2020 at 13:57)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules">#new members &gt; f.g. free modules</a> by <span class="user-mention silent" data-user-id="110596">Rob Lewis</span></p>



<a name="199372420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199372420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199372420">(Jun 01 2020 at 13:59)</a>:</h4>
<p>Another thing about introducing a terminology for <code>ι →₀ R</code> is that Lean will then have to be told that it's e.g. a module.</p>



<a name="199372799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199372799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199372799">(Jun 01 2020 at 14:03)</a>:</h4>
<p>I think we already have a characteristic predicate for "M is the free R-module on a set S", only we call it instead "S is an R-basis of the R-module M".</p>



<a name="199372826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199372826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199372826">(Jun 01 2020 at 14:03)</a>:</h4>
<p>@_<strong>Notification Bot|100006</strong> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199372241">said</a>:</p>
<blockquote>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/f.2Eg.2E.20free.20modules">#new members &gt; f.g. free modules</a> by <span class="user-mention silent" data-user-id="110596">Rob Lewis</span></p>
</blockquote>
<p>hey we can do that??!!</p>



<a name="199373175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199373175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199373175">(Jun 01 2020 at 14:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199372799">said</a>:</p>
<blockquote>
<p>I think we already have a characteristic predicate for "M is the free R-module on a set S", only we call it instead "S is an R-basis of the R-module M".</p>
</blockquote>
<p>My understanding of the original question is that basically it is how to prove that if M is a finitely-generated (so in particular there's some <code>S : finset M</code> which is known to span) then it admits a surjection from an f.g. free module. One issue is that S here has type <code>finset M</code>, so you do need to build some kind of free module with something resembling S as a basis, and then it will all be easy. The question is how to build this free module in an idiomatic way.</p>



<a name="199373552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199373552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199373552">(Jun 01 2020 at 14:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> yes, I agree with that. but then when you use the "object" that is the free module on <code>ι</code>, it should be convenient to get your hands on:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">std_basis</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">lof</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="n">i</span> <span class="mi">1</span> <span class="c1">-- this is the std basis if we are working with direct_sum ι (λ _:ι, R)) as the free R-module on ι</span>

<span class="kn">lemma</span> <span class="n">is_basis_std_basis</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">R</span> <span class="o">(</span><span class="n">std_basis</span> <span class="n">R</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>(I know that lemma is not so hard to prove, but the proof doesn't seem to be as easy as <code>simp</code> given the lemma of the same name in linear_algebra/basis.lean.)</p>



<a name="199373841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199373841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199373841">(Jun 01 2020 at 14:12)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/f142b4208bee350d00931b9fa38069cc740c83ef/src/linear_algebra/finsupp_vector_space.lean#L52-L54">https://github.com/leanprover-community/mathlib/blob/f142b4208bee350d00931b9fa38069cc740c83ef/src/linear_algebra/finsupp_vector_space.lean#L52-L54</a></p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">is_basis_single</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">ι</span><span class="o">,</span> <span class="n">φ</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">i</span><span class="o">,</span> <span class="n">is_basis</span> <span class="n">K</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">is_basis</span> <span class="n">K</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">ix</span> <span class="o">:</span> <span class="err">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">φ</span> <span class="n">i</span><span class="o">,</span> <span class="n">single</span> <span class="n">ix</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">f</span> <span class="n">ix</span><span class="bp">.</span><span class="mi">1</span> <span class="n">ix</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="o">:=</span>
</code></pre></div>



<a name="199374369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199374369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199374369">(Jun 01 2020 at 14:17)</a>:</h4>
<p>Doesn't seem like that lemma should need <code>[field K]</code>, right?</p>



<a name="199374762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199374762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199374762">(Jun 01 2020 at 14:20)</a>:</h4>
<p>Right, so while the characterization of being a free module is more or less under control, the construction of free modules is lacking, at a minimum, a coherent API. "The free R-module on a set" is far too important a notion to give the cryptic notation <code>ι →₀ R</code>, in my opinion.</p>



<a name="199375639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199375639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199375639">(Jun 01 2020 at 14:29)</a>:</h4>
<p>I don't suppose the parser could handle the notation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⨁</mo><mi>ι</mi></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">\bigoplus_\iota R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ι</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>, assuming we could type that in Unicode easily?</p>



<a name="199375684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199375684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199375684">(Jun 01 2020 at 14:29)</a>:</h4>
<p>or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi>ι</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{\oplus \iota}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">ι</span></span></span></span></span></span></span></span></span></span></span></span> I suppose</p>



<a name="199389033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199389033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199389033">(Jun 01 2020 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> That first suggestion shouldn't be a problem</p>



<a name="199389092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199389092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199389092">(Jun 01 2020 at 16:17)</a>:</h4>
<p>It would basically be</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="bp">`</span><span class="err">\</span><span class="n">bigoplus</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">direct_sum</span>
</code></pre></div>



<a name="199389538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199389538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199389538">(Jun 01 2020 at 16:20)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> Concerning your question about the cost of adding a <code>def</code>.</p>
<ol>
<li>
<p>You certainly don't have to worry about what <code>lean</code> the program thinks about a new def. It sees thousands of them every day, and it won't loose any sleep over seeing yet another one.</p>
</li>
<li>
<p>You might worry about the 'social contract' that comes with add a <code>def</code> to mathlib. Namely, that you should also provide a (bare minimum) API. You'll have to sit down, and think of all the stupid, silly, trivial statements that a mathematician would <em>not</em> write down in a textbook chapter on that new definition. And then state and prove all those stupid, silly, trivial lemmas.</p>
</li>
</ol>
<p>As Reid said above: <code>free</code> is certainly so fundamental that it deserves being a definition.</p>



<a name="199390838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199390838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199390838">(Jun 01 2020 at 16:30)</a>:</h4>
<p>apparently \bigoplus is not in the unicode character set. what about ∐ (as distinct from the infix operator ⨿ for binary coproducts)</p>



<a name="199391423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199391423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199391423">(Jun 01 2020 at 16:35)</a>:</h4>
<p>Hmmm... maybe we should just implement LaTeX mode for lean</p>



<a name="199391468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199391468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199391468">(Jun 01 2020 at 16:35)</a>:</h4>
<p><span aria-label="fire" class="emoji emoji-1f525" role="img" title="fire">:fire:</span> burn unicode to the ground <span aria-label="fire" class="emoji emoji-1f525" role="img" title="fire">:fire:</span></p>



<a name="199391510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199391510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199391510">(Jun 01 2020 at 16:35)</a>:</h4>
<p>Is Tom Hales's CNL already usable is input language for lean?</p>



<a name="199391588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199391588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199391588">(Jun 01 2020 at 16:36)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> do you have any news from the front?</p>



<a name="199394089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199394089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199394089">(Jun 01 2020 at 16:58)</a>:</h4>
<p>I found ⨁ U+2A01 N-ARY CIRCLED PLUS OPERATOR (not to be confused with ⊕ U+2295 CIRCLED PLUS)</p>



<a name="199394186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199394186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199394186">(Jun 01 2020 at 16:58)</a>:</h4>
<p>In case of emergency there's also ⴲ U+2D32 TIFINAGH LETTER YABH</p>



<a name="199394194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199394194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199394194">(Jun 01 2020 at 16:58)</a>:</h4>
<p>That's <code>\slightlybiggerthannormaloplus</code></p>



<a name="199396441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199396441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199396441">(Jun 01 2020 at 17:16)</a>:</h4>
<p>ah I see --- it lives in 'Supplemental Mathematical Operators"</p>



<a name="199398459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199398459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199398459">(Jun 01 2020 at 17:31)</a>:</h4>
<p>⨁ U+2A01 N-ARY CIRCLED PLUS OPERATOR <a href="https://github.com/leanprover/vscode-lean/blob/master/translations.json#L781">should be <code>\O+</code></a> in vscode-lean.</p>



<a name="199447862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199447862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199447862">(Jun 02 2020 at 03:48)</a>:</h4>
<p>OK i took a stab at coming up with an API for free modules. It's mostly just specializing Kenny's direct_sum API to the non-dependent case. (I am sure there are things I could improve upon stylistically...)</p>
<p>However, the "punchline" lemma <code>free.surj_of_fg</code> still seems surprisingly hard to prove, because of the difficulties Kevin noted regarding coercion between various subset types. I have an outline of the proof at the bottom below. Unfortunately, at the key moment, the <code>transitivity</code> tactic fails to work for reasons that are mysterious to me.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
       <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">direct_sum_module</span>
       <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span>
       <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finsupp_vector_space</span>
       <span class="n">ring_theory</span><span class="bp">.</span><span class="n">noetherian</span>
       <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span>
       <span class="n">tactic</span>

<span class="kn">section</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">def</span> <span class="n">free</span> <span class="o">(</span><span class="n">R</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">][</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">:=</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u₁</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⨁</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">500</span> <span class="n">ι</span><span class="o">:</span><span class="mi">25</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span>

<span class="kn">instance</span> <span class="n">free</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span>  <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">add_comm_group</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
<span class="kn">instance</span> <span class="n">free</span><span class="bp">.</span><span class="n">module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">ι</span><span class="o">}</span>

<span class="kn">abbreviation</span> <span class="n">free</span><span class="bp">.</span><span class="n">to_module</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
   <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="o">(</span><span class="n">R</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">))</span>  <span class="bp">→</span>  <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
   <span class="n">direct_sum</span><span class="bp">.</span><span class="n">to_module</span> <span class="n">R</span> <span class="n">ι</span> <span class="n">M</span>
<span class="kn">abbreviation</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span>
     <span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">free</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">ext</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span>

<span class="kn">lemma</span> <span class="n">free</span><span class="bp">.</span><span class="n">ext_iff</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">split</span><span class="o">,</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">i</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">abbreviation</span> <span class="n">free</span><span class="bp">.</span><span class="n">lof</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">lof</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>

<span class="n">def</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="n">free</span><span class="bp">.</span><span class="n">lof</span> <span class="n">i</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">noncomputable</span> <span class="n">def</span> <span class="n">free</span><span class="bp">.</span><span class="n">to_finsupp</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">support</span> <span class="o">:=</span> <span class="n">dfinsupp</span><span class="bp">.</span><span class="n">support</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">to_fun</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">mem_support_to_fun</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">finish</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span><span class="o">(</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="err">•</span> <span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span>
<span class="o">)</span>

<span class="c1">-- kronecker delta on ι with values in R</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">δ</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="mi">0</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">free</span><span class="bp">.</span><span class="n">apply_eq_component</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span><span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">free</span><span class="bp">.</span><span class="n">to_finsupp</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_std_basis</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">δ</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
 <span class="k">begin</span> <span class="n">rw</span> <span class="n">δ</span><span class="o">,</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span>
<span class="o">{</span><span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">,</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span><span class="bp">.</span><span class="n">lof_self</span><span class="o">]},</span>
<span class="o">{</span><span class="k">have</span> <span class="n">H</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span><span class="bp">.</span><span class="n">of</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">i</span> <span class="n">j</span> <span class="mi">1</span><span class="o">,</span>
 <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_rec_constant</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
 <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">R</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">,</span>
 <span class="n">replace</span> <span class="n">this</span> <span class="o">:</span> <span class="o">(</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">lof</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">R</span><span class="o">)</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="n">free</span><span class="bp">.</span><span class="n">lof</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">H</span><span class="o">,</span> <span class="n">finish</span><span class="o">}</span>
<span class="kn">end</span>

<span class="n">noncomputable</span> <span class="kn">lemma</span> <span class="n">free</span><span class="bp">.</span><span class="n">equiv_finsupp</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">to_fun</span>  <span class="o">:=</span> <span class="n">free</span><span class="bp">.</span><span class="n">to_finsupp</span><span class="o">,</span>
    <span class="n">add</span>     <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span> <span class="n">induction</span> <span class="n">y</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}},</span>
    <span class="n">smul</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="bp">_</span> <span class="n">x</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}},</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span><span class="o">,</span>
  <span class="n">left_inv</span>  <span class="o">:=</span> <span class="k">begin</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">free</span><span class="bp">.</span><span class="n">ext_iff</span><span class="o">,</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span><span class="o">)],</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">comp_std_basis</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">δ</span><span class="o">,</span>
                   <span class="n">mul_boole</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_ite_eq&#39;</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">],</span>
        <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">tauto</span> <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">intro</span> <span class="n">f</span><span class="o">,</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">component</span> <span class="n">i</span><span class="o">)],</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_boole</span><span class="o">,</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_ite_eq&#39;</span><span class="o">,</span> <span class="n">δ</span><span class="o">,</span>
            <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="o">,</span> <span class="n">comp_std_basis</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span>
            <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">],</span>
        <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">finish</span> <span class="kn">end</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">is_basis_std_basis</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_basis</span> <span class="n">ι</span> <span class="n">R</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">is_basis</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
<span class="c1">-- linear independence</span>
<span class="o">{</span><span class="n">rw</span> <span class="n">linear_independent_iff&#39;</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span> <span class="n">rw</span> <span class="n">free</span><span class="bp">.</span><span class="n">ext_iff</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span> <span class="n">replace</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span> <span class="n">i</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">,</span> <span class="n">comp_std_basis</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">δ</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">finish</span><span class="o">},</span>
<span class="c1">-- span</span>
<span class="o">{</span><span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Inf_eq_top</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span>
<span class="n">ext1</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span> <span class="n">intros</span> <span class="n">hx</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">replace</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span>
        <span class="o">{</span><span class="n">intro</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H</span><span class="o">,</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="k">from</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
<span class="n">apply</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span><span class="n">finish</span><span class="o">},</span>
    <span class="o">{</span><span class="n">intros</span> <span class="n">i</span> <span class="n">r</span><span class="o">,</span> <span class="k">have</span> <span class="n">Hi</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">free</span><span class="bp">.</span><span class="n">lof</span> <span class="n">i</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">mul_one</span> <span class="n">r</span><span class="o">,</span> <span class="err">←</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">],</span>
    <span class="k">from</span> <span class="n">a</span><span class="bp">.</span><span class="n">smul_mem</span> <span class="n">r</span> <span class="n">Hi</span><span class="o">},</span>
    <span class="o">{</span><span class="n">intros</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">from</span> <span class="n">a</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">}}</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">lmap_of_elt</span><span class="bp">.</span><span class="n">smul</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">):</span>
     <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="err">•</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="n">x</span>
<span class="o">:=</span> <span class="k">begin</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">s</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="kn">end</span>
<span class="n">def</span> <span class="n">lmap_of_elt</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">):</span> <span class="n">R</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
    <span class="n">linear_map</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">R</span><span class="o">),</span> <span class="n">r</span><span class="err">•</span><span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">add_smul</span> <span class="n">x</span> <span class="n">y</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">lmap_of_elt</span><span class="bp">.</span><span class="n">smul</span> <span class="n">R</span> <span class="n">m</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">elt_of_lmap_of_elt_of_one</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">lmap_of_elt</span> <span class="n">R</span> <span class="n">m</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">rw</span> <span class="n">lmap_of_elt</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">coe_mk</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">]</span> <span class="kn">end</span>

<span class="n">def</span> <span class="n">lmap_of_elts</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">free</span><span class="bp">.</span><span class="n">to_module</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="n">lmap_of_elt</span> <span class="n">R</span> <span class="o">(</span><span class="n">m</span> <span class="n">i</span><span class="o">))</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">lmap_of_elts</span> <span class="n">R</span>

<span class="kn">lemma</span> <span class="n">needs_a_name</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">lmap_of_elts</span><span class="o">,</span> <span class="n">rw</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">to_module_lof</span><span class="o">],</span>
<span class="k">from</span> <span class="o">(</span><span class="n">elt_of_lmap_of_elt_of_one</span> <span class="n">R</span> <span class="o">(</span><span class="n">m</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="c1">-- set_option trace.simplify.rewrite true</span>
<span class="kn">lemma</span> <span class="n">free</span><span class="bp">.</span><span class="n">surj_of_fg</span> <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">],</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">π</span>  <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">cases</span> <span class="n">hfg</span> <span class="k">with</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="k">let</span> <span class="n">ι₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">s</span><span class="o">,</span> <span class="k">let</span> <span class="n">ι</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="err">↥</span><span class="n">ι₀</span><span class="o">,</span>
<span class="n">use</span> <span class="n">ι</span><span class="o">,</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="o">{</span><span class="n">apply_instance</span><span class="o">},</span>
<span class="k">let</span> <span class="n">π₀</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span>
<span class="k">let</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="n">π₀</span><span class="o">,</span>
<span class="n">fconstructor</span><span class="o">,</span> <span class="o">{</span><span class="n">use</span> <span class="n">π</span><span class="o">},</span>
<span class="o">{</span><span class="k">let</span> <span class="n">πι</span> <span class="o">:=</span> <span class="n">π</span> <span class="err">&#39;&#39;</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">),</span>
<span class="k">have</span> <span class="n">Rπι_eq_πRι</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span_image</span> <span class="n">R</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">)</span> <span class="n">π</span><span class="o">,</span>
<span class="n">replace</span>  <span class="n">Rπι_eq_πRι</span> <span class="o">:</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span> <span class="bp">=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">map</span> <span class="n">π</span> <span class="err">⊤</span> <span class="o">:=</span> <span class="k">by</span>
    <span class="o">{</span><span class="n">rw</span> <span class="err">←</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_basis_std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">exact</span> <span class="n">Rπι_eq_πRι</span><span class="o">},</span>
<span class="n">intro</span> <span class="n">m</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hs</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">mem_span</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">replace</span> <span class="n">this</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">subset_span</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">πι</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">s_le_πι</span> <span class="o">:</span> <span class="err">↑</span><span class="n">s</span> <span class="err">⊆</span> <span class="n">πι</span> <span class="o">:=</span>
 <span class="k">begin</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">πι</span><span class="o">,</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
    <span class="n">intros</span> <span class="n">i₀</span> <span class="n">hi₀</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="n">use</span> <span class="n">i₀</span><span class="o">,</span> <span class="n">tauto</span> <span class="kn">end</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">πi</span> <span class="o">:=</span> <span class="n">π</span> <span class="o">(</span><span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">)),</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">i₀</span> <span class="bp">=</span> <span class="n">πi</span><span class="o">,</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">replace</span> <span class="n">this</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">image_eq_range</span> <span class="n">π</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">),</span>

        <span class="k">have</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">set</span><span class="bp">.</span><span class="n">mem_range</span> <span class="n">M</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">)),</span> <span class="n">π</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">πi</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span>

        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span> <span class="n">π</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">πi</span><span class="o">),</span>
            <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span><span class="o">,</span> <span class="n">use</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">use</span> <span class="n">i</span><span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">πi</span> <span class="bp">=</span> <span class="n">π₀</span> <span class="n">i</span> <span class="o">:=</span>
        <span class="k">begin</span>
            <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">needs_a_name</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">π₀</span> <span class="n">i</span><span class="o">,</span> <span class="n">finish</span><span class="o">,</span>
        <span class="kn">end</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">this</span> <span class="o">:</span> <span class="n">π₀</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
 <span class="kn">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span> <span class="o">:=</span>
 <span class="k">begin</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span> <span class="c1">-- transitivity, -- does not work for some reason</span>
    <span class="n">sorry</span>
 <span class="kn">end</span><span class="o">,</span>
 <span class="c1">-- should be easy to finish from here</span>
 <span class="n">sorry</span><span class="o">,</span>
<span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span>
</code></pre></div>



<a name="199450038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450038">(Jun 02 2020 at 04:42)</a>:</h4>
<p>I got the proof of the last lemma to work by manually doing the <code>transitivity</code>. I also put all the <code>free.*</code> lemmas/definitions inside a <code>namespace</code>, which I assume is the right thing to do. See below for the version with these corrections. The proof of <code>surj_of_fg</code> is still way too painful for what it is, though, so I welcome suggestions if anyone has some.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
       <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">direct_sum_module</span>
       <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span>
       <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finsupp_vector_space</span>
       <span class="n">ring_theory</span><span class="bp">.</span><span class="n">noetherian</span>
       <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span>
       <span class="n">tactic</span>


<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">def</span> <span class="n">free</span> <span class="o">(</span><span class="n">R</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">ι</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">][</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">:=</span> <span class="n">direct_sum</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">free</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u₁</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⨁</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">500</span> <span class="n">ι</span><span class="o">:</span><span class="mi">25</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">free</span> <span class="n">R</span> <span class="n">ι</span>


<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span>  <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">add_comm_group</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">ι</span><span class="o">}</span>

<span class="kn">abbreviation</span> <span class="n">to_module</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
   <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span> <span class="o">(</span><span class="n">R</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">))</span>  <span class="bp">→</span>  <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
   <span class="n">direct_sum</span><span class="bp">.</span><span class="n">to_module</span> <span class="n">R</span> <span class="n">ι</span> <span class="n">M</span>
<span class="kn">abbreviation</span> <span class="n">component</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span>
     <span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">component</span> <span class="n">i</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">component</span> <span class="n">i</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
  <span class="bp">@</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">ext</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span>

<span class="kn">lemma</span> <span class="n">ext_iff</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">component</span> <span class="n">i</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">component</span> <span class="n">i</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">split</span><span class="o">,</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">i</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">abbreviation</span> <span class="n">lof</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">lof</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span>

<span class="n">def</span> <span class="n">std_basis</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="n">lof</span> <span class="n">i</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">noncomputable</span> <span class="n">def</span> <span class="n">to_finsupp</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">support</span> <span class="o">:=</span> <span class="n">dfinsupp</span><span class="bp">.</span><span class="n">support</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">to_fun</span>  <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">component</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">mem_support_to_fun</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">finish</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">of_finsupp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span><span class="o">(</span>
    <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="err">•</span> <span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span>
<span class="o">)</span>

<span class="c1">-- kronecker delta on ι with values in R</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">δ</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">ite</span> <span class="o">(</span><span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="mi">0</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">apply_eq_component</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span><span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">to_finsupp</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">component</span> <span class="n">i</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_std_basis</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="n">component</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">std_basis</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">δ</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
 <span class="k">begin</span> <span class="n">rw</span> <span class="n">δ</span><span class="o">,</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span>
<span class="o">{</span><span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">std_basis</span><span class="o">,</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span><span class="bp">.</span><span class="n">lof_self</span><span class="o">]},</span>
<span class="o">{</span><span class="k">have</span> <span class="n">H</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span><span class="bp">.</span><span class="n">of</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">i</span> <span class="n">j</span> <span class="mi">1</span><span class="o">,</span>
 <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_rec_constant</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
 <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">component</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">R</span><span class="o">)</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">component</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">std_basis</span><span class="o">,</span>
 <span class="n">replace</span> <span class="n">this</span> <span class="o">:</span> <span class="o">(</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">lof</span> <span class="n">R</span> <span class="n">ι</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">R</span><span class="o">)</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="n">lof</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">H</span><span class="o">,</span> <span class="n">finish</span><span class="o">}</span>
<span class="kn">end</span>

<span class="n">noncomputable</span> <span class="kn">lemma</span> <span class="n">equiv_finsupp</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">to_fun</span>  <span class="o">:=</span> <span class="n">to_finsupp</span><span class="o">,</span>
    <span class="n">add</span>     <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span> <span class="n">induction</span> <span class="n">y</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}},</span>
    <span class="n">smul</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="bp">_</span> <span class="n">x</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">induction</span> <span class="n">x</span><span class="o">,</span> <span class="n">all_goals</span> <span class="o">{</span><span class="n">refl</span><span class="o">}},</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">of_finsupp</span><span class="o">,</span>
  <span class="n">left_inv</span>  <span class="o">:=</span> <span class="k">begin</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ext_iff</span><span class="o">,</span> <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">of_finsupp</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span> <span class="o">(</span><span class="n">component</span> <span class="n">i</span><span class="o">)],</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">comp_std_basis</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">δ</span><span class="o">,</span>
                   <span class="n">mul_boole</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_ite_eq&#39;</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">],</span>
        <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">tauto</span> <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">intro</span> <span class="n">f</span><span class="o">,</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">component</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">of_finsupp</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">of_finsupp</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span> <span class="o">(</span><span class="n">component</span> <span class="n">i</span><span class="o">)],</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_boole</span><span class="o">,</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_ite_eq&#39;</span><span class="o">,</span> <span class="n">δ</span><span class="o">,</span>
            <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="o">,</span> <span class="n">comp_std_basis</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span>
            <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">],</span>
        <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">finish</span> <span class="kn">end</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">is_basis_std_basis</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_basis</span> <span class="n">ι</span> <span class="n">R</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="n">std_basis</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">is_basis</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
<span class="c1">-- linear independence</span>
<span class="o">{</span><span class="n">rw</span> <span class="n">linear_independent_iff&#39;</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ext_iff</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span> <span class="n">replace</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span> <span class="n">i</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">,</span> <span class="n">comp_std_basis</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">δ</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">finish</span><span class="o">},</span>
<span class="c1">-- span</span>
<span class="o">{</span><span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Inf_eq_top</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span>
<span class="n">ext1</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span> <span class="n">intros</span> <span class="n">hx</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">replace</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="n">std_basis</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">by</span>
        <span class="o">{</span><span class="n">intro</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H</span><span class="o">,</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="k">from</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
<span class="n">apply</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span><span class="n">finish</span><span class="o">},</span>
    <span class="o">{</span><span class="n">intros</span> <span class="n">i</span> <span class="n">r</span><span class="o">,</span> <span class="k">have</span> <span class="n">Hi</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">lof</span> <span class="n">i</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">mul_one</span> <span class="n">r</span><span class="o">,</span> <span class="err">←</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">],</span>
    <span class="k">from</span> <span class="n">a</span><span class="bp">.</span><span class="n">smul_mem</span> <span class="n">r</span> <span class="n">Hi</span><span class="o">},</span>
    <span class="o">{</span><span class="n">intros</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">from</span> <span class="n">a</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">}}</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">lmap_of_elt</span><span class="bp">.</span><span class="n">smul</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">):</span>
     <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="err">•</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="n">x</span>
<span class="o">:=</span> <span class="k">begin</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">s</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">algebra</span><span class="bp">.</span><span class="n">id</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="kn">end</span>
<span class="n">def</span> <span class="n">lmap_of_elt</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">):</span> <span class="n">R</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
    <span class="n">linear_map</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">R</span><span class="o">),</span> <span class="n">r</span><span class="err">•</span><span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">add_smul</span> <span class="n">x</span> <span class="n">y</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">lmap_of_elt</span><span class="bp">.</span><span class="n">smul</span> <span class="n">R</span> <span class="n">m</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">elt_of_lmap_of_elt_of_one</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">lmap_of_elt</span> <span class="n">R</span> <span class="n">m</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span> <span class="n">rw</span> <span class="n">lmap_of_elt</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">coe_mk</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">]</span> <span class="kn">end</span>

<span class="n">def</span> <span class="n">lmap_of_elts</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">to_module</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">),</span> <span class="n">lmap_of_elt</span> <span class="n">R</span> <span class="o">(</span><span class="n">m</span> <span class="n">i</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">needs_a_name</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
    <span class="o">(</span><span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">std_basis</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">lmap_of_elts</span><span class="o">,</span> <span class="n">rw</span> <span class="n">std_basis</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">direct_sum</span><span class="bp">.</span><span class="n">to_module_lof</span><span class="o">],</span>
<span class="k">from</span> <span class="o">(</span><span class="n">elt_of_lmap_of_elt_of_one</span> <span class="n">R</span> <span class="o">(</span><span class="n">m</span> <span class="n">i</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span>
<span class="c1">-- set_option trace.simplify.rewrite true</span>
<span class="kn">lemma</span> <span class="n">surj_of_fg</span> <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">],</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">π</span>  <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">cases</span> <span class="n">hfg</span> <span class="k">with</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="k">let</span> <span class="n">ι₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">s</span><span class="o">,</span> <span class="k">let</span> <span class="n">ι</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="err">↥</span><span class="n">ι₀</span><span class="o">,</span>
<span class="n">use</span> <span class="n">ι</span><span class="o">,</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="o">{</span><span class="n">apply_instance</span><span class="o">},</span>
<span class="k">let</span> <span class="n">π₀</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span>
<span class="k">let</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="n">π₀</span><span class="o">,</span>
<span class="n">fconstructor</span><span class="o">,</span> <span class="o">{</span><span class="n">use</span> <span class="n">π</span><span class="o">},</span>
<span class="o">{</span><span class="k">let</span> <span class="n">πι</span> <span class="o">:=</span> <span class="n">π</span> <span class="err">&#39;&#39;</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">πι&#39;</span> <span class="o">:</span>
     <span class="n">πι</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span> <span class="n">π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">))</span>
    <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">image_eq_range</span> <span class="n">π</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">)),</span>
<span class="k">have</span> <span class="n">Rπι_eq_πRι</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span_image</span> <span class="n">R</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">std_basis</span><span class="o">)</span> <span class="n">π</span><span class="o">,</span>
<span class="n">replace</span>  <span class="n">Rπι_eq_πRι</span> <span class="o">:</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span> <span class="bp">=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">map</span> <span class="n">π</span> <span class="err">⊤</span> <span class="o">:=</span> <span class="k">by</span>
    <span class="o">{</span><span class="n">rw</span> <span class="err">←</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_basis_std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">exact</span> <span class="n">Rπι_eq_πRι</span><span class="o">},</span>
<span class="n">intro</span> <span class="n">m</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hs</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">mem_span</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">replace</span> <span class="n">this</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">subset_span</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">πι</span><span class="o">,</span>
 <span class="n">replace</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span><span class="err">∈</span> <span class="n">πι</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
 <span class="k">have</span> <span class="n">s_le_πι</span> <span class="o">:</span> <span class="err">↑</span><span class="n">s</span> <span class="err">⊆</span> <span class="n">πι</span> <span class="o">:=</span>
 <span class="k">begin</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">πι</span><span class="o">,</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
    <span class="n">intros</span> <span class="n">i₀</span> <span class="n">hi₀</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="n">use</span> <span class="n">i₀</span><span class="o">,</span> <span class="n">tauto</span> <span class="kn">end</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">πi</span> <span class="o">:=</span> <span class="n">π</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">)),</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">i₀</span> <span class="bp">=</span> <span class="n">πi</span><span class="o">,</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">set</span><span class="bp">.</span><span class="n">mem_range</span> <span class="n">M</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">std_basis</span><span class="o">)),</span> <span class="n">π</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">πi</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span>

        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span> <span class="n">π</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">πi</span><span class="o">),</span>
            <span class="o">{</span><span class="n">rw</span> <span class="n">πι&#39;</span><span class="o">,</span><span class="n">apply</span> <span class="n">baz</span><span class="o">,</span> <span class="k">from</span> <span class="n">this</span><span class="o">},</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span><span class="o">,</span> <span class="n">use</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">use</span> <span class="n">i</span><span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">πi</span> <span class="bp">=</span> <span class="n">π₀</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">needs_a_name</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">π₀</span> <span class="n">i</span><span class="o">,</span> <span class="n">finish</span><span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">this</span> <span class="o">:</span> <span class="n">π₀</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
 <span class="kn">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span> <span class="o">:=</span>
 <span class="k">begin</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span><span class="o">),</span>
        <span class="n">tauto</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">s_le_πι</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">πι</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
    <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="k">from</span> <span class="n">foo</span> <span class="n">i</span> <span class="o">(</span><span class="n">s_le_πι</span> <span class="n">i</span> <span class="n">hi</span><span class="o">),</span>
 <span class="kn">end</span><span class="o">,</span>
 <span class="c1">--  easy to finish from here</span>
 <span class="n">rw</span> <span class="n">Rπι_eq_πRι</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">map</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
 <span class="n">use</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">free</span>
</code></pre></div>



<a name="199450349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450349">(Jun 02 2020 at 04:49)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> Wow, nice work. I encourage you to also look at the API for finsupp. For example, there is <code>finsupp.single</code> which is almost the Kronecker delta (except that it takes any scalar, instead of fixing on <code>1</code>). It would be good to do the same thing here, as it is predictable.<br>
I'll now load the code into VScode.</p>



<a name="199450408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450408">(Jun 02 2020 at 04:50)</a>:</h4>
<p>I'll take a look at <code>single</code> tomorrow. Here is a slightly improved version of <code>surj_of_fg</code> removing some back-and-forth nonsense:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">surj_of_fg</span> <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">],</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">π</span>  <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">cases</span> <span class="n">hfg</span> <span class="k">with</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="k">let</span> <span class="n">ι₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">s</span><span class="o">,</span> <span class="k">let</span> <span class="n">ι</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span> <span class="err">↥</span><span class="n">ι₀</span><span class="o">,</span>
<span class="n">use</span> <span class="n">ι</span><span class="o">,</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="o">{</span><span class="n">apply_instance</span><span class="o">},</span>
<span class="k">let</span> <span class="n">π₀</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span>
<span class="k">let</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="n">π₀</span><span class="o">,</span>
<span class="n">fconstructor</span><span class="o">,</span> <span class="o">{</span><span class="n">use</span> <span class="n">π</span><span class="o">},</span>
<span class="o">{</span><span class="k">let</span> <span class="n">πι</span> <span class="o">:=</span> <span class="n">π</span> <span class="err">&#39;&#39;</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">πι&#39;</span> <span class="o">:</span>
     <span class="n">πι</span> <span class="bp">=</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span> <span class="n">π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">))</span>
    <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">image_eq_range</span> <span class="n">π</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">)),</span>
<span class="k">have</span> <span class="n">Rπι_eq_πRι</span> <span class="o">:=</span>
    <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span_image</span> <span class="n">R</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">std_basis</span><span class="o">)</span> <span class="n">π</span><span class="o">,</span>
<span class="n">replace</span>  <span class="n">Rπι_eq_πRι</span> <span class="o">:</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span> <span class="bp">=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">map</span> <span class="n">π</span> <span class="err">⊤</span> <span class="o">:=</span> <span class="k">by</span>
    <span class="o">{</span><span class="n">rw</span> <span class="err">←</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_basis_std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">exact</span> <span class="n">Rπι_eq_πRι</span><span class="o">},</span>
<span class="n">intro</span> <span class="n">m</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hs</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
 <span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">mem_span</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">replace</span> <span class="n">this</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span><span class="o">),</span>
 <span class="k">have</span> <span class="n">foo</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">submodule</span><span class="bp">.</span><span class="n">subset_span</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">πι</span><span class="o">,</span>
 <span class="n">replace</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span><span class="err">∈</span> <span class="n">πι</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">tauto</span><span class="o">},</span>
 <span class="k">have</span> <span class="n">s_le_πι</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">πι</span> <span class="o">:=</span>
 <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">i₀</span> <span class="n">hi₀</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span> <span class="o">:=</span> <span class="k">begin</span> <span class="n">fconstructor</span><span class="o">,</span> <span class="n">use</span> <span class="n">i₀</span><span class="o">,</span> <span class="n">tauto</span> <span class="kn">end</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">πi</span> <span class="o">:=</span> <span class="n">π</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">)),</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">i₀</span> <span class="bp">=</span> <span class="n">πi</span><span class="o">,</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">baz</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">set</span><span class="bp">.</span><span class="n">mem_range</span> <span class="n">M</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">std_basis</span><span class="o">)),</span> <span class="n">π</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">πi</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span>

        <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span><span class="o">))),</span> <span class="n">π</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">πi</span><span class="o">),</span>
            <span class="o">{</span><span class="n">rw</span> <span class="n">πι&#39;</span><span class="o">,</span><span class="n">apply</span> <span class="n">baz</span><span class="o">,</span> <span class="k">from</span> <span class="n">this</span><span class="o">},</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">std_basis</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">i</span><span class="o">,</span> <span class="n">use</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">use</span> <span class="n">i</span><span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">πi</span> <span class="bp">=</span> <span class="n">π₀</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">needs_a_name</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">ι</span> <span class="bp">_</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">π₀</span> <span class="n">i</span><span class="o">,</span> <span class="n">finish</span><span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">this</span> <span class="o">:</span> <span class="n">π₀</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
 <span class="kn">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="n">πι</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">this</span><span class="o">,</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
                                       <span class="n">exact</span> <span class="n">foo</span> <span class="n">i</span> <span class="o">(</span><span class="n">s_le_πι</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)},</span>
 <span class="c1">-- easy to finish from here</span>
 <span class="n">rw</span> <span class="n">Rπι_eq_πRι</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">map</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
 <span class="n">use</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">ha</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199450562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450562">(Jun 02 2020 at 04:55)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> Concerning the notation: what do you think of</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="bp">`</span><span class="err">⨁</span><span class="bp">`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">f</span><span class="o">,</span> <span class="n">direct_sum</span> <span class="bp">_</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="kn">example</span> <span class="o">:</span> <span class="err">⨁</span> <span class="n">i</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">R</span> <span class="o">:=</span> <span class="mi">0</span>
</code></pre></div>



<a name="199450618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450618">(Jun 02 2020 at 04:56)</a>:</h4>
<p>That way, you generalise the notation to arbitrary direct sums.</p>



<a name="199450625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450625">(Jun 02 2020 at 04:56)</a>:</h4>
<p>It does mean that you wouldn't have explicit notation for <code>free</code></p>



<a name="199450631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450631">(Jun 02 2020 at 04:56)</a>:</h4>
<p>So that's a downside</p>



<a name="199450645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450645">(Jun 02 2020 at 04:57)</a>:</h4>
<p>hrm I need to think about it. I think the point of the API I made is that the non-dependent case should be simpler to work with. But I agree that it doesn't really make sense to restrict ⨁ to non-dependent direct sums!</p>



<a name="199450686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450686">(Jun 02 2020 at 04:58)</a>:</h4>
<p>API design is hard...</p>



<a name="199450689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450689">(Jun 02 2020 at 04:58)</a>:</h4>
<p>If the parser can handle superscripts, there's still the idea of using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi>ι</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{\oplus \iota}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">ι</span></span></span></span></span></span></span></span></span></span></span></span>.</p>



<a name="199450696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450696">(Jun 02 2020 at 04:59)</a>:</h4>
<p>When I copy paste your code into a new file, I get errors on this line</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">free</span><span class="bp">.</span><span class="n">module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">module</span>
</code></pre></div>


<p>It says it doesn't know about <code>direct_sum.module</code></p>



<a name="199450702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450702">(Jun 02 2020 at 04:59)</a>:</h4>
<p>Or more generally <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊕</mo><mi>ι</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M^{\oplus \iota}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">ι</span></span></span></span></span></span></span></span></span></span></span></span> -- that should always refer toa non-dependent sum!</p>



<a name="199450714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450714">(Jun 02 2020 at 04:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246647">Sam Lichtenstein</span> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199450689">said</a>:</p>
<blockquote>
<p>If the parser can handle superscripts, there's still the idea of using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi>ι</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{\oplus \iota}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">ι</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
</blockquote>
<p>Well... we can only do unicode <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="199450763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450763">(Jun 02 2020 at 05:00)</a>:</h4>
<p>Can you use the second version I posted at 12:42?</p>



<a name="199450773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450773">(Jun 02 2020 at 05:00)</a>:</h4>
<p>I switched to using a <code>namespace</code> and the <code>instance</code>s are anonymous now</p>



<a name="199450775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450775">(Jun 02 2020 at 05:00)</a>:</h4>
<p>Aah.. you are using an old mathlib, I guess</p>



<a name="199450781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450781">(Jun 02 2020 at 05:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="o">[</span><span class="n">package</span><span class="o">]</span>
<span class="n">name</span> <span class="bp">=</span> <span class="s2">&quot;pid&quot;</span>
<span class="n">version</span> <span class="bp">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">lean_version</span> <span class="bp">=</span> <span class="s2">&quot;leanprover-community/lean:3.14.0&quot;</span>
<span class="n">path</span> <span class="bp">=</span> <span class="s2">&quot;src&quot;</span>

<span class="o">[</span><span class="n">dependencies</span><span class="o">]</span>
<span class="n">mathlib</span> <span class="bp">=</span> <span class="o">{</span><span class="n">git</span> <span class="bp">=</span> <span class="s2">&quot;https://github.com/leanprover-community/mathlib&quot;</span><span class="o">,</span> <span class="n">rev</span> <span class="bp">=</span> <span class="s2">&quot;cc06d538378b040fcd60c80412cf6e5cecf93ff7&quot;</span><span class="o">}</span>
</code></pre></div>



<a name="199450783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450783">(Jun 02 2020 at 05:01)</a>:</h4>
<p>probably a few days old at least</p>



<a name="199450786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450786">(Jun 02 2020 at 05:01)</a>:</h4>
<p>Yup</p>



<a name="199450789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450789">(Jun 02 2020 at 05:02)</a>:</h4>
<p>Since then modules have been generalised to "semimodules" over semirings</p>



<a name="199450829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450829">(Jun 02 2020 at 05:02)</a>:</h4>
<p>So it's <code>direct_sum.semimodule</code> now</p>



<a name="199450831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450831">(Jun 02 2020 at 05:02)</a>:</h4>
<p>anyways bed time for me. I can try to merge with the upstream changes later this week</p>



<a name="199450833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450833">(Jun 02 2020 at 05:02)</a>:</h4>
<p>Sure</p>



<a name="199450844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450844">(Jun 02 2020 at 05:02)</a>:</h4>
<p>Also, when you post several screens of code, would you please put a copy on <code>gist.github</code> (or some other pastebin)?</p>



<a name="199450847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450847">(Jun 02 2020 at 05:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199450714">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246647">Sam Lichtenstein</span> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199450689">said</a>:</p>
<blockquote>
<p>If the parser can handle superscripts, there's still the idea of using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi>ι</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{\oplus \iota}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">ι</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
</blockquote>
<p>Well... we can only do unicode <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>
</blockquote>
<p>You can always use <code>^⨁</code></p>



<a name="199450848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450848">(Jun 02 2020 at 05:02)</a>:</h4>
<p>It's useful to see the code on zulip. But copy-pasting is hard</p>



<a name="199450860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450860">(Jun 02 2020 at 05:03)</a>:</h4>
<p>At least, I haven't figured out a trick to copy an entire code block from zulip. (They should offer a "copy this" link)</p>



<a name="199450862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450862">(Jun 02 2020 at 05:03)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> Sleep well!</p>



<a name="199450926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199450926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199450926">(Jun 02 2020 at 05:05)</a>:</h4>
<p><a href="https://gist.github.com/sflicht/53bdcdb1e3536e668736f7b4eb63cd79">https://gist.github.com/sflicht/53bdcdb1e3536e668736f7b4eb63cd79</a></p>



<a name="199451156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199451156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199451156">(Jun 02 2020 at 05:11)</a>:</h4>
<blockquote>
<p><code>instance : module R ⨁[ι] R := direct_sum.module</code></p>
</blockquote>
<p>The precedence here looks a little odd. It should probably be around 40, not 500</p>



<a name="199451213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199451213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199451213">(Jun 02 2020 at 05:13)</a>:</h4>
<blockquote>
<p><code>   (ι → (R →ₗ[R] M))  →  (⨁[ι] R) →ₗ[R] M :=</code></p>
</blockquote>
<p>The trailing precedence should also be higher than 0 so that the parentheses are not necessary here</p>



<a name="199451337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199451337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199451337">(Jun 02 2020 at 05:16)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> I've sent you an invitation for write access to non-master branches on the mathlib repo. You can put your code in a branch there. That way, others can easily take a look, and using <code>leanproject</code> we'll never have to worry about which version of <code>lean</code> or mathlib that's being used.</p>



<a name="199451522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199451522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199451522">(Jun 02 2020 at 05:23)</a>:</h4>
<p>One problem with the library is that a <em>lot</em> of linear algebra is developed in terms of finsupp, and not direct_sum.</p>



<a name="199451671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199451671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199451671">(Jun 02 2020 at 05:27)</a>:</h4>
<p>Ouch, <code>direct_sum</code> clearly hasn't been used a lot. There are names like <code>direct_sum.to_module</code> that do what a <em>mathematician</em> think they should do <span aria-label="shock" class="emoji emoji-1f628" role="img" title="shock">:shock:</span> <br>
(Instead of being some typeclass instance thingy, it's actually a linear map to a module. In mathlib parlance, that map would be called <code>lift</code>, blehh.)</p>



<a name="199451993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199451993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199451993">(Jun 02 2020 at 05:36)</a>:</h4>
<p>A reminder also that <code>has_finite_biproducts</code> landed in mathlib not so long ago, so there is a uniform API for talking about direct sums available in any category. We even use <code>⨁</code> as a notation for indexed biproducts.</p>



<a name="199452609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199452609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199452609">(Jun 02 2020 at 05:53)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> Here's my first attempt:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">free</span><span class="bp">.</span><span class="n">surj_of_fg</span> <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="o">(</span><span class="err">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">],</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="o">(</span><span class="err">⨁</span><span class="o">[</span><span class="n">ι</span><span class="o">]</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">π</span>  <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">hfg</span> <span class="k">with</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ι</span> <span class="o">:=</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">//</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">s</span><span class="o">},</span>
  <span class="k">let</span> <span class="n">π₀</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">lmap_of_elts</span> <span class="n">R</span> <span class="n">π₀</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">ι</span><span class="o">,</span> <span class="n">infer_instance</span><span class="o">,</span> <span class="n">π</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">m</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hs</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_span_iff_total</span> <span class="n">at</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hm</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">hl</span><span class="o">,</span> <span class="n">hlm</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span> <span class="n">l</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">hlm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">free</span><span class="bp">.</span><span class="n">of_finsupp</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_sum</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_congr</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="n">hil</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">π</span><span class="o">,</span> <span class="n">free</span><span class="bp">.</span><span class="n">std_basis</span><span class="o">,</span> <span class="n">lmap_of_elts</span><span class="o">,</span> <span class="n">π₀</span><span class="o">],</span>
  <span class="n">delta</span> <span class="n">free</span><span class="bp">.</span><span class="n">to_module</span> <span class="n">free</span><span class="bp">.</span><span class="n">lof</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">direct_sum</span><span class="bp">.</span><span class="n">to_module_lof</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">lmap_of_elt</span><span class="o">],</span>
<span class="kn">end</span>
</code></pre></div>



<a name="199452624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199452624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199452624">(Jun 02 2020 at 05:53)</a>:</h4>
<p>I also kicked out al the <code>decidable_eq \io</code> from the file, and added <code>noncomputable theory</code> to the top of the file.</p>



<a name="199454358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199454358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199454358">(Jun 02 2020 at 06:34)</a>:</h4>
<p>One thing to be said for <code>single</code> rather than the mathematician's more instinctive basis defined by the delta function is that the free module is the abelian group generated by <code>single i r</code> but it's only the R-module generated by the basis. This sounds like a minor point but actually in the theory of derivations of multivariable polynomials this was a decisive simplification. An induction procedure of the form "check on singles and on sums" is easier to use than "check on a basis and on sums and on R-multiples" because then you have to deal with multiplying a general element of the module by an element of R, and there are times when this is much harder to deal with than multiplying a basis element by R.</p>



<a name="199455271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199455271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199455271">(Jun 02 2020 at 06:50)</a>:</h4>
<p>In summary, <code>single</code> makes sure you make module elements in the simplest possible way</p>



<a name="199484385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199484385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199484385">(Jun 02 2020 at 12:38)</a>:</h4>
<p>there seems to be a bit of a tradeoff: using "good" API design (e.g. building linear algebra in terms of <code>finsupp</code> rather than <code>direct_sum</code>, favoring <code>single</code> rather than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\delta_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> , and calling the universal mapping-out property of the module co-product <code>lift</code> instead of <code>to_module</code>) actually makes the API more impenetrable for newer users like me (at least those coming from a more math rather than CS perspective)...</p>



<a name="199484947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199484947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199484947">(Jun 02 2020 at 12:43)</a>:</h4>
<p>I completely agree that <code>lift</code> is a bad name</p>



<a name="199485080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199485080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199485080">(Jun 02 2020 at 12:44)</a>:</h4>
<p><span class="user-mention" data-user-id="246647">@Sam Lichtenstein</span> On the other hand, if you have <code>group.to_monoid</code> and <code>ring.to_add_group</code> etc... as standard names for "forgetful functors" then you get caught of guard when <code>direct_sum.to_module</code> is something completely different.</p>



<a name="199485126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199485126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199485126">(Jun 02 2020 at 12:45)</a>:</h4>
<p>I don't think developping lin.alg in terms of <code>finsupp</code> instead of <code>direct_sum</code> is "good" API design.</p>



<a name="199485165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199485165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199485165">(Jun 02 2020 at 12:45)</a>:</h4>
<p>It just so happened. But certainly we need a good API for <code>direct_sum</code>. I was just observing that it isn't there yet.</p>



<a name="199492079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199492079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199492079">(Jun 02 2020 at 13:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I can't quite tell whether you would actually recommend using the high level category-theoretic direct sum API. AFAICT, it looks like algebra/category/Group/* shows that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">b</mi></mrow><annotation encoding="application/x-tex">\mathrm{Ab}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">b</span></span></span></span></span> is a preadditive category with all colimits and  finite direct sums are biproducts. (Does it actually show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">b</mi></mrow><annotation encoding="application/x-tex">\mathrm{Ab}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">b</span></span></span></span></span> is an abelian category, or maybe this follows from the above?) But there are comments pointing out that the colimit construction used there is at least not definitionally equal to the <code>finsupp</code> version used for linear algebra over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span> elsewhere in mathlib. And it seems like there is much less done for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mrow><mi mathvariant="normal">/</mi><mi>R</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm{Mod}_{/R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">M</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> than for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">b</mi></mrow><annotation encoding="application/x-tex">\mathrm{Ab}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">b</span></span></span></span></span> in algebra/category/Module/*.</p>



<a name="199493289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493289">(Jun 02 2020 at 13:49)</a>:</h4>
<p>Abelian categories were added somewhere the last 10? days... so I wouldn't expect there to be very much...</p>



<a name="199493374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493374">(Jun 02 2020 at 13:50)</a>:</h4>
<p>Well, the brief version is that the category_theory/ directory remains largely disconnected from the rest of the library. There are some good reasons for this (one should use only as much category theory as one needs...). The most important one is that people have found it hard to use, in large part because of universe polymorphism issues. This has got better recently, however.</p>



<a name="199493428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493428">(Jun 02 2020 at 13:50)</a>:</h4>
<p>But I think overall we should be trying to use it more.</p>



<a name="199493466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493466">(Jun 02 2020 at 13:51)</a>:</h4>
<p>I think the main reasons it is hard to use is that it has not been used, and it has not been designed with use in mind.</p>



<a name="199493561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493561">(Jun 02 2020 at 13:51)</a>:</h4>
<p>At least, not the special shapes of limits stuff (which would include <code>direct_sum</code>). The rest is mostly fine I think.</p>



<a name="199493589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493589">(Jun 02 2020 at 13:51)</a>:</h4>
<p>I don't think "it has not been designed with use in mind"</p>



<a name="199493646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493646">(Jun 02 2020 at 13:52)</a>:</h4>
<p>I mostly got started on it because I wanted to play with automation, but then got sucked in to trying to provide things that it seemed people wanted...</p>



<a name="199493681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493681">(Jun 02 2020 at 13:52)</a>:</h4>
<p>but, as Reid says, the special shapes of limits stuff has never been particularly satisfactory.</p>



<a name="199493700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493700">(Jun 02 2020 at 13:52)</a>:</h4>
<p>But it would certainly help if people who wrote that part of the library could show us how to <em>use</em> it.</p>



<a name="199493845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493845">(Jun 02 2020 at 13:53)</a>:</h4>
<p>I do think the special shapes of limits stuff is just really hard. In the rest of the library we just ignore this issue completely.</p>



<a name="199493988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199493988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199493988">(Jun 02 2020 at 13:54)</a>:</h4>
<p>e.g. I spent quite a while trying to define <code>homeomorph.sum_prod_distrib : (α ⊕ β) × γ ≃ₜ α × γ ⊕ β × γ</code> in terms of <code>homeomorph.sigma_prod_distrib : ((Σ i, σ i) × β) ≃ₜ (Σ i, (σ i × β))</code>, and eventually I just gave up and copied the proof</p>



<a name="199494314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199494314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199494314">(Jun 02 2020 at 13:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199493700">said</a>:</p>
<blockquote>
<p>But it would certainly help if people who wrote that part of the library could show us how to <em>use</em> it.</p>
</blockquote>
<p>Is there anything in particular you think would be helpful? Personally I found it reasonably easy to get my head around when I first tried, and it's been getting gradually better (although I agree it's not particularly nice to use)</p>



<a name="199494464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199494464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199494464">(Jun 02 2020 at 13:57)</a>:</h4>
<p>(deleted)</p>



<a name="199494643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199494643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199494643">(Jun 02 2020 at 13:58)</a>:</h4>
<p>In terms of using it, I hope that we've now laid good foundations for doing homological algebra, which should come quickly now.</p>



<a name="199494783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199494783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199494783">(Jun 02 2020 at 13:59)</a>:</h4>
<p>Similarly with abelian categories and semisimplicity around the corner, I think it will be useful in the near future as we start doing some representation theory.</p>



<a name="199495156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199495156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199495156">(Jun 02 2020 at 14:01)</a>:</h4>
<p>I think the thing for me is that map_cone and relatives can be pretty annoying to use, especially when related to limits of special shapes but I have <em>no idea</em> how one would do it better</p>



<a name="199496042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199496042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199496042">(Jun 02 2020 at 14:07)</a>:</h4>
<p>Having usable homological algebra using category theory would be awesome. Of course the other big test is sheaf theory.</p>



<a name="199496120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199496120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199496120">(Jun 02 2020 at 14:08)</a>:</h4>
<p>So you could try to do sheaf cohomology, and check all boxes.</p>



<a name="199496186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199496186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199496186">(Jun 02 2020 at 14:08)</a>:</h4>
<p>Sheaf theory should be coming soon!</p>



<a name="199496332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199496332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199496332">(Jun 02 2020 at 14:09)</a>:</h4>
<p>Testing the interface with the concrete world could be something like relating sheaf cohomology with a low tech definition of Cech cohomology for instance (when it makes sense).</p>



<a name="199500329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199500329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199500329">(Jun 02 2020 at 14:31)</a>:</h4>
<p>What I would love to see is the fact that, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> are two <em>homeomorphic</em> compact subsets of the sphere <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">S^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>−</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">S^n - K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>−</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">S^n - L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> have the same number of connected components (which contains Jordan curve theorem as a trivial case). A.k.a. Alexander duality. I have just seen on Wikipedia that this follows from a more general theorem of completely abstract flavor <a href="https://en.wikipedia.org/wiki/Spanier%E2%80%93Whitehead_duality">https://en.wikipedia.org/wiki/Spanier%E2%80%93Whitehead_duality</a>, for which I can't parse the statement :)</p>



<a name="199501470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199501470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199501470">(Jun 02 2020 at 14:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Are your <code>K</code> and <code>L</code> homeomorphic?</p>



<a name="199501500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199501500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199501500">(Jun 02 2020 at 14:35)</a>:</h4>
<p>Otherwise I don't see how to believe your claim</p>



<a name="199502507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199502507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199502507">(Jun 02 2020 at 14:42)</a>:</h4>
<p>Yes, obviously. That's what the original message says now :)</p>



<a name="199502871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199502871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199502871">(Jun 02 2020 at 14:45)</a>:</h4>
<p>is there really a non-circular proof of the Jordan curve theorem along such lines?</p>



<a name="199503123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199503123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199503123">(Jun 02 2020 at 14:47)</a>:</h4>
<p>Yes</p>



<a name="199503141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199503141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam Lichtenstein <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199503141">(Jun 02 2020 at 14:47)</a>:</h4>
<p>cool</p>



<a name="199507668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199507668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199507668">(Jun 02 2020 at 15:17)</a>:</h4>
<p>In fact I think the Jordan curve theorem is proved in this way in HOL Light, and maybe also Isabelle</p>



<a name="199508811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199508811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199508811">(Jun 02 2020 at 15:23)</a>:</h4>
<p>oh, actually I see not using Alexander duality, but still using homology<br>
<a href="https://www.mathematics.pitt.edu/hales60/pdf/Harrison-John.pdf">https://www.mathematics.pitt.edu/hales60/pdf/Harrison-John.pdf</a></p>



<a name="199509635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199509635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199509635">(Jun 02 2020 at 15:28)</a>:</h4>
<p>The original proofs in HOL Light and Isabelle were naive proofs, without homology. It was refactored in HOL Light to use homology, but the Isabelle one is still the original one, with bare hands.</p>



<a name="199513142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199513142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199513142">(Jun 02 2020 at 15:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> we will get there in the end. Every time I've used the category theory library it's got easier. It's still really hard to use though. About a month ago I spent over an hour trying to do a trivial-on-paper codewars category theory question and then gave up. Every single new concept (natural transformations, pushouts/pullbacks, products, general limits, concrete categories, ...) comes with its own API and for some reason I find it much harder to extract the API from the source lean files than I do with something like an algebra file written by Kenny, where I just read it and then know what I'm doing immediately. I find it hard to believe that my understanding of pushouts is somehow deficient compared to my understanding of R-algebras, but somehow I still find pushouts harder to use than R-algebras. Writing those basic docs on natural transformations etc helped me, but I feel like I need to write basic docs on all the other things too before I can use it. I don't know why this is -- genuinely. There is some measure of "hard for Kevin to work with" which I can't quantify -- I really want to believe that category theory at the level I want to use it should be completely content-free (I only ever use very basic stuff about pullbacks and Yoneda etc in reality) whereas I feel that I'm doing harder stuff with algebra, but somehow I find algebra easier to formalise, in the sense that I can do it slowly, whereas with category theory sometimes I just can't do it at all. This is most definitely not a criticism of your work! It's just a frustrated brain-dump on my part.</p>



<a name="199672956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199672956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199672956">(Jun 03 2020 at 20:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199450860">said</a>:</p>
<blockquote>
<p>At least, I haven't figured out a trick to copy an entire code block from zulip. (They should offer a "copy this" link)</p>
</blockquote>
<p>There's a "view source button". After I click that, I click inside of the box that the text comes in, press cmd-a. Then all of the text is highlighted and i can copy it. I'm on macOS + chrome (but i'd guess that your setup has some similar functionality)</p>



<a name="199676334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199676334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199676334">(Jun 03 2020 at 21:02)</a>:</h4>
<p>Don't you then have to delete the <code> ``` </code>s?</p>



<a name="199678912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199678912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199678912">(Jun 03 2020 at 21:26)</a>:</h4>
<p>yes, I suppose so. I think it's lower friction to delete one line of text than to click an external link from zulip, but I can imagine someone else feeling differently</p>



<a name="199705164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/f.g.%20free%20modules/near/199705164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/f.2Eg.2E.20free.20modules.html#199705164">(Jun 04 2020 at 04:53)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> Thanks, that works. (Though I would still like a little 'copy-to-clipboard' button. I guess I should start an issue over at zulip's github.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/sheaves.20of.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html">sheaves of modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204996202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996202">(Jul 25 2020 at 09:14)</a>:</h4>
<p>I was thinking a bit about how to do sheaves of modules (over a fixed sheaf of rings <code>O</code>). (The difficult is already all at the presheaf level, I think.) (Everywhere here I'm just thinking about presheaves on a space: no sites, no toposes.)</p>
<p>I can think of three options, and none of them are great.</p>
<ol>
<li>
<p>Consider the category whose objects are pairs (R, M), with R a ring and M an R-module. Now take a presheaf valued in this category, and additionally ask for an isomorphism between the "ring part" of this presheaf and <code>O</code>.</p>
</li>
<li>
<p>Given <code>O</code>, we get a <code>Cat</code> valued presheaf, by sending each ring <code>R</code> to <code>Module R</code>. Now do the <a href="https://en.wikipedia.org/wiki/Grothendieck_construction">Grothendieck construction</a> on this (eek, 2-categorical stuff, dependent type theory hell everywhere!) and call this <code>C_O</code>. We can take a presheaf <code>F</code> with values in <code>C_O</code>, and ask for a natural isomorphism from (<code>F</code> composed with the "base" functor from <code>C_O</code> back to <code>(opens X)^op</code>) to the identity functor on <code>(opens X)^op</code>.</p>
</li>
<li>
<p>We can just write down what it means to be a presheaf of modules explicitly, not even attempting to make it a functor from <code>(opens X)^op</code> to somewhere... From this we can extract the underlying (non-dependent) presheaf of Types, and maybe hobble along using the general API only with that part.</p>
</li>
</ol>



<a name="204996300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996300">(Jul 25 2020 at 09:17)</a>:</h4>
<p>a module <code>M</code> over a ring <code>R</code> consists of:</p>
<ol>
<li>a structure of an abelian group on <code>M</code> (maps <code>+ : M \to M \to M</code> and <code>- : M \to M</code> and <code>0 : M</code> satisfying properties)</li>
<li>a scalar multiplication <code>R \to M \to M</code> satisfying more properties</li>
</ol>
<p>so likewise a sheaf of modules <code>M</code> over a sheaf of rings <code>R</code> consists of:</p>
<ol>
<li>a structure of an abelian group on <code>M</code> (maps <code>+ : M \to M \to M</code> and <code>- : M \to M</code> and <code>0 : M</code> satisfying properties)</li>
<li>a scalar multiplication <code>R \to M \to M</code> satisfying more properties</li>
</ol>



<a name="204996451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996451">(Jul 25 2020 at 09:21)</a>:</h4>
<p>or, categorically, a sheaf or rings is a ring object in the category of sheaves, and likewise for modules</p>



<a name="204996776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996776">(Jul 25 2020 at 09:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> How about the following (which is close to what Kenny says, but maybe a bit more explicit)</p>
<ol start="4">
<li><code>O</code> is a sheaf of rings. <code>M</code> is a presheaf valued in <code>Ab</code>. On top of that, one of the following:</li>
</ol>
<p>4.(a) we have the data <code>module (O U) (M U)</code> for every <code>U</code> + the statement that the restriction maps are linear. (Note: The restriction maps will not be bundled linear maps automatically.)<br>
4.(b) A morphism <code>O \hom End(M)</code><br>
4.(c) A morphism <code>O × M → M</code></p>



<a name="204996779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996779">(Jul 25 2020 at 09:32)</a>:</h4>
<p>Will Kenny's version, or something close to it</p>
<ol start="4">
<li>Think of the presheaf of rings <code>O</code> as a monoid object in presheaves of AddCommGroup, and think of a presheaf of modules as a module object for that monoid object</li>
</ol>
<p>satisfy Kevin / Johan?</p>



<a name="204996851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996851">(Jul 25 2020 at 09:35)</a>:</h4>
<p>It all depends on the API. We need to get access to all the existing library on modules. In particular, we need <code>module (O U) (M U)</code>, and lean should never have trouble inferring it. Also we need a way to talk about the restriction maps as <code>(O U)</code>-linear bundled homs.</p>



<a name="204996856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996856">(Jul 25 2020 at 09:35)</a>:</h4>
<p>And a good way to construct sheaves of modules.</p>



<a name="204996901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996901">(Jul 25 2020 at 09:36)</a>:</h4>
<p>So, whatever definition we choose, a great test would be to take a vector space <code>V</code> of <code>real</code> and see if we can turn functions <code>X → V</code> into a sheaf of modules over <code>X → real</code>.</p>



<a name="204996903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204996903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204996903">(Jul 25 2020 at 09:36)</a>:</h4>
<p>If that is painless, I consider that a huge indicator of being on the right path.</p>



<a name="204997186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204997186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204997186">(Jul 25 2020 at 09:46)</a>:</h4>
<p>Well, the restriction maps aren't exactly (O U)-linear maps, because the U is changing...  I don't think we really have existing API covering that.</p>



<a name="204997333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204997333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204997333">(Jul 25 2020 at 09:50)</a>:</h4>
<p>Well, if <code>U &lt; V</code> in <code>opens X</code>, then you can view <code>M U</code> as an <code>O V</code> module via the restriction <code>O V → O U</code>, and then the restriction <code>M V → M U</code> should be <code>O V</code>-linear.</p>



<a name="204997347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/204997347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#204997347">(Jul 25 2020 at 09:51)</a>:</h4>
<p>We will want to use that a lot. So we will need a way to access those maps as bundled homs (even if those bundled homs don't roll directly out of the definition, which I guess they won't, whatever we choose).</p>



<a name="205000164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000164">(Jul 25 2020 at 11:25)</a>:</h4>
<p>The first test/challenge is to define the tensor product of presheaves of modules. Then tensor product of sheaves of modules. Then Picard groups</p>



<a name="205000208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000208">(Jul 25 2020 at 11:26)</a>:</h4>
<p>Then Picard groups without universe bumping, but that's a question for the logicians</p>



<a name="205000223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000223">(Jul 25 2020 at 11:27)</a>:</h4>
<p>I've just run into 100 sheep.</p>



<a name="205000228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000228">(Jul 25 2020 at 11:28)</a>:</h4>
<p>The theorem we need is that tensor product is associative up to isomorphism</p>



<a name="205000267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000267">(Jul 25 2020 at 11:28)</a>:</h4>
<p>Then we can make Picard monoids</p>



<a name="205000274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000274">(Jul 25 2020 at 11:29)</a>:</h4>
<p>And the Picard group is I think the units of this monoid. So the goal should be the monoid of isomorphism classes of sheaves of modules</p>



<a name="205000371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000371">(Jul 25 2020 at 11:32)</a>:</h4>
<p>It seems to me that the sheafification issue and the "make sure you have access to the module API" question are basically disjoint and perhaps the module one should be solved first</p>



<a name="205000381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000381">(Jul 25 2020 at 11:33)</a>:</h4>
<p>The presheaf tensor product is nothing more than just taking tensor product on each open</p>



<a name="205000743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000743">(Jul 25 2020 at 11:46)</a>:</h4>
<p>Okay... the internal object route actually sounds pretty reasonable for all this. We'll show <code>presheaf Ab X</code> is symmetric monoidal. We'll think of <code>O</code> as a commutative monoid object internal to that. Anytime you have a commutative monoid in a symmetric (even just braided!) monoidal category, its category of module objects is monoidal.</p>



<a name="205000753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000753">(Jul 25 2020 at 11:47)</a>:</h4>
<p>So if we just define a presheaf of module objects to be a module object, we won't even need to transport this monoidal structure anywhere. :-)</p>



<a name="205000867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205000867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205000867">(Jul 25 2020 at 11:51)</a>:</h4>
<p>We should make sure we can do pushforwards and pullbacks along morphisms of ringed spaces, which are the same thing as morphisms of spaces equipped with a presheaf of rings</p>



<a name="205001458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001458">(Jul 25 2020 at 12:08)</a>:</h4>
<p>I think at the presheaf level <code>pushforward</code> has been in place for a while.</p>



<a name="205001460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001460">(Jul 25 2020 at 12:08)</a>:</h4>
<p>No pullback yet!</p>



<a name="205001536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001536">(Jul 25 2020 at 12:11)</a>:</h4>
<p>Oh for pullbacks you need tensor again</p>



<a name="205001588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001588">(Jul 25 2020 at 12:12)</a>:</h4>
<p>So the fundamental question is whether we can get a workable definition of presheaves of modules for which tensor product works</p>



<a name="205001600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001600">(Jul 25 2020 at 12:12)</a>:</h4>
<p>Sounds like someone should go add the definitions of braided and symmetric categories. :-)</p>



<a name="205001614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001614">(Jul 25 2020 at 12:13)</a>:</h4>
<p>Then commutative monoid objects in a braided category, then the tensor product on their module objects.</p>



<a name="205001626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001626">(Jul 25 2020 at 12:13)</a>:</h4>
<p>that should all be very formal, and hopefully not particularly painful.</p>



<a name="205001629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205001629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205001629">(Jul 25 2020 at 12:13)</a>:</h4>
<p>(That said, it is exactly for this stuff that I originally wanted <code>rewrite_search</code>...)</p>



<a name="205003474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205003474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205003474">(Jul 25 2020 at 13:13)</a>:</h4>
<p>So how does all this work? Equality of types is troublesome in type theory, but equality of terms is fine. This is why we don't use the type <code>module R</code> because equality of R-modules is not the right idea, we instead introduce a new type M and have a typeclass <code>module R M</code>. However we can have the category of R-modules, that is a better thing to do somehow. So similarly a sheaf of rings on X shouldn't be a type, we should either put some kind of typeclass structure on a map from opens to rings, or make a category. But is it a good idea to make the typeclass first and then build the category on top?</p>



<a name="205003524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205003524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205003524">(Jul 25 2020 at 13:14)</a>:</h4>
<p>I guess we're just firmly committing ourselves to not talking about equalities and only talk about isomorphisms instead.</p>



<a name="205004885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205004885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205004885">(Jul 25 2020 at 13:56)</a>:</h4>
<p>I'm confused by your question, Kevin, but it's late, so perhaps I'll try again tomorrow.</p>
<p>A presheaf of rings on X is functor <code>(opens X)^op \func Ring</code>. That automatically receives a category instance, with morphisms natural tranformations. The category of sheaves is just defined as the induced category given by forgetting the sheaf condition.</p>



<a name="205005185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205005185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205005185">(Jul 25 2020 at 14:04)</a>:</h4>
<p>I'm saying that a presheaf of rings _could_ be a family of types and you could make a typeclass just like we do for modules</p>



<a name="205005261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205005261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205005261">(Jul 25 2020 at 14:07)</a>:</h4>
<p>And then you could bundle it to make the category</p>



<a name="205005389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205005389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205005389">(Jul 25 2020 at 14:10)</a>:</h4>
<p>And a sheaf of modules could similarly be another function M from opens to Type and then you have a typeclass forall U, abelian group (M U) and then forall U, module (R U) (M U) could be another typeclass</p>



<a name="205005463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205005463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205005463">(Jul 25 2020 at 14:12)</a>:</h4>
<p>Is it possible to bundle a typeclass which takes more than one type as input?</p>



<a name="205005472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/sheaves%20of%20modules/near/205005472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/sheaves.20of.20modules.html#205005472">(Jul 25 2020 at 14:12)</a>:</h4>
<p>Can we "bundle <code>module</code>"?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
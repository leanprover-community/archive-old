---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/finset.20puzzle.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html">finset puzzle</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="186520877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186520877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186520877">(Jan 24 2020 at 18:41)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span>  <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- or to put it another way</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
<span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span> <span class="bp">_</span>  <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>There are two different ways to take a finite union of finite sets. Trying to prove directly that they are equal seems hard to me -- but am I missing something? Perhaps one should prove instead that they have the same elements?</p>



<a name="186520948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186520948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186520948">(Jan 24 2020 at 18:42)</a>:</h4>
<p>Yes, use <code>ext</code></p>



<a name="186521225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521225">(Jan 24 2020 at 18:45)</a>:</h4>
<p>This came up when I was trying to prove this:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">mv_polynomial</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">σ</span><span class="o">]</span> <span class="o">:</span>
<span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="n">bind</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p><code>vars</code> is something in the <code>mv_polynomial</code> API which I had not come across until the other day, but its interface seems very basic. Chris' instinct was to use <code>bind</code> to do unions like this -- but apparently it wasn't Johannes'. Of course as long as the API is there it doesn't matter, but when Chris proved for me that evaluating a polynomial at two different assignments of the variables which agree on the variables of the polynomial will give the same answer, he used bind and it came out really nicely.</p>



<a name="186521343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521343">(Jan 24 2020 at 18:46)</a>:</h4>
<p>gaargh, <code>finset.mem_sup</code> is not there because it's working in some arbitrary lattice</p>



<a name="186521540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521540">(Jan 24 2020 at 18:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span>
</pre></div>


<p>is what I'm left with</p>



<a name="186521615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521615">(Jan 24 2020 at 18:49)</a>:</h4>
<p>the sup is defined as a fold over union.</p>



<a name="186521663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521663">(Jan 24 2020 at 18:49)</a>:</h4>
<p>Is there a <code>mem_fold</code>?</p>



<a name="186521722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521722">(Jan 24 2020 at 18:50)</a>:</h4>
<p>I just don't know whether I'm supposed to be digging this low. All I want to prove is that evaluating a polynomial at two different assignments which agree on all the variables of the polynomial gives the same answer :-)</p>



<a name="186521751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521751">(Jan 24 2020 at 18:50)</a>:</h4>
<p>So, sorry the statement and feed it to an UG at xena (-;</p>



<a name="186521961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186521961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186521961">(Jan 24 2020 at 18:53)</a>:</h4>
<p>There's no <code>mem_fold</code> anywhere. I could prove it by induction I guess :-/ But when I launched into a proof the other day involving evaluations of mv_polynomials, Mario just came along and proved it with a very well-judged <code>simp</code>, and at Xena on Thursday when we were proving that the evaluations were equal if the assignments agreed on the support (as defined by <code>bind</code>) Chris stopped at some point and said "automation should do it from here". I am not sure I understand the full power of <code>simp</code> with these things.</p>



<a name="186522613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186522613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186522613">(Jan 24 2020 at 19:00)</a>:</h4>
<p>oh I see what to do -- there is sup_le and le_sup and those should give it me.</p>



<a name="186525422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186525422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186525422">(Jan 24 2020 at 19:30)</a>:</h4>
<p>gaargh <code>le_sup</code> isn't enough. I'm left with</p>
<div class="codehilite"><pre><span></span>1 goal
α : Type u_1,
s : finset α,
β : Type u_2,
_inst_2 : decidable_eq β,
f : α → finset β,
x : β,
hx : x ∈ finset.sup s f
⊢ ∃ (a : α) (H : a ∈ s), x ∈ f a
</pre></div>



<a name="186528174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186528174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186528174">(Jan 24 2020 at 19:57)</a>:</h4>
<p>Here is a proof assuming decidable equality on <code>\a</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span>  <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">s</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">s</span> <span class="n">hx</span> <span class="n">IH</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">IH</span><span class="o">])</span>
</pre></div>



<a name="186529196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186529196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186529196">(Jan 24 2020 at 20:07)</a>:</h4>
<p>And here is a proof without that assumption:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">y</span><span class="o">,</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_bind</span><span class="o">,</span> <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">le_sup</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">f</span> <span class="bp">_</span> <span class="n">hx</span><span class="o">,</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">hy</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup_le</span> <span class="bp">_</span><span class="o">,</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_bind</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="186529280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186529280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186529280">(Jan 24 2020 at 20:08)</a>:</h4>
<p>You indeed also need <code>sup_le</code>.</p>



<a name="186536736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186536736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186536736">(Jan 24 2020 at 21:36)</a>:</h4>
<p>Thanks a lot Floris. What frustrates me is that I still can't do an arbitrary puzzle like this immediately. Mulling things over I wondered whether it was worth proving that if you had a predicate on lattices with the property that P(x union y) was true iff P(x) or P(y) was true then some statement about sups was true</p>



<a name="186536811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186536811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186536811">(Jan 24 2020 at 21:37)</a>:</h4>
<p>True for sup iff true for one of the elements. Need P(bot) false too</p>



<a name="186538668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186538668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186538668">(Jan 24 2020 at 22:01)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> do you think it's crazy to prove the <code>vars</code> question and I should instead just re-define mv_polynomial.vars? Chris seemed to think that the bind version was much easier to work with. See for example his (untidied) proof of the thing I needed yesterday: <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20course/near/186420269" title="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20course/near/186420269">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic.20geometry.20course/near/186420269</a></p>



<a name="186548543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186548543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186548543">(Jan 25 2020 at 00:34)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> Here's a shorter proof without the assumption:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span>  <span class="o">:=</span>
<span class="k">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">s</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">s</span> <span class="n">hx</span> <span class="n">IH</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">IH</span><span class="o">])</span>
</pre></div>



<a name="186550291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186550291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186550291">(Jan 25 2020 at 01:12)</a>:</h4>
<p>Thanks Mario. Can you prove <span class="user-mention" data-user-id="110044">@Chris Hughes</span> ' <code>vars</code> defined via the bind is the same as <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span>'s '?</p>



<a name="186551086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186551086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186551086">(Jan 25 2020 at 01:30)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">finset</span><span class="bp">.</span><span class="n">bind_eq_sup</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">s</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">s</span> <span class="n">hx</span> <span class="n">IH</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">IH</span><span class="o">])</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">union_to_finset</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s</span> <span class="err">∪</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">s</span><span class="bp">.</span><span class="n">to_finset</span> <span class="err">∪</span> <span class="n">t</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">ext</span> <span class="n">a</span><span class="bp">;</span> <span class="n">simp</span>

<span class="kn">theorem</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">sup_to_finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">sup</span> <span class="n">s</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">bind</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">classical</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">s</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">s</span> <span class="n">hx</span> <span class="n">IH</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">IH</span><span class="o">])</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">σ</span><span class="o">]</span> <span class="o">:</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span><span class="bp">.</span><span class="n">bind</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">support</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">degrees</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">sup_to_finset</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">funext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">to_finset_to_multiset</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="186989498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finset%20puzzle/near/186989498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finset.20puzzle.html#186989498">(Jan 30 2020 at 14:10)</a>:</h4>
<p>A belated thanks for this Mario!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
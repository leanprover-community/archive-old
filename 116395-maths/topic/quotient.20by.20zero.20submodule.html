---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/quotient.20by.20zero.20submodule.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html">quotient by zero submodule</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197054048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197054048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197054048">(May 10 2020 at 12:58)</a>:</h4>
<p>Does Lean know how to "canonically identify" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mn>0</mn><mo>≅</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M/0 \cong M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>? And to treat the quotient map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">M \to M/0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">0</span></span></span></span> like the identity map?</p>



<a name="197054069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197054069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197054069">(May 10 2020 at 12:59)</a>:</h4>
<p>I'm trying to show that a field is a Henselian local ring, and part of the definition of a Henselian ring involves lifting along <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mi mathvariant="normal">/</mi><mi mathvariant="fraktur">m</mi></mrow><annotation encoding="application/x-tex">R \to R/\mathfrak{m}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord"><span class="mord mathfrak">m</span></span></span></span></span>. But if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">R = k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="fraktur">m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathfrak{m} = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.47534em;vertical-align:0em;"></span><span class="mord"><span class="mord mathfrak">m</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> then this is just the identity...</p>



<a name="197054138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197054138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197054138">(May 10 2020 at 13:00)</a>:</h4>
<p>Or is the right thing to do to show that <code>residue R</code> is a bijection in this case (when we have <code>[field R]</code>)?</p>



<a name="197054735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197054735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197054735">(May 10 2020 at 13:16)</a>:</h4>
<p>I think perhaps the correct way to do quotients is to prove every theorem about quotients on rings that satisfy the universal property of the quotient. That way you can prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is the quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.  The library unfortunately hasn't been set up to make this easy, but I think it should be refactored.</p>



<a name="197054773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197054773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197054773">(May 10 2020 at 13:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235423">Ashwin Iyengar</span> <a href="#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054048" title="#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054048">said</a>:</p>
<blockquote>
<p>Does Lean know how to "canonically identify" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mn>0</mn><mo>≅</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M/0 \cong M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>? And to treat the quotient map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">M \to M/0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">0</span></span></span></span> like the identity map?</p>
</blockquote>
<p>No. Once you write down a construction of the quotient <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">M/0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">0</span></span></span></span>, it is whatever it is and it's highly unlikely to be "the same" as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> in Lean's eyes. There are basically two approaches:</p>
<ol>
<li>Use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">M \to M/0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">0</span></span></span></span> as an isomorphism (it's easy to write down an inverse) and then lift along this isomorphism (which is just composition with the inverse).</li>
<li>Don't work with a specific model for the quotient map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant="normal">/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">M \to M/I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>, but characterize what it means to be one (e.g., surjective with kernel <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>); then the identity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M \to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> will qualify.</li>
</ol>



<a name="197055364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197055364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197055364">(May 10 2020 at 13:26)</a>:</h4>
<p>Also, we don't yet have the definition of a Henselian ring in mathlib, do we? I'd be very interested to see what you are working on!</p>



<a name="197055424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197055424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197055424">(May 10 2020 at 13:27)</a>:</h4>
<p>As much as it pains me to say it, it's usually better for technical reasons to choose definitions which don't involve quantifying over <code>Type</code></p>



<a name="197056750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197056750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197056750">(May 10 2020 at 13:54)</a>:</h4>
<p>On my job list is bundling <code>normal_subgroup G</code> and then rewriting quotients in group theory to use bundled normal subgroups.</p>



<a name="197056780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197056780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197056780">(May 10 2020 at 13:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197055364" title="#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197055364">said</a>:</p>
<blockquote>
<p>Also, we don't yet have the definition of a Henselian ring in mathlib, do we? I'd be very interested to see what you are working on!</p>
</blockquote>
<p>Yeah I'm working on this now! I'll push some more in a bit.</p>



<a name="197056783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197056783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197056783">(May 10 2020 at 13:54)</a>:</h4>
<p>But I have a lot of marking and a grant application deadline to juggle right now, as well as trying to write this Mathematics in Lean book with Jeremy, Patrick and Rob.</p>



<a name="197057369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057369">(May 10 2020 at 14:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054735" title="#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054735">said</a>:</p>
<blockquote>
<p>I think perhaps the correct way to do quotients is to prove every theorem about quotients on rings that satisfy the universal property of the quotient. That way you can prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is the quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.  The library unfortunately hasn't been set up to make this easy, but I think it should be refactored.</p>
</blockquote>
<p>I could try defining the notion of a quotient of a <code>nonzero_comm_ring</code> by an ideal using the universal property. Are there already examples of things defined using universal properties in Lean that I could use as a starting point?</p>



<a name="197057424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057424">(May 10 2020 at 14:12)</a>:</h4>
<p>Localisation of rings was set up this way in <span class="user-mention" data-user-id="132858">@Ramon Fernandez Mir</span> 's MSc thesis</p>



<a name="197057446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057446">(May 10 2020 at 14:13)</a>:</h4>
<p>It's available in the links on the leanprover-community website. Can I write some hashtag to link to this nowadays?</p>



<a name="197057492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057492">(May 10 2020 at 14:14)</a>:</h4>
<p>He defined what it meant for a homomorphism of rings to be isomorphic to a localisation, following an API idea of Strickland</p>



<a name="197057556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057556">(May 10 2020 at 14:15)</a>:</h4>
<p>For technical reasons this concept of being isomorphic to a localisation turned out to be very useful. Life was a lot more unbundled in those days though</p>



<a name="197057744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057744">(May 10 2020 at 14:18)</a>:</h4>
<p>You should make a new predicate for a ring homomorphism R -&gt; A saying that it is surjective and its kernel is I, and then every theorem that is proved for R/I you should prove as well for all rings A equipped with a map from R satisfying the predicate</p>



<a name="197057779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197057779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197057779">(May 10 2020 at 14:18)</a>:</h4>
<p>We are still experimenting in this area</p>



<a name="197058560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197058560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197058560">(May 10 2020 at 14:30)</a>:</h4>
<p>Ok. Then if I have a local ring, there should not be "the residue field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi mathvariant="fraktur">m</mi></mrow><annotation encoding="application/x-tex">R/\mathfrak{m}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord"><span class="mord mathfrak">m</span></span></span></span></span>", instead there should be a predicate <code>is_residue_field f</code> which is an alias of <code>is_quotient f m</code> where <code>f</code> is a ring homomorphism and <code>m</code> is the unique maximal ideal. And then maybe one proves the lemma that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mi mathvariant="normal">/</mi><mi mathvariant="fraktur">m</mi></mrow><annotation encoding="application/x-tex">R \to R/\mathfrak{m}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord"><span class="mord mathfrak">m</span></span></span></span></span> constructed in the usual way is a residue field?</p>



<a name="197058859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197058859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197058859">(May 10 2020 at 14:34)</a>:</h4>
<p>Yeah I guess the proof of the pudding will be in the eating here. I would just experiment.</p>



<a name="197059228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059228">(May 10 2020 at 14:40)</a>:</h4>
<p>fair enough, will do</p>



<a name="197059263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059263">(May 10 2020 at 14:41)</a>:</h4>
<p>With localisations we were well on the way to defining schemes, and then discovered that we had proved a sequence involving <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/fg]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span> was exact, but we needed it for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/f][1/g]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span>. We realised later on that we should have proved exactness of the sequence for any ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> which was isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/fg]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span>.</p>



<a name="197059349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059349">(May 10 2020 at 14:43)</a>:</h4>
<p>This is the difference between <a href="https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/1819-ug-projects/Fernandez-I-MirR-Schemes-in-Lean.pdf" title="https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/1819-ug-projects/Fernandez-I-MirR-Schemes-in-Lean.pdf">Ramon's work</a> and <a href="https://github.com/kbuzzard/lean-stacks-project" title="https://github.com/kbuzzard/lean-stacks-project">my earlier work with Kenny and Chris</a> which we wrote after only a few months of working with Lean and which contained several serious design flaws (but which taught us a lot about Lean).</p>



<a name="197059593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059593">(May 10 2020 at 14:49)</a>:</h4>
<p><span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span> After defining Henselian local rings, I think the first step to do is prove that:</p>
<ol>
<li>For every Henselian local ring, you can lift along every surjective <code>f : R → K</code>, where <code>K</code> is a field.</li>
<li>If <code>R</code> is a local ring, and satisfies lifting for some surjective <code>f : R → K</code>, where <code>K</code> is a field, then <code>R</code> is local Henselian.</li>
</ol>



<a name="197059812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059812">(May 10 2020 at 14:55)</a>:</h4>
<p>Or better yet, prove some lemma from the stacks project giving 11 equivalent characterisations. (But modify the statement so that it works for surjective ring maps to fields, instead of only <code>R/m</code>.)</p>



<a name="197059928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059928">(May 10 2020 at 14:58)</a>:</h4>
<p>In that case does</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>

<span class="n">class</span> <span class="n">henselian</span> <span class="kn">extends</span> <span class="n">local_ring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_henselian</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a₀</span> <span class="o">:</span> <span class="n">residue_field</span> <span class="n">R</span><span class="o">,</span> <span class="n">monic</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">is_root</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">residue</span> <span class="n">R</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span> <span class="n">a₀</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">is_root</span><span class="o">(</span><span class="n">derivative</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">residue</span> <span class="n">R</span><span class="o">)</span> <span class="n">p</span><span class="o">))</span> <span class="n">a₀</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">is_root</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">residue</span> <span class="n">R</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a₀</span><span class="o">)</span>
</code></pre></div>


<p>look like a sensible definition or should I <em>define</em> it using (2)?</p>



<a name="197059936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059936">(May 10 2020 at 14:59)</a>:</h4>
<p>if you define it using (2) you will run into universe issues</p>



<a name="197059939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197059939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197059939">(May 10 2020 at 14:59)</a>:</h4>
<p>or maybe not</p>



<a name="197060012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197060012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197060012">(May 10 2020 at 15:00)</a>:</h4>
<p>btw does this imply the more general Hensel theorem about factorizing polynomials, or does that require algebraic closure?</p>



<a name="197060202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197060202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197060202">(May 10 2020 at 15:05)</a>:</h4>
<p>The universe issues aren't a serious obstruction, but either way you are going to want to prove the equivalence of the two definitions and if you are going to do that anyways it's more ergonomic to use the one that doesn't involve quantification over Type as the definition.</p>



<a name="197060267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197060267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197060267">(May 10 2020 at 15:07)</a>:</h4>
<p>Typically you actually have some statements like (lifting for rings in Type u) =&gt; (some polynomial thing) =&gt; (lifting for rings in all universes), but the last one can't be expressed as the definition</p>



<a name="197060325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197060325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197060325">(May 10 2020 at 15:08)</a>:</h4>
<p>and in a hypothetical future world where we can automatically transfer properties from <code>R</code> to <code>ulift R</code>, it's a lot harder to do it if your definition involves quantification over types</p>



<a name="197060404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197060404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197060404">(May 10 2020 at 15:10)</a>:</h4>
<p>Ok I'll stick with my definition. And yes, it's equivalent to the definition which says that you can lift factorizations.</p>



<a name="197060421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197060421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197060421">(May 10 2020 at 15:11)</a>:</h4>
<p>One suggestion though, use more newlines!</p>



<a name="197063034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197063034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197063034">(May 10 2020 at 15:58)</a>:</h4>
<p>I'm going to submit a PR including the linear equivalence between <code>M</code> and <code>M/0</code> today or tomorrow, see <a href="https://github.com/leanprover-community/mathlib/blob/closed-complement/src/linear_algebra/basic.lean#L1673" title="https://github.com/leanprover-community/mathlib/blob/closed-complement/src/linear_algebra/basic.lean#L1673">here</a>.</p>



<a name="197065805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20by%20zero%20submodule/near/197065805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ramon Fernandez Mir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20by.20zero.20submodule.html#197065805">(May 10 2020 at 16:55)</a>:</h4>
<p>If it helps, what Kevin was referring to can be found here: <a href="https://github.com/ramonfmir/lean-scheme/blob/master/src/to_mathlib/localization/localization_alt.lean" title="https://github.com/ramonfmir/lean-scheme/blob/master/src/to_mathlib/localization/localization_alt.lean">https://github.com/ramonfmir/lean-scheme/blob/master/src/to_mathlib/localization/localization_alt.lean</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
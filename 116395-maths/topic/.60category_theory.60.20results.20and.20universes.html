---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html">`category_theory` results and universes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="168229540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/168229540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#168229540">(Jun 16 2019 at 00:55)</a>:</h4>
<p>Hi, do I understand correctly that (currently) there is no easy way to prove some results for all (concrete) categories, then apply them for <code>Type</code>s living in different universes? I mean, even if I define <code>is_conj (f : End X) (g : End Y) := ∃ h : X ≅ Y, f ≫ h = h ≫ g</code>, then in order to apply it to <code>X : Type u</code> and <code>Y : Type v</code> I have to use <code>ulift</code> functor.<br>
Do I understand correctly that there is no (simple) way to overcome this, because we obviously can't have a category of "all types from all universes"?</p>



<a name="168229718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/168229718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#168229718">(Jun 16 2019 at 01:00)</a>:</h4>
<p>Yes.</p>



<a name="169723241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723241">(Jul 05 2019 at 17:13)</a>:</h4>
<p>Hi again,<br>
What do you think about the following alternative approach to dealing with multiple universes:<br>
1. In most cases (may be, outside of <code>/category_theory</code>), use one universe.<br>
2. If really needed, use <code>ulift</code><br>
3. To make 2 possible, write a tactic that lifts properties/instances/... to <code>ulift</code>.<br>
This way it would be possible to, e.g., directly apply various category theory facts to groups/rings/etc. I guess there should be something bad about this approach (I mean, you must've had some reason not to take this path), but I fail to guess what exactly is bad.</p>



<a name="169723323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723323">(Jul 05 2019 at 17:14)</a>:</h4>
<p>I think the main difference is that universes are mostly handled automatically by lean, while <code>ulift</code> makes its presence known whenever you deal with it</p>



<a name="169723613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723613">(Jul 05 2019 at 17:19)</a>:</h4>
<p>How often somebody really needs more than one universe? My guess is that more rarely than someone needs to prove a lemma/def that can be stated for categories.</p>



<a name="169723703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723703">(Jul 05 2019 at 17:21)</a>:</h4>
<p>You would be surprised. A common one is if you have a ring <code>R</code> in <code>Type u</code> and then it interacts with a concrete structure like <code>int : Type 0</code></p>



<a name="169723766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723766">(Jul 05 2019 at 17:22)</a>:</h4>
<p>When do you need a ring <code>R</code> in <code>Type u</code> and not <code>Type</code>?</p>



<a name="169723785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723785">(Jul 05 2019 at 17:22)</a>:</h4>
<p>as soon as you start doing enough category theory that ZFC isn't enough</p>



<a name="169723800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723800">(Jul 05 2019 at 17:22)</a>:</h4>
<p>ZFC is always enough. It's just that sometimes it's a bit painful to show this</p>



<a name="169723804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723804">(Jul 05 2019 at 17:23)</a>:</h4>
<p>that's the kind of constraint you can't undo without a huge refactor</p>



<a name="169723820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723820">(Jul 05 2019 at 17:23)</a>:</h4>
<p>The ZFC'ists would argue that a ring in Type u is not a ring, it's something weirder.</p>



<a name="169723866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169723866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169723866">(Jul 05 2019 at 17:24)</a>:</h4>
<p>a conglomer-ring</p>



<a name="169726187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726187">(Jul 05 2019 at 18:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> For me, choosing between "explicit <code>ulift</code> in advanced topics of one branch of math" vs "restating almost every category theory result for every concrete category" would mean "go with option 1". But I understand that I'm not the one who decides. At least, now I know that all this extra code is not a complete waste of time.</p>



<a name="169726241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726241">(Jul 05 2019 at 18:06)</a>:</h4>
<p>What do you mean by "restating almost every category theory result for every concrete category"</p>



<a name="169726274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726274">(Jul 05 2019 at 18:07)</a>:</h4>
<p>The definition of a group hom is not provided by any category theory machination</p>



<a name="169726296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726296">(Jul 05 2019 at 18:07)</a>:</h4>
<p>AFAIK there aren't many theorems that would actually benefit from a category formulation</p>



<a name="169726298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726298">(Jul 05 2019 at 18:07)</a>:</h4>
<p>Probably, I badly formulated my thoughts.</p>



<a name="169726531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726531">(Jul 05 2019 at 18:11)</a>:</h4>
<p>Here are a few facts/defs I'd prefer to have in various categories for free:<br>
1. <code>iso</code> and <code>Aut</code> for groups, rings etc, compare with <code>data/equiv/algebra</code><br>
2. (semi)conjugacy of morphisms</p>



<a name="169726559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726559">(Jul 05 2019 at 18:11)</a>:</h4>
<p>(thinking about other examples)</p>



<a name="169726705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726705">(Jul 05 2019 at 18:13)</a>:</h4>
<p>While it might be nice to transport results from the category theory iso, I think we actually want a group_iso to have a particular definition as a structure</p>



<a name="169726761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726761">(Jul 05 2019 at 18:14)</a>:</h4>
<p>because people will be constructing these with structure builders and such</p>



<a name="169726887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726887">(Jul 05 2019 at 18:16)</a>:</h4>
<p>I think it would be good to have more meta-structure in the algebraic hierarchy...</p>



<a name="169726925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726925">(Jul 05 2019 at 18:17)</a>:</h4>
<p>Currently there is no (<code>meta</code>?) dictionary that relates <code>group</code>, <code>is_group_hom</code>, <code>is_group_hom.comp</code>, and <code>is_group_hom.id</code>,<br>
and similarly for <code>monoid</code> and <code>ring</code>, etc...</p>



<a name="169726986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169726986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169726986">(Jul 05 2019 at 18:17)</a>:</h4>
<p>If we had those, we could use a little <code>meta</code>-programming to define <code>Aut</code> in one go for all the cases that we care about.</p>



<a name="169727039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727039">(Jul 05 2019 at 18:18)</a>:</h4>
<p>We could unify a lot of boilerplate by looping over that dictionary.</p>



<a name="169727055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727055">(Jul 05 2019 at 18:18)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> Currently has a 400-line file that basically does that. And I'm sure that <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, <span class="user-mention" data-user-id="121918">@Edward Ayers</span>  and <span class="user-mention" data-user-id="110026">@Simon Hudon</span> can probably golf it to &lt; 300 lines in one evening.</p>



<a name="169727078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727078">(Jul 05 2019 at 18:19)</a>:</h4>
<p>Shame on me. I can't think about any other good example where the "non-category theory" version involves morphisms between types in different universes. I'm very sorry for starting this conversation without preparing examples.</p>



<a name="169727188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727188">(Jul 05 2019 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> If we have a (meta) dictionary like this, we can define corresponding categories "for free" as well.</p>



<a name="169727297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727297">(Jul 05 2019 at 18:23)</a>:</h4>
<p>Exactly, that is what Fabian has been focusing on so far.</p>



<a name="169727310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727310">(Jul 05 2019 at 18:23)</a>:</h4>
<p>But all sorts of definitions and little simp-lemmas could also be unified.</p>



<a name="169727734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727734">(Jul 05 2019 at 18:30)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  So, basically the idea is to move "really useful" category theory definitions/lemmas to a <code>meta def</code>, and define them (semi-)automatically with every concrete category?<br>
BTW, I think that it's better to have a command or a user attr, not one loop for the following reason. If we have one loop in one file, then all "ground work" for all concrete categories has to be below this file in the <code>import</code> tree. In particular, we can't use these autogenerated results in these files.</p>



<a name="169727829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727829">(Jul 05 2019 at 18:32)</a>:</h4>
<p>Sure, I guess the best thing would be something like</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">category</span> <span class="n">Aut</span> <span class="n">blah</span> <span class="n">foo</span> <span class="n">bar</span> <span class="n">etc</span><span class="o">]</span>
<span class="n">class</span> <span class="n">monoid</span> <span class="bp">...</span> <span class="o">:=</span> <span class="bp">...</span>
</pre></div>



<a name="169727851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727851">(Jul 05 2019 at 18:33)</a>:</h4>
<p>Of course we can't do that for the monoids we have atm, because they are locked into core. But we could still run a user-command to generate a bunch of stuff.</p>



<a name="169727928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169727928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169727928">(Jul 05 2019 at 18:34)</a>:</h4>
<p>How can you derive category before you have <code>is_monoid_hom</code>?</p>



<a name="169728024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169728024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169728024">(Jul 05 2019 at 18:36)</a>:</h4>
<p>You can autogenerate <code>is_monoid_hom</code>.</p>



<a name="169728257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169728257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169728257">(Jul 05 2019 at 18:40)</a>:</h4>
<p>An autogenerated <code>is_group_hom</code> will probably have <code>map_one</code> and <code>map_inv</code></p>



<a name="169728349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169728349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169728349">(Jul 05 2019 at 18:42)</a>:</h4>
<p>Also, it's better not to autogenerate <code>is_*_hom</code> for topology/analysis-related categories (e.g., metric spaces, topology, manifolds).</p>



<a name="169728393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169728393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169728393">(Jul 05 2019 at 18:43)</a>:</h4>
<p>Sure, so you should be able to define manually, and then add an entry to the dictionary.</p>



<a name="169728444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169728444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169728444">(Jul 05 2019 at 18:44)</a>:</h4>
<p>That shouldn't be too hard...</p>



<a name="169733144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169733144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169733144">(Jul 05 2019 at 20:11)</a>:</h4>
<blockquote>
<p>Mario Carneiro: While it might be nice to transport results from the category theory iso, I think we actually want a group_iso to have a particular definition as a structure<br>
Mario Carneiro: because people will be constructing these with structure builders and such</p>
</blockquote>
<p>I'm not sure what the objection is here. <code>iso</code> is defined just like <code>equiv</code>, it's a structure you define like so:</p>
<div class="codehilite"><pre><span></span>{ hom := ...,
  inv := ... }
</pre></div>


<p>and each of those <code>...</code> is constructing say a <code>subtype is_group_hom</code>.</p>



<a name="169734379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60category_theory%60%20results%20and%20universes/near/169734379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60category_theory.60.20results.20and.20universes.html#169734379">(Jul 05 2019 at 20:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span>  For many algebraic objects, with the current implementation you only need to prove that <code>hom</code> is an <code>is_group_hom</code>. Also, you don't need to use <code>ext</code> in proofs of <code>inv * hom = id</code> and <code>hom * inv = id</code>.<br>
Of course, a method like <code>of_equiv_hom (e : equiv α β) [is_group_hom e.to_fun] : iso α β</code> would solve this issue.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/DVRs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html">DVRs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="188142696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188142696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188142696">(Feb 13 2020 at 19:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">unique_nonzero_max_ideal</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">is_prime</span> <span class="bp">∧</span> <span class="n">P</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
</pre></div>


<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> what do you think?</p>



<a name="188143009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143009">(Feb 13 2020 at 19:46)</a>:</h4>
<p>Well, we already have <code>local_ring</code></p>



<a name="188143031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143031">(Feb 13 2020 at 19:46)</a>:</h4>
<p>So maybe you should <code>extend</code> that</p>



<a name="188143061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143061">(Feb 13 2020 at 19:46)</a>:</h4>
<p>and then add one extra condition saying that it's not a field</p>



<a name="188143208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143208">(Feb 13 2020 at 19:48)</a>:</h4>
<p>but a general local ring isn't a PID so I need to add that somehow, right?</p>



<a name="188143260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143260">(Feb 13 2020 at 19:49)</a>:</h4>
<p>You are already extending that, right?</p>



<a name="188143271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143271">(Feb 13 2020 at 19:49)</a>:</h4>
<p>I meant, in addition, extend local ring</p>



<a name="188143412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143412">(Feb 13 2020 at 19:51)</a>:</h4>
<p>I wonder whether we'll be happy with <code>[dvr R]</code> and <code>[pid R]</code>, etc... Or that we'd rather have <code>[comm_ring R] [is_dvr R]</code> and <code>[comm_ring R] [is_pid R]</code> etc...</p>



<a name="188143445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143445">(Feb 13 2020 at 19:51)</a>:</h4>
<p>The first version has more chances to lead to diamonds, I think</p>



<a name="188143550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143550">(Feb 13 2020 at 19:52)</a>:</h4>
<p>I never know if I'm allowed to extend PID and local ring because perhaps I just defined two different multiplications or something? I really have no understanding of this stuff and don't know a place where it's all written up coherently. I occasionally half-understand it for a while and then I just forget it all again.</p>



<a name="188143877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188143877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188143877">(Feb 13 2020 at 19:54)</a>:</h4>
<p>Aha, I think it's fine, but maybe you need to switch on the <code>old_structure_cmd</code></p>



<a name="188145502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188145502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188145502">(Feb 13 2020 at 20:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span><span class="o">,</span>
  <span class="n">local_ring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pseudouniformiser</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">is_unit</span> <span class="n">a</span><span class="o">)</span>
</pre></div>



<a name="188146043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188146043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188146043">(Feb 13 2020 at 20:16)</a>:</h4>
<p>Yeah, that seems fine. Although I would maybe not call the condition <code>pseudouniformiser</code></p>



<a name="188146075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/188146075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#188146075">(Feb 13 2020 at 20:16)</a>:</h4>
<p><code>exists_nonzero_nonunit</code>?</p>



<a name="195333635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195333635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195333635">(Apr 26 2020 at 12:56)</a>:</h4>
<p>Thinking about the proof that given a DVR you actually get a valuation, there's a slight stumbling block: I want to use <code>enat</code> and then do something like <code>R →*+ enat</code> which should be a map from the DVR <code>R</code> to <code>enat</code> which is a map of monoids, but the problem is that I want to think of <code>R</code> as a multiplicative monoid and <code>enat</code> as an additive monoid: it doesn't seem like <code>→*+</code> exists. One other option is to use multiplicative valuations landing in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbb{R}_{\geq 0}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.934069em;vertical-align:-0.24517899999999998em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span></span></span></span> but then it's not really clear where a uniformizer is supposed to go: there are infinitely many choices, none of which really stand out in general.</p>



<a name="195333813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195333813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195333813">(Apr 26 2020 at 13:02)</a>:</h4>
<p>Is there some systematic way to add in things like <code>→*+</code>?</p>



<a name="195335223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195335223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195335223">(Apr 26 2020 at 13:38)</a>:</h4>
<p>Alternatively, <code>\bbZ</code> and <code>\bbN</code> have <code>has_le</code>, but <code>multiplicative \bbZ</code> doesn't seem to preserve this, and I'm not sure whether <code>with_zero</code> defines a new ordering...</p>



<a name="195335249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195335249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195335249">(Apr 26 2020 at 13:39)</a>:</h4>
<p><span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span> they used valuations in <a href="https://leanprover-community.github.io/lean-perfectoid-spaces/" title="https://leanprover-community.github.io/lean-perfectoid-spaces/">the perfectoid project</a> which you might find helpful</p>



<a name="195335498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195335498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195335498">(Apr 26 2020 at 13:44)</a>:</h4>
<p>Yeah I guess what I want to use is linear_ordered_comm_group_with_zero.lean then: <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> is this destined for mathlib?</p>



<a name="195335533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195335533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195335533">(Apr 26 2020 at 13:45)</a>:</h4>
<p>But maybe this should be rewritten replacing <code>0</code> with <code>⊥</code> to avoid confusion with <code>0</code> in the integers?</p>



<a name="195336032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195336032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195336032">(Apr 26 2020 at 13:58)</a>:</h4>
<p>I guess I can achieve what I want if I have linear_ordered_comm_group_with_zero.lean, and some way to distinguish between the natural number <code>0</code> and the adjoined <code>0</code></p>



<a name="195338108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195338108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195338108">(Apr 26 2020 at 14:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235423">Ashwin Iyengar</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/195335498" title="#narrow/stream/116395-maths/topic/DVRs/near/195335498">said</a>:</p>
<blockquote>
<p>Yeah I guess what I want to use is linear_ordered_comm_group_with_zero.lean then: <span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> is this destined for mathlib?</p>
</blockquote>
<p>I think this can be PR'd. All prerequisites are now in mathlib, if I'm not mistaken. Note that it only works in a multiplicative setting though... so it doesn't yet solve your problem.</p>
<p>I think there are two questions that need to be answered:</p>
<ol>
<li>
<p>Should DVR's use multiplicative or additive valuations?</p>
</li>
<li>
<p>What ever the answer is to (1): what should the target type be of discrete valuations?</p>
</li>
</ol>
<p>Note that we could also opt for a "heretical" approach, in which we take a discrete additive valuation with target type the integers, and we require <code>val 0 = 0</code>, instead of <code>val  0 = infty</code>. This would create it's own problems, but it also solves a lot...</p>



<a name="195339207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195339207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195339207">(Apr 26 2020 at 15:27)</a>:</h4>
<p>Additive is what is usually done, but if we want to do multiplicative instead, one option for the target would be to just use a free group on one generator (written multiplicatively), define the obvious ordering on it, and then use your</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- Adjoining a zero element to a linearly ordered commutative group</span>
<span class="cm">gives a linearly ordered commutative group with zero.-/</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">linear_ordered_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">linear_ordered_comm_group_with_zero</span> <span class="o">(</span><span class="n">with_zero</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span><span class="bp">```</span>
</pre></div>


<p>I'll try this for now.</p>



<a name="195341519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195341519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195341519">(Apr 26 2020 at 16:25)</a>:</h4>
<p>Later on it might be convenient to have valuations taking values in a discrete subgroup of the rationals</p>



<a name="195341580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195341580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195341580">(Apr 26 2020 at 16:26)</a>:</h4>
<p>I think Johan is the expert in valuations now, there has been lot of movement since that valuation file was originally written, especially with group_with_zero</p>



<a name="195341707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195341707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195341707">(Apr 26 2020 at 16:29)</a>:</h4>
<p>We could do something like</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">to_discrete_valuation</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">cyclic</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">span</span> <span class="o">{</span><span class="n">g</span><span class="o">})</span> <span class="o">:</span>
<span class="n">discrete_valuation</span> <span class="n">R</span> <span class="n">G</span> <span class="n">g</span> <span class="o">:=</span>
</pre></div>


<p>maybe, and have the discrete valuation take values in an arbitrary infinite cyclic group... oh but I'm missing a proof that it's infinite</p>



<a name="195341852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195341852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195341852">(Apr 26 2020 at 16:33)</a>:</h4>
<p>An alternative is to use the general valuations as found in the perfectoid project, and define a predicate on those, saying that the valuation is discrete.</p>



<a name="195341916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195341916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195341916">(Apr 26 2020 at 16:34)</a>:</h4>
<p>Do you want <code>discrete_valuation_ring R</code> to be a <code>Prop</code> or will it record data (say a distinguished uniformiser...)?</p>



<a name="195342402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342402">(Apr 26 2020 at 16:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">prime_ideal&#39;</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>
<span class="o">(</span><span class="n">primality</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span><span class="bp">.</span><span class="n">is_prime</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_nonzero</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span>
<span class="o">(</span><span class="n">unique_nonzero_prime_ideal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">is_prime</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">prime_ideal&#39;</span><span class="o">)</span>
</pre></div>



<a name="195342405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342405">(Apr 26 2020 at 16:47)</a>:</h4>
<p>so it records some data</p>



<a name="195342447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342447">(Apr 26 2020 at 16:48)</a>:</h4>
<p>a PID with a unique nonzero prime ideal</p>



<a name="195342489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342489">(Apr 26 2020 at 16:50)</a>:</h4>
<p>Ok, I see. But it is a subsingleton. That seems like a fine definition</p>



<a name="195342540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342540">(Apr 26 2020 at 16:50)</a>:</h4>
<p>Then we construct a valuation basically by using the UFD structure and the fact that prime elements are uniformizers</p>



<a name="195342926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342926">(Apr 26 2020 at 17:01)</a>:</h4>
<p>In the perfectoid project we also had the notion of a <code>valued_ring</code>, which was a class that registered a (multiplicative) valuation on the ring.</p>



<a name="195342953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342953">(Apr 26 2020 at 17:02)</a>:</h4>
<p>One could have an is_discrete predicate on a valuation in the sense of Huber and a construction which goes from this to the Z-valued valuation. But I don't think it matters that traditionally the group law on Z with 0 is addition -- why not use multiplicative Z with 0?</p>



<a name="195342997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195342997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195342997">(Apr 26 2020 at 17:02)</a>:</h4>
<p>We might want to have two classes <code>discrete_valuation_ring R</code>, like you propose, and <code>discretely_valued_ring R</code>, for rings like Z_p that have a canonical valuation.</p>



<a name="195343020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343020">(Apr 26 2020 at 17:03)</a>:</h4>
<p>What structure do people use on Z with +infinity? Add, max, probably never multiplication, but external multiplication by Z yes. But we have all this on a group with 0</p>



<a name="195343030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343030">(Apr 26 2020 at 17:03)</a>:</h4>
<p>I'm still upset that it seems really painful to move back and forth between multiplicative and additive valuations...</p>



<a name="195343034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343034">(Apr 26 2020 at 17:03)</a>:</h4>
<p>So why not just bite the bullet and never use additive valuations?</p>



<a name="195343075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343075">(Apr 26 2020 at 17:04)</a>:</h4>
<p>It's either that or make add_group_with_zero</p>



<a name="195343077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343077">(Apr 26 2020 at 17:04)</a>:</h4>
<p>Because sometimes it's really nice and intuitive to reason about <code>int</code></p>



<a name="195343085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343085">(Apr 26 2020 at 17:04)</a>:</h4>
<p>Or with infinity or whatever</p>



<a name="195343088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343088">(Apr 26 2020 at 17:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/195343075" title="#narrow/stream/116395-maths/topic/DVRs/near/195343075">said</a>:</p>
<blockquote>
<p>It's either that or make add_group_with_zero</p>
</blockquote>
<p><code>add_group_with_infty</code></p>



<a name="195343096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343096">(Apr 26 2020 at 17:04)</a>:</h4>
<p>But I don't think the <code>to_additive</code> machinery is built with such translations in mind...</p>



<a name="195343105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343105">(Apr 26 2020 at 17:05)</a>:</h4>
<p>But I don't think the target Z really is a Z. It's certainly not the ring Z. It's the additive group Z with an occasional infinity</p>



<a name="195343124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343124">(Apr 26 2020 at 17:05)</a>:</h4>
<p>And an action of Z which is either a smul or a gpow</p>



<a name="195343196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343196">(Apr 26 2020 at 17:07)</a>:</h4>
<p>I don't see why we need to introduce the concept of an additive valuation at all. Just because it's in maths in some superficial way doesn't mean we need it. Or we could have it in this one off case. What did Rob use for p-adics?</p>



<a name="195343208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343208">(Apr 26 2020 at 17:07)</a>:</h4>
<p>norms...</p>



<a name="195343272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343272">(Apr 26 2020 at 17:08)</a>:</h4>
<p>I would be happy with multiplicative <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> with an added 0 element, but won't this cause notational trouble because you have the integer 0 and then the added 0?</p>



<a name="195343296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343296">(Apr 26 2020 at 17:09)</a>:</h4>
<p>There are ways around that.</p>



<a name="195343342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343342">(Apr 26 2020 at 17:10)</a>:</h4>
<p>We could define <code>free_group</code>, or something like that.</p>



<a name="195343348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343348">(Apr 26 2020 at 17:10)</a>:</h4>
<p>As in, don't actually use <code>int</code>, but use a different type.</p>



<a name="195343430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343430">(Apr 26 2020 at 17:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/195343348" title="#narrow/stream/116395-maths/topic/DVRs/near/195343348">said</a>:</p>
<blockquote>
<p>As in, don't actually use <code>int</code>, but use a different type.</p>
</blockquote>
<p>If you want, we could give it some names like <code>discrete_valuation.target_type</code>, or something fancier...</p>



<a name="195343556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343556">(Apr 26 2020 at 17:14)</a>:</h4>
<p>But it would be best to already include the extra <code>0</code> element in the definition of this type. You don't want to work with <code>with_zero foo</code> all the time, even though in "normal" maths we keep up that facade.</p>



<a name="195343565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343565">(Apr 26 2020 at 17:14)</a>:</h4>
<p>We did that for a long time in the perfectoid project, but it just became too painful.</p>



<a name="195343597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343597">(Apr 26 2020 at 17:15)</a>:</h4>
<p>Still, I wonder if you should settle on 1 target type. It might be better to characterise what it means to be a discrete valuation, as I proposed above.</p>



<a name="195343606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343606">(Apr 26 2020 at 17:15)</a>:</h4>
<p>Because otherwise you will regret it once you get a DVR with a different target type.</p>



<a name="195343651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343651">(Apr 26 2020 at 17:16)</a>:</h4>
<p>(Say some subset of the reals)</p>



<a name="195343661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195343661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195343661">(Apr 26 2020 at 17:16)</a>:</h4>
<p>We should really work to get the definition of a general valuation into mathlib</p>



<a name="195374804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195374804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195374804">(Apr 27 2020 at 05:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I think that sometimes it's useful to view <code>padic_val_int</code> as an <em>actual</em> integer, don't you think? But nevertheless we can probably get away with using multiplicative valuations as the default.</p>
<p><span class="user-mention" data-user-id="235423">@Ashwin Iyengar</span> I'm starting to think that we should just hurry up with PR'ing the basics of valuations from the perfectoid project. Stuff like equivalence of valuations etc would also be useful to you. And it would be silly to have to do all of that again.</p>
<p>Maybe we need a class like <code>normed_valued_ring R</code> that can be used for examples like <code>Z_p</code>, and will register both a norm and a valuation, and an axiom that claims the two are the same thing.</p>



<a name="195378643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195378643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195378643">(Apr 27 2020 at 06:55)</a>:</h4>
<p>Yeah if i have access to the perfectoid project stuff then I'm sure I can just go from there, but no rush</p>



<a name="195382632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/195382632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#195382632">(Apr 27 2020 at 07:45)</a>:</h4>
<p>I'll try to prioritise these PRs</p>



<a name="200535272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200535272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200535272">(Jun 11 2020 at 12:11)</a>:</h4>
<p>I am trying to state the following lemma</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span> <span class="o">]</span>
<span class="kn">open</span> <span class="n">discrete_valuation_ring</span>
<span class="n">def</span> <span class="n">uniformizers</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">π</span> <span class="bp">|</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">({</span><span class="n">π</span><span class="o">}</span> <span class="o">:</span><span class="n">set</span> <span class="n">R</span> <span class="o">)</span> <span class="bp">=</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">element_of_dvr</span> <span class="o">{</span><span class="n">r</span> <span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">nonzero</span><span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">unif</span><span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">uniformizers</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">,</span> <span class="n">associated</span> <span class="n">r</span> <span class="n">π</span><span class="bp">^</span><span class="n">n</span> <span class="o">:=</span>
</code></pre></div>


<p>and I get two errors : </p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">,</span>
<span class="n">r</span> <span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
<span class="n">nonzero</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">has_mem</span> <span class="n">R</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">)</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">],</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span>  <span class="c1">-- regarding the uniformizer</span>

<span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">,</span>
<span class="n">r</span> <span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
<span class="n">nonzero</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">unif</span> <span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">uniformizers</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="n">has_pow</span> <span class="kt">Prop</span> <span class="bp">ℕ</span>  <span class="c1">-- regarding \pi ^n</span>
</code></pre></div>


<p>I understand why the second error occurs, but don't know the right has_pow code to fix it. I don't know what causes the first error. Any help is appreciated, thanks!</p>



<a name="200536053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200536053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200536053">(Jun 11 2020 at 12:19)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> I think it might be better to write <code>def is_uniformizer (\pi : R) := ...</code></p>



<a name="200536108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200536108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200536108">(Jun 11 2020 at 12:20)</a>:</h4>
<p>You usually don't want to reason about the set of all uniformizers, just about one uniformizer.</p>



<a name="200536163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200536163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200536163">(Jun 11 2020 at 12:20)</a>:</h4>
<p>For the second error: it's trying to raise <code>associated r \pi</code> to the power <code>n</code>. That's not what you mean. So put parens around <code>\pi ^ n</code> <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="200547645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200547645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200547645">(Jun 11 2020 at 13:59)</a>:</h4>
<p>I see! That makes sense. </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_uniformizer</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">({</span><span class="n">π</span><span class="o">}</span> <span class="o">:</span><span class="n">set</span> <span class="n">R</span> <span class="o">)</span> <span class="bp">=</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span>

<span class="kn">lemma</span> <span class="n">element_of_dvr</span> <span class="o">{</span><span class="n">r</span> <span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">nonzero</span><span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">unif</span> <span class="o">:</span> <span class="n">is_uniformizer</span> <span class="n">π</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">,</span> <span class="n">associated</span> <span class="n">r</span> <span class="o">(</span><span class="n">π</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>


<p>shows the error</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">is_uniformizer</span> <span class="n">π</span>
<span class="n">term</span>
  <span class="n">π</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="err">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="err">?</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>


<p>Did I end up defining is_uniformizer as a function which gives output \pi?</p>



<a name="200547773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200547773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200547773">(Jun 11 2020 at 14:00)</a>:</h4>
<p>No, I guess that you have <code>variable (R : Type*)</code> somewhere above this definition.</p>



<a name="200547803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200547803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200547803">(Jun 11 2020 at 14:00)</a>:</h4>
<p>That makes <code>R</code> an explicit variable of <code>is_uniformizer</code>.</p>



<a name="200547851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200547851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200547851">(Jun 11 2020 at 14:01)</a>:</h4>
<p>So you have to type <code>is_uniformizer R \pi</code>, or you have to change it to <code>variable {R : Type*}</code></p>



<a name="200548105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200548105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200548105">(Jun 11 2020 at 14:02)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> Btw, about <code>element_of_dvr</code>... this is of course a useful statement. But don't you want the slightly stronger statement that says that there is also a unique unit such that <code>x = u * pi ^ n</code></p>



<a name="200549010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200549010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200549010">(Jun 11 2020 at 14:09)</a>:</h4>
<p>Yes, it might be needed for the well-definedness of the associated valuation. I will add it, thank you!</p>



<a name="200762335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200762335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200762335">(Jun 13 2020 at 11:41)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">local_ring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">)</span>
<span class="o">(</span><span class="n">principal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span> <span class="n">S</span><span class="bp">.</span><span class="n">is_principal</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">discrete_valuation</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">R</span> <span class="bp">→*</span> <span class="bp">ℤ</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">map_top&#39;</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="o">(</span><span class="n">map_add_leq&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">y</span><span class="o">))</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span> <span class="o">]</span>
<span class="kn">open</span> <span class="n">discrete_valuation_ring</span>
<span class="n">def</span> <span class="n">is_uniformizer</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">({</span><span class="n">π</span><span class="o">}</span> <span class="o">:</span><span class="n">set</span> <span class="n">R</span> <span class="o">)</span> <span class="bp">=</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span>

<span class="kn">lemma</span> <span class="n">element_of_dvr</span> <span class="o">{</span><span class="n">r</span> <span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">nonzero</span><span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">non_unit</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">unif</span> <span class="o">:</span> <span class="n">is_uniformizer</span> <span class="n">π</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">,</span> <span class="n">associated</span> <span class="n">r</span> <span class="o">(</span><span class="n">π</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>

<span class="k">begin</span>
<span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">is_principal</span><span class="bp">.</span><span class="n">mem_iff_generator_dvd</span> <span class="n">at</span> <span class="n">non_unit</span><span class="o">,</span>
</code></pre></div>


<p>The last line gives me the error,</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">rewrite</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span>
</code></pre></div>


<p>I realise why the rw statement is problematic, how can I fix it?</p>



<a name="200762407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200762407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200762407">(Jun 13 2020 at 11:43)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> There is already <code>principal_ideal_domain R</code>, you can also extend that. (That way, every DVR is automatically a PID in lean)</p>



<a name="200762524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200762524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200762524">(Jun 13 2020 at 11:46)</a>:</h4>
<p>also, your definition of discrete valuation seems to mix the additive and multiplicative points of view.</p>



<a name="200762547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200762547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200762547">(Jun 13 2020 at 11:46)</a>:</h4>
<p>I had tried that earlier, </p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span><span class="o">,</span> <span class="n">local_ring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">)</span>
</code></pre></div>


<p>gives the error</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="err">&#39;</span><span class="kn">structure</span><span class="err">&#39;</span> <span class="n">header</span><span class="o">,</span> <span class="n">field</span> <span class="err">&#39;</span><span class="n">add&#39;</span> <span class="k">from</span> <span class="err">&#39;</span><span class="n">local_ring&#39;</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">declared</span>
</code></pre></div>



<a name="200762554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200762554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200762554">(Jun 13 2020 at 11:47)</a>:</h4>
<p>Aah... right. The solution is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
</code></pre></div>


<p>That will merge the duplicate fields</p>



<a name="200763029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763029">(Jun 13 2020 at 12:00)</a>:</h4>
<p>That does it! The invalid rewrite tactic error stays, though..</p>



<a name="200763439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763439">(Jun 13 2020 at 12:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Should <code>submodule.is_prinicipal</code> be a class?</p>



<a name="200763565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763565">(Jun 13 2020 at 12:16)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">principal_ideal_domain</span><span class="bp">.</span><span class="n">principal</span> <span class="o">(</span><span class="n">nonunits_ideal</span> <span class="n">R</span><span class="o">)</span>
<span class="n">term</span>
  <span class="n">nonunits_ideal</span> <span class="n">R</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">ideal</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_comm_ring</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_local_ring</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">ideal</span> <span class="n">R</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">integral_domain</span><span class="bp">.</span><span class="n">to_comm_ring</span> <span class="n">R</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">principal_ideal_domain</span><span class="bp">.</span><span class="n">to_integral_domain</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_principal_ideal_domain</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)))</span>
</code></pre></div>


<p>With the following code</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">universe</span> <span class="kn">variable</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">local_ring</span> <span class="n">R</span><span class="o">,</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">discrete_valuation_ring</span>
<span class="kn">open</span> <span class="n">local_ring</span>

<span class="n">def</span> <span class="n">is_uniformizer</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">({</span><span class="n">π</span><span class="o">}</span> <span class="o">:</span><span class="n">set</span> <span class="n">R</span> <span class="o">)</span> <span class="bp">=</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span>

<span class="kn">lemma</span> <span class="n">element_of_dvr</span> <span class="o">{</span><span class="n">r</span> <span class="n">π</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">nonzero</span><span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">non_unit</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">nonunits_ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">unif</span> <span class="o">:</span> <span class="n">is_uniformizer</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃!</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">,</span> <span class="n">associated</span> <span class="n">r</span> <span class="o">(</span><span class="n">π</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">principal_ideal_domain</span><span class="bp">.</span><span class="n">principal</span> <span class="n">R</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nonunits_ideal</span> <span class="n">R</span><span class="o">),</span> <span class="c1">-- error is here</span>
  <span class="n">rw</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">is_principal</span><span class="bp">.</span><span class="n">mem_iff_generator_dvd</span> <span class="o">(</span><span class="n">nonunits_ideal</span> <span class="n">R</span><span class="o">)</span> <span class="n">at</span> <span class="n">non_unit</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="200763573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763573">(Jun 13 2020 at 12:16)</a>:</h4>
<p>This is not nice</p>



<a name="200763579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763579">(Jun 13 2020 at 12:17)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">discrete_valuation</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">R</span> <span class="bp">→*</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_top&#39;</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_add_leq&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>


<p>This doesn't look right. Are we supposed to be modelling the p-adic valuation or the p-adic norm? If the valuation then the valuation of 0 should be +infty. If the norm then the norm of pi will be between 0 and 1, and so which integer will you use?</p>



<a name="200763589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763589">(Jun 13 2020 at 12:17)</a>:</h4>
<p>I think we should ignore that code for now...</p>



<a name="200763596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763596">(Jun 13 2020 at 12:17)</a>:</h4>
<p>But I agree with the point</p>



<a name="200763652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763652">(Jun 13 2020 at 12:18)</a>:</h4>
<p>I've never really used <code>[principal_ideal_domain R]</code> before... I'm not sure if it's in optimal form.</p>



<a name="200763799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763799">(Jun 13 2020 at 12:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what's going on here?</p>



<a name="200763858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200763858">(Jun 13 2020 at 12:24)</a>:</h4>
<p>I'm starting to think more and more that we should just go for</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_local_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="c1">-- or</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_integral_domain</span> <span class="n">R</span><span class="o">]</span>
<span class="c1">-- or</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_principal_ideal_domain</span> <span class="n">R</span><span class="o">]</span>
<span class="c1">-- etc</span>
</code></pre></div>



<a name="200764027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764027">(Jun 13 2020 at 12:28)</a>:</h4>
<p>what's the question?</p>



<a name="200764047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764047">(Jun 13 2020 at 12:29)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/DVRs/near/200763565">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200763565</a></p>



<a name="200764051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764051">(Jun 13 2020 at 12:29)</a>:</h4>
<p>Is it about unbundling ring classes into mixins?</p>



<a name="200764058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764058">(Jun 13 2020 at 12:29)</a>:</h4>
<p>It's about inferred instances not being defeq</p>



<a name="200764133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764133">(Jun 13 2020 at 12:30)</a>:</h4>
<p>aha, this came up not too long ago</p>



<a name="200764150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764150">(Jun 13 2020 at 12:31)</a>:</h4>
<p>ooh, is this the "bug" that Kenny found?</p>



<a name="200764155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764155">(Jun 13 2020 at 12:31)</a>:</h4>
<p>With alternating old and new structures?</p>



<a name="200764158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764158">(Jun 13 2020 at 12:31)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/old_structure_cmd/near/199101684">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/old_structure_cmd/near/199101684</a></p>



<a name="200764209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764209">(Jun 13 2020 at 12:32)</a>:</h4>
<p>It's actually a kind of fundamental problem</p>



<a name="200764222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764222">(Jun 13 2020 at 12:33)</a>:</h4>
<p>One solution would be to always explode all instances into their constructors (which I think happens behind the scenes a lot anyway) but this seems pretty expensive</p>



<a name="200764261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764261">(Jun 13 2020 at 12:34)</a>:</h4>
<p>it also doesn't work for instances that are variables</p>



<a name="200764333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764333">(Jun 13 2020 at 12:36)</a>:</h4>
<p>So... how should we turn this into working code?</p>



<a name="200764399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764399">(Jun 13 2020 at 12:38)</a>:</h4>
<p>I suspect that sprinkling some old structures around will fix the problem</p>



<a name="200764421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764421">(Jun 13 2020 at 12:39)</a>:</h4>
<p>But new structure were introduced for a reason, right?</p>



<a name="200764426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764426">(Jun 13 2020 at 12:39)</a>:</h4>
<p>It seems like now everything has to become an old structure...</p>



<a name="200764434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764434">(Jun 13 2020 at 12:39)</a>:</h4>
<p>And the hierarchy is far from finished.</p>



<a name="200764477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764477">(Jun 13 2020 at 12:40)</a>:</h4>
<p><code>complete_discrete_valuation_ring</code> will throw some topology into the mix, etc...</p>



<a name="200764491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764491">(Jun 13 2020 at 12:41)</a>:</h4>
<p>Would it be really bad to have a spine for the hierarchy which wouldn't be too big (I mean, semigroup -&gt; monoid -&gt; group -&gt; ring -&gt; comm_ring -&gt; field, add or subtract a few things) and mixins for additional properties like we do for topological spaces?</p>



<a name="200764504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764504">(Jun 13 2020 at 12:41)</a>:</h4>
<p>I think that would be a good idea.</p>



<a name="200764612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764612">(Jun 13 2020 at 12:44)</a>:</h4>
<p>This is one reason why I would like to have an interactive graph of the hierarchy...</p>



<a name="200764617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764617">(Jun 13 2020 at 12:44)</a>:</h4>
<p>Oh wait, <code>discrete_valuation_ring</code> is actually broken</p>



<a name="200764626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764626">(Jun 13 2020 at 12:44)</a>:</h4>
<p>check out the constructor:</p>
<div class="codehilite"><pre><span></span><code><span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">to_comm_ring</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">to_nonzero</span> <span class="o">:</span> <span class="n">nonzero</span> <span class="n">R</span><span class="o">]</span>
<span class="o">(</span><span class="n">is_local</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">is_unit</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">a</span><span class="o">))</span> <span class="o">[</span><span class="bp">_</span><span class="n">to_integral_domain</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="n">R</span><span class="o">],</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">is_principal</span> <span class="n">S</span><span class="o">)</span> <span class="bp">→</span> <span class="n">nonunits_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="bp">→</span> <span class="n">discrete_valuation_ring</span> <span class="n">R</span>
</code></pre></div>



<a name="200764636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764636">(Jun 13 2020 at 12:45)</a>:</h4>
<p>note the separate appearance of <code>comm_ring R</code> and <code>integral_domain R</code></p>



<a name="200764642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764642">(Jun 13 2020 at 12:45)</a>:</h4>
<p>the unification problem fails because it's actually false</p>



<a name="200764682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764682">(Jun 13 2020 at 12:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/200764636">said</a>:</p>
<blockquote>
<p>note the separate appearance of <code>comm_ring R</code> and <code>integral_domain R</code></p>
</blockquote>
<p>How did that happen?</p>



<a name="200764687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764687">(Jun 13 2020 at 12:46)</a>:</h4>
<p>the double extends</p>



<a name="200764697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764697">(Jun 13 2020 at 12:47)</a>:</h4>
<p>Shouldn't old_structure_cmd take care of that?</p>



<a name="200764707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764707">(Jun 13 2020 at 12:47)</a>:</h4>
<p>As was noted previously, <code>old_structure_cmd</code> was not written with extensions of new structures in mind</p>



<a name="200764709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764709">(Jun 13 2020 at 12:47)</a>:</h4>
<p>Which structure isn't old?</p>



<a name="200764714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764714">(Jun 13 2020 at 12:47)</a>:</h4>
<p>Both, I think</p>



<a name="200764760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764760">(Jun 13 2020 at 12:48)</a>:</h4>
<p><code>local_ring</code> and <code>principal_ideal_domain</code> are both new structures</p>



<a name="200764766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764766">(Jun 13 2020 at 12:48)</a>:</h4>
<p>you can tell because if you <code>#print</code> them you don't get a mile long list of fields</p>



<a name="200764771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764771">(Jun 13 2020 at 12:49)</a>:</h4>
<p>Which of course they shouldn't have been, because they extend old structures, and they aren't the top of the hierarchy</p>



<a name="200764781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764781">(Jun 13 2020 at 12:49)</a>:</h4>
<p>I think this could be addressed by fixing old structures extending new structures</p>



<a name="200764789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200764789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200764789">(Jun 13 2020 at 12:49)</a>:</h4>
<p>the compilation here is pretty unquestionably wrong</p>



<a name="200765009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765009">(Jun 13 2020 at 12:54)</a>:</h4>
<p>What is the Lean 3 idiomatic way to proceed?</p>



<a name="200765036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765036">(Jun 13 2020 at 12:55)</a>:</h4>
<p>Is there any harm in just making them old structures?</p>



<a name="200765096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765096">(Jun 13 2020 at 12:56)</a>:</h4>
<p>I think that was bad for performance... hence new structures were introduced.</p>



<a name="200765100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765100">(Jun 13 2020 at 12:56)</a>:</h4>
<p>Mario wants to fix lean instead.</p>



<a name="200765283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765283">(Jun 13 2020 at 13:00)</a>:</h4>
<p>I am not convinced by the performance argument that was the original motivation for new structures. The performance in question is the time it takes to elaborate a <code>structure</code> definition, which is not the bottleneck in mathlib at all</p>



<a name="200765313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765313">(Jun 13 2020 at 13:01)</a>:</h4>
<p>possibly also structure literals are affected</p>



<a name="200765379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765379">(Jun 13 2020 at 13:02)</a>:</h4>
<p>I just tried making <code>local_ring</code> an old structure and I got some odd errors. It may not be a drop in replacement</p>



<a name="200765418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765418">(Jun 13 2020 at 13:03)</a>:</h4>
<p>the old structure command doesn't like to extend things in a dependent sequence</p>



<a name="200765476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200765476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200765476">(Jun 13 2020 at 13:04)</a>:</h4>
<p>that is, <code>class foo X extends bar X, @baz X &lt;typeclass problem involving _inst_bar_X&gt;</code> fails</p>



<a name="200769162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200769162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200769162">(Jun 13 2020 at 14:33)</a>:</h4>
<p>So what do we do?</p>



<a name="200959589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200959589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200959589">(Jun 15 2020 at 23:53)</a>:</h4>
<p>I want a working definition of <code>discrete_valuation_ring</code> (DVR) and now I'm entering a period in my life where I should have a lot more time for Lean; it would be nice to get this moving again. Recall that the issue is that the definition should be this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span><span class="o">,</span> <span class="n">local_ring</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">)</span>
</code></pre></div>


<p>but <code>principal_ideal_domain</code> (PID) and <code>local_ring</code> have overlapping fields, and the obvious fix of using the old structure command doesn't work because neither PID or local_ring were made with the old structure command. </p>
<p>Approach 1: make PID and local ring old structures and then pick up the pieces.<br>
Approach 2: make DVR by just extending <code>comm_ring</code>, adding in all the fields, and then defining the projections to PID and local ring manually. <br>
Approach 3: some other idea</p>
<p>I would like a definition of DVR and am prepared to work for it. What should I do? Any advice?</p>



<a name="200961093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200961093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200961093">(Jun 16 2020 at 00:16)</a>:</h4>
<p>Mario tried making <code>local_ring</code> an old structure so I thought I'd try PID. I stuck <code>set_option old_structure_cmd true</code> near the top of <code>ring_theory/principal_ideal_domain</code>. I am getting errors in <code>gaussian_int.lean</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">ambiguous</span> <span class="n">overload</span><span class="o">,</span> <span class="n">possible</span> <span class="n">interpretations</span>
    <span class="n">add_comm</span>
    <span class="n">principal_ideal_domain</span><span class="bp">.</span><span class="n">add_comm</span>
</code></pre></div>


<p>Does that mean I've done something wrong? I can fix everything by changing it to <code>_root_.add_comm</code>.</p>
<p>Apparently special functions and a bunch of calculus uses principal ideal domains. How do I look at the import graph?</p>



<a name="200962056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200962056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200962056">(Jun 16 2020 at 00:35)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3085">#3085</a> . Let me know if I'm doing the wrong thing.</p>



<a name="200964341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200964341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200964341">(Jun 16 2020 at 01:21)</a>:</h4>
<p>Mario's comment above refers to the following issue:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
<span class="n">class</span> <span class="n">local_ring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">comm_ring</span> <span class="n">α</span><span class="o">,</span> <span class="n">nonzero</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_local</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">is_unit</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">is_unit</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)))</span>
</code></pre></div>


<p>-&gt;</p>
<div class="codehilite"><pre><span></span><code>type mismatch at application
  @comm_ring.to_ring α mul_comm
term
  mul_comm
has type
  ∀ (a b : α), a * b = b * a
but is expected to have type
  comm_ring α
</code></pre></div>


<p>Can I solve this by not extending <code>nonzero \a</code> and instead just adding the <code>zero_ne_one</code> field and a projection from local_ring to nonzero?</p>



<a name="200964395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200964395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200964395">(Jun 16 2020 at 01:22)</a>:</h4>
<p>I have literally epsilon understanding of this structure command stuff. Yes I know there's a wiki page about it. I just don't understand the underlying issues properly enough for the page to help.</p>



<a name="200965659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200965659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200965659">(Jun 16 2020 at 01:49)</a>:</h4>
<p>What about the suggestion to not bundle any operations at all for PID, since it is just a property. That is, introduce <code>is_PID</code>.</p>



<a name="200965732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200965732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200965732">(Jun 16 2020 at 01:50)</a>:</h4>
<p>Similarly for <code>is_local</code></p>



<a name="200966632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200966632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200966632">(Jun 16 2020 at 02:10)</a>:</h4>
<p>What are your thoughts about using some definition like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="n">class</span> <span class="n">DVR</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">A</span>  <span class="o">:=</span>
<span class="o">(</span><span class="n">val_cond</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">z</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- i.e. A is a valuation ring</span>
<span class="o">(</span><span class="n">nonfield</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">u</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">u</span> <span class="bp">*</span> <span class="n">v</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- or some other formulation</span>
</code></pre></div>


<p>Any valuation ring which is a PID is a DVR. Actually, any valuation ring which is Noetherian is a DVR!</p>
<p>Proving the local ring instance is simple enough.... here's a working gist:<br>
<a href="https://gist.github.com/adamtopaz/7e573ec60777001ace5a3479608f992e">https://gist.github.com/adamtopaz/7e573ec60777001ace5a3479608f992e</a></p>



<a name="200967220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200967220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200967220">(Jun 16 2020 at 02:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/200964341">said</a>:</p>
<blockquote>
<p>Can I solve this by not extending <code>nonzero \a</code> and instead just adding the <code>zero_ne_one</code> field and a projection from local_ring to nonzero?</p>
</blockquote>
<p>That's what I did for the algebraic hierarchy (e.g. <code>domain</code>)</p>



<a name="200967501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200967501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200967501">(Jun 16 2020 at 02:31)</a>:</h4>
<p>TIL what a local ring is, that's not as scary as I feared</p>



<a name="200967720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200967720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200967720">(Jun 16 2020 at 02:36)</a>:</h4>
<p>maybe you're confused with local field, which is slightly scarier</p>



<a name="200973631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200973631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200973631">(Jun 16 2020 at 05:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/200965732">said</a>:</p>
<blockquote>
<p>Similarly for <code>is_local</code></p>
</blockquote>
<p><code>is_local_ring</code> already exists. I'm all in favour of trying to add <code>is_pid</code>, <code>is_dvr</code>, <code>is_noetherian</code>, <code>is_integrally_closed</code>, etc...</p>



<a name="200973668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200973668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200973668">(Jun 16 2020 at 05:03)</a>:</h4>
<p>how about <code>is_ring</code> and <code>is_comm_ring</code> predicated on semirings</p>



<a name="200973752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200973752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200973752">(Jun 16 2020 at 05:05)</a>:</h4>
<p>oh wait that doesn't work because you need negation which isn't Prop</p>



<a name="200973799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200973799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200973799">(Jun 16 2020 at 05:06)</a>:</h4>
<p>but if you have <code>is_integral_domain</code> then <code>normalization_domain</code> will be a pain in the bottom</p>



<a name="200979158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/200979158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#200979158">(Jun 16 2020 at 07:00)</a>:</h4>
<p>Why?</p>



<a name="201030275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030275">(Jun 16 2020 at 15:15)</a>:</h4>
<p>Mathlib doesn't have general valuation rings right? Would it make sense for you to define a DVR like this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">noetherian</span>

<span class="n">class</span> <span class="n">valuation_ring</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">integral_domain</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val_cond</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">a</span> <span class="err">∣</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">b</span> <span class="err">∣</span> <span class="n">a</span><span class="o">)</span>

<span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">valuation_ring</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_noetherian</span> <span class="o">:</span> <span class="n">is_noetherian_ring</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">nonfield</span> <span class="o">:</span> <span class="bp">...</span> <span class="o">)</span>
</code></pre></div>


<p>Presumably most things one might prove about DVRs actually hold for arbitrary valuation rings.</p>



<a name="201030488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030488">(Jun 16 2020 at 15:16)</a>:</h4>
<p>General valuations (but not general valuation rings) are around the corner. I think we can have them in one or two weeks, depending on the review process...</p>



<a name="201030777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030777">(Jun 16 2020 at 15:18)</a>:</h4>
<p>But this <code>valuation_ring</code> (or maybe <code>is_valuation_ring</code>) seems like a useful gadget anyhow.</p>



<a name="201030824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030824">(Jun 16 2020 at 15:18)</a>:</h4>
<p>(Zariski–Riemann spaces are coming to mathlib, lol.)</p>



<a name="201030914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030914">(Jun 16 2020 at 15:19)</a>:</h4>
<p>(deleted)</p>



<a name="201030926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030926">(Jun 16 2020 at 15:19)</a>:</h4>
<p>I guess we'll want to have 13 constructors of <code>is_DVR</code>. There isn't 1 true definition.</p>



<a name="201030972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030972">(Jun 16 2020 at 15:19)</a>:</h4>
<p>I was thinking of valuations as in adic spaces...</p>



<a name="201030995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201030995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201030995">(Jun 16 2020 at 15:19)</a>:</h4>
<p>We are currently considering not making them a class at all, and instead making them a predicate on commutative rings</p>



<a name="201031175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031175">(Jun 16 2020 at 15:21)</a>:</h4>
<p>So still a <code>class</code>, but taking <code>(comm_)ring R</code> as assumption, instead of extending it.</p>



<a name="201031204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031204">(Jun 16 2020 at 15:21)</a>:</h4>
<p>I see. Presumably you would want to phrase things like the valuative criteria from AG. So valuation rings could be useful for that.</p>



<a name="201031287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031287">(Jun 16 2020 at 15:21)</a>:</h4>
<p>I guess we would want CDVRs as well</p>



<a name="201031336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031336">(Jun 16 2020 at 15:22)</a>:</h4>
<p>and a proof that they are henselian</p>



<a name="201031371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031371">(Jun 16 2020 at 15:22)</a>:</h4>
<p>What does CDVR stand for?</p>



<a name="201031378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031378">(Jun 16 2020 at 15:22)</a>:</h4>
<p>CDVR could also be a predicate</p>



<a name="201031386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031386">(Jun 16 2020 at 15:22)</a>:</h4>
<p>complete DVR</p>



<a name="201031422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031422">(Jun 16 2020 at 15:22)</a>:</h4>
<p>ah ok.</p>



<a name="201031435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031435">(Jun 16 2020 at 15:22)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">R</span><span class="o">]</span>
    <span class="o">[</span><span class="n">topological_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">complete_space</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span>
</code></pre></div>



<a name="201031441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031441">(Jun 16 2020 at 15:22)</a>:</h4>
<p>because it doesn't involve choosing some auxiliary ideal or a topology, the phrase always means "complete with respect to the topology defined by the max ideal"</p>



<a name="201031456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031456">(Jun 16 2020 at 15:23)</a>:</h4>
<p>We're only missing the last class on that line.</p>



<a name="201031508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031508">(Jun 16 2020 at 15:23)</a>:</h4>
<p>Johan that's bad, because then you'd want the topology to be the maximal-ideal-adic one</p>



<a name="201031525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031525">(Jun 16 2020 at 15:23)</a>:</h4>
<p>i.e. there's still something missing</p>



<a name="201031564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031564">(Jun 16 2020 at 15:23)</a>:</h4>
<p>Ooh, right, we need another compatibility class.</p>



<a name="201031597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031597">(Jun 16 2020 at 15:24)</a>:</h4>
<p><code>distrib++</code></p>



<a name="201031675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031675">(Jun 16 2020 at 15:24)</a>:</h4>
<p>I guess we could add <code>is_cdvr</code> which extends <code>complete_space</code> and <code>is_dvr</code></p>



<a name="201031684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031684">(Jun 16 2020 at 15:24)</a>:</h4>
<p>Just don't bother asking for the topology at all, would be another option</p>



<a name="201031728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031728">(Jun 16 2020 at 15:24)</a>:</h4>
<p>Nope...</p>



<a name="201031739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031739">(Jun 16 2020 at 15:24)</a>:</h4>
<p>Because <code>Z_p</code></p>



<a name="201031766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031766">(Jun 16 2020 at 15:24)</a>:</h4>
<p>"complete with respect to the topology generated by the max ideal"</p>



<a name="201031826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031826">(Jun 16 2020 at 15:25)</a>:</h4>
<p>Maybe this is a bad question - what if we started with a Dedekind domain and used it to define a DVR?</p>



<a name="201031837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031837">(Jun 16 2020 at 15:25)</a>:</h4>
<p>Will that play nice with the rest of the topology?</p>



<a name="201031887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031887">(Jun 16 2020 at 15:25)</a>:</h4>
<p>You can define a dedekind domain after you define DVRs :)</p>



<a name="201031917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031917">(Jun 16 2020 at 15:25)</a>:</h4>
<p>We could define DVR's via Dededkind domains, but my gut feeling is that DVRs are conceptually simpler</p>



<a name="201031926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201031926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201031926">(Jun 16 2020 at 15:26)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> I think we just want 10 equivalent definitions, in the end.</p>



<a name="201032021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032021">(Jun 16 2020 at 15:26)</a>:</h4>
<p>10 equivalent definitions for DVRs?</p>



<a name="201032029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032029">(Jun 16 2020 at 15:26)</a>:</h4>
<p>But ideally we don't want 10 choose 2 theorems,</p>



<a name="201032053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032053">(Jun 16 2020 at 15:26)</a>:</h4>
<p>Yes, there are 10 definitions of DVR on Wikipedia</p>



<a name="201032196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032196">(Jun 16 2020 at 15:27)</a>:</h4>
<p>I will spend some time on this tomorrow; I'll try and get a definition of DVR into mathlib. I'm going for local PID which isn't a field as the "canonical" definition, and then there are 9 theorems to prove</p>



<a name="201032323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032323">(Jun 16 2020 at 15:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201032029">said</a>:</p>
<blockquote>
<p>But ideally we don't want 10 choose 2 theorems,</p>
</blockquote>
<p>No, just 10 constructors.</p>



<a name="201032438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032438">(Jun 16 2020 at 15:29)</a>:</h4>
<p>It's not going to be a structure so surely it's 9 theorems?</p>



<a name="201032470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032470">(Jun 16 2020 at 15:29)</a>:</h4>
<p>I was trying to do a PID with a unique prime ideal, and showing that the prime ideal is maximal.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">prime_ideal&#39;</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="o">(</span><span class="n">primality</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span><span class="bp">.</span><span class="n">is_prime</span><span class="o">)</span>

<span class="o">(</span><span class="n">is_nonzero</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span>

<span class="o">(</span><span class="n">unique_nonzero_prime_ideal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">is_prime</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">prime_ideal&#39;</span><span class="o">)</span>


<span class="n">def</span> <span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">prime_ideal</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">prime_ideal&#39;</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">principal_ideal_domain</span>
<span class="kn">open</span> <span class="n">discrete_valuation_ring</span>

<span class="kn">lemma</span> <span class="n">prime_ideal_is_maximal</span> <span class="o">:</span> <span class="o">(</span><span class="n">prime_ideal</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">is_maximal</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">prime_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">is_prime</span><span class="bp">.</span><span class="n">to_maximal_ideal</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201032556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032556">(Jun 16 2020 at 15:30)</a>:</h4>
<p>The last line gives me an error,</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">prime_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span>
<span class="err">⊢</span> <span class="o">(</span><span class="n">prime_ideal</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">is_maximal</span>
</code></pre></div>



<a name="201032676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032676">(Jun 16 2020 at 15:30)</a>:</h4>
<p>All these definitions should work, but my experience in the past has been that if you just choose a random definition and then formalise some stuff, you might find it's hard to get it into mathlib, and I know now that it's a grave mistake not to have mathlib in mind from the very start</p>



<a name="201032973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201032973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201032973">(Jun 16 2020 at 15:33)</a>:</h4>
<p>What does getting it into mathlib mean? Isn't it sufficient to pass the Lean checker test?</p>



<a name="201033005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033005">(Jun 16 2020 at 15:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> It's going to be a <code>class</code> right? With fields, etc... so it's a souped up structure, so constructors?</p>



<a name="201033097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033097">(Jun 16 2020 at 15:33)</a>:</h4>
<p>Wait -- I thought we had just established that <code>is_DVR</code> was going to be a non-class predicate on comm_rings?</p>



<a name="201033125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033125">(Jun 16 2020 at 15:34)</a>:</h4>
<p><code>is_local_ring</code> isn't a class</p>



<a name="201033338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033338">(Jun 16 2020 at 15:35)</a>:</h4>
<p>I thought the plan was <code>is_principal_ideal_domain</code> and <code>is_discrete_valuation_domain</code> both being Props on...actually <code>integral_domain</code> is a class so how about predicates on integral domains?</p>



<a name="201033538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033538">(Jun 16 2020 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="250372">Ashvni Narayanan</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201032973">said</a>:</p>
<blockquote>
<p>What does getting it into mathlib mean? Isn't it sufficient to pass the Lean checker test?</p>
</blockquote>
<p>No. Mathlib only accepts code which satisfies certain very high standards. I'm not bothered about our general DVR project being of this standard but for the definition itself I think we should engage with the hard question of deciding exactly which implementation we will use for the specification of DVR's.</p>



<a name="201033580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033580">(Jun 16 2020 at 15:37)</a>:</h4>
<p>Once we have this, we can forget about all this nonsense and just prove some theorems</p>



<a name="201033619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033619">(Jun 16 2020 at 15:37)</a>:</h4>
<p>and the theorems can be refactored and cleaned up later. But if we get the definition wrong then the clean-up process is much much harder</p>



<a name="201033708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033708">(Jun 16 2020 at 15:38)</a>:</h4>
<p>This is why there is currently such a fuss about the definition of a DVR. It has turned into a discussion of whether classes such as <code>principal_ideal_domain</code> should even exist</p>



<a name="201033731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201033731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201033731">(Jun 16 2020 at 15:38)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> can you clarify your comments about <code>is_DVR</code> being a class?</p>



<a name="201034356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201034356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201034356">(Jun 16 2020 at 15:43)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">prime_ideal&#39;</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="o">(</span><span class="n">primality</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span><span class="bp">.</span><span class="n">is_prime</span><span class="o">)</span>

<span class="o">(</span><span class="n">is_nonzero</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span>

<span class="o">(</span><span class="n">unique_nonzero_prime_ideal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">is_prime</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">prime_ideal&#39;</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_ring</span>

<span class="n">def</span> <span class="n">prime_ideal</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span> <span class="o">:=</span>
<span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">prime_ideal&#39;</span>

<span class="kn">instance</span> <span class="n">is_prime</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">prime_ideal</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">is_prime</span> <span class="o">:=</span>
<span class="n">primality</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_valuation_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">open</span> <span class="n">principal_ideal_domain</span>
<span class="kn">open</span> <span class="n">discrete_valuation_ring</span>

<span class="kn">lemma</span> <span class="n">prime_ideal_is_maximal</span> <span class="o">:</span> <span class="o">(</span><span class="n">prime_ideal</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">is_maximal</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">prime_ideal</span> <span class="n">R</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">discrete_valuation_ring</span><span class="bp">.</span><span class="n">is_nonzero</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">is_prime</span><span class="bp">.</span><span class="n">to_maximal_ideal</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">discrete_valuation_ring</span>
</code></pre></div>


<p>The fact that the prime ideal was prime was not in Lean's type class inference system.</p>



<a name="201035071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201035071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201035071">(Jun 16 2020 at 15:48)</a>:</h4>
<p>The problem with your code (and Lean did a very poor job of pointing this out) was that the inputs to the <code>is_prime.to_maximal_ideal</code> function  look like this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">is_prime</span><span class="bp">.</span><span class="n">to_maximal_ideal</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">is_prime.to_maximal_ideal :</span>
<span class="cm">  ∀ {R : Type u_1} [_inst_1 : principal_ideal_domain R] {S : ideal R}</span>
<span class="cm">  [hpi : S.is_prime], S ≠ ⊥ → S.is_maximal</span>
<span class="cm">-/</span>
</code></pre></div>


<p>(the <code>@</code> means "show me even the inputs which Lean is supposed to guess!). One of the inputs is <code>hpi : S.is_prime</code> and because that input is in square brackets it means that a system called type class inference is supposed to be used to magic up the proof that the ideal S is prime. In your case, S is <code>prime_ideal R</code> but just because it's called that doesn't mean that the type class inference system knows it's prime :-) The <code>instance</code> line which I added to your code tells the type class inference system that the prime ideal is prime, and then the error goes away.</p>
<p>Note also that I moved into the <code>discrete_valuation_ring</code> namespace, meaning that I don't have to type <code>discrete_valuation_ring</code> in front of everything.</p>



<a name="201036663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201036663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201036663">(Jun 16 2020 at 15:58)</a>:</h4>
<p>Ah, now I understand! In the definition of prime_ideal, I took it to be prime_ideal', but that does not include the primality condition. Thank you!</p>



<a name="201037637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201037637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201037637">(Jun 16 2020 at 16:04)</a>:</h4>
<p>Right -- the <code>instance</code> means "feed this proof into the type class inference machine" but the proof was <code>primality</code></p>



<a name="201038753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201038753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201038753">(Jun 16 2020 at 16:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201033731">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> can you clarify your comments about <code>is_DVR</code> being a class?</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I would like to have automation (in this case, the type class system) to take care of "every DVR is a PID", and not supply those proofs explicitly.</p>



<a name="201038793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201038793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201038793">(Jun 16 2020 at 16:13)</a>:</h4>
<p>Just like <code>topological_ring R</code> is a class that assumes <code>ring R</code> and <code>topological_space R</code></p>



<a name="201038969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201038969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201038969">(Jun 16 2020 at 16:15)</a>:</h4>
<p>How is what you're proposing different to the current definition of PID?</p>



<a name="201039107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201039107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201039107">(Jun 16 2020 at 16:16)</a>:</h4>
<p>The difference is that <code>zero</code> and <code>add</code> etc are no longer fields of that class</p>



<a name="201039141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201039141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201039141">(Jun 16 2020 at 16:16)</a>:</h4>
<p>So the class lives in <code>Prop</code> instead of <code>Type*</code></p>



<a name="201039270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201039270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201039270">(Jun 16 2020 at 16:17)</a>:</h4>
<p>So the change is that were not extending integral_domain but instead asking for it as a typeclass on our type?</p>



<a name="201039980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201039980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201039980">(Jun 16 2020 at 16:22)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="n">class</span> <span class="n">is_principal_ideal_domain</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">principal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span> <span class="n">S</span><span class="bp">.</span><span class="n">is_principal</span><span class="o">)</span>

<span class="n">class</span> <span class="n">is_PID_fail</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">principal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">),</span> <span class="n">S</span><span class="bp">.</span><span class="n">is_principal</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">is_PID_fail</span> <span class="c1">-- Π ..., Type</span>
</code></pre></div>


<p>You think <code> is_principal_ideal_domain</code> is the way to go? I am slightly surprised I had to explicitly tell Lean that it was a Prop.</p>



<a name="201040235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201040235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201040235">(Jun 16 2020 at 16:24)</a>:</h4>
<p>PS it does seem absurd that UFD contains all that data. The analogue would be choosing a generator for each ideal.</p>



<a name="201040302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201040302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201040302">(Jun 16 2020 at 16:25)</a>:</h4>
<p>Yeah, <code>structure</code>/<code>class</code> never defaults to <code>Prop</code> for some reason and it is weird.</p>



<a name="201040403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201040403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201040403">(Jun 16 2020 at 16:26)</a>:</h4>
<p>I think some of the separation classes like <code>t2_space</code> used to accidentally not be <code>Prop</code>s.</p>



<a name="201043616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201043616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201043616">(Jun 16 2020 at 16:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Yes, but I would assume <code>[comm_ring R]</code>, and in applications we can assume <code>[integral_domain R]</code>.</p>



<a name="201043689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201043689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201043689">(Jun 16 2020 at 16:51)</a>:</h4>
<p>This way we get principal ideal rings and principal ideal domains in one go (a slight hint of the flexibility I'm hoping this refactor will achieve).</p>



<a name="201045757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201045757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201045757">(Jun 16 2020 at 17:06)</a>:</h4>
<p>So do you want <code>is_PIR</code> <em>and</em> <code>is_PID</code>?</p>



<a name="201045847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201045847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201045847">(Jun 16 2020 at 17:08)</a>:</h4>
<p>No, only <code>is_PIR</code></p>



<a name="201045903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201045903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201045903">(Jun 16 2020 at 17:08)</a>:</h4>
<p>Because it covers everything</p>



<a name="201045991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201045991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201045991">(Jun 16 2020 at 17:09)</a>:</h4>
<p>I guess we'll end up with "principal ideal semirings" (-;</p>



<a name="201046077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201046077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201046077">(Jun 16 2020 at 17:09)</a>:</h4>
<p>and we'll also end up with mathematicians asking "where are PIDs?" and we'll have to say "oh you use ID and PIR" and they'll say "why no PID?"</p>



<a name="201046082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201046082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201046082">(Jun 16 2020 at 17:10)</a>:</h4>
<p>Similarly, we'll probably define "discrete valuation semiring". But all theorems will assume <code>integral_domain</code>.</p>



<a name="201046169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201046169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201046169">(Jun 16 2020 at 17:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201046077">said</a>:</p>
<blockquote>
<p>and we'll also end up with mathematicians asking "where are PIDs?" and we'll have to say "oh you use ID and PIR" and they'll say "why no PID?"</p>
</blockquote>
<p>Because it means proving things twice?</p>



<a name="201046734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201046734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201046734">(Jun 16 2020 at 17:15)</a>:</h4>
<p>Maybe we could at some point have some syntactic sugar to make things look nicer.</p>



<a name="201046756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201046756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201046756">(Jun 16 2020 at 17:15)</a>:</h4>
<p>But at the moment I would go for maximum flexibility.</p>



<a name="201156428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201156428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201156428">(Jun 17 2020 at 15:19)</a>:</h4>
<p>I am trying to prove that a local PID that is not a field is a DVR, using the definition that a DVR is a PID with a unique nonzero prime ideal (doing it to get comfortable with Lean).</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">principal_ideal_domain</span> <span class="n">R</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">prime_ideal&#39;</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="o">(</span><span class="n">primality</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span><span class="bp">.</span><span class="n">is_prime</span><span class="o">)</span>

<span class="o">(</span><span class="n">is_nonzero</span> <span class="o">:</span> <span class="n">prime_ideal&#39;</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span>

<span class="o">(</span><span class="n">unique_nonzero_prime_ideal</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">is_prime</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="bp">∨</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">prime_ideal&#39;</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">principal_ideal_domain</span>
<span class="kn">open</span> <span class="n">local_ring</span>

<span class="kn">lemma</span> <span class="n">local_pid_dvr</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">is_local</span> <span class="o">:</span> <span class="n">local_ring</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">pid</span><span class="o">:</span> <span class="n">principal_ideal_domain</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">S</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">)</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="n">S</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">use</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">S</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">zero_mem_nonunits</span> <span class="n">S</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>The first line of the proof gives me 6 goals, 5 of which are basically properties of ideals. Since S is a local ring, why do I need to reprove it? Also, the second line gives me an error </p>
<div class="codehilite"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">zero_mem_nonunits</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="mi">0</span> <span class="err">∈</span> <span class="n">nonunits</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">↔</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="mi">1</span>
</code></pre></div>



<a name="201157296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201157296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201157296">(Jun 17 2020 at 15:25)</a>:</h4>
<p>A <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> needs imports!</p>



<a name="201158165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201158165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201158165">(Jun 17 2020 at 15:30)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> the way you have set up a DVR, it contains data (the choice of a prime ideal) so you don't want to use <code>lemma</code> -- this is a construction, the way you've set it up, so it's a <code>definition</code>. The way to make terms of a structure is like this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">local_pid_dvr</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">is_local</span> <span class="o">:</span> <span class="n">local_ring</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">pid</span><span class="o">:</span> <span class="n">principal_ideal_domain</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">S</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_valuation_ring</span> <span class="n">S</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">prime_ideal&#39;</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">primality</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">is_nonzero</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">unique_nonzero_prime_ideal</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">pid</span><span class="o">}</span>
</code></pre></div>


<p>but <code>principal_ideal_domain</code> is a class so you should be using <code>[]</code> brackets (and local_ring too)</p>



<a name="201164685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201164685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201164685">(Jun 17 2020 at 16:18)</a>:</h4>
<p>Thank you, that was very helpful. But I am back with the type mismatch errors, I am guessing it is the new/old structure problem cropping up?</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">local_pid_dvr</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">is_local</span> <span class="o">:</span> <span class="n">local_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">pid</span><span class="o">:</span> <span class="n">principal_ideal_domain</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">non_field</span> <span class="o">:</span> <span class="n">local_ring</span><span class="bp">.</span><span class="n">nonunits_ideal</span> <span class="n">S</span> <span class="bp">≠</span> <span class="err">⊥</span> <span class="o">)</span> <span class="o">:</span>
  <span class="n">discrete_valuation_ring</span> <span class="n">S</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">prime_ideal&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nonunits_ideal</span> <span class="n">S</span><span class="o">),</span>
  <span class="n">primality</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nonunits_ideal</span> <span class="n">S</span><span class="o">)</span><span class="bp">.</span><span class="n">is_prime</span><span class="o">,</span>
  <span class="n">is_nonzero</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">unique_nonzero_prime_ideal</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">pid</span><span class="o">}</span>
</code></pre></div>


<p>I get the error</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="err">&#39;</span><span class="n">prime_ideal&#39;&#39;</span>
  <span class="n">nonunits_ideal</span> <span class="n">S</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">ideal</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_comm_ring</span> <span class="n">S</span> <span class="n">is_local</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">ideal</span> <span class="n">S</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">integral_domain</span><span class="bp">.</span><span class="n">to_comm_ring</span> <span class="n">S</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">to_integral_domain</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">principal_ideal_domain</span><span class="bp">.</span><span class="n">mk</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">to_integral_domain</span> <span class="n">S</span> <span class="n">pid</span><span class="o">)</span> <span class="bp">_</span><span class="o">)))</span>
</code></pre></div>



<a name="201165504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201165504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201165504">(Jun 17 2020 at 16:24)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> Yes, that looks like it is getting the wrong ring structure again.</p>



<a name="201165556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201165556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201165556">(Jun 17 2020 at 16:24)</a>:</h4>
<p>We really need to fix this... but I won't have time for such a project the next few days <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="201166014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201166014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201166014">(Jun 17 2020 at 16:28)</a>:</h4>
<p>Oh, no worries, I am just trying to see how far I can go, and just get comfortable with the language.</p>



<a name="201179146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201179146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201179146">(Jun 17 2020 at 18:07)</a>:</h4>
<p>I will fix it the moment I am done with all this work admin (which has a deadline of Thurs).</p>



<a name="201338554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201338554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201338554">(Jun 18 2020 at 23:37)</a>:</h4>
<p>I am trying to define a discrete valuation field : </p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">discrete_valuation</span> <span class="o">:</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="bp">ℤ</span> <span class="bp">∨</span> <span class="err">∞</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span><span class="o">{</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)}</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∞</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>
</code></pre></div>


<p>I get the error </p>
<div class="codehilite"><pre><span></span><code><span class="n">unknown</span> <span class="n">identifier</span> <span class="err">&#39;</span><span class="n">v&#39;</span>
</code></pre></div>


<p>How can I fix this? Thanks!</p>



<a name="201338652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201338652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201338652">(Jun 18 2020 at 23:38)</a>:</h4>
<p>the second line has two binders</p>



<a name="201338682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201338682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201338682">(Jun 18 2020 at 23:39)</a>:</h4>
<p>Is <code>ℤ ∨ ∞</code> a type? if not, maybe you mean <code>with_top</code></p>



<a name="201338782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201338782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201338782">(Jun 18 2020 at 23:40)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span><span class="o">{</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)}</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">\</span><span class="n">top</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>
</code></pre></div>



<a name="201338812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201338812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201338812">(Jun 18 2020 at 23:41)</a>:</h4>
<p>Always look at the first error</p>



<a name="201338852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201338852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201338852">(Jun 18 2020 at 23:41)</a>:</h4>
<p>Thank you!</p>



<a name="201339124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339124">(Jun 18 2020 at 23:45)</a>:</h4>
<p>The following does not throw errors on my machine</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">v</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>
</code></pre></div>



<a name="201339201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339201">(Jun 18 2020 at 23:46)</a>:</h4>
<p>what does open_locale classical do?</p>



<a name="201339257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339257">(Jun 18 2020 at 23:47)</a>:</h4>
<p>it tells lean to <em>not</em> worry about stuff like the law of excluded middle</p>



<a name="201339283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339283">(Jun 18 2020 at 23:47)</a>:</h4>
<p>before I added it, it wanted me to supply a decidable linear order on <code>K</code></p>



<a name="201339379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339379">(Jun 18 2020 at 23:49)</a>:</h4>
<p>(important edit to the previous post)</p>



<a name="201339559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339559">(Jun 18 2020 at 23:52)</a>:</h4>
<p>Thank you!</p>



<a name="201339819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201339819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201339819">(Jun 18 2020 at 23:55)</a>:</h4>
<p>most of the errors lean gives you are easy to understand. When I first put in </p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">discrete_valuation</span> <span class="o">:</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="bp">ℤ</span> <span class="bp">∨</span> <span class="err">∞</span><span class="o">)</span>
</code></pre></div>


<p>I got <code>unknown identifier v</code>. If you look near the first appearance of the identifier <code>v</code>, there are two binders. So Lean read the first one and was expecting an expression that defines a type; instead it got <code>v</code> which it has never heard of before</p>



<a name="201340019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340019">(Jun 18 2020 at 23:58)</a>:</h4>
<p>Oh I didn't even notice the bad syntax on the first line, I assumed the error was later.</p>



<a name="201340065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340065">(Jun 18 2020 at 23:59)</a>:</h4>
<p>Next I try this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="bp">ℤ</span> <span class="bp">∨</span> <span class="err">∞</span><span class="o">)</span>
</code></pre></div>


<p>and I get <code>unknown identifier field</code>, which means I haven't imported enough of mathlib to get fields</p>



<a name="201340204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340204">(Jun 19 2020 at 00:01)</a>:</h4>
<p>I think this definition is missing a nontriviality assumption. E.g. you can  ensure v is surjective (or at least nontrivial). Otherwise, this definition will include the trivial valuation.</p>



<a name="201340207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340207">(Jun 19 2020 at 00:01)</a>:</h4>
<p>Next I try this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="bp">ℤ</span> <span class="bp">∨</span> <span class="err">∞</span><span class="o">)</span>
</code></pre></div>


<p>and <code>field</code> gets recognized. Next I get <code>unexpected token</code>. The two unicode characters that pop out at me are <code>ℤ</code> and <code>∞</code>. I know I've seen <code>ℤ</code> before, but I don't know about the other one. To confirm, I try the following and it works</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="bp">ℤ</span> <span class="bp">∨</span> <span class="err">∞</span><span class="o">)</span>
</code></pre></div>



<a name="201340438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340438">(Jun 19 2020 at 00:05)</a>:</h4>
<p>Now I add the rest</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span><span class="o">{</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)}</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>
</code></pre></div>


<p>and get multiple unknown identifiers for <code>x</code> and <code>y</code>. x and y appear a lot of times, sometimes with a forall and sometimes not. I add some quantifiers and those errors go away</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span><span class="o">{</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)}</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>
</code></pre></div>



<a name="201340463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340463">(Jun 19 2020 at 00:05)</a>:</h4>
<p>Now I have a much longer error</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">v</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span> <span class="o">{</span><span class="n">v</span> <span class="n">x</span><span class="o">,</span> <span class="n">v</span> <span class="n">y</span><span class="o">}</span>
<span class="n">term</span>
  <span class="n">min</span> <span class="o">{</span><span class="n">v</span> <span class="n">x</span><span class="o">,</span> <span class="n">v</span> <span class="n">y</span><span class="o">}</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="err">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:</span> <span class="kt">Type</span>
</code></pre></div>



<a name="201340531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340531">(Jun 19 2020 at 00:06)</a>:</h4>
<p>Maybe the question marks look scary, but just treat <code>?m_1</code> as a variable.</p>



<a name="201340577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340577">(Jun 19 2020 at 00:06)</a>:</h4>
<p>It says that a certain expression is supposed to have type <code>with_top ℤ</code>, which is the image of the valuation map. Mathematically, I agree that's the right type.</p>



<a name="201340672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340672">(Jun 19 2020 at 00:08)</a>:</h4>
<p>next I do <code>#check min</code> and lean tells me its type is <code>min : ?M_1 → ?M_1 → ?M_1</code>. That means it's a function of two arguments. In Lean, a function of two arguments is written like <code>min (v x) (v y)</code>, with only spaces separating the function and arguments.</p>



<a name="201340750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340750">(Jun 19 2020 at 00:09)</a>:</h4>
<p>I can also do <code>#check @min</code> to see <code>min : Π {α : Type u_1} [_inst_1 : decidable_linear_order α], α → α → α</code><br>
this means that min only applies to types which are known to be <code>decidable_linear_order</code>s</p>



<a name="201340760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340760">(Jun 19 2020 at 00:09)</a>:</h4>
<p>where by "known to be" I mean "known by the typeclass-inference systems"</p>



<a name="201340861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201340861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201340861">(Jun 19 2020 at 00:11)</a>:</h4>
<p>apparently lean stops complaining at this point, although I thought before lean had complained about inferring the order and the field operations on <code>K</code></p>



<a name="201341141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201341141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201341141">(Jun 19 2020 at 00:16)</a>:</h4>
<p>I see. That was very useful, thanks a lot! I didn't know about #check @... , will keep it in mind.</p>



<a name="201405400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201405400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201405400">(Jun 19 2020 at 15:29)</a>:</h4>
<p>I am trying to define discrete valuations via discrete valuation fields : </p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">val</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span> <span class="o">(</span><span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">val</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_trivial</span> <span class="o">:</span> <span class="n">val</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">instance</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">val</span>
</code></pre></div>


<p>The last definition gives the error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="err">⊢</span> <span class="n">field</span> <span class="n">K</span>
</code></pre></div>


<p>I don't know why there is a type class instance error here. Help is appreciated. Thanks!</p>



<a name="201405648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201405648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201405648">(Jun 19 2020 at 15:30)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span>
</code></pre></div>



<a name="201405679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201405679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201405679">(Jun 19 2020 at 15:31)</a>:</h4>
<p>i.e. insert the fact that K is a field -- this is what Lean is telling you that it can't figure out.</p>



<a name="201405992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201405992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201405992">(Jun 19 2020 at 15:33)</a>:</h4>
<p>oh and it's a <code>def</code> not an <code>instance</code>.</p>



<a name="201406089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201406089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201406089">(Jun 19 2020 at 15:34)</a>:</h4>
<p>You use <code>instance</code> for a definition which you want to teach to the type class inference system (the stuff in square brackets which you want Lean to fill in).</p>



<a name="201406256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201406256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201406256">(Jun 19 2020 at 15:36)</a>:</h4>
<p>The units of the valuation are the preimage of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. And <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> is a unit. So the "non_trivial" assumption is not correct here...</p>



<a name="201880262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201880262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201880262">(Jun 24 2020 at 17:44)</a>:</h4>
<p>Trying to show that the valuation ring coming from a discrete valuation field is an integral domain. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">val</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span> <span class="o">(</span><span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">val</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">val</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">is_integral_domain</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">≥</span> <span class="mi">0</span><span class="o">})</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="n">S</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">split</span><span class="o">,</span>
  <span class="n">rintros</span><span class="o">,</span>
   <span class="o">{</span><span class="n">apply</span> <span class="n">mul_comm</span><span class="o">},</span>
    <span class="o">{</span>
      <span class="n">rintros</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">val</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">val</span><span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">K</span><span class="o">),</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>The g part gives an error</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">S</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="err">↥</span><span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span><span class="o">},</span>
<span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">},</span>
<span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span>
<span class="n">a_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">has_mul</span> <span class="n">S</span>
</code></pre></div>


<p>It seems like Lean sees a and b as elements of S, instead of K. But why was that not an issue for the first goal? Also, how do I show that it is in K? I tried </p>
<div class="codehilite"><pre><span></span><code><span class="k">have</span> <span class="n">a</span><span class="o">:</span><span class="n">K</span>
</code></pre></div>


<p>but this seems to create a new variable a in K.<br>
Any help is appreciated. Thank you!</p>



<a name="201882169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201882169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201882169">(Jun 24 2020 at 18:00)</a>:</h4>
<p>(Is it normal that it's taking me 10 min to get the Lean server to even import the files listed here?)</p>



<a name="201883008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201883008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201883008">(Jun 24 2020 at 18:07)</a>:</h4>
<p>No, it is not normal. The server has been going up and down for a while now.</p>



<a name="201883534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201883534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201883534">(Jun 24 2020 at 18:12)</a>:</h4>
<p>Would it be better to try something like this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">is_integral_domain</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">≥</span> <span class="mi">0</span><span class="o">}</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="201883996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201883996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201883996">(Jun 24 2020 at 18:16)</a>:</h4>
<p>I would say also that its better to use <code>{x : K // 0 ≤ val x}</code>, the <code>//</code> means subtype rather than subset, so there isn't this weird <code>↥</code>, you have the type of all elements satisfying the prop directly. Also less or equal rather than greater or equal as the mathlib setup is to almost always use less than statements (by swapping sides if needed) so it might be easier to find and apply lemmas relating to less than.</p>



<a name="201884046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201884046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201884046">(Jun 24 2020 at 18:17)</a>:</h4>
<p>Also, mathlib has this:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/subring.html#subring.domain">https://leanprover-community.github.io/mathlib_docs/ring_theory/subring.html#subring.domain</a><br>
So if you can prove a subring instance for the valuation ring, then lean should be able to deduce the fact that it's a domain from the fact that any field is a domain.</p>



<a name="201884227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201884227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201884227">(Jun 24 2020 at 18:18)</a>:</h4>
<p>If you do what adam says then you should ignore the first thing I said, looks like that lemma is set up as a set rather than a subtype!</p>



<a name="201900713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201900713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201900713">(Jun 24 2020 at 20:39)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> Or do what you said + fix mathlib <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="201901006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201901006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201901006">(Jun 24 2020 at 20:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201884046">said</a>:</p>
<blockquote>
<p>Also, mathlib has this:<br>
<a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/subring.html#subring.domain">https://leanprover-community.github.io/mathlib_docs/ring_theory/subring.html#subring.domain</a><br>
So if you can prove a subring instance for the valuation ring, then lean should be able to deduce the fact that it's a domain from the fact that any field is a domain.</p>
</blockquote>
<p>I don't know how to work with is_subring, how do I split it into goals? split does not seem to work out</p>



<a name="201901948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201901948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201901948">(Jun 24 2020 at 20:50)</a>:</h4>
<p><code>constructor</code>?</p>



<a name="201901973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201901973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201901973">(Jun 24 2020 at 20:50)</a>:</h4>
<p>Or <code>refine { zero_mem := _, etc....}</code></p>



<a name="201902683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201902683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201902683">(Jun 24 2020 at 20:57)</a>:</h4>
<p>Oh, ok. Thank you!</p>



<a name="201904431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201904431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201904431">(Jun 24 2020 at 21:12)</a>:</h4>
<p><code>suggest</code> will find you the <code>refine</code> block that Johan suggested, possibly along with lemmas that let you do the construction with fewer fields</p>



<a name="201911580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201911580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201911580">(Jun 24 2020 at 22:30)</a>:</h4>
<p>Trying to prove that the valuation ring coming from a discrete valuation field is an integral domain. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">val</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">min</span> <span class="o">(</span><span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">val</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">discrete_valuation_field</span><span class="bp">.</span><span class="n">val</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">val_zero</span> <span class="o">:</span> <span class="n">val</span><span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">non_zero</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">instance</span> <span class="n">is_integral_domain</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">},</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="n">rintros</span><span class="o">,</span>
    <span class="o">{</span><span class="n">apply</span> <span class="n">mul_comm</span><span class="o">},</span>
    <span class="o">{</span>
      <span class="n">rintros</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">val</span> <span class="o">((</span><span class="n">a</span><span class="o">:</span><span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">val</span><span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">K</span><span class="o">),</span>
        <span class="o">{</span>
          <span class="n">sorry</span><span class="o">,</span>
        <span class="o">},</span>
      <span class="n">rw</span> <span class="n">mul</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">val_zero</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">add_eq_top</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">non_zero</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">with_top</span><span class="bp">.</span><span class="n">coe_eq_zero</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">g</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="o">},</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>I get the error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="err">↑</span><span class="n">a</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">},</span>
<span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">↥</span><span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span> <span class="n">x</span><span class="o">},</span>
<span class="n">a_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">g</span> <span class="o">:</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>


<p>Any help is appreciated. Thank you!</p>



<a name="201911959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201911959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201911959">(Jun 24 2020 at 22:34)</a>:</h4>
<p>Which line gives you an error? I get a different error on the line <code>exact g</code></p>



<a name="201912008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912008">(Jun 24 2020 at 22:35)</a>:</h4>
<p>The exact g line gives the error..</p>



<a name="201912106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912106">(Jun 24 2020 at 22:36)</a>:</h4>
<p>Hmm but the error you pasted is talking about <code>rewrite</code>, is that the right one?</p>



<a name="201912216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912216">(Jun 24 2020 at 22:37)</a>:</h4>
<p>Oh, apologies, I edited the code.</p>



<a name="201912259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912259">(Jun 24 2020 at 22:38)</a>:</h4>
<p>wow that is some error</p>



<a name="201912317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912317">(Jun 24 2020 at 22:38)</a>:</h4>
<p>Yeah, that is why i changed it to rewrite, atleast it is shorter.</p>



<a name="201912321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912321">(Jun 24 2020 at 22:38)</a>:</h4>
<p>Ok, the problem is that the little up arrow means different things in your hypothesis and goal, if you want to see what its doing you can do <code>unfold_coes at *</code> to unfold the coercions.</p>



<a name="201912438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912438">(Jun 24 2020 at 22:40)</a>:</h4>
<p>You're missing an <code>end discrete_valuation_field</code>.</p>
<p>The whole point of namespaces is precisely so you <em>don't</em> have to write <code>definition discrete_valuation_field.valuation</code> after the namespace command -- you can just write <code>definition valuation ...</code>. See section 6.3 of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



<a name="201912549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912549">(Jun 24 2020 at 22:41)</a>:</h4>
<p>Also, the server has stopped working several times today. Is that the case only for me?</p>



<a name="201912557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912557">(Jun 24 2020 at 22:41)</a>:</h4>
<p>It's a server running on your computer</p>



<a name="201912607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912607">(Jun 24 2020 at 22:42)</a>:</h4>
<p>In this case it tells us that <code>g</code> is saying <code>a.val</code> is zero, as <code>a</code> is really a pair, an element of <code>K</code> and a proof that it has nonnegative valuation. So you can use <code>rw subtype.ext</code> to change the goal to  be of that form.</p>



<a name="201912985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201912985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201912985">(Jun 24 2020 at 22:47)</a>:</h4>
<p>I think the problem here is that Lean might not know what the multiplication on the integral domain is?</p>



<a name="201913075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913075">(Jun 24 2020 at 22:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">is_integral_domain</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_add</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_zero</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">neg</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_comm</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">left_distrib</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">right_distrib</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_comm</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">eq_zero_or_eq_zero_of_mul_eq_zero</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_ne_one</span> <span class="o">:=</span> <span class="bp">_</span> <span class="o">}</span>
</code></pre></div>


<p>This is the job you have to do here. I'm not sure where Lean got the ring structure on P from.</p>



<a name="201913136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913136">(Jun 24 2020 at 22:49)</a>:</h4>
<p>But the definition of add and mul must at the very least contain proofs that if 0&lt;=v(a) and 0&lt;=v(b) then 0&lt;=v(a+b) resp v(a*b) and I don't see them in your set-up.</p>



<a name="201913147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913147">(Jun 24 2020 at 22:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201912321">said</a>:</p>
<blockquote>
<p>Ok, the problem is that the little up arrow means different things in your hypothesis and goal, if you want to see what its doing you can do <code>unfold_coes at *</code> to unfold the coercions.</p>
</blockquote>
<p>wow! I have been doing a lot more work than that to figure out what my mystery coercions are, and I'm grateful that <code>unfold_coes</code> exists</p>



<a name="201913255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913255">(Jun 24 2020 at 22:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="250372">Ashvni Narayanan</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201912549">said</a>:</p>
<blockquote>
<p>Also, the server has stopped working several times today. Is that the case only for me?</p>
</blockquote>
<p><a href="#narrow/stream/113488-general/topic/crashes/near/201856564">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/crashes/near/201856564</a></p>



<a name="201913323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913323">(Jun 24 2020 at 22:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/201913136">said</a>:</p>
<blockquote>
<p>But the definition of add and mul must at the very least contain proofs that if 0&lt;=v(a) and 0&lt;=v(b) then 0&lt;=v(a+b) resp v(a*b) and I don't see them in your set-up.</p>
</blockquote>
<p>These follow pretty easily from <code>discrete_valuation_field.mul</code> and <code>discrete_valuation_field.add</code></p>



<a name="201913377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913377">(Jun 24 2020 at 22:52)</a>:</h4>
<p>Sure, but the fact that they're not in the original code makes me skeptical that the original code has got the right definition of multiplication. That's why the earlier sorry is there, I think the result is unprovable</p>



<a name="201913448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913448">(Jun 24 2020 at 22:53)</a>:</h4>
<p>I just assumed that Lean would ask for it in the proof, because in the definition, the valuation ring is just a set with no structure</p>



<a name="201913511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913511">(Jun 24 2020 at 22:54)</a>:</h4>
<p>The way I'm setting it up it will ask you when you define <code>add</code> and <code>mul</code>.</p>



<a name="201913797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913797">(Jun 24 2020 at 22:57)</a>:</h4>
<p>The definition of <code>add</code> in <code>discrete_valuation_field</code> should be rewritten so it uses &lt;= not &gt;=</p>



<a name="201913857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913857">(Jun 24 2020 at 22:58)</a>:</h4>
<p>sorry, I need to go. I didn't finish the job:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">is_integral_domain</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">change</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">val</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">add</span> <span class="n">a</span><span class="bp">.</span><span class="mi">1</span> <span class="n">b</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hb</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span> <span class="o">(</span><span class="n">b</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
      <span class="n">sorry</span>
  <span class="kn">end</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">add_assoc</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
</code></pre></div>



<a name="201913918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201913918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201913918">(Jun 24 2020 at 22:59)</a>:</h4>
<p>It's very confusing that a.val = a.1, and val is something else too. Maybe change the DVF val to v?</p>



<a name="201915860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201915860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201915860">(Jun 24 2020 at 23:25)</a>:</h4>
<p>An alternative approach is to make a term of type <code>subring K</code>. This will involve having to check far fewer axioms</p>



<a name="201946493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201946493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201946493">(Jun 25 2020 at 09:07)</a>:</h4>
<p>Here's a far less painful way to make that subset into a ring:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_add_subgroup</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">add_mem</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">neg_mem</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_submonoid</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_mem</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span><span class="bp">..</span><span class="n">is_add_subgroup</span><span class="o">,</span> <span class="bp">..</span><span class="n">is_submonoid</span><span class="o">}</span>
</code></pre></div>



<a name="201961572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201961572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201961572">(Jun 25 2020 at 12:24)</a>:</h4>
<p>What does the .. do?</p>



<a name="201961833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201961833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201961833">(Jun 25 2020 at 12:28)</a>:</h4>
<p><a href="https://leanprover.github.io/reference/declarations.html#structures-and-records">https://leanprover.github.io/reference/declarations.html#structures-and-records</a></p>



<a name="201961859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201961859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201961859">(Jun 25 2020 at 12:28)</a>:</h4>
<p>Or the more friendly <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects">https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#objects</a></p>



<a name="201961991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201961991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201961991">(Jun 25 2020 at 12:30)</a>:</h4>
<p>Thank you!</p>



<a name="201962034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201962034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201962034">(Jun 25 2020 at 12:31)</a>:</h4>
<p>All of the <code>sorry</code>s are Propositions, so you can replace them with <code>begin ... end</code> and then fill in the proofs.</p>



<a name="201963049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201963049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201963049">(Jun 25 2020 at 12:41)</a>:</h4>
<p>The last one (is_subring K) gives me an error</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="kn">structure</span> <span class="kn">notation</span> <span class="n">source</span><span class="o">,</span> <span class="n">not</span> <span class="n">a</span> <span class="kn">structure</span>
  <span class="n">is_add_subgroup</span>
<span class="n">which</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">set</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="kt">Prop</span>
</code></pre></div>



<a name="201963202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201963202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201963202">(Jun 25 2020 at 12:42)</a>:</h4>
<p>It takes an argument</p>



<a name="201963253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201963253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201963253">(Jun 25 2020 at 12:42)</a>:</h4>
<p>Also, why do both is_add_subgroup and add_subgroup exist?</p>



<a name="201963302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201963302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201963302">(Jun 25 2020 at 12:43)</a>:</h4>
<p>One of them will be removed one day (<code>is_add_subgroup</code> will be the one which goes)</p>



<a name="201963444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201963444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201963444">(Jun 25 2020 at 12:44)</a>:</h4>
<p>It seemed to me that <code>subring</code> doesn't exist so it seemed simpler to show you a unified approach. The <code>is_</code> stuff might disappear one day, but you don't have to worry about this right now.</p>



<a name="201963884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201963884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201963884">(Jun 25 2020 at 12:49)</a>:</h4>
<p>(deleted)</p>



<a name="201970953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201970953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201970953">(Jun 25 2020 at 13:48)</a>:</h4>
<p>Which version of lean and mathlib are you using</p>



<a name="201971591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201971591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201971591">(Jun 25 2020 at 13:53)</a>:</h4>
<p>I get similar problems with the latest lean + mathlib about <code>is_add_subgroup</code> not being a structure?<br>
I tried</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">refine</span> <span class="n">is_subring</span><span class="bp">.</span><span class="n">mk</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>and it looks like it worked?</p>



<a name="201975765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/201975765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#201975765">(Jun 25 2020 at 14:24)</a>:</h4>
<p>Oh nice! This seems to work. Thank you!</p>



<a name="202114974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202114974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202114974">(Jun 26 2020 at 16:51)</a>:</h4>
<p>I am trying to define S := {x : K | 0 ≤ v(x) } , the valuation ring.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>

<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>  <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">definition</span> <span class="n">valuation_ring</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">S</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">]</span>

<span class="kn">end</span> <span class="n">discrete_valuation_field</span>
</code></pre></div>


<p>I can't use the valuation_ring definition because it has no variables. I don't know how to put in a variable S there. The variables line gives me an error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">S</span> <span class="bp">=</span> <span class="n">is_subring</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span><span class="o">}</span>
<span class="n">term</span>
  <span class="n">is_subring</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span><span class="o">}</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u_2</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>


<p>It would simplify my life a great deal if I had this variable S. Any help is appreciated. Thank you!</p>



<a name="202115970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202115970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202115970">(Jun 26 2020 at 17:01)</a>:</h4>
<p>I'm confused about what you want to do with this <code>S</code>.</p>



<a name="202116000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116000">(Jun 26 2020 at 17:01)</a>:</h4>
<p>In <code>definition valuation_ring</code> you are not using <code>S</code> at all, so you can just delete it.</p>



<a name="202116150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116150">(Jun 26 2020 at 17:02)</a>:</h4>
<p><code>[S = {x : K | 0 ≤ v(x) } ]</code> will not make any sense to lean at all.<br>
If you have <code>[blabla]</code> then lean will try to add something to the type class system. That's what <code>[]</code> do. (For example <code>[ring R]</code>.)</p>



<a name="202116225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116225">(Jun 26 2020 at 17:03)</a>:</h4>
<p>It means that you tell lean: "Hey, you know this <code>R</code> that I told you about earlier. Give it the structure of a ring."</p>



<a name="202116331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116331">(Jun 26 2020 at 17:04)</a>:</h4>
<p>This is just for notation purposes, it would be easier to use S instead of {x : K | 0 ≤ v(x) }</p>



<a name="202116332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116332">(Jun 26 2020 at 17:04)</a>:</h4>
<p>Maybe you want notation?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="bp">`</span><span class="n">S</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">valuation_ring</span> <span class="n">K</span>
</code></pre></div>



<a name="202116379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116379">(Jun 26 2020 at 17:04)</a>:</h4>
<p>You shouldn't use <code>{x : K | 0 ≤ v(x) }</code> either, because you have made a definition.</p>



<a name="202116414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116414">(Jun 26 2020 at 17:05)</a>:</h4>
<p>You want to prove things about that definition instead</p>



<a name="202116752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116752">(Jun 26 2020 at 17:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202116332">said</a>:</p>
<blockquote>
<p>Maybe you want notation?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="bp">`</span><span class="n">S</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">valuation_ring</span> <span class="n">K</span>
</code></pre></div>


</blockquote>
<p>If this is what you want, it might be better to use <code>local notation</code> instead of <code>notation</code>, so that it is only notation in this file, and not everything that will import this file (in the future).</p>



<a name="202116961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202116961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202116961">(Jun 26 2020 at 17:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202116332">said</a>:</p>
<blockquote>
<p>Maybe you want notation?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">notation</span> <span class="bp">`</span><span class="n">S</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">valuation_ring</span> <span class="n">K</span>
</code></pre></div>


</blockquote>
<p>Yes! This is what I was looking for! Thanks a ton!</p>



<a name="202190539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202190539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202190539">(Jun 27 2020 at 15:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="250372">Ashvni Narayanan</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202114974">said</a>:</p>
<blockquote>
<p>I am trying to define S := {x : K | 0 ≤ v(x) } , the valuation ring.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>

<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>  <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">definition</span> <span class="n">valuation_ring</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">S</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">S</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span> <span class="o">]</span>

<span class="kn">end</span> <span class="n">discrete_valuation_field</span>
</code></pre></div>


<p>I can't use the valuation_ring definition because it has no variables. I don't know how to put in a variable S there. The variables line gives me an error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">S</span> <span class="bp">=</span> <span class="n">is_subring</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span><span class="o">}</span>
<span class="n">term</span>
  <span class="n">is_subring</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span><span class="o">}</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u_2</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>


<p>It would simplify my life a great deal if I had this variable S. Any help is appreciated. Thank you!</p>
</blockquote>
<p>In this example, I have defined valuation_ring. I am now trying to prove 0 is in the ring. The goal is :</p>
<div class="codehilite"><pre><span></span><code><span class="mi">0</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
</code></pre></div>


<p>How can I change it to</p>
<div class="codehilite"><pre><span></span><code><span class="mi">0</span> <span class="err">∈</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span> <span class="o">}</span>
</code></pre></div>


<p>I guess the general question is, how do I unravel a definition?</p>
<p>Any help is appreciated. Thank you!</p>



<a name="202190854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202190854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202190854">(Jun 27 2020 at 15:13)</a>:</h4>
<p><code>unfold val_ring</code>?</p>



<a name="202190920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202190920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202190920">(Jun 27 2020 at 15:14)</a>:</h4>
<p>Oh, great! Thank you!</p>



<a name="202190938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202190938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202190938">(Jun 27 2020 at 15:15)</a>:</h4>
<p>you should also be able to manipulate it without unfolding it, try <code>erw non_zero</code></p>



<a name="202191009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202191009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202191009">(Jun 27 2020 at 15:16)</a>:</h4>
<p>Gives the error </p>
<div class="codehilite"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">v</span> <span class="err">?</span><span class="n">m_4</span> <span class="bp">=</span> <span class="err">⊤</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
</code></pre></div>



<a name="202191576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202191576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202191576">(Jun 27 2020 at 15:30)</a>:</h4>
<p>ah, that's because we tried the wrong direction. does <code>erw ← non_zero</code> work there? <code>erw</code> means something like "<code>rw</code>, but do some definitional unfolding first"</p>



<a name="202192044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202192044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202192044">(Jun 27 2020 at 15:42)</a>:</h4>
<p>Gives this error : </p>
<div class="codehilite"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="err">?</span><span class="n">m_2</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
</code></pre></div>


<p>I am not sure rw would work here, because first it needs to be got from </p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="mi">0</span> <span class="err">∈</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span><span class="o">}</span>
</code></pre></div>


<p>to</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="mi">0</span>
</code></pre></div>


<p>which is done by simp. Unless erw also tries simp?</p>



<a name="202192750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202192750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202192750">(Jun 27 2020 at 16:01)</a>:</h4>
<p>there's a <code>simp_rw</code> which might work (i'm assuming you've gotten around this on your own and the current conversation is academic; is that right?)</p>



<a name="202192824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202192824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202192824">(Jun 27 2020 at 16:02)</a>:</h4>
<p>Yes, I constructed a lemma that showed v(0) = \top, and then used that.</p>



<a name="202193414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202193414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202193414">(Jun 27 2020 at 16:15)</a>:</h4>
<p>hopefully the proof of that lemma was just <code>rw non_zero</code>?</p>



<a name="202193436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202193436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202193436">(Jun 27 2020 at 16:16)</a>:</h4>
<p>Yes</p>



<a name="202294134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202294134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202294134">(Jun 29 2020 at 10:46)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>

<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>  <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- a = ⊤ case</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="c1">-- true by definition</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- ℤ case</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="c1">-- true by definition</span>
  <span class="o">}</span>
<span class="kn">end</span>


<span class="kn">lemma</span> <span class="n">val_one_eq_zero</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)),</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">k</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="o">{</span><span class="n">apply</span> <span class="n">mul</span><span class="o">},</span>
<span class="n">rw</span> <span class="n">k</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">g</span><span class="o">,</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)))</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="o">{</span>
<span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h1</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">non_zero</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">exfalso</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">one_ne_zero</span> <span class="n">h1</span><span class="o">,</span>
<span class="o">},</span>
<span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">n</span> <span class="n">h2</span><span class="o">,</span>
<span class="o">{</span>
<span class="n">rw</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sum_zero_iff_zero</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">norm_cast</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">linarith</span><span class="o">,</span>
<span class="o">},</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">val_ring</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">unit_iff_val_zero</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">α</span> <span class="o">:</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)]</span> <span class="o">:</span> <span class="n">v</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">is_unit</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">split</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">rintros</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_unit_iff_exists_inv</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">α</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="n">α</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">α</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="n">mul_inv_cancel</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">val_one_is_zero</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="k">from</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">by</span>
        <span class="o">{</span>
          <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span><span class="n">non_zero</span><span class="o">,</span> <span class="n">a</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
        <span class="o">},</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="n">rw</span> <span class="n">mul</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">a</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
<span class="o">},</span>
<span class="o">{</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="o">},</span>

<span class="kn">end</span> <span class="n">discrete_valuation_field</span>
</code></pre></div>


<p>I don't understand the goal for the second to last sorry:</p>
<div class="codehilite"><pre><span></span><code><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">α</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">),</span>
<span class="n">a</span> <span class="o">:</span> <span class="n">v</span> <span class="err">↑</span><span class="n">α</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">α</span> <span class="bp">*</span> <span class="bp">⟨</span><span class="o">(</span><span class="err">↑</span><span class="n">α</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>


<p>Any help is appreciated. Thank you!</p>



<a name="202296415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296415">(Jun 29 2020 at 11:17)</a>:</h4>
<p>It looks like <code>α</code> has been coerced to somewhere (you should work out where), then you've taken the inverse, and then you've put it back in <code>↥(val_ring K)</code> by providing a proof which just appears as <code>_</code>.</p>



<a name="202296432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296432">(Jun 29 2020 at 11:17)</a>:</h4>
<p>Your code doesn't compile for me -- I get an error at <code>rw sum_zero_iff_zero</code></p>



<a name="202296486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296486">(Jun 29 2020 at 11:18)</a>:</h4>
<p>Were you hoping to see <code>⊢ α * α⁻¹ = 1</code>?</p>



<a name="202296521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296521">(Jun 29 2020 at 11:19)</a>:</h4>
<p>and I get an error on <code>is_unit alpha</code> in the statement of <code>unit_iff_val_zero</code></p>



<a name="202296748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296748">(Jun 29 2020 at 11:22)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> If you want to treat <code>val_ring K</code> as a type then it would be better to define it as the subtype  <code>{ x : K // 0 ≤ v x }</code> (which is a type) rather than the subset <code>{ x : K | 0 ≤ v x }</code> (which is only a term and not a type, and keeps having to be promoted to a type with a confusing little up-arrow)</p>



<a name="202296771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296771">(Jun 29 2020 at 11:22)</a>:</h4>
<p>This can be summarised as "if you want to treat it as a set, don't define it as a subset"</p>



<a name="202296800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296800">(Jun 29 2020 at 11:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202296486">said</a>:</p>
<blockquote>
<p>Were you hoping to see <code>⊢ α * α⁻¹ = 1</code>?</p>
</blockquote>
<p>Yes</p>



<a name="202296939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202296939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202296939">(Jun 29 2020 at 11:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202296748">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="250372">Ashvni Narayanan</span> If you want to treat <code>val_ring K</code> as a type then it would be better to define it as the subtype  <code>{ x : K // 0 ≤ v x }</code> (which is a type) rather than the subset <code>{ x : K | 0 ≤ v x }</code> (which is only a term and not a type, and keeps having to be promoted to a type with a confusing little up-arrow)</p>
</blockquote>
<p>This gives me a lot of type mismatch errors, for example,</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">is_add_subgroup</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">term</span>
  <span class="n">val_ring</span> <span class="n">K</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="err">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="err">?</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">set</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span>
</code></pre></div>



<a name="202297008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297008">(Jun 29 2020 at 11:26)</a>:</h4>
<p>Yes, it will do.</p>



<a name="202297035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297035">(Jun 29 2020 at 11:26)</a>:</h4>
<p>Ah, is this because it must not be treated as a subgroup, but as a group?</p>



<a name="202297074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297074">(Jun 29 2020 at 11:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202296415">said</a>:</p>
<blockquote>
<p>It looks like <code>α</code> has been coerced to somewhere (you should work out where), then you've taken the inverse, and then you've put it back in <code>↥(val_ring K)</code> by providing a proof which just appears as <code>_</code>.</p>
</blockquote>
<p>I think it should be coerced to the field K, because that is where the inverse exists.</p>



<a name="202297234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297234">(Jun 29 2020 at 11:29)</a>:</h4>
<p>It seems to me that you are treating <code>val_ring</code> as an independent thing, rather than a subthing of a thing. Don't you have an error on <code>is_unit alpha</code> in the statement of your theorem? What's the first error in your file?</p>



<a name="202297241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297241">(Jun 29 2020 at 11:29)</a>:</h4>
<p>Not the one which confuses you, but the first one.</p>



<a name="202297336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297336">(Jun 29 2020 at 11:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202297234">said</a>:</p>
<blockquote>
<p>It seems to me that you are treating <code>val_ring</code> as an independent thing, rather than a subthing of a thing. Don't you have an error on <code>is_unit alpha</code> in the statement of your theorem? What's the first error in your file?</p>
</blockquote>
<p>I don't have any errors..</p>



<a name="202297364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297364">(Jun 29 2020 at 11:31)</a>:</h4>
<p>Are you using the latest mathlib?</p>



<a name="202297389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297389">(Jun 29 2020 at 11:31)</a>:</h4>
<p>I can't work with your file right now. If I cut and paste literally what you posted, I have errors.</p>



<a name="202297416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297416">(Jun 29 2020 at 11:31)</a>:</h4>
<p>If you cut and paste literally what you posted, do you get errors too?</p>



<a name="202297510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297510">(Jun 29 2020 at 11:33)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>

<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>

<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>  <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- a = ⊤ case</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="c1">-- true by definition</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- ℤ case</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="c1">-- true by definition</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_zero_iff_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- the hard way</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- h is a proof of a+a=0</span>
    <span class="c1">-- split into cases</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="n">a</span><span class="o">)</span> <span class="k">with</span> <span class="n">htop</span> <span class="n">hn</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- a = ⊤</span>
      <span class="n">rw</span> <span class="n">htop</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="c1">-- h is false</span>
      <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
      <span class="c1">-- no cases!</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- a = n</span>
      <span class="n">cases</span> <span class="n">hn</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hn</span> <span class="n">at</span> <span class="n">h</span> <span class="err">⊢</span><span class="o">,</span>
      <span class="c1">-- now h says n+n=0 and our goal is n=0</span>
      <span class="c1">-- but these are equalities in `with_top ℤ</span>
      <span class="c1">-- so we need to get them into ℤ</span>
      <span class="c1">-- A tactic called `norm_cast` does this</span>
     <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span> <span class="err">⊢</span><span class="o">,</span>
      <span class="c1">-- we finally have a hypothesis n + n = 0</span>
      <span class="c1">-- and a goal n = 0</span>
      <span class="c1">-- and everything is an integer</span>
      <span class="n">rw</span> <span class="n">add_self_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">assumption</span>
    <span class="o">}</span>
  <span class="o">},</span>
   <span class="o">{</span> <span class="c1">-- the easy way</span>
    <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">simp</span>
  <span class="o">}</span>
<span class="kn">end</span>
 <span class="c1">--Thanks Kevin!</span>

<span class="kn">lemma</span> <span class="n">val_one_eq_zero</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)),</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">k</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="o">{</span><span class="n">apply</span> <span class="n">mul</span><span class="o">},</span>
<span class="n">rw</span> <span class="n">k</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">g</span><span class="o">,</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)))</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="o">{</span>
<span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h1</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">non_zero</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">exfalso</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">one_ne_zero</span> <span class="n">h1</span><span class="o">,</span>
<span class="o">},</span>
<span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">n</span> <span class="n">h2</span><span class="o">,</span>
<span class="o">{</span>
<span class="n">rw</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sum_zero_iff_zero</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">norm_cast</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">linarith</span><span class="o">,</span>
<span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">val_minus_one_is_zero</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">k</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
<span class="o">{</span>
  <span class="n">apply</span> <span class="n">mul</span><span class="o">,</span>
<span class="o">},</span>
<span class="n">rw</span> <span class="n">k</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">val_one_eq_zero</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">sum_zero_iff_zero</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">g</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">val_zero</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">non_zero</span><span class="o">,</span>
<span class="kn">end</span>


<span class="kn">lemma</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">transitivity</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rintros</span><span class="o">,</span>
<span class="n">cases</span><span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="n">c</span><span class="o">)</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">n</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">cases</span><span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="n">a</span><span class="o">)</span> <span class="k">with</span> <span class="n">k1</span> <span class="n">k2</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">k1</span><span class="o">,</span> <span class="n">h2</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">k1</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">h2</span> <span class="n">at</span> <span class="n">a_2</span><span class="o">,</span>
      <span class="n">cases</span><span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="n">b</span><span class="o">)</span> <span class="k">with</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">l1</span> <span class="n">at</span> <span class="n">a_2</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">a_2</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">cases</span> <span class="n">l2</span> <span class="k">with</span> <span class="n">m</span> <span class="n">l2</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">l2</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
        <span class="n">exfalso</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">not_top_le_coe</span> <span class="n">m</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">a_1</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">k2</span> <span class="k">with</span> <span class="n">m</span> <span class="n">k2</span><span class="o">,</span>
      <span class="n">cases</span><span class="o">(</span><span class="n">with_top</span><span class="bp">.</span><span class="n">cases</span> <span class="n">b</span><span class="o">)</span> <span class="k">with</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">l1</span><span class="o">,</span><span class="n">h2</span><span class="o">]</span> <span class="n">at</span> <span class="n">a_2</span><span class="o">,</span>
        <span class="n">exfalso</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">not_top_le_coe</span> <span class="n">n</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">a_2</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">cases</span> <span class="n">l2</span> <span class="k">with</span> <span class="n">k</span> <span class="n">l2</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">k2</span><span class="o">,</span><span class="n">l2</span><span class="o">]</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">l2</span><span class="o">,</span><span class="n">h2</span><span class="o">]</span> <span class="n">at</span> <span class="n">a_2</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">k2</span><span class="o">,</span><span class="n">h2</span><span class="o">],</span>
        <span class="n">rw</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_le_coe</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_le_coe</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_le_coe</span> <span class="n">at</span> <span class="n">a_2</span><span class="o">,</span>
        <span class="n">transitivity</span> <span class="n">k</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">a_1</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">a_2</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="o">},</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">val_ring</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_add_subgroup</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">zero_mem</span> <span class="o">:=</span> <span class="k">begin</span>
              <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
              <span class="n">simp</span><span class="o">,</span>
              <span class="n">rw</span> <span class="n">val_zero</span><span class="o">,</span>
              <span class="n">simp</span><span class="o">,</span>
              <span class="kn">end</span><span class="o">,</span>
  <span class="n">add_mem</span> <span class="o">:=</span> <span class="k">begin</span>
            <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
            <span class="n">simp</span><span class="o">,</span>
            <span class="n">rintros</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">g</span> <span class="o">:</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">b</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">),</span>
            <span class="o">{</span>
              <span class="n">apply</span> <span class="n">add</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="n">rw</span> <span class="n">min_le_iff</span> <span class="n">at</span> <span class="n">g</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
            <span class="o">{</span>
              <span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">transitivity</span><span class="o">,</span>
              <span class="n">exact</span> <span class="n">a_1</span><span class="o">,</span>
              <span class="n">exact</span> <span class="n">g</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="o">{</span>
              <span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">transitivity</span><span class="o">,</span>
              <span class="n">exact</span> <span class="n">a_2</span><span class="o">,</span>
              <span class="n">exact</span> <span class="n">g</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="kn">end</span><span class="o">,</span>
  <span class="n">neg_mem</span> <span class="o">:=</span> <span class="k">begin</span>
            <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
            <span class="n">rintros</span><span class="o">,</span>
            <span class="n">simp</span><span class="o">,</span>
            <span class="n">simp</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span>
            <span class="o">{</span>
              <span class="n">simp</span><span class="o">,</span>
            <span class="o">},</span>
            <span class="n">rw</span> <span class="n">f</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">mul</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">val_minus_one_is_zero</span><span class="o">,</span>
            <span class="n">simp</span><span class="o">,</span>
            <span class="n">assumption</span><span class="o">,</span>
            <span class="kn">end</span><span class="o">,</span>
<span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_submonoid</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">one_mem</span> <span class="o">:=</span> <span class="k">begin</span>
            <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
            <span class="n">simp</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">val_one_eq_zero</span><span class="o">,</span>
            <span class="n">norm_num</span><span class="o">,</span>
            <span class="kn">end</span><span class="o">,</span>
  <span class="n">mul_mem</span> <span class="o">:=</span> <span class="k">begin</span>
            <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
            <span class="n">rintros</span><span class="o">,</span>
            <span class="n">simp</span><span class="o">,</span>
            <span class="n">simp</span> <span class="n">at</span> <span class="n">a_1</span><span class="o">,</span>
            <span class="n">simp</span> <span class="n">at</span> <span class="n">a_2</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">mul</span><span class="o">,</span>
            <span class="n">apply</span> <span class="n">add_le_add&#39;</span> <span class="n">a_1</span> <span class="n">a_2</span><span class="o">,</span>
            <span class="kn">end</span><span class="o">,</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="n">valuation_ring</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">is_subring</span><span class="bp">.</span><span class="n">mk</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">instance</span> <span class="n">is_domain</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">integral_domain</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">subring</span><span class="bp">.</span><span class="n">domain</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">),</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">unit_iff_val_zero</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">α</span> <span class="o">:</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)]</span> <span class="o">:</span> <span class="n">v</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">is_unit</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">split</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">rintros</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_unit_iff_exists_inv</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">α</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">unfold</span> <span class="n">val_ring</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="n">α</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">α</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">rw</span> <span class="n">mul_inv_cancel</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="n">val_one_eq_zero</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="k">from</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">by</span>
        <span class="o">{</span>
          <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span><span class="n">non_zero</span><span class="o">,</span> <span class="n">a</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
          <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
        <span class="o">},</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="n">rw</span> <span class="n">mul</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">a</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">norm_num</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="o">},</span>
<span class="o">},</span>
<span class="o">{</span>
  <span class="n">rintros</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_unit_iff_exists_inv</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">b</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">v</span><span class="o">((</span><span class="n">α</span><span class="o">:</span><span class="n">K</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">K</span><span class="o">))</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">K</span><span class="o">),</span>
  <span class="o">{</span>
    <span class="n">norm_cast</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="n">mul</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">val_one_eq_zero</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_eq_zero_iff&#39;</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">f_left</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">exact</span> <span class="n">α</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">exact</span> <span class="n">b</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="o">},</span>
<span class="o">}</span>
<span class="kn">end</span>
<span class="kn">end</span> <span class="n">discrete_valuation_field</span>
</code></pre></div>


<p>This might help. It is the entire file.</p>



<a name="202297614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202297614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202297614">(Jun 29 2020 at 11:34)</a>:</h4>
<p>I still get errors. You are probably using a different mathlib to me.</p>



<a name="202424722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202424722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202424722">(Jun 30 2020 at 11:55)</a>:</h4>
<p>I am trying to show that the valuation of a uniformiser is 1.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>  <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>

<span class="n">def</span> <span class="n">unif</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">π</span> <span class="bp">|</span> <span class="n">v</span> <span class="n">π</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">hπ</span> <span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">val_unif_eq_one</span> <span class="o">:</span> <span class="n">v</span><span class="o">(</span><span class="n">π</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">unfold</span> <span class="n">unif</span> <span class="n">at</span> <span class="n">hπ</span><span class="o">,</span>
<span class="kn">end</span>
<span class="kn">end</span> <span class="n">discrete_valuation_field</span>
</code></pre></div>


<p>I get an error</p>
<div class="codehilite"><pre><span></span><code><span class="n">get_local</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">unknown</span> <span class="err">&#39;</span><span class="n">hπ&#39;</span> <span class="n">local</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">π</span> <span class="o">:</span> <span class="n">K</span>
<span class="err">⊢</span> <span class="n">v</span> <span class="n">π</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>


<p>How can I rectify this? Any help is appreciated, thank you!</p>



<a name="202426630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202426630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202426630">(Jun 30 2020 at 12:16)</a>:</h4>
<p>Put <code>h\pi</code> in the lemma statement, instead of <code>variables</code></p>



<a name="202426658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202426658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202426658">(Jun 30 2020 at 12:16)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> If you introduce something with <code>variables</code>, then Lean will only use it if you mention it in the statement.</p>



<a name="202426681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202426681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202426681">(Jun 30 2020 at 12:17)</a>:</h4>
<p>That's why it picks up <code>\pi</code>, but not <code>h\pi</code>.</p>



<a name="202426740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202426740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202426740">(Jun 30 2020 at 12:17)</a>:</h4>
<p>Variables usually work well for types, and terms of types, but not for assumptions like <code>h\pi</code>. Those are better stated directly in the statement of the lemma</p>



<a name="202427357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202427357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202427357">(Jun 30 2020 at 12:25)</a>:</h4>
<p>Oh, I see. Thank you!</p>



<a name="202429188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202429188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202429188">(Jun 30 2020 at 12:45)</a>:</h4>
<p>Actually a <code>variable</code> will be included if it is used in the body too, but not inside a tactic block. (Because Lean doesn't know which tokens inside the tactic block are names until it's too late.)<br>
You can also use <code>include</code> to force a <code>variable</code> to be included in subsequent top-level definitions, but beware of accidentally <code>include</code>ing it in lemmas where you don't want it!</p>



<a name="202456986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202456986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202456986">(Jun 30 2020 at 16:01)</a>:</h4>
<p>Oh ok, thank you!</p>



<a name="202459618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202459618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202459618">(Jun 30 2020 at 16:21)</a>:</h4>
<p>I am trying to prove that for n a natural number, ↑n ≠ ⊤ : </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">bounded_lattice</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">lemma</span> <span class="n">nat_neq_top</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">n</span><span class="o">:</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_ne_top</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">a</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>I have the goals:</p>
<div class="codehilite"><pre><span></span><code><span class="mi">2</span> <span class="n">goals</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">=</span> <span class="err">⊤</span>
<span class="err">⊢</span> <span class="err">↑?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">n</span>

<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">a</span> <span class="o">:</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">=</span> <span class="err">⊤</span>
<span class="err">⊢</span> <span class="bp">ℤ</span>
</code></pre></div>


<p>I don't know how to proceed from here, I think it means that I need to show n is an integer, which can possibly be done by int.coe_nat_eq , but that does not work out.<br>
Any help is appreciated. Thank you!</p>



<a name="202459830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202459830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202459830">(Jun 30 2020 at 16:22)</a>:</h4>
<p>Does <code>with_top.coe_ne_top</code> take an argument? If so, you could try to pass it <code>n</code>.</p>



<a name="202461720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202461720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202461720">(Jun 30 2020 at 16:35)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">nat_neq_top</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">n</span><span class="o">:</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_ne_top</span> <span class="err">↑</span><span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">n</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">intro</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">&lt;-</span><span class="n">a</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_eq</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>This is as far as I can get..</p>



<a name="202462341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462341">(Jun 30 2020 at 16:39)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">nat_neq_top</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">with_top</span><span class="bp">.</span><span class="n">coe_ne_top</span> <span class="bp">ℤ</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">this</span> <span class="kn">using</span> <span class="mi">1</span><span class="o">,</span>

<span class="kn">end</span>
</code></pre></div>



<a name="202462375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462375">(Jun 30 2020 at 16:39)</a>:</h4>
<p>Unfortunately there don't seem to be lemmas for <code>\u \u n = \u n</code>.</p>



<a name="202462399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462399">(Jun 30 2020 at 16:39)</a>:</h4>
<p>Which is a hole in the with_top API that should be fixed first.</p>



<a name="202462657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462657">(Jun 30 2020 at 16:41)</a>:</h4>
<p>Doesn't this just work?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">bounded_lattice</span>

<span class="kn">lemma</span> <span class="n">nat_neq_top</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">n</span><span class="o">:</span><span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="n">with_top</span><span class="bp">.</span><span class="n">coe_ne_top</span>
</code></pre></div>



<a name="202462771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462771">(Jun 30 2020 at 16:42)</a>:</h4>
<p>Unfortunately not.</p>



<a name="202462800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462800">(Jun 30 2020 at 16:42)</a>:</h4>
<p>It would if <code>n : int</code> of course</p>



<a name="202462841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462841">(Jun 30 2020 at 16:43)</a>:</h4>
<p>Strange, I don't see any errors in my Lean.</p>



<a name="202462910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462910">(Jun 30 2020 at 16:43)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_ne_top</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="err">↑?</span><span class="n">m_2</span> <span class="bp">≠</span> <span class="err">⊤</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="err">↑</span><span class="n">n</span> <span class="bp">≠</span> <span class="err">⊤</span>
</code></pre></div>



<a name="202462953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202462953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202462953">(Jun 30 2020 at 16:44)</a>:</h4>
<p>Yeah, I get the same error</p>



<a name="202463044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202463044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202463044">(Jun 30 2020 at 16:44)</a>:</h4>
<p>This is on a mathlib that is more than 3 hours old, I admit</p>



<a name="202463094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202463094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202463094">(Jun 30 2020 at 16:44)</a>:</h4>
<p>Did I copy and paste something wrong? I don't see any errors in <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20order.bounded_lattice%0A%0Alemma%20nat_neq_top%20%28n%20%3A%E2%84%95%29%20%3A%20%28%E2%86%91n%3Awith_top%20%E2%84%A4%29%20%E2%89%A0%20%E2%8A%A4%20%3A%3D%0Awith_top.coe_ne_top%0A">the web editor either</a>.</p>



<a name="202463157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202463157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202463157">(Jun 30 2020 at 16:45)</a>:</h4>
<p>Or maybe, I could possibly avoid this if I could work with \pi^n, with n \in \Z.<br>
Is that possible?</p>



<a name="202463210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202463210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202463210">(Jun 30 2020 at 16:45)</a>:</h4>
<p>My "playground" project is apparently on commit <a href="https://github.com/leanprover-community/mathlib/commit/35fbfe0a40395e6ea394f05b1c56a2fbcf4b33ce">35fbfe0a40395e6ea394f05b1c56a2fbcf4b33ce</a> from 2 days ago.</p>



<a name="202463243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202463243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202463243">(Jun 30 2020 at 16:45)</a>:</h4>
<p>The web editor is on <a href="https://github.com/leanprover-community/mathlib/commit/056a72aa92fa6cc3430348a84e19df6853d07775">this commit</a> from 14 hours ago.</p>



<a name="202463636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202463636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202463636">(Jun 30 2020 at 16:48)</a>:</h4>
<p>Crazy <span aria-label="confused" class="emoji emoji-1f615" role="img" title="confused">:confused:</span></p>



<a name="202464259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464259">(Jun 30 2020 at 16:52)</a>:</h4>
<p><del>#3132 (merged 7 days ago) looks related, possibly?</del></p>



<a name="202464552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464552">(Jun 30 2020 at 16:54)</a>:</h4>
<div class="codehilite"><pre><span></span><code>commit 9acf5903f385e2c017cde4b93d2323d59232707a (origin/master, origin/HEAD, master)
Author: Yakov Pechersky &lt;yakov@pechersky.us&gt;
Date:   Mon Jun 29 03:57:10 2020 +0000

    feat(data/matrix/notation): smul matrix lemmas (#3208)
</code></pre></div>



<a name="202464567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464567">(Jun 30 2020 at 16:54)</a>:</h4>
<p>That's from yesterday</p>



<a name="202464670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464670">(Jun 30 2020 at 16:55)</a>:</h4>
<p>I think maybe it's <a href="https://github.com/leanprover-community/mathlib/issues/3157">#3157</a>?</p>



<a name="202464879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464879">(Jun 30 2020 at 16:57)</a>:</h4>
<p>Aha, that makes sense</p>



<a name="202464913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464913">(Jun 30 2020 at 16:57)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> Please try updating mathlib. It might solve your problem (-;</p>



<a name="202464918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464918">(Jun 30 2020 at 16:57)</a>:</h4>
<p>This also works:</p>
<div class="codehilite"><pre><span></span><code>lemma nat_neq_top (n :ℕ) : (n : with_top ℤ) ≠ ⊤ := by apply with_top.coe_ne_top
</code></pre></div>



<a name="202464998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202464998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202464998">(Jun 30 2020 at 16:58)</a>:</h4>
<p>That's what Bryan already wrote. But it depends on having today's mathlib, not yesterdays.</p>



<a name="202465018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202465018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202465018">(Jun 30 2020 at 16:58)</a>:</h4>
<p>Oh sorry :)</p>



<a name="202468252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202468252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202468252">(Jun 30 2020 at 17:23)</a>:</h4>
<p>Oh ok, I will do that. Thank you!</p>



<a name="202702937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202702937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202702937">(Jul 02 2020 at 15:22)</a>:</h4>
<p><a href="https://github.com/laughinggas/DVR/blob/cc3a8e881c914fa17f9bde07fbcead8850f9152f/src/Test.lean#L598">https://github.com/laughinggas/DVR/blob/cc3a8e881c914fa17f9bde07fbcead8850f9152f/src/Test.lean#L598</a></p>
<p>I am trying to prove Line 598. Line 608 gives me an error, I don't know how to use the lemma val_int_power then.<br>
Any help is appreciated. Thank you!</p>



<a name="202741794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202741794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202741794">(Jul 02 2020 at 20:36)</a>:</h4>
<p><code>α⁻¹</code> is notation for <code>has_inv.inv α</code>. And <code>α ^(-1)</code> is notation for <code>has_pow.pow α (-1)</code>. They're not the same, so this is why the rewrite failed.</p>



<a name="202742091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202742091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202742091">(Jul 02 2020 at 20:40)</a>:</h4>
<p>After <code>unfold val_ring</code> you can do</p>
<div class="codehilite"><pre><span></span><code>      <span class="n">suffices</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="o">(</span><span class="n">α</span> <span class="bp">^</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)),</span>
        <span class="n">simpa</span><span class="o">,</span>
</code></pre></div>


<p>and then your rewrite will work</p>



<a name="202757784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202757784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202757784">(Jul 03 2020 at 00:10)</a>:</h4>
<p>Thank you!</p>



<a name="202850826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202850826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202850826">(Jul 04 2020 at 01:52)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">ideals</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">principal_ideal_domain</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">localization</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">bounded_lattice</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field_power</span>
<span class="kn">universe</span> <span class="n">u</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">class</span> <span class="n">discrete_valuation_field</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">min</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>  <span class="o">)</span>
<span class="o">(</span><span class="n">non_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">discrete_valuation_field</span>

<span class="kn">definition</span> <span class="n">valuation</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span> <span class="o">]</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">-&gt;</span> <span class="n">with_top</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span>
<span class="n">def</span> <span class="n">val_ring</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">v</span> <span class="n">x</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">ideal_is_unif_power</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">ideal_is_unique_unif_power</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">v</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">split</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">cases</span> <span class="n">ideal_is_unif_power</span> <span class="n">S</span> <span class="n">x</span> <span class="n">H</span> <span class="k">with</span> <span class="n">m</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="o">},</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>


<p>The goal is:</p>
<div class="codehilite"><pre><span></span><code><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">),</span>
<span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">),</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span>
<span class="n">m</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">g</span> <span class="o">:</span> <span class="err">↑</span><span class="n">m</span> <span class="bp">≤</span> <span class="n">v</span> <span class="err">↑</span><span class="n">x</span>
<span class="err">⊢</span> <span class="err">↑?</span><span class="n">m_1</span> <span class="bp">≤</span> <span class="n">v</span> <span class="err">↑</span><span class="n">x</span>
</code></pre></div>


<p>I want to use g, but apply does not seem to work out. Any help is appreciated. Thank you!</p>
<div class="codehilite"><pre><span></span><code>
</code></pre></div>



<a name="202851656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851656">(Jul 04 2020 at 02:18)</a>:</h4>
<p>Does <code>exact g</code> work?</p>



<a name="202851790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851790">(Jul 04 2020 at 02:21)</a>:</h4>
<p>Wait, isn't your lemma false? Why should <code>n</code> be unique?</p>



<a name="202851851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851851">(Jul 04 2020 at 02:23)</a>:</h4>
<p>The problem is that <code>m</code> is out of scope of the metavariable</p>



<a name="202851856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851856">(Jul 04 2020 at 02:23)</a>:</h4>
<p>You tried to intro the exists before you have <code>m</code> available</p>



<a name="202851899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851899">(Jul 04 2020 at 02:24)</a>:</h4>
<p>If you move the <code>cases</code> line to the beginning then <code>exact g</code> works</p>



<a name="202851922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851922">(Jul 04 2020 at 02:25)</a>:</h4>
<p>Thank you!</p>



<a name="202851929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/202851929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#202851929">(Jul 04 2020 at 02:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/202851790">said</a>:</p>
<blockquote>
<p>Wait, isn't your lemma false? Why should <code>n</code> be unique?</p>
</blockquote>
<p>Thanks for pointing this out, you are correct, I forgot to put in additional conditions.</p>



<a name="203047320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203047320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203047320">(Jul 06 2020 at 22:16)</a>:</h4>
<p>I am trying to state the following lemma , for a discrete valuation field K, and a uniformiser π in K : </p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">contains_unif_power</span> <span class="o">(</span><span class="n">hπ</span> <span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">π</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="err">∈</span> <span class="n">S</span> <span class="o">:=</span>
</code></pre></div>


<p>This statement gives me the error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">π</span> <span class="o">:</span> <span class="n">K</span><span class="o">,</span>
<span class="n">hπ</span> <span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span><span class="o">,</span>
<span class="n">S</span> <span class="o">:</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">),</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="n">has_mem</span> <span class="n">K</span> <span class="o">(</span><span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span>
</code></pre></div>


<p>Is this because S is not realised as a subset of K? If so, is there any way around this?<br>
Any help is appreciated, thank you!</p>



<a name="203048403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203048403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203048403">(Jul 06 2020 at 22:31)</a>:</h4>
<p>You would need to either map S back to K using something like set.image, or use a proof that \pi^n is in the valuation ring. (Also, the lemma is false for the trivial ideal.)</p>



<a name="203049709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203049709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203049709">(Jul 06 2020 at 22:47)</a>:</h4>
<p>Thanks! How can I put in the nontrivial condition?</p>



<a name="203049864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203049864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203049864">(Jul 06 2020 at 22:48)</a>:</h4>
<p>Ideals are a lattice, so <code>I \ne \bot</code> is the preferred way to say I isn't the zero ideal.</p>



<a name="203049868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203049868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203049868">(Jul 06 2020 at 22:48)</a>:</h4>
<p>Add an assumption <code>S ≠ ⊥</code></p>



<a name="203049904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203049904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203049904">(Jul 06 2020 at 22:49)</a>:</h4>
<p>And as for the membership issue: <code>∃ n : ℕ, π^n ∈ set.range (λ s : S, (s : K))</code></p>



<a name="203050061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203050061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203050061">(Jul 06 2020 at 22:50)</a>:</h4>
<p>That at least typechecks. There are other possibilities as well.</p>



<a name="203050609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203050609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203050609">(Jul 06 2020 at 22:57)</a>:</h4>
<p>Yeah, I guess an equivalent lemma would be to show the ideal spanned by \pi^n lies inside S, which would involve showing \pi^n is in val_ring K.</p>



<a name="203219189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219189">(Jul 08 2020 at 00:22)</a>:</h4>
<p>Is there a way to change S ≠ ⊥ to ∃ x ∈ S, x ≠ 0 ? <br>
I only see exists_mem_ne_zero_of_ne_bot, but this does not work. I am trying to prove,</p>
<div class="codehilite"><pre><span></span><code><span class="n">K</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="bp">_</span><span class="n">inst_4</span><span class="o">:</span> <span class="n">field</span> <span class="n">K</span>
<span class="bp">_</span><span class="n">inst_5</span><span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="n">π</span><span class="o">:</span> <span class="n">K</span>
<span class="n">hπ</span><span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span>
<span class="n">S</span><span class="o">:</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">Q</span><span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">),</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">=</span> <span class="n">v</span> <span class="err">↑</span><span class="n">x</span><span class="o">}</span>
<span class="n">h</span><span class="o">:</span> <span class="n">S</span> <span class="bp">≠</span> <span class="err">⊥</span>
<span class="err">⊢</span> <span class="n">Q</span><span class="bp">.</span><span class="n">nonempty</span>
</code></pre></div>



<a name="203219283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219283">(Jul 08 2020 at 00:24)</a>:</h4>
<p>What doesn't work and what is the error message</p>



<a name="203219494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219494">(Jul 08 2020 at 00:28)</a>:</h4>
<p>Does <code>exists_mem_ne_zero_of_ne_bot</code> assume that the ring is a field?</p>



<a name="203219495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219495">(Jul 08 2020 at 00:28)</a>:</h4>
<p>That may be the issue.</p>



<a name="203219507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219507">(Jul 08 2020 at 00:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">exists_mem_ne_zero_of_ne_bot</span> <span class="n">h</span><span class="o">,</span>
</code></pre></div>


<p>does not work.<br>
exists_mem_ne_zero_of_ne_bot does not work, but I cannot expect it to work, because it is for fields, and I am not dealing with fields. I get the error :</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">exists_mem_ne_zero_of_ne_bot</span> <span class="n">h</span>
<span class="n">term</span>
  <span class="n">h</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">S</span> <span class="bp">≠</span> <span class="err">⊥</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="err">?</span><span class="n">m_6</span> <span class="bp">≠</span> <span class="err">⊥</span>
</code></pre></div>


<p>which is understandable. Is there any other way to get from S ≠ ⊥ to ∃ x ∈ S, x ≠ 0 ? <br>
Thank you!</p>



<a name="203219546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219546">(Jul 08 2020 at 00:30)</a>:</h4>
<p>It looks like there ought to be a lemma saying an ideal is bot iff all its elements are 0</p>



<a name="203219639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219639">(Jul 08 2020 at 00:31)</a>:</h4>
<p>The lemma <code>exists_mem_ne_zero_of_ne_bot</code> should be true for submoddules of any module over a ring in which <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \neq 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, but it's done in mathlib for vector spaces.</p>



<a name="203219662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219662">(Jul 08 2020 at 00:31)</a>:</h4>
<p>It should even be true for the zero ring right? because then there is no ideal other than <code>bot</code></p>



<a name="203219699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219699">(Jul 08 2020 at 00:32)</a>:</h4>
<p>yeah true.</p>



<a name="203219706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219706">(Jul 08 2020 at 00:32)</a>:</h4>
<p>in that case everything is bot :)</p>



<a name="203219850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203219850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203219850">(Jul 08 2020 at 00:35)</a>:</h4>
<p>The same exact proof works in general: </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>
<span class="kn">import</span> <span class="n">linear_algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">exists_mem_ne_zero_of_ne_bot</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">≠</span> <span class="err">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">by_contradiction</span> <span class="n">hex</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">not_not</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">]</span> <span class="kn">using</span> <span class="n">hex</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="err">$</span> <span class="n">bot_unique</span> <span class="err">$</span> <span class="k">assume</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="o">(</span><span class="n">submodule</span><span class="bp">.</span><span class="n">mem_bot</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">this</span> <span class="n">s</span> <span class="n">hs</span><span class="o">)</span>
<span class="kn">end</span>
</code></pre></div>



<a name="203220163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203220163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203220163">(Jul 08 2020 at 00:41)</a>:</h4>
<p>I think <code>contrapose!</code> should do this pretty easily</p>



<a name="203220233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203220233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203220233">(Jul 08 2020 at 00:42)</a>:</h4>
<p>I just copied the proof from mathlib :)</p>



<a name="203220253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203220253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203220253">(Jul 08 2020 at 00:42)</a>:</h4>
<p>Except I changed the field to a ring</p>



<a name="203391041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203391041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203391041">(Jul 09 2020 at 14:19)</a>:</h4>
<p>I am trying to apply a transitivity argument : </p>
<div class="codehilite"><pre><span></span><code><span class="n">K</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="bp">_</span><span class="n">inst_4</span><span class="o">:</span> <span class="n">field</span> <span class="n">K</span>
<span class="bp">_</span><span class="n">inst_5</span><span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="n">π</span><span class="o">:</span> <span class="n">K</span>
<span class="n">hπ</span><span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span>
<span class="n">S</span><span class="o">:</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">h</span><span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="err">⊥</span>
<span class="n">Q</span><span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">),</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">=</span> <span class="n">v</span> <span class="err">↑</span><span class="n">x</span><span class="o">}</span>
<span class="n">g</span><span class="o">:</span> <span class="n">v</span> <span class="o">(</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="o">(</span><span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span>
<span class="n">nz</span><span class="o">:</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="n">x</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">z</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">f_right</span><span class="o">:</span> <span class="n">v</span> <span class="err">↑</span><span class="n">z</span> <span class="bp">=</span> <span class="n">v</span> <span class="o">(</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span>
<span class="n">f_left</span><span class="o">:</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">z</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">S</span>
<span class="n">l</span><span class="o">:</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">z</span><span class="o">}</span>
<span class="err">⊢</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">S</span>
</code></pre></div>


<p>Using </p>
<div class="codehilite"><pre><span></span><code><span class="n">transitivity</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">z</span><span class="o">},</span>
</code></pre></div>


<p>gives me an error</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">S</span>
<span class="k">with</span>
  <span class="err">?</span><span class="n">m_3</span> <span class="bp">≤</span> <span class="err">?</span><span class="n">m_4</span> <span class="bp">→</span> <span class="err">?</span><span class="n">m_4</span> <span class="bp">≤</span> <span class="err">?</span><span class="n">m_5</span> <span class="bp">→</span> <span class="err">?</span><span class="n">m_3</span> <span class="bp">≤</span> <span class="err">?</span><span class="n">m_5</span>
</code></pre></div>


<p>Any help is appreciated, thank you!</p>



<a name="203391426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203391426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203391426">(Jul 09 2020 at 14:22)</a>:</h4>
<p>Looks like the <code>apply</code> bug again</p>



<a name="203391457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203391457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203391457">(Jul 09 2020 at 14:23)</a>:</h4>
<p>I would just build the term manually: <code>refine le_trans l _</code></p>



<a name="203391477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203391477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203391477">(Jul 09 2020 at 14:23)</a>:</h4>
<p>oh, you have both parts already</p>



<a name="203392114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392114">(Jul 09 2020 at 14:28)</a>:</h4>
<p>does <code>linarith</code> close it?</p>



<a name="203392166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392166">(Jul 09 2020 at 14:28)</a>:</h4>
<p><code>exact le_trans l f_left</code></p>



<a name="203392257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392257">(Jul 09 2020 at 14:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203392166">said</a>:</p>
<blockquote>
<p><code>exact le_trans l f_left</code></p>
</blockquote>
<p>This gives me the error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">le_trans</span> <span class="n">l</span>
<span class="n">term</span>
  <span class="n">l</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">z</span><span class="o">}</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="bp">≤</span> <span class="err">?</span><span class="n">m_1</span>
</code></pre></div>



<a name="203392326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392326">(Jul 09 2020 at 14:29)</a>:</h4>
<p>OK, well I don't know what this is but then you need to fix this anyways.</p>



<a name="203392349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392349">(Jul 09 2020 at 14:29)</a>:</h4>
<p>You can try <code>convert</code> instead of <code>exact</code>.</p>



<a name="203392446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392446">(Jul 09 2020 at 14:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203392114">said</a>:</p>
<blockquote>
<p>does <code>linarith</code> close it?</p>
</blockquote>
<p>No, this gives the error,</p>
<div class="codehilite"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="err">?</span><span class="n">m_3</span> <span class="bp">≤</span> <span class="err">?</span><span class="n">m_4</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">S</span>
</code></pre></div>



<a name="203392954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392954">(Jul 09 2020 at 14:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203392349">said</a>:</p>
<blockquote>
<p>You can try <code>convert</code> instead of <code>exact</code>.</p>
</blockquote>
<p>This gives me a goal :</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="n">K</span>
</code></pre></div>



<a name="203392999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203392999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203392999">(Jul 09 2020 at 14:34)</a>:</h4>
<p>Which is false... so you need to backtrack.</p>



<a name="203393169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203393169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203393169">(Jul 09 2020 at 14:36)</a>:</h4>
<p>It looks like a subtype thing again... <code>π ^ Inf Q</code> vs <code>⟨π ^ Inf Q, _⟩</code></p>



<a name="203393262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203393262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203393262">(Jul 09 2020 at 14:36)</a>:</h4>
<p>Yup. Can you <code>convert (some stuff) using 1</code></p>



<a name="203393284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203393284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203393284">(Jul 09 2020 at 14:36)</a>:</h4>
<p>The <code>using 1</code> will make it less aggresive.</p>



<a name="203395361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203395361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203395361">(Jul 09 2020 at 14:51)</a>:</h4>
<p>Is there a way to apply </p>
<div class="codehilite"><pre><span></span><code><span class="kn">using</span> <span class="mi">1</span>
</code></pre></div>


<p>to a goal of the form</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="err">⊆</span> <span class="err">↑</span><span class="n">S</span>
</code></pre></div>


<p>?</p>



<a name="203395592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203395592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203395592">(Jul 09 2020 at 14:53)</a>:</h4>
<p>I don't know what that means.</p>



<a name="203395622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203395622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203395622">(Jul 09 2020 at 14:53)</a>:</h4>
<p>What did your goal look like after the <code>convert .... using 1</code>?</p>



<a name="203395960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203395960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203395960">(Jul 09 2020 at 14:55)</a>:</h4>
<p>I actually managed to get it down to</p>
<div class="codehilite"><pre><span></span><code><span class="n">K</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="bp">_</span><span class="n">inst_4</span><span class="o">:</span> <span class="n">field</span> <span class="n">K</span>
<span class="bp">_</span><span class="n">inst_5</span><span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="n">π</span><span class="o">:</span> <span class="n">K</span>
<span class="n">hπ</span><span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span>
<span class="n">S</span><span class="o">:</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">h</span><span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="err">⊥</span>
<span class="n">Q</span><span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">),</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">=</span> <span class="n">v</span> <span class="err">↑</span><span class="n">x</span><span class="o">}</span>
<span class="n">g</span><span class="o">:</span> <span class="n">v</span> <span class="o">(</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="o">(</span><span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span>
<span class="n">nz</span><span class="o">:</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="n">x</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">a</span><span class="o">:</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="err">⊆</span> <span class="err">↑</span><span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span>
<span class="n">z</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">f_left</span><span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">S</span>
<span class="n">w</span><span class="o">:</span> <span class="n">K</span>
<span class="n">f_1</span><span class="o">:</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
<span class="n">f_2</span><span class="o">:</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">f_3</span><span class="o">:</span> <span class="err">↑</span><span class="n">z</span> <span class="bp">*</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span>
<span class="err">⊢</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="err">⊆</span> <span class="err">↑</span><span class="n">S</span>
</code></pre></div>


<p>which seems like an easier thing to show.</p>



<a name="203396168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203396168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203396168">(Jul 09 2020 at 14:57)</a>:</h4>
<p>There must be a lemma <code>singleton_subset</code> or <code>singleton_subset_iff</code></p>



<a name="203396212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203396212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203396212">(Jul 09 2020 at 14:57)</a>:</h4>
<p>Does <code>simp</code> help you here?</p>



<a name="203396241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203396241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203396241">(Jul 09 2020 at 14:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203395622">said</a>:</p>
<blockquote>
<p>What did your goal look like after the <code>convert .... using 1</code>?</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="bp">=</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">}</span>
</code></pre></div>



<a name="203396459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203396459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203396459">(Jul 09 2020 at 14:59)</a>:</h4>
<p>Aha, and with <code>using 2</code>?</p>



<a name="203396510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203396510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203396510">(Jul 09 2020 at 14:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203396212">said</a>:</p>
<blockquote>
<p>Does <code>simp</code> help you here?</p>
</blockquote>
<p>No</p>



<a name="203397272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203397272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203397272">(Jul 09 2020 at 15:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203395622">said</a>:</p>
<blockquote>
<p>What did your goal look like after the <code>convert .... using 1</code>?</p>
</blockquote>
<p>This also gives 2 more goals:</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="n">has_singleton</span> <span class="n">K</span> <span class="o">(</span><span class="n">set</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span>
</code></pre></div>



<a name="203397382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203397382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203397382">(Jul 09 2020 at 15:05)</a>:</h4>
<p>Aha, we clearly don't want that.</p>



<a name="203397405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203397405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203397405">(Jul 09 2020 at 15:05)</a>:</h4>
<p>using 2 gives</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">}</span>
</code></pre></div>


<p>plus</p>
<div class="codehilite"><pre><span></span><code><span class="err">⊢</span> <span class="n">has_singleton</span> <span class="n">K</span> <span class="o">(</span><span class="n">set</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span>
</code></pre></div>


<p>twice.</p>



<a name="203397419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203397419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203397419">(Jul 09 2020 at 15:05)</a>:</h4>
<p>So let's move back to the inclusion that you had reduced the goal to.</p>



<a name="203398639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203398639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203398639">(Jul 09 2020 at 15:14)</a>:</h4>
<p>if you livestream in discord then we can compete to tell you the tactic you need!</p>



<a name="203398682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203398682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203398682">(Jul 09 2020 at 15:15)</a>:</h4>
<p>Something strange must have happened, since <code>submodule.span ↥(val_ring K) {π ^ Inf Q}</code> shouldn't even make sense! <code>π ^ Inf Q</code> is a term of type <code>K</code>, that's why it's asking for the <code>has_singleton</code> instance.</p>



<a name="203398913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203398913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203398913">(Jul 09 2020 at 15:16)</a>:</h4>
<p>Where did your assumption <code>l</code> come from?</p>



<a name="203399773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203399773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203399773">(Jul 09 2020 at 15:23)</a>:</h4>
<p>I had not solved l, just put a sorry. :(</p>



<a name="203400011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203400011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203400011">(Jul 09 2020 at 15:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="250372">Ashvni Narayanan</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203395960">said</a>:</p>
<blockquote>
<p>I actually managed to get it down to</p>
<div class="codehilite"><pre><span></span><code><span class="n">K</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="bp">_</span><span class="n">inst_4</span><span class="o">:</span> <span class="n">field</span> <span class="n">K</span>
<span class="bp">_</span><span class="n">inst_5</span><span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span>
<span class="n">π</span><span class="o">:</span> <span class="n">K</span>
<span class="n">hπ</span><span class="o">:</span> <span class="n">π</span> <span class="err">∈</span> <span class="n">unif</span> <span class="n">K</span>
<span class="n">S</span><span class="o">:</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">h</span><span class="o">:</span> <span class="bp">¬</span><span class="n">S</span> <span class="bp">=</span> <span class="err">⊥</span>
<span class="n">Q</span><span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">),</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">=</span> <span class="n">v</span> <span class="err">↑</span><span class="n">x</span><span class="o">}</span>
<span class="n">g</span><span class="o">:</span> <span class="n">v</span> <span class="o">(</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="o">(</span><span class="n">Inf</span> <span class="n">Q</span><span class="o">)</span>
<span class="n">nz</span><span class="o">:</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="n">x</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">a</span><span class="o">:</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="err">⊆</span> <span class="err">↑</span><span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span>
<span class="n">z</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">f_left</span><span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">S</span>
<span class="n">w</span><span class="o">:</span> <span class="n">K</span>
<span class="n">f_1</span><span class="o">:</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
<span class="n">f_2</span><span class="o">:</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">f_3</span><span class="o">:</span> <span class="err">↑</span><span class="n">z</span> <span class="bp">*</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span>
<span class="err">⊢</span> <span class="o">{</span><span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">}</span> <span class="err">⊆</span> <span class="err">↑</span><span class="n">S</span>
</code></pre></div>


<p>which seems like an easier thing to show.</p>
</blockquote>
<p>This has no sorries.</p>



<a name="203400380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203400380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203400380">(Jul 09 2020 at 15:27)</a>:</h4>
<p>You can certainly solve this goal, but it looks like might want to first change <code>⟨π ^ Inf Q, _⟩</code> to <code>z * ⟨w, f_1⟩</code> where the multiplication takes place in the valuation ring, so that you can apply the ideal condition for S.</p>



<a name="203401592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203401592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203401592">(Jul 09 2020 at 15:36)</a>:</h4>
<p>How can I do this? Using a subtype argument at f_3?</p>



<a name="203401732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203401732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203401732">(Jul 09 2020 at 15:37)</a>:</h4>
<p>I think I would go for <code>rw singleton_subset_iff</code></p>



<a name="203401785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203401785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203401785">(Jul 09 2020 at 15:37)</a>:</h4>
<p>Well,  first try to reduce to proving that the element is in <code>S</code> using <code>singleton_subset_iff</code>, as Johan suggested. Then rewrite using f_3 and go from there.</p>



<a name="203406050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203406050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203406050">(Jul 09 2020 at 16:09)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">rw</span> <span class="n">singleton_subset_iff</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">submodule</span><span class="bp">.</span><span class="n">mem_coe</span><span class="o">],</span>
</code></pre></div>


<p>brings it down to </p>
<div class="codehilite"><pre><span></span><code><span class="n">z</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">f_left</span><span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">S</span>
<span class="n">w</span><span class="o">:</span> <span class="n">K</span>
<span class="n">f_1</span><span class="o">:</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
<span class="n">f_2</span><span class="o">:</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">f_3</span><span class="o">:</span> <span class="err">↑</span><span class="n">z</span> <span class="bp">*</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span>
<span class="err">⊢</span> <span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="err">∈</span> <span class="n">S</span>
</code></pre></div>


<p>rw &lt;-f_3 does not work, it gives the error :</p>
<div class="codehilite"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">motive</span> <span class="n">is</span> <span class="n">not</span> <span class="n">type</span> <span class="n">correct</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">a</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="bp">⟨</span><span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">⟨_</span><span class="n">a</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="err">∈</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div>


<p>:(</p>



<a name="203408127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203408127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203408127">(Jul 09 2020 at 16:26)</a>:</h4>
<p>I don't know what that means. Does lean know how to fill the hole in the <code>⟨π ^ Inf Q, _⟩</code>?</p>



<a name="203409780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203409780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203409780">(Jul 09 2020 at 16:40)</a>:</h4>
<p>I don't know, but I don't think so. Is there a way to check this?</p>



<a name="203410651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203410651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203410651">(Jul 09 2020 at 16:45)</a>:</h4>
<p>When the <code>_</code> is in the goal or a hypothesis like this it probably isn't a hole, but rather a proof lean has elected not to display, try <code>set_option pp.proofs true</code> to see it</p>



<a name="203410749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203410749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203410749">(Jul 09 2020 at 16:46)</a>:</h4>
<p>The context doesn't seem to know that <code>π ^ Inf Q</code> is in the valuation ring.</p>



<a name="203410804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203410804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203410804">(Jul 09 2020 at 16:46)</a>:</h4>
<p>By definition, it is not.</p>



<a name="203410830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203410830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203410830">(Jul 09 2020 at 16:47)</a>:</h4>
<p>Can someone paste some code I can try?</p>



<a name="203411176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203411176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203411176">(Jul 09 2020 at 16:50)</a>:</h4>
<p><a href="https://github.com/laughinggas/DVR/blob/86c6dad4514e328c49b62300f1546c15d773b10c/src/Test.lean#L967">https://github.com/laughinggas/DVR/blob/86c6dad4514e328c49b62300f1546c15d773b10c/src/Test.lean#L967</a></p>



<a name="203413354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203413354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203413354">(Jul 09 2020 at 17:09)</a>:</h4>
<p>On line 834, you write <code>use π^(Inf Q)</code>but this is something in <code>K</code> a priori. This might be the issue...<br>
(nevermind -- ignore this)</p>



<a name="203413380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203413380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203413380">(Jul 09 2020 at 17:09)</a>:</h4>
<p>Thanks, love the github username lol.<br>
You can use <code>simp_rw [← f_3],</code>  to rewrite <code>f_3</code> here, its a version of <code>rw</code> that works more like simp so its a bit better at rewriting things that are in a more complicated term.</p>



<a name="203413905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203413905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203413905">(Jul 09 2020 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203413354">said</a>:</p>
<blockquote>
<p>On line 834, you write <code>use π^(Inf Q)</code>but this is something in <code>K</code> a priori. This might be the issue...<br>
(nevermind -- ignore this)</p>
</blockquote>
<p>As soon as I use this, the first goal is to check that it is in val_ring K.</p>



<a name="203413991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203413991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203413991">(Jul 09 2020 at 17:15)</a>:</h4>
<p>Yeah I just noticed that. Ignore what I said.</p>



<a name="203419458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203419458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203419458">(Jul 09 2020 at 18:04)</a>:</h4>
<p><span class="user-mention" data-user-id="250372">@Ashvni Narayanan</span> What is your goal now?</p>



<a name="203419469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203419469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203419469">(Jul 09 2020 at 18:05)</a>:</h4>
<p>Or is this solved by now?</p>



<a name="203419514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203419514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203419514">(Jul 09 2020 at 18:05)</a>:</h4>
<p>No it is not :(</p>



<a name="203419717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203419717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203419717">(Jul 09 2020 at 18:07)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">z</span><span class="o">:</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
<span class="n">f_left</span><span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">S</span>
<span class="n">w</span><span class="o">:</span> <span class="n">K</span>
<span class="n">f_1</span><span class="o">:</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">val_ring</span> <span class="n">K</span>
<span class="n">f_2</span><span class="o">:</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">f_3</span><span class="o">:</span> <span class="err">↑</span><span class="n">z</span> <span class="bp">*</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">^</span> <span class="n">Inf</span> <span class="n">Q</span>
<span class="err">⊢</span> <span class="bp">⟨</span><span class="err">↑</span><span class="n">z</span> <span class="bp">*</span> <span class="n">w</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="err">∈</span> <span class="n">S</span>
</code></pre></div>


<p>This is the goal</p>



<a name="203420139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203420139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203420139">(Jul 09 2020 at 18:11)</a>:</h4>
<p>I was trying to use </p>
<div class="codehilite"><pre><span></span><code><span class="n">ideal</span><span class="bp">.</span><span class="n">mul_mem_left</span>
</code></pre></div>


<p>at f_1, but w does not have type val_ring K, which causes an issue.</p>



<a name="203420404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203420404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203420404">(Jul 09 2020 at 18:13)</a>:</h4>
<p>Try <code>change z * \&lt;w,f_1\&gt; \in S</code></p>



<a name="203420479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203420479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203420479">(Jul 09 2020 at 18:14)</a>:</h4>
<p>I'm not sure if that will help.</p>



<a name="203420770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203420770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203420770">(Jul 09 2020 at 18:17)</a>:</h4>
<p><code>apply S.mul_mem_right f_left</code>?</p>



<a name="203420781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203420781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203420781">(Jul 09 2020 at 18:17)</a>:</h4>
<p>Or something like that.</p>



<a name="203421158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203421158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203421158">(Jul 09 2020 at 18:21)</a>:</h4>
<p>Yes, that works. Thank you so much!</p>



<a name="203421177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203421177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203421177">(Jul 09 2020 at 18:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/DVRs/near/203420404">said</a>:</p>
<blockquote>
<p>Try <code>change z * \&lt;w,f_1\&gt; \in S</code></p>
</blockquote>
<p>It helped, thank you!</p>



<a name="203536869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203536869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203536869">(Jul 10 2020 at 17:42)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">is_dvr</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">prime_ideal&#39;</span> <span class="o">:=</span> <span class="k">begin</span>
                  <span class="k">have</span> <span class="n">hπ</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">π</span> <span class="o">:</span> <span class="n">K</span><span class="o">,</span> <span class="n">v</span><span class="o">(</span><span class="n">π</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
                  <span class="o">{</span>
                    <span class="n">cases</span> <span class="n">hv</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">π</span> <span class="n">hv</span><span class="o">,</span>
                    <span class="n">use</span> <span class="n">π</span><span class="o">,</span>
                    <span class="n">rw</span> <span class="n">hv</span><span class="o">,</span>
                  <span class="o">},</span>
                  <span class="n">cases</span> <span class="n">hπ</span> <span class="k">with</span> <span class="n">π</span> <span class="n">hπ</span><span class="o">,</span>
                  <span class="n">use</span> <span class="n">submodule</span><span class="bp">.</span><span class="n">span</span> <span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span> <span class="o">{</span><span class="n">π</span><span class="o">},</span>
                  <span class="kn">end</span>
<span class="o">}</span>
</code></pre></div>


<p>This is not a mwe. The </p>
<div class="codehilite"><pre><span></span><code><span class="n">cases</span> <span class="n">hπ</span> <span class="k">with</span> <span class="n">π</span> <span class="n">hπ</span><span class="o">,</span>
</code></pre></div>


<p>line gives me an error : </p>
<div class="codehilite"><pre><span></span><code><span class="n">induction</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">recursor</span> <span class="err">&#39;</span><span class="n">Exists</span><span class="bp">.</span><span class="n">dcases_on&#39;</span> <span class="n">can</span> <span class="n">only</span> <span class="n">eliminate</span> <span class="n">into</span> <span class="kt">Prop</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">hπ</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">K</span><span class="o">),</span> <span class="n">v</span> <span class="n">π</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="err">⊢</span> <span class="n">ideal</span> <span class="err">↥</span><span class="o">(</span><span class="n">val_ring</span> <span class="n">K</span><span class="o">)</span>
</code></pre></div>


<p>I don't understand why, because I have used exactly the same code elsewhere and it did not create any issues.<br>
Any help is appreciated, thank you!</p>



<a name="203537401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203537401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203537401">(Jul 10 2020 at 17:47)</a>:</h4>
<p>That probably means that your goal is not a proposition</p>



<a name="203537490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203537490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203537490">(Jul 10 2020 at 17:48)</a>:</h4>
<p>Your definition of the prime ideal is data so should really be done in term mode</p>



<a name="203537562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203537562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203537562">(Jul 10 2020 at 17:49)</a>:</h4>
<p>You should probably prove the lemma beforehand, that there exists pi with valuation 1</p>



<a name="203537597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203537597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203537597">(Jul 10 2020 at 17:49)</a>:</h4>
<p>And then use classical.some to define the prime ideal in one line</p>



<a name="203537935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203537935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203537935">(Jul 10 2020 at 17:52)</a>:</h4>
<p>Oh alright, thank you!</p>



<a name="203538033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203538033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203538033">(Jul 10 2020 at 17:53)</a>:</h4>
<p>It's probably better to define it in some more obviously invariant way, like the span of all elements of valuation 1, or just the set of elements of positive valuation (right?)</p>



<a name="203538206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203538206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203538206">(Jul 10 2020 at 17:55)</a>:</h4>
<p>That's a good idea</p>



<a name="203538238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203538238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203538238">(Jul 10 2020 at 17:55)</a>:</h4>
<p>Then you can prove it's also spanned by any element of valuation 1</p>



<a name="203538598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/DVRs/near/203538598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/DVRs.html#203538598">(Jul 10 2020 at 17:58)</a>:</h4>
<p>So then when you make the definition, you can define the set (which is data) directly, and then prove that it's an ideal in tactic mode and you won't get the weird error</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
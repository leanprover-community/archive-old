---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Naming.20contest.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html">Naming contest</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213781917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213781917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213781917">(Oct 19 2020 at 13:08)</a>:</h4>
<p>How would you call</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">some_name</span> <span class="o">:</span> <span class="n">affine_subspace</span> <span class="n">k</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">},</span> <span class="bp">..</span> <span class="o">}</span>
</code></pre></div>

<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">some_name</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→₀</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">f</span> <span class="bp">|</span> <span class="n">f.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">x</span><span class="o">}</span>
</code></pre></div>

<p><span class="user-mention" data-user-id="266253">@Joseph Myers</span> I want to rewrite affine combinations based on the first definition. This way we'll have an API much closer to what's used in <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_independent">docs#linear_independent</a>.</p>



<a name="213782470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213782470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213782470">(Oct 19 2020 at 13:13)</a>:</h4>
<p>Can you show the typeclasses on <code>α </code> and <code>k</code>?</p>



<a name="213782986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213782986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213782986">(Oct 19 2020 at 13:16)</a>:</h4>
<p><code>simplex</code> for the second one?</p>



<a name="213783043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783043">(Oct 19 2020 at 13:17)</a>:</h4>
<p>The second one looks more suited to a <code>Prop</code> or perhaps a subtype rather than a set to me</p>
<ul>
<li><code>is_some_name (f : α →₀ k) : Prop := f.sum (λ a, id) = 1 ∧ ∀ x, 0 ≤ f x</code></li>
<li><code>is_some_name : Type := { f : α →₀ k // f.sum (λ a, id) = 1 ∧ ∀ x, 0 ≤ f x}</code></li>
</ul>
<p>(or both)</p>



<a name="213783073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783073">(Oct 19 2020 at 13:17)</a>:</h4>
<p>(I'm on mobile, so I can't see some Unicode, but I assume those are finsupps?)</p>



<a name="213783310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783310">(Oct 19 2020 at 13:19)</a>:</h4>
<p>Yes, arrows are finsupps</p>



<a name="213783334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783334">(Oct 19 2020 at 13:19)</a>:</h4>
<p>The first one is the affine space generated by the second one, which is the "standard" simplex, right?</p>



<a name="213783382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783382">(Oct 19 2020 at 13:19)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> The second one is the convex hull of all <code>single x 1</code>, so I want it as a set.</p>



<a name="213783453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783453">(Oct 19 2020 at 13:20)</a>:</h4>
<p>No typeclasses on <code>α</code>, <code>semiring</code> or <code>ring</code> on <code>k</code>.</p>



<a name="213783521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783521">(Oct 19 2020 at 13:20)</a>:</h4>
<p>Well, you need an order on k for the second one</p>



<a name="213783582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783582">(Oct 19 2020 at 13:21)</a>:</h4>
<p>Yes, an ordered semiring for the second one.</p>



<a name="213783673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783673">(Oct 19 2020 at 13:21)</a>:</h4>
<p>Those are universal objects for affine spaces with marked points and convex sets with marked points (as <code>finsupp</code> is for vector spaces with marked points).</p>



<a name="213783833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213783833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213783833">(Oct 19 2020 at 13:22)</a>:</h4>
<p><code>free_affine</code> and <code>free_convex</code> for names?</p>



<a name="213831262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213831262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213831262">(Oct 19 2020 at 19:11)</a>:</h4>
<p>Whatever the implementation approach, <code>weighted_vsub</code> (combinations with sum of weights 0) should be implemented consistently with <code>affine_combination</code> (combinations with sum of weights 1) and it should be easy to work with both of those together.</p>



<a name="213831387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213831387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213831387">(Oct 19 2020 at 19:12)</a>:</h4>
<p>In principle, <code>finsupp</code> makes sense for the weights. In practice, I think you'll need to do a lot of work on the <code>finsupp</code> API to make it as convenient to work with <code>finsupp</code> as it is to work with the <code>big_operators</code> API for sums over <code>finset</code>s.</p>



<a name="213831677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213831677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213831677">(Oct 19 2020 at 19:14)</a>:</h4>
<p>Existing code using affine combinations uses of lots of <code>big_operators</code> lemmas, some of which were added to make those proofs more convenient. It constructs concrete weights using e.g. <code>function.const</code>, <code>function.update</code>, <code>set.indicator</code> and lambdas using <code>ite</code> and <code>dite</code> to describe weights piecewise. There are various lemmas for sums and products involving those operations; corresponding API will be needed for use of those operations or equivalent operations for <code>finsupp</code>.</p>



<a name="213831921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213831921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213831921">(Oct 19 2020 at 19:16)</a>:</h4>
<p>There are also cases where concrete weights in geometry are defined using pattern matching on <code>points_with_circumcenter_index</code>.</p>



<a name="213832353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213832353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213832353">(Oct 19 2020 at 19:20)</a>:</h4>
<p>Some of the manipulations in <code>geometry.euclidean.monge_point</code> dispose of quite complicated expressions with a quick <code>simp</code>, so should serve as a reasonable stress test for parts of the API for doing such things with <code>finsupp</code>.</p>



<a name="213832434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/213832434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#213832434">(Oct 19 2020 at 19:21)</a>:</h4>
<p>I understand that if I want to refactor, then migrating existing code is my job ;)</p>



<a name="230693939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/230693939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#230693939">(Mar 17 2021 at 13:57)</a>:</h4>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span></span> be a category, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> an object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> a set of objects in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span></span>.</p>
<p>Consider the full subcategory of the over category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">C</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> given by arrows <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \to X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Y \in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>. </p>
<p>What should this category be called?</p>



<a name="230736772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/230736772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#230736772">(Mar 17 2021 at 17:51)</a>:</h4>
<p>Well, I still don't know if this has a name, but I called it <code>over_trunc</code> in the specific case I'm thinking about:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/f3215b8e8b0929c62d9803632629d5af732c37fa/src/algebraic_topology/simplex_category.lean#L345">https://github.com/leanprover-community/mathlib/blob/f3215b8e8b0929c62d9803632629d5af732c37fa/src/algebraic_topology/simplex_category.lean#L345</a></p>



<a name="230773792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/230773792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#230773792">(Mar 17 2021 at 21:56)</a>:</h4>
<p>I think one popular name for that would be that it's a comma category. Specifically one would give a name to the full subcategory of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex"> C </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex"> S </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> -- say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex"> D </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> -- and then it's the comma category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (D, X) </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>.</p>



<a name="231172751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/231172751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#231172751">(Mar 20 2021 at 21:29)</a>:</h4>
<p>New naming contest, with a series of three lemmas (improvements and golfing also welcome):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">yo</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="n">N</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">strict_mono</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="o">(</span><span class="n">φ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">choose</span> <span class="n">u</span> <span class="n">hu</span> <span class="n">hu'</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.rec_on</span> <span class="n">n</span> <span class="o">(</span><span class="n">u</span> <span class="mi">0</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">v</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">strict_mono.nat</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hu</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span> <span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hu'</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">yo'</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">N</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">strict_mono</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="o">(</span><span class="n">φ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">yo</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="n">n</span> <span class="o">(</span><span class="n">N</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">,</span> <span class="n">hk'</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="n">k</span><span class="bp">;</span> <span class="n">tauto</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">yo''</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">N</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">strict_mono</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="o">(</span><span class="n">φ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">yo'</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="n">n</span> <span class="k">with</span> <span class="n">N₀</span> <span class="n">hN₀</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">max</span> <span class="n">N</span> <span class="n">N₀</span><span class="o">,</span> <span class="n">le_max_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">hN₀</span> <span class="n">_</span> <span class="bp">$</span> <span class="n">le_max_right</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="231178074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/231178074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#231178074">(Mar 20 2021 at 23:20)</a>:</h4>
<p>They can be golfed a little if you're willing to change the hypotheses to involve <code>eventually</code> and <code>frequently</code>.  I feel like there is more that can be done in this direction, but at least this is a start:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kn">open</span> <span class="n">filter</span>

<span class="kd">lemma</span> <span class="n">yo</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∃ᶠ</span> <span class="n">k</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">strict_mono</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="o">(</span><span class="n">φ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">frequently_at_top'</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">choose</span> <span class="n">u</span> <span class="n">hu</span> <span class="n">hu'</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.rec_on</span> <span class="n">n</span> <span class="o">(</span><span class="n">u</span> <span class="mi">0</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">v</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">strict_mono.nat</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hu</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span> <span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hu'</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">yo''</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∀ᶠ</span> <span class="n">k</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">strict_mono</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="o">(</span><span class="n">φ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">yo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">frequently</span><span class="o">)</span>
</code></pre></div>



<a name="231226101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/231226101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#231226101">(Mar 21 2021 at 16:28)</a>:</h4>
<p><code>exists_strict_mono_forall_of_frequently</code>?</p>



<a name="231380102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/231380102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#231380102">(Mar 22 2021 at 20:33)</a>:</h4>
<p>Thanks Heather and Yury. I wanted to PR this to <code>order.basic</code>, next to <code>strict_mono.nat</code> so it's a bit early in the hierarchy for frequently and eventually. But I guess I could put it in <code>order.filter.at_top_bot</code></p>



<a name="246782807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246782807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246782807">(Jul 21 2021 at 21:35)</a>:</h4>
<p>I would like to introduce something approximately like the following category</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">inductive</span> <span class="n">thing</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">left</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">right</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">thing</span>

<span class="kn">namespace</span> <span class="n">thing</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">inductive</span> <span class="n">hom</span> <span class="o">:</span> <span class="n">thing</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">thing</span> <span class="n">f</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">id</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">thing</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">X</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">of</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">left</span> <span class="bp">$</span> <span class="n">f</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">hom.comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">thing</span> <span class="n">f</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">),</span> <span class="n">hom</span> <span class="n">X</span> <span class="n">Z</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hom.id</span> <span class="n">_</span><span class="o">)</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">H</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hom.of</span> <span class="n">b</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hom.id</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hom.of</span> <span class="n">b</span> <span class="n">g</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">tidy</span><span class="o">]</span> <span class="n">tactic.case_bash</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">thing</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">hom</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="n">hom.id</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">,</span> <span class="n">hom.comp</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">thing</span>
</code></pre></div>
<p>Does this thing have a name? (Ping <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> since this is related to stating the sheaf condition in the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span> is a two-term type)</p>



<a name="246782988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246782988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246782988">(Jul 21 2021 at 21:37)</a>:</h4>
<p><code>f</code> might as well have type <code>f : γ → β → α</code>, right?</p>



<a name="246783096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246783096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246783096">(Jul 21 2021 at 21:38)</a>:</h4>
<p>(Of course! Fixed)</p>



<a name="246783195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246783195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246783195">(Jul 21 2021 at 21:39)</a>:</h4>
<p>This is some common generalization of the diagrams we use for wide pullbacks and for equalizers.</p>



<a name="246783748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246783748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246783748">(Jul 21 2021 at 21:45)</a>:</h4>
<p>Maybe you can use this to generalise wide equalizers too?</p>



<a name="246783768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246783768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246783768">(Jul 21 2021 at 21:45)</a>:</h4>
<p>Yeah, that should be possible</p>



<a name="246784047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246784047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246784047">(Jul 21 2021 at 21:48)</a>:</h4>
<p>If you take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha = \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span> to be <code>punit</code>, and <code>f punit.star</code> to be the identity, that should give the shape for wide equalizers</p>



<a name="246784071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246784071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246784071">(Jul 21 2021 at 21:48)</a>:</h4>
<p>Umm, sorry not quite.</p>



<a name="246784104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246784104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246784104">(Jul 21 2021 at 21:48)</a>:</h4>
<p>I want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha = \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> to both be <code>punit</code>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span> arbitrary</p>



<a name="246784117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246784117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246784117">(Jul 21 2021 at 21:49)</a>:</h4>
<p>That should give wide euqlizers</p>



<a name="246784142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246784142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246784142">(Jul 21 2021 at 21:49)</a>:</h4>
<p>with usual equalizers being <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>=</mo><mi>f</mi><mi>i</mi><mi>n</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\gamma = fin 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord">2</span></span></span></span></p>



<a name="246823848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246823848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246823848">(Jul 22 2021 at 09:08)</a>:</h4>
<p>It might be easier to define this as a path category? You probably want to think of functors out of it as just collections of arrows</p>



<a name="246825342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/246825342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#246825342">(Jul 22 2021 at 09:27)</a>:</h4>
<p>It might be easier to define this as a path category? You probably want to think of functors out of it as just collections of arrows</p>



<a name="281088674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/281088674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#281088674">(May 03 2022 at 22:49)</a>:</h4>
<p>How should I call this? It is useful, e.g., to define <a href="https://leanprover-community.github.io/mathlib_docs/find/bornology">docs#bornology</a> on a quotient space.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.basic</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span>

<span class="kd">def</span> <span class="n">name_me</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sets</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">t</span><span class="bp">ᶜ</span><span class="o">)</span><span class="bp">ᶜ</span><span class="o">},</span>
  <span class="n">univ_sets</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">univ</span><span class="o">,</span> <span class="n">univ_mem</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
  <span class="n">sets_of_superset</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">_</span> <span class="n">t</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hsl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="n">hst</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span><span class="o">,</span> <span class="n">mem_of_superset</span> <span class="n">hsl</span> <span class="o">(</span><span class="n">subset_union_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">compl_union</span><span class="o">,</span> <span class="bp">←</span> <span class="n">preimage_compl</span><span class="o">,</span> <span class="n">image_inter_preimage</span><span class="o">,</span> <span class="n">compl_inter</span><span class="o">,</span> <span class="n">compl_compl</span><span class="o">,</span>
      <span class="n">union_eq_self_of_subset_left</span> <span class="n">hst</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">inter_sets</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hsl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">htl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">,</span> <span class="n">inter_mem</span> <span class="n">hsl</span> <span class="n">htl</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">compl_inter</span><span class="o">,</span> <span class="n">image_union</span><span class="o">,</span> <span class="n">compl_union</span><span class="o">]⟩</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="281089565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/281089565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#281089565">(May 03 2022 at 22:57)</a>:</h4>
<p>Is this the right adjoint of filter.comap?</p>



<a name="281094379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/281094379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#281094379">(May 03 2022 at 23:51)</a>:</h4>
<p>Indeed,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">la</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">lb</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">comap</span> <span class="n">f</span> <span class="n">lb</span> <span class="bp">≤</span> <span class="n">la</span> <span class="bp">↔</span> <span class="n">lb</span> <span class="bp">≤</span> <span class="n">name_me</span> <span class="n">f</span> <span class="n">la</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">H</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">H</span> <span class="n">hs</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hts</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">mem_of_superset</span> <span class="n">ht</span> <span class="o">(</span><span class="n">subset_compl_comm.1</span> <span class="bp">$</span> <span class="n">image_subset_iff.2</span> <span class="bp">$</span> <span class="n">compl_subset_compl.2</span> <span class="n">hts</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">H</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">preimage_compl</span><span class="o">,</span> <span class="n">compl_subset_comm</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">subset_preimage_image</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="281106598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/281106598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#281106598">(May 04 2022 at 03:24)</a>:</h4>
<p><code>filter.cocomap</code>?</p>



<a name="284413724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/284413724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iván Sadofschi Costa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#284413724">(May 30 2022 at 23:39)</a>:</h4>
<p>What would be a good name for these?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">name_me</span>  <span class="o">(</span><span class="n">F</span> <span class="n">E</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">E</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">E</span><span class="o">)</span> <span class="bp">↪</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">σ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_scalar_tower.to_alg_hom</span> <span class="n">F</span> <span class="n">E</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="n">σ.to_alg_hom</span><span class="o">,</span>
 <span class="bp">λ</span> <span class="n">σ</span> <span class="n">τ</span> <span class="n">h</span><span class="o">,</span> <span class="n">alg_equiv.ext_iff.2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">no_zero_smul_divisors.algebra_map_injective</span> <span class="n">E</span>
   <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">alg_hom.ext_iff.1</span> <span class="n">h</span> <span class="n">a</span><span class="o">))⟩</span>

<span class="kd">def</span> <span class="n">name_me'</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normal</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">E</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">))</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">E</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine</span> <span class="n">equiv.mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">)),</span> <span class="o">(</span><span class="n">alg_hom.restrict_normal'</span> <span class="n">σ</span> <span class="n">E</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">σ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_scalar_tower.to_alg_hom</span> <span class="n">F</span> <span class="n">E</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="n">σ.to_alg_hom</span><span class="o">)</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">σ</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">alg_hom.restrict_normal'</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span>
  <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">σ</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">alg_hom.restrict_normal'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_equiv.to_alg_hom_eq_coe</span><span class="o">,</span> <span class="n">alg_equiv.coe_of_bijective</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">no_zero_smul_divisors.algebra_map_injective</span> <span class="n">E</span> <span class="o">(</span><span class="n">algebraic_closure</span> <span class="n">E</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">alg_hom.restrict_normal_commutes</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>(These definitions use <a href="https://github.com/leanprover-community/mathlib/pull/14450">#14450</a>)</p>



<a name="284449318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/284449318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#284449318">(May 31 2022 at 09:35)</a>:</h4>
<p>I'd argue you should replace <code>E ≃ₐ[F] E</code> with <code>E →ₐ[F] E</code> there</p>



<a name="284452065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/284452065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#284452065">(May 31 2022 at 10:01)</a>:</h4>
<p>Based on <a href="https://leanprover-community.github.io/mathlib_docs/find/alg_equiv.aut">docs#alg_equiv.aut</a> I'd say something like <code>name_me := alg_equiv.aut_embedding_(algebraic_)closure</code> and <code>name_me' := alg_equiv.alg_hom_(algebraic_)closure_equiv_aut</code>.</p>



<a name="284452776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/284452776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#284452776">(May 31 2022 at 10:08)</a>:</h4>
<p>Although if we make that statement more general and use <code>alg_hom</code> then that name isn't going to help much...</p>



<a name="284452839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/284452839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#284452839">(May 31 2022 at 10:09)</a>:</h4>
<p>It looks to me like it would factor better into "composing with an injective alg_hom is itself injective"</p>



<a name="284452869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/284452869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#284452869">(May 31 2022 at 10:09)</a>:</h4>
<p>we have <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.cancel_left">docs#linear_map.cancel_left</a>, but it's not stated in terms of <code>function.injective</code>, and we're also missing the alg_hom version</p>



<a name="286702246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702246">(Jun 19 2022 at 10:29)</a>:</h4>
<p>The three results below (two of them special cases of the first) are very common in measure theory and probability theory, but they don't appear to have sufficiently standard recognizable names and I am failing to come up with good mathlib style naming (that is easy for a probabilist/analyst to guess and find), too. These results are in PR <a href="https://github.com/leanprover-community/mathlib/pull/14424">#14424</a>, and I'm looking for better names than the ones used in the PR. Help appreciated!</p>
<p>The naming (in math, not in mathlib) has been <a href="#narrow/stream/113489-new-members/topic/Portmanteau.20theorem/near/244488754">discussed before</a>. The names "layer cake representation" and "Cavalieri's principle" were pointed out to me then. But my feeling is that very few mathematicians recognize the result with either of those names.</p>



<a name="286702251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702251">(Jun 19 2022 at 10:29)</a>:</h4>
<ul>
<li><code>layercake</code> (the general result): Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span> be a (sigma-finite) measure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>X</mi><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \colon X \to [0,\infty]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∞</span><span class="mclose">]</span></span></span></span> a measurable function. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : [0,\infty) \to [0,\infty)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∞</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∞</span><span class="mclose">)</span></span></span></span> be an increasing differentiable function with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\phi(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>. Then:</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mo>∫</mo><mi>X</mi></msub><mo stretchy="false">(</mo><mi>ϕ</mi><mo>∘</mo><mi>f</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>μ</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>ϕ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>μ</mi><mo stretchy="false">{</mo><mi>f</mi><mo>≥</mo><mi>t</mi><mo stretchy="false">}</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\int_X (\phi \circ f) \, \mathrm{d} \mu = \int_0^\infty \phi&#x27;(t) \, \mu \{ f \ge t \} \, \mathrm{d} t .</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2719em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.4336em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3262em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">μ</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p>
<ul>
<li><code>layercake_one</code> (the most common use case): Taking <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\phi(t) = t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>, one obtains</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mo>∫</mo><mi>X</mi></msub><mi>f</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>μ</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mi>μ</mi><mo stretchy="false">{</mo><mi>f</mi><mo>≥</mo><mi>t</mi><mo stretchy="false">}</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\int_X f \, \mathrm{d} \mu = \int_0^\infty \mu \{ f \ge t \} \, \mathrm{d} t .</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2719em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.4336em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3262em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">μ</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p>
<ul>
<li><code>layercake_p</code> (another common case for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">L^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> considerations): Taking <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>t</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">\phi(t) = t^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span>, one obtains</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mo>∫</mo><mi>X</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mi>p</mi></msup><mtext> </mtext><mi mathvariant="normal">d</mi><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mtext>  </mtext><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>μ</mi><mo stretchy="false">{</mo><mi>f</mi><mo>≥</mo><mi>t</mi><mo stretchy="false">}</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\int_X f(x)^p \, \mathrm{d} \mu (x) = p \; \int_0^\infty t^{p-1} \, \mu \{ f \ge t \} \, \mathrm{d} t .</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2719em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.4336em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">μ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3262em;vertical-align:-0.9119em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">μ</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p>



<a name="286702306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702306">(Jun 19 2022 at 10:30)</a>:</h4>
<p>To facilitate mathlib-style naming, here are the actual types:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">layercake</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">sigma_finite</span> <span class="n">μ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f_nn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">f_mble</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g_intble</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">interval_integrable</span> <span class="n">g</span> <span class="n">volume</span> <span class="mi">0</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g_nn</span> <span class="o">:</span> <span class="bp">∀ᵐ</span> <span class="n">t</span> <span class="bp">∂</span><span class="o">(</span><span class="n">volume.restrict</span> <span class="o">(</span><span class="n">Ioi</span> <span class="mi">0</span><span class="o">)),</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∫⁻</span> <span class="n">ω</span><span class="o">,</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="bp">∫</span> <span class="n">t</span> <span class="k">in</span> <span class="mi">0</span> <span class="bp">..</span> <span class="n">f</span> <span class="n">ω</span><span class="o">,</span> <span class="n">g</span> <span class="n">t</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ</span>
    <span class="bp">=</span> <span class="bp">∫⁻</span> <span class="n">t</span> <span class="k">in</span> <span class="n">Ioi</span> <span class="mi">0</span><span class="o">,</span> <span class="n">μ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">a</span><span class="o">}</span> <span class="bp">*</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">g</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">layercake_one</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">sigma_finite</span> <span class="n">μ</span><span class="o">]</span> <span class="o">(</span><span class="n">f_nn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">f_mble</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∫⁻</span> <span class="n">ω</span><span class="o">,</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">f</span> <span class="n">ω</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ</span> <span class="bp">=</span> <span class="bp">∫⁻</span> <span class="n">t</span> <span class="k">in</span> <span class="n">Ioi</span> <span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">μ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">a</span><span class="o">})</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">layercake_p</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">measure</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">sigma_finite</span> <span class="n">μ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f_nn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">f_mble</span> <span class="o">:</span> <span class="n">measurable</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">p_large</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∫⁻</span> <span class="n">ω</span><span class="o">,</span> <span class="n">ennreal.of_real</span> <span class="o">((</span><span class="n">f</span> <span class="n">ω</span><span class="o">)</span><span class="bp">^</span><span class="n">p</span><span class="o">)</span> <span class="bp">∂</span><span class="n">μ</span>
    <span class="bp">=</span> <span class="o">(</span><span class="n">ennreal.of_real</span> <span class="n">p</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">∫⁻</span> <span class="n">t</span> <span class="k">in</span> <span class="n">Ioi</span> <span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">μ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">a</span><span class="o">})</span> <span class="bp">*</span> <span class="n">ennreal.of_real</span> <span class="o">(</span><span class="n">t</span><span class="bp">^</span><span class="o">(</span><span class="n">p</span><span class="bp">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="286702312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702312">(Jun 19 2022 at 10:30)</a>:</h4>
<p>It turned out that <span class="user-mention" data-user-id="243312">@Jason KY.</span> independently proved and PR'ed the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>:th power case <code>layercake_p</code> in <a href="https://github.com/leanprover-community/mathlib/pull/14769">#14769</a> under the name <code>integral_pow_nonneg_eq_integral_meas_le</code> (minor differences: <code>integral</code> instead of <code>lintegral</code>, and some differences in hypotheses). This option and some inspired by it are included below.</p>



<a name="286702315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702315">(Jun 19 2022 at 10:30)</a>:</h4>
<p>/poll What should <code>layercake</code> be called?</p>
<p><code>layercake</code><br>
<code>lintegral_primitive_comp_eq_lintegral_measure_le_mul</code></p>



<a name="286702324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702324">(Jun 19 2022 at 10:31)</a>:</h4>
<p>/poll What should layercake_one be called?</p>
<p>layercake_one<br>
lintegral_eq_lintegral_measure_le</p>



<a name="286702331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286702331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286702331">(Jun 19 2022 at 10:31)</a>:</h4>
<p>/poll What should <code>layercake_p</code> be called?</p>
<p>layercake_p<br>
integral_rpow_nonneg_eq_integral_meas_le<br>
lintegral_rpow_comp_eq_lintegral_measure_le<br>
lintegral_rpow_comp_eq_lintegral_measure_le_mul_deriv_rpow</p>



<a name="286703100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286703100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286703100">(Jun 19 2022 at 10:51)</a>:</h4>
<p>(Oops, sorry! The copy-pasted option from Jason's PR had <code>integral</code>. Clearly the <code>lintegral</code>/<code>integral</code> choice will be an uncontroversial part of the naming, so please disregard that difference.)</p>



<a name="286706404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286706404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286706404">(Jun 19 2022 at 12:09)</a>:</h4>
<p>Sorry, my polls are not ideally organized, as there are many components at play at once. The above was meant as a poll about which assumptions (nonnegativity, composition, weighing the second integral by the derivative) need to be indicated by the naming --- or alternatively whether there is a single recognizable name such as "layercake" or "Cavalieri" that could be used instead of specific assumptions. But there are other naming issues at play here...</p>



<a name="286706417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286706417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286706417">(Jun 19 2022 at 12:09)</a>:</h4>
<p>One aspect that I think can be independently chosen from the rest is the following. Jason used the terminology <em>tail probability formula</em> for these, which I think is quite descriptive for probabilists (I might have used complementary cumulative distribution function). Since the component <code>measure_le</code> often might refer to <code>μ s ≤ ...</code> but here refers to <code>μ {a : α | t ≤ f a}</code>, is it better to dub it <code>measure_tail</code>?</p>
<p>Another aspect is abbreviating <code>measure</code> to <code>meas</code>. Versions with <code>meas_le</code>s could sound more concise (as well as more contagiouos <span aria-label="rolling eyes" class="emoji emoji-1f644" role="img" title="rolling eyes">:rolling_eyes:</span>) than <code>measure_le</code>s.</p>
<p>Let me still poll about those separately. (I think opinions about these can be incorporated into the above opinions about which assumptions are the ones that the naming should refer to.)</p>



<a name="286706422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286706422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286706422">(Jun 19 2022 at 12:09)</a>:</h4>
<p>/poll As a component in the names, which one(s) should we prefer?<br>
<code>measure_le</code><br>
<code>meas_le</code><br>
<code>measure_tail</code><br>
<code>meas_tail</code></p>



<a name="286707502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286707502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286707502">(Jun 19 2022 at 12:33)</a>:</h4>
<p>My problem with <code>tail</code> is that there is no way to guess it if you don't already know that's is used for this in the library.</p>



<a name="286711438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286711438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286711438">(Jun 19 2022 at 14:04)</a>:</h4>
<p>I might imagine people searching for these results with the substring <code>(l)integral_measure</code> or <code>(l)integral_measure_mul</code>. If so, the <code>tail</code> vs <code>le</code> should only make only a small difference for finding them. On the other hand, some probabilist might actually try <code>tail</code>, <code>measure_tail</code>, or <code>(l)integral_tail</code> as substrings, but I of course fully agree we can't count on that. My mild preference is mainly due to the <code>μ s ≤ ...</code> vs <code>μ {a : α | t ≤ f a}</code> distinction.</p>



<a name="286711501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286711501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle Kytölä <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286711501">(Jun 19 2022 at 14:06)</a>:</h4>
<p>If <code>tail</code> is not used in the naming, then we should perhaps at least use the term "tail probability" in docstrings --- I suppose the API documentation search will then find this for someone who search using "tail" keywords.</p>



<a name="286713107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286713107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286713107">(Jun 19 2022 at 14:40)</a>:</h4>
<p>I think you could use "epigraph" or "supergraph" in the name: <a href="https://en.wikipedia.org/wiki/Epigraph_(mathematics)">https://en.wikipedia.org/wiki/Epigraph_(mathematics)</a></p>



<a name="286713159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286713159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286713159">(Jun 19 2022 at 14:40)</a>:</h4>
<p>This is already part of the naming convention: <a href="https://leanprover-community.github.io/mathlib_docs/find/convex_on.convex_epigraph">docs#convex_on.convex_epigraph</a></p>



<a name="286713186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Naming%20contest/near/286713186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Naming.20contest.html#286713186">(Jun 19 2022 at 14:41)</a>:</h4>
<p>See also stuff around <a href="https://leanprover-community.github.io/mathlib_docs/find/quasiconvex">docs#quasiconvex</a>, eg. <a href="https://leanprover-community.github.io/mathlib_docs/find/quasiconvex_on.convex_lt">docs#quasiconvex_on.convex_lt</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
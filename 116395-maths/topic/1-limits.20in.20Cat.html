---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/1-limits.20in.20Cat.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html">1-limits in Cat</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270118438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270118438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270118438">(Jan 31 2022 at 22:40)</a>:</h4>
<p>Hi! I'm spending this week proving that Cat is complete (as a 1-category). Whilst this is "evil" somehow since Cat is really a 2-category, I think the results are worth having in mathlib. The non-master branch of my repo currently contains constructions of binary products and equalizers in Cat. <a href="https://github.com/Jlh18/discrete_fibrations/tree/Joseph">https://github.com/Jlh18/discrete_fibrations/tree/Joseph</a> is this worth a PR?</p>



<a name="270119902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270119902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270119902">(Jan 31 2022 at 22:52)</a>:</h4>
<p>Ping <span class="user-mention" data-user-id="224323">@Junyan Xu</span></p>



<a name="270128759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270128759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270128759">(Feb 01 2022 at 00:08)</a>:</h4>
<p>This doesn't look too bad as far as <code>eq_to_hom</code> stuff is concerned, but I wonder if we have to deal with <code>eq_to_hom</code> anyways, maybe we can get a bigger payoff, like proving <code>Cat</code> is equivalent to some presentation of the 1-category of categories that doesn't involve dependent types.</p>



<a name="270128835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270128835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270128835">(Feb 01 2022 at 00:09)</a>:</h4>
<p>For example the presentation in terms of objects and morphisms with source and target maps and partially defined composition (which is the models of an essentially algebraic theory), or even the presentation as a reflective subcategory of simplicial sets.</p>



<a name="270157884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270157884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270157884">(Feb 01 2022 at 06:06)</a>:</h4>
<p><a href="https://github.com/Jlh18/discrete_fibrations/compare/Joseph...alreadydone:patch-1">Golfed the product part</a>; why didn't you do it with arbitrary product? Because we don't have a category structure on the pi type yet? Will think about equalizers tomorrow; wondering whether using heq instead of eq in the definition of hom could lead to easier proofs.</p>



<a name="270182075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270182075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270182075">(Feb 01 2022 at 10:12)</a>:</h4>
<p>oh wow, thanks for that <span class="user-mention" data-user-id="224323">@Junyan Xu</span> . I am going to prove things about arbitrary product today! I did binary products first because I wanted to first get used to the category theory library with an easier exercise. </p>
<p>I am not familiar with the theory that you mention <span class="user-mention" data-user-id="110032">@Reid Barton</span> ,  so I probably won't be doing that... So the conclusion is that this is not good PR material, given that this alternative is available?</p>



<a name="270184841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270184841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270184841">(Feb 01 2022 at 10:33)</a>:</h4>
<p>hext is amazing</p>



<a name="270214960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270214960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270214960">(Feb 01 2022 at 14:04)</a>:</h4>
<p>Using hext results in a goal without eq_to_hom, which is simpler in some sense, but there are very few lemmas about == (heq), for example there's no analogue of prod.ext for heq in mathlib, so I need to do <code>dsimp [prod_map, (‚â´)], cases F.map f, refl</code> instead of just <code>prod.ext rfl rfl</code> (in fact the types are defeq as I realized today and <code>heq_of_eq (prod.ext rfl rfl)</code> works). eq_to_hom is used to flush everything into the same type, and then heq can be expressed using = (eq), and all lemmas about eq can be used. It's not too bad to work with heq in this case, as many things involved are "almost defeq", i.e. Lean can recognized them to be defeq once the structures are broken down into its components using <code>cases</code>.</p>



<a name="270236124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270236124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270236124">(Feb 01 2022 at 16:05)</a>:</h4>
<p>I'm struggling to find the right definition for equalizers using <code>heq</code>. The objects should just be as I originally had, requiring <code>F.obj x = G.obj x</code>, but it seems like requiring <code>F.map f == G.map f</code> for morphisms is not a good idea, since I can't do cases on a proof of the statement.</p>



<a name="270299665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270299665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270299665">(Feb 01 2022 at 22:35)</a>:</h4>
<p>okay i showed that the category of small category has all small limits. I'm still confused about how equalizers should work using <code>heq</code></p>



<a name="270329909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270329909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270329909">(Feb 02 2022 at 03:53)</a>:</h4>
<p>Sorry to make you confused. I was just wondering whether heq would make equalizer simpler as well, given that it works well with products; but it turns out not to be the case. Although generally speaking heq between morphisms is equivalent to eq between morphisms conjugated by eq_to_hom, heq has less library support and most lemmas are stated in terms of eq_to_hom. (eq_to_hom seems to play well with simp lemmas, while proofs involving heq often requires the <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Reindexing.20a.20dependent.20product/near/262352108"><code>generalize</code> tactic</a> and that may be hard to automate, and if you want to compose to non-defeq'ly composable morphisms, you have to use eq_to_hom; these are possibly why people invented eq_to_hom and mostly abandoned heq.) Though I'm able to define the equalizer category using heq, it's complicated and this is the best I can get:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>equalizer.str'</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equalizer.str'</span> <span class="o">:</span> <span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span> <span class="n">c</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">//</span> <span class="n">F.obj</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">‚ü∂</span> <span class="n">y.1</span> <span class="bp">//</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">G.map</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span><span class="o">,</span> <span class="o">‚ü®</span><span class="mi">ùüô</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">erw</span> <span class="o">[</span><span class="n">F.map_id</span><span class="o">,</span> <span class="n">G.map_id</span><span class="o">,</span> <span class="n">x.2</span><span class="o">]‚ü©,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="n">f.1</span> <span class="bp">‚â´</span> <span class="n">g.1</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">F.map_comp</span><span class="o">,</span> <span class="n">G.map_comp</span><span class="o">],</span>
    <span class="k">have</span> <span class="n">hf</span> <span class="o">:=</span> <span class="n">f.2</span><span class="o">,</span> <span class="k">have</span> <span class="n">hg</span> <span class="o">:=</span> <span class="n">g.2</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f.1</span> <span class="bp">=</span> <span class="n">Ff</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hf</span><span class="o">,</span> <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">G.map</span> <span class="n">f.1</span> <span class="bp">=</span> <span class="n">Gf</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">g.1</span> <span class="bp">=</span> <span class="n">Fg</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hg</span><span class="o">,</span> <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">G.map</span> <span class="n">g.1</span> <span class="bp">=</span> <span class="n">Gg</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hg</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="k">have</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">x.2</span><span class="o">,</span> <span class="k">have</span> <span class="n">hy</span> <span class="o">:=</span> <span class="n">y.2</span><span class="o">,</span> <span class="k">have</span> <span class="n">hz</span> <span class="o">:=</span> <span class="n">z.2</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">x.1</span> <span class="bp">=</span> <span class="n">Fx</span> <span class="n">at</span> <span class="n">Ff</span> <span class="n">hx</span> <span class="bp">‚ä¢</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">y.1</span> <span class="bp">=</span> <span class="n">Fy</span> <span class="n">at</span> <span class="n">Ff</span> <span class="n">Fg</span> <span class="n">hy</span> <span class="bp">‚ä¢</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">z.1</span> <span class="bp">=</span> <span class="n">Fz</span> <span class="n">at</span> <span class="n">Fg</span> <span class="n">hz</span> <span class="bp">‚ä¢</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hx</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hy</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hz</span><span class="o">,</span> <span class="n">apply</span> <span class="n">heq_of_eq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eq_of_heq</span> <span class="n">hf</span><span class="o">,</span> <span class="n">eq_of_heq</span> <span class="n">hg</span><span class="o">]</span> <span class="o">}</span> <span class="o">‚ü©</span> <span class="o">}</span>
</code></pre></div>
</div></div>
<p>and here is a proof that the heq condition is equivalent to the "eq to conjugation by eq_to_hom" condition:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>heq_iff_eq_conj_eq_to_hom</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">heq_iff_eq_conj_eq_to_hom</span> <span class="o">{</span><span class="n">c‚ÇÅ</span> <span class="n">c‚ÇÇ</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">h‚ÇÅ</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÅ</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c‚ÇÅ</span><span class="o">)</span> <span class="o">(</span><span class="n">h‚ÇÇ</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÇ</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c‚ÇÇ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">c‚ÇÅ</span> <span class="bp">‚ü∂</span> <span class="n">c‚ÇÇ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">eq_to_hom</span> <span class="n">h‚ÇÅ</span> <span class="bp">‚â´</span> <span class="n">G.map</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="n">eq_to_hom</span> <span class="n">h‚ÇÇ.symm</span> <span class="bp">‚Üî</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">G.map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">generalize</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">Ff</span><span class="o">,</span> <span class="n">generalize</span> <span class="o">:</span> <span class="n">G.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">Gf</span><span class="o">,</span> <span class="n">clear</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÅ</span> <span class="bp">=</span> <span class="n">F‚ÇÅ</span> <span class="n">at</span> <span class="n">h‚ÇÅ</span> <span class="n">Ff</span> <span class="bp">‚ä¢</span><span class="o">,</span> <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÇ</span> <span class="bp">=</span> <span class="n">F‚ÇÇ</span> <span class="n">at</span> <span class="n">h‚ÇÇ</span> <span class="n">Ff</span> <span class="bp">‚ä¢</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h‚ÇÅ</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h‚ÇÇ</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>
</code></pre></div>
</div></div>
<p>Now that limits are done, are you proceeding to colimits?</p>



<a name="270344307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270344307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270344307">(Feb 02 2022 at 07:29)</a>:</h4>
<p>Seems we don't have the forgetful functor from Cat to Type (taking the object part). We'd like to show it preserves (co)limits.</p>



<a name="270360138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270360138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270360138">(Feb 02 2022 at 10:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/1-limits.20in.20Cat/near/270329909">said</a>:</p>
<blockquote>
<p>Sorry to make you confused. I was just wondering whether heq would make equalizer simpler as well, given that it works well with products; but it turns out not to be the case. Although generally speaking heq between morphisms is equivalent to eq between morphisms conjugated by eq_to_hom, heq has less library support and most lemmas are stated in terms of eq_to_hom. (eq_to_hom seems to play well with simp lemmas, while proofs involving heq often requires the <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Reindexing.20a.20dependent.20product/near/262352108"><code>generalize</code> tactic</a> and that may be hard to automate, and if you want to compose to non-defeq'ly composable morphisms, you have to use eq_to_hom; these are possibly why people invented eq_to_hom and mostly abandoned heq.) Though I'm able to define the equalizer category using heq, it's complicated and this is the best I can get:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>equalizer.str'</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equalizer.str'</span> <span class="o">:</span> <span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span> <span class="n">c</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">//</span> <span class="n">F.obj</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">‚ü∂</span> <span class="n">y.1</span> <span class="bp">//</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">G.map</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span><span class="o">,</span> <span class="o">‚ü®</span><span class="mi">ùüô</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">erw</span> <span class="o">[</span><span class="n">F.map_id</span><span class="o">,</span> <span class="n">G.map_id</span><span class="o">,</span> <span class="n">x.2</span><span class="o">]‚ü©,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="n">f.1</span> <span class="bp">‚â´</span> <span class="n">g.1</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">F.map_comp</span><span class="o">,</span> <span class="n">G.map_comp</span><span class="o">],</span>
    <span class="k">have</span> <span class="n">hf</span> <span class="o">:=</span> <span class="n">f.2</span><span class="o">,</span> <span class="k">have</span> <span class="n">hg</span> <span class="o">:=</span> <span class="n">g.2</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f.1</span> <span class="bp">=</span> <span class="n">Ff</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hf</span><span class="o">,</span> <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">G.map</span> <span class="n">f.1</span> <span class="bp">=</span> <span class="n">Gf</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">g.1</span> <span class="bp">=</span> <span class="n">Fg</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hg</span><span class="o">,</span> <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">G.map</span> <span class="n">g.1</span> <span class="bp">=</span> <span class="n">Gg</span> <span class="n">at</span> <span class="bp">‚ä¢</span> <span class="n">hg</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="k">have</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">x.2</span><span class="o">,</span> <span class="k">have</span> <span class="n">hy</span> <span class="o">:=</span> <span class="n">y.2</span><span class="o">,</span> <span class="k">have</span> <span class="n">hz</span> <span class="o">:=</span> <span class="n">z.2</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">x.1</span> <span class="bp">=</span> <span class="n">Fx</span> <span class="n">at</span> <span class="n">Ff</span> <span class="n">hx</span> <span class="bp">‚ä¢</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">y.1</span> <span class="bp">=</span> <span class="n">Fy</span> <span class="n">at</span> <span class="n">Ff</span> <span class="n">Fg</span> <span class="n">hy</span> <span class="bp">‚ä¢</span><span class="o">,</span>
    <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">z.1</span> <span class="bp">=</span> <span class="n">Fz</span> <span class="n">at</span> <span class="n">Fg</span> <span class="n">hz</span> <span class="bp">‚ä¢</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hx</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hy</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hz</span><span class="o">,</span> <span class="n">apply</span> <span class="n">heq_of_eq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eq_of_heq</span> <span class="n">hf</span><span class="o">,</span> <span class="n">eq_of_heq</span> <span class="n">hg</span><span class="o">]</span> <span class="o">}</span> <span class="o">‚ü©</span> <span class="o">}</span>
</code></pre></div>
</div></div>
<p>and here is a proof that the heq condition is equivalent to the "eq to conjugation by eq_to_hom" condition:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>heq_iff_eq_conj_eq_to_hom</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">heq_iff_eq_conj_eq_to_hom</span> <span class="o">{</span><span class="n">c‚ÇÅ</span> <span class="n">c‚ÇÇ</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">h‚ÇÅ</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÅ</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c‚ÇÅ</span><span class="o">)</span> <span class="o">(</span><span class="n">h‚ÇÇ</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÇ</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c‚ÇÇ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">c‚ÇÅ</span> <span class="bp">‚ü∂</span> <span class="n">c‚ÇÇ</span><span class="o">)</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">eq_to_hom</span> <span class="n">h‚ÇÅ</span> <span class="bp">‚â´</span> <span class="n">G.map</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="n">eq_to_hom</span> <span class="n">h‚ÇÇ.symm</span> <span class="bp">‚Üî</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">G.map</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">generalize</span> <span class="o">:</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">Ff</span><span class="o">,</span> <span class="n">generalize</span> <span class="o">:</span> <span class="n">G.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">Gf</span><span class="o">,</span> <span class="n">clear</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÅ</span> <span class="bp">=</span> <span class="n">F‚ÇÅ</span> <span class="n">at</span> <span class="n">h‚ÇÅ</span> <span class="n">Ff</span> <span class="bp">‚ä¢</span><span class="o">,</span> <span class="n">generalize_hyp</span> <span class="o">:</span> <span class="n">F.obj</span> <span class="n">c‚ÇÇ</span> <span class="bp">=</span> <span class="n">F‚ÇÇ</span> <span class="n">at</span> <span class="n">h‚ÇÇ</span> <span class="n">Ff</span> <span class="bp">‚ä¢</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h‚ÇÅ</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h‚ÇÇ</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>
</code></pre></div>
</div></div>
<p>Now that limits are done, are you gonna proceed to colimits? Seems eq.rec is inevitable to define homs for the sigma category ... Oh it's actually Grothendieck construction with base a discrete category ... <del>Maybe the Grothendieck construction yields the colimit for arbitrary diagram ...</del></p>
</blockquote>
<p>Ah okay - yeah I couldn't figure out how to generalize the data <code>F.map f</code> to eliminate it. I'll try to see if this definition could tidy up my work. Thanks a lot!</p>
<p>About coproducts: it seems to me that <code>category_theory.elements</code> and <code>category_theory.sigma</code> are kind of duplicates of the same Grothendieck construction. Would it be nicer to make the <code>sigma</code> version from the <code>elements</code> version by making the indexing type <code>I</code> a discrete category? Either way, I will use this both for making pullbacks (which I would like to have a direct construction for) and maybe I'll do colimits too.</p>



<a name="270394307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270394307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270394307">(Feb 02 2022 at 14:44)</a>:</h4>
<p>Oh I didn't know that <code>category_theory.sigma.basic</code> and <code>category_theory.pi.basic</code> exist! It seems <code>sigma</code> works for a  functor from a discrete category to Cat, while <code>elements</code> works for a functor from an arbitrary category to Type, so they are complementary instead of special case of one another (and there is also <code>grothendieck</code> that works for a functor from any category to Cat, which I've generalized to oplax functors). <code>sigma</code> defines the homs not via another sigma type, but directly as an inductive type, which may or may not be easy to work with, and it would be interesting to try.</p>



<a name="270394789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270394789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270394789">(Feb 02 2022 at 14:47)</a>:</h4>
<p>I found it a lot easier to work with the homs for <code>sigma</code> as an inductive type rather than a sigma type, because it avoids <code>eq.rec</code> and <code>eq_to_hom</code> sorts of things showing up everywhere and it made the proofs more awkward than usual to work with! My original method was to use a standard sigma type though</p>



<a name="270396162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270396162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270396162">(Feb 02 2022 at 14:55)</a>:</h4>
<p>I just finished golfing the equalizer proof using <code>heq</code> and refactoring maps into the limit <span class="user-mention" data-user-id="224323">@Junyan Xu</span> . There are a bunch of irrelevant comments about authenticity (I'm submitting this as coursework) so please ignore them.</p>



<a name="270396353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270396353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270396353">(Feb 02 2022 at 14:56)</a>:</h4>
<p>Also made a couple of lemmas for composition working with <code>heq</code></p>



<a name="270407555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270407555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270407555">(Feb 02 2022 at 15:59)</a>:</h4>
<p>oh right elements is for functors into Type u silly me</p>



<a name="270417895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270417895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270417895">(Feb 02 2022 at 16:54)</a>:</h4>
<p>Joseph -- is this for the assessment "prove a theorem at 1st year undergraduate level" due in on Friday? <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="270503740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270503740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270503740">(Feb 03 2022 at 05:45)</a>:</h4>
<p>Just want to note that <code>map_comp_heq</code> has an easy proof using <code>congr'</code> as in</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>equalizer.str'</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equalizer.str'</span> <span class="o">:</span> <span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span> <span class="n">c</span> <span class="bp">//</span> <span class="n">F.obj</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">‚ü∂</span> <span class="n">y.1</span> <span class="bp">//</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">G.map</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="mi">ùüô</span> <span class="n">x</span> <span class="o">,</span> <span class="kd">by</span> <span class="n">erw</span> <span class="o">[</span><span class="n">F.map_id</span><span class="o">,</span> <span class="n">G.map_id</span><span class="o">,</span> <span class="n">x.2</span><span class="o">]</span> <span class="o">‚ü©,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="n">f.1</span> <span class="bp">‚â´</span> <span class="n">g.1</span> <span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">F.map_comp</span><span class="o">,</span> <span class="n">G.map_comp</span><span class="o">],</span>
    <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">exacts</span> <span class="o">[</span><span class="n">x.2</span><span class="o">,</span> <span class="n">y.2</span><span class="o">,</span> <span class="n">z.2</span><span class="o">,</span> <span class="n">f.2</span><span class="o">,</span> <span class="n">g.2</span><span class="o">]</span> <span class="o">}</span> <span class="o">‚ü©</span> <span class="o">}</span>
</code></pre></div>
</div></div>



<a name="270615576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270615576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270615576">(Feb 03 2022 at 20:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/1-limits.20in.20Cat/near/270503740">said</a>:</p>
<blockquote>
<p>Just want to note that <code>map_comp_heq</code> has an easy proof using <code>congr'</code> as in</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>equalizer.str'</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">equalizer.str'</span> <span class="o">:</span> <span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span> <span class="n">c</span> <span class="bp">//</span> <span class="n">F.obj</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">G.obj</span> <span class="n">c</span> <span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">‚ü∂</span> <span class="n">y.1</span> <span class="bp">//</span> <span class="n">F.map</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">G.map</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="mi">ùüô</span> <span class="n">x</span> <span class="o">,</span> <span class="kd">by</span> <span class="n">erw</span> <span class="o">[</span><span class="n">F.map_id</span><span class="o">,</span> <span class="n">G.map_id</span><span class="o">,</span> <span class="n">x.2</span><span class="o">]</span> <span class="o">‚ü©,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">‚ü®</span> <span class="n">f.1</span> <span class="bp">‚â´</span> <span class="n">g.1</span> <span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">F.map_comp</span><span class="o">,</span> <span class="n">G.map_comp</span><span class="o">],</span>
    <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">exacts</span> <span class="o">[</span><span class="n">x.2</span><span class="o">,</span> <span class="n">y.2</span><span class="o">,</span> <span class="n">z.2</span><span class="o">,</span> <span class="n">f.2</span><span class="o">,</span> <span class="n">g.2</span><span class="o">]</span> <span class="o">}</span> <span class="o">‚ü©</span> <span class="o">}</span>
</code></pre></div>
<p></div></div><br>
</p>
</blockquote>
<p>oh wow that's slick. but why does it work? I don't see how being "less aggressive at breaking down the goal"  helps</p>



<a name="270632126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270632126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270632126">(Feb 03 2022 at 23:04)</a>:</h4>
<p>If you try <code>congr</code> you'll see it's too aggressive and produces five identical goals <code>F = G</code> which isn't necessarily true...</p>



<a name="270632354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270632354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270632354">(Feb 03 2022 at 23:06)</a>:</h4>
<p>and this is the output of <code>show_term { congr' 1, exacts [x.2, y.2, z.2, f.2, g.2] }</code>:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exact</span> <span class="n">eq.rec</span>
  <span class="o">(</span><span class="bp">Œª</span> <span class="o">[</span><span class="n">self</span> <span class="o">:</span> <span class="n">category_struct</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">]</span> <span class="o">(</span><span class="n">self'</span> <span class="o">:</span> <span class="n">category_struct</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">self</span> <span class="bp">==</span> <span class="n">self'</span><span class="o">),</span>
     <span class="n">eq.rec</span>
       <span class="o">(</span><span class="bp">Œª</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">X'</span> <span class="o">:</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">e_2</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">==</span> <span class="n">X'</span><span class="o">),</span>
          <span class="n">eq.rec</span>
            <span class="o">(</span><span class="bp">Œª</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">Y'</span> <span class="o">:</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">e_3</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">==</span> <span class="n">Y'</span><span class="o">),</span>
               <span class="n">eq.rec</span>
                 <span class="o">(</span><span class="bp">Œª</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">}</span> <span class="o">(</span><span class="n">Z'</span> <span class="o">:</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">e_4</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">==</span> <span class="n">Z'</span><span class="o">),</span>
                    <span class="n">eq.rec</span>
                      <span class="o">(</span><span class="bp">Œª</span> <span class="o">(</span><span class="n">·æ∞</span> <span class="n">·æ∞'</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">‚ü∂</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">e_5</span> <span class="o">:</span> <span class="n">·æ∞</span> <span class="bp">==</span> <span class="n">·æ∞'</span><span class="o">),</span>
                         <span class="n">eq.rec</span>
                           <span class="o">(</span><span class="bp">Œª</span> <span class="o">(</span><span class="n">·æ∞_1</span> <span class="n">·æ∞'</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">‚ü∂</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">e_6</span> <span class="o">:</span> <span class="n">·æ∞_1</span> <span class="bp">==</span> <span class="n">·æ∞'</span><span class="o">),</span>
                              <span class="n">eq.rec</span> <span class="o">(</span><span class="n">heq.refl</span> <span class="o">(</span><span class="n">·æ∞</span> <span class="bp">‚â´</span> <span class="n">·æ∞_1</span><span class="o">))</span> <span class="o">(</span><span class="n">eq_of_heq</span> <span class="n">e_6</span><span class="o">))</span>
                           <span class="o">(</span><span class="n">eq_of_heq</span> <span class="n">e_5</span><span class="o">))</span>
                      <span class="o">(</span><span class="n">eq_of_heq</span> <span class="n">e_4</span><span class="o">))</span>
                 <span class="o">(</span><span class="n">eq_of_heq</span> <span class="n">e_3</span><span class="o">))</span>
            <span class="o">(</span><span class="n">eq_of_heq</span> <span class="n">e_2</span><span class="o">))</span>
       <span class="o">(</span><span class="n">eq_of_heq</span> <span class="n">e_1</span><span class="o">))</span>
  <span class="o">(</span><span class="n">eq.refl</span> <span class="bp">‚Ü•</span><span class="n">D</span><span class="o">)</span>
  <span class="n">category.to_category_struct</span>
  <span class="o">(</span><span class="n">heq_of_eq</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">category.to_category_struct</span><span class="o">))</span>
  <span class="o">(</span><span class="n">G.obj</span> <span class="n">x.val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">heq_of_eq</span> <span class="n">x.property</span><span class="o">)</span>
  <span class="o">(</span><span class="n">G.obj</span> <span class="n">y.val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">heq_of_eq</span> <span class="n">y.property</span><span class="o">)</span>
  <span class="o">(</span><span class="n">G.obj</span> <span class="n">z.val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">heq_of_eq</span> <span class="n">z.property</span><span class="o">)</span>
  <span class="o">(</span><span class="n">F.map</span> <span class="n">f.val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">G.map</span> <span class="n">f.val</span><span class="o">)</span>
  <span class="n">f.property</span>
  <span class="o">(</span><span class="n">F.map</span> <span class="n">g.val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">G.map</span> <span class="n">g.val</span><span class="o">)</span>
  <span class="n">g.property</span>
</code></pre></div>
</div></div>



<a name="270634799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270634799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270634799">(Feb 03 2022 at 23:26)</a>:</h4>
<p>yeah i used show_term to have a look too. I guess it first looks for proofs of equality then tries to compare the terms, rather than looking to compare the terms, then checking equality (which fails)?</p>



<a name="270644726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270644726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270644726">(Feb 03 2022 at 23:43)</a>:</h4>
<p>I don't quite get the question. Are you asking why <code>congr</code> fails? It doesn't actually fail but produces goals you won't be able to prove. For example <code>congr' 1</code> produces <code>F.obj x.val = G.obj x.val</code>, but <code>congr</code> breaks it down one step further to get <code>F = G</code>, which is too much. It seems <code>congr</code> does recognize equalities in the context (but not the ones buried in a structure like subtype) but doesn't automatically apply them: if you do <code>have := x.2</code> before <code>congr</code> you see that the first resulting goal becomes <code>F.obj x.val = G.obj x.val</code> (which is the type of <code>x.2</code> but not automatically solved) but the other four goals remain <code>F = G</code>. <code>congr'</code> in contrast automatically uses equalities to solve resulting goals: if you do <code>have := x.2, have := y.2, have := z.2, have := f.2, have := g.2, congr' 1</code> then <code>goals accomplished</code>.</p>



<a name="270645041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/1-limits%20in%20Cat/near/270645041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/1-limits.20in.20Cat.html#270645041">(Feb 03 2022 at 23:47)</a>:</h4>
<p>you answered my question with yes haha, that is what I vaguely had in mind</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
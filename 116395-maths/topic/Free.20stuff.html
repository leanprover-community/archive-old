---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Free.20stuff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html">Free stuff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209502556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209502556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209502556">(Sep 09 2020 at 12:15)</a>:</h4>
<p>I'm wondering about the recent PR <a href="https://github.com/leanprover-community/mathlib/issues/4077">#4077</a> and the related <a href="https://github.com/leanprover-community/mathlib/issues/4079">#4079</a> and <a href="https://github.com/leanprover-community/mathlib/issues/4078">#4078</a> that <span class="user-mention" data-user-id="110087">@Scott Morrison</span> made.</p>
<p>I'm mainly wondering about the design choices here. Namely, the free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra on a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-tensor-algebra on the free module generated by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, whereas these PRs construct the tensor algebra as a quotient of the free algebra. Certainly I think the constructions of the free module and free algebra should interact, but the question is, in which way. With the PRs mentioned above, it would not be immediate that the free algebra is the tensor algebra of the free module, but what would be immediate is that the tensor algebra is a quotient of the free algebra. </p>
<p>A related question: We could take the approach from these PRs even further -- we can define the free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra on a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> as a quotient of the free (semi)ring on generated by the disjoint union of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>. Does it make sense to do this? I certainly think it is important to have some consistency in the way such free objects are constructed, and the "top-down/make the free-est thing possible first" approach might be a way to make everything more uniform.</p>



<a name="209503279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209503279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209503279">(Sep 09 2020 at 12:23)</a>:</h4>
<p>All of these things should really be constructed by some metapprogram that looks at the equations and universal axioms of the objects involved a la universal algebra. And the approach taken by these PRs is presumably how such metaprograms would operate in practice.</p>



<a name="209503755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209503755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209503755">(Sep 09 2020 at 12:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> <span class="user-mention" data-user-id="110044">@Chris Hughes</span> what do you think?</p>



<a name="209505835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209505835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209505835">(Sep 09 2020 at 12:51)</a>:</h4>
<p>One more thing to note: the previous construction of the tensor algebra was already as a quotient of some gigantic free thing with no relations, so the refactoring that Scott did in those PRs definitely makes sense.</p>



<a name="209511088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209511088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209511088">(Sep 09 2020 at 13:38)</a>:</h4>
<p>I think that with most of these free objects, the universal property on its own is not that useful, and there is usually some other construction that tells you more about the object. E.g. It is hard to define the coefficient or degree of a polynomial directly from the universal property. I've been working with free groups lately, and some theory depends on induction on the length of a normalised word.</p>
<p>If you do use universal algebra to define these objects then you probably end up having to effectively prove isomorphism with some other construction to prove any non trivial theorem about the object.</p>



<a name="209512054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209512054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209512054">(Sep 09 2020 at 13:46)</a>:</h4>
<p>I think it would be handy for a universal algebra to be able to deal with equational theories that aren't type classes, e.g. Rings with a root of a particular polynomial. I think maybe avoiding meta code for the bulk of the theory might be a good idea for this reason, and have a small amount of code to turn a structure like <code>group</code> into the appropriate term of a non-meta type <code>equational_theory </code> or something like that.</p>



<a name="209512364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209512364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209512364">(Sep 09 2020 at 13:48)</a>:</h4>
<p>Of course, I agree that in the "usual" cases from algebra it's more useful to have a concrete construction of the free objects. But this is really an "accident" of the construction, and usually does not generalize.</p>



<a name="209512423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209512423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209512423">(Sep 09 2020 at 13:48)</a>:</h4>
<p>Induction on the length of a normalized word in a free group is a good example.</p>



<a name="209512776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209512776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209512776">(Sep 09 2020 at 13:51)</a>:</h4>
<p>Concerning metaprogramming, I think to make it actually useful you would need some code to go in both directions -- from classes like group to <code>equational_theory</code>, and some code to go from some equational theory thing back to a typeclass. This would let you carry out whatever general constructions you need in the universal world, and pass back to the concrete world if necessary</p>



<a name="209514297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209514297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209514297">(Sep 09 2020 at 14:01)</a>:</h4>
<p>I agree that the concrete constructions can't be generalised, that's why I'm slightly skeptical that it would be useful to attempt to generalise free objects. I disagree that these are "accidents", it's almost the whole point of distributivity that the free commutative ring is also the free abelian group over the free monoid. Similarly the whole point of associativity is that free monoids are list. This is a slightly meaningless discussion I know.</p>



<a name="209514991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209514991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209514991">(Sep 09 2020 at 14:05)</a>:</h4>
<p>I envision a world where I can write the following and have the class <code>monoid</code> generated for me, as well as code for free monoids, colimits of monoids, etc.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">monoid</span>
<span class="n">def</span> <span class="n">ops</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="o">:=</span>
  <span class="o">[</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="o">(</span><span class="n">mul</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">]</span>

<span class="n">def</span> <span class="n">axioms</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="o">:=</span>
  <span class="o">[</span> <span class="o">(</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">mul</span> <span class="n">c</span> <span class="n">b</span><span class="o">)),</span>
    <span class="o">(</span><span class="n">one_mul</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">),</span>
    <span class="o">(</span><span class="n">mul_one</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">mul</span> <span class="n">a</span> <span class="n">one</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">]</span>

<span class="n">run_cmd</span> <span class="n">make_alg</span> <span class="n">ops</span> <span class="n">axioms</span>
<span class="kn">end</span> <span class="n">monoid</span>
</code></pre></div>



<a name="209515277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209515277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209515277">(Sep 09 2020 at 14:07)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="326322">@Jacques Carette</span> is working on a prover-independent version of this.</p>



<a name="209515354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209515354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209515354">(Sep 09 2020 at 14:08)</a>:</h4>
<p>I haven't had a chance to check it out yet though.</p>



<a name="209515720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209515720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209515720">(Sep 09 2020 at 14:10)</a>:</h4>
<p>I would do it very similarly to this, but with a custom, non-meta <code>expr</code></p>



<a name="209515819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209515819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209515819">(Sep 09 2020 at 14:11)</a>:</h4>
<p><span class="user-mention" data-user-id="315523">@Colter MacDonald</span> and I did some non-meta stuff like this here: <a href="https://github.com/adamtopaz/UnivAlg">https://github.com/adamtopaz/UnivAlg</a><br>
I still don't know how to make it actually useful.</p>



<a name="209516043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516043">(Sep 09 2020 at 14:12)</a>:</h4>
<p>I also dream of a world where I can write this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">ring</span>
<span class="n">def</span> <span class="n">ops</span> <span class="o">:=</span> <span class="n">monoid</span><span class="bp">.</span><span class="n">ops</span> <span class="bp">++</span> <span class="n">add_comm_group</span><span class="bp">.</span><span class="n">ops</span>
<span class="n">def</span> <span class="n">axioms</span> <span class="o">:=</span> <span class="n">monoid</span><span class="bp">.</span><span class="n">axioms</span> <span class="bp">++</span>
  <span class="n">add_comm_group</span><span class="bp">.</span><span class="n">axioms</span> <span class="bp">++</span>
  <span class="o">[</span> <span class="o">(</span><span class="n">left_distrib</span><span class="o">,</span> <span class="bp">...</span><span class="o">),</span> <span class="o">(</span><span class="n">right_distrib</span><span class="o">,</span> <span class="bp">...</span><span class="o">)</span> <span class="o">]</span>
<span class="n">run_cmd</span> <span class="n">make_alg</span> <span class="n">ops</span> <span class="n">axioms</span>
<span class="kn">end</span> <span class="n">ring</span>
</code></pre></div>


<p>and have lean generate code for monoid rings, etc.</p>



<a name="209516185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516185">(Sep 09 2020 at 14:13)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> had written quite a bunch of meta code like that.</p>



<a name="209516276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516276">(Sep 09 2020 at 14:14)</a>:</h4>
<p>It could generate <code>ring_hom</code> and the category <code>Ring</code> from the lean code of <code>ring</code></p>



<a name="209516301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516301">(Sep 09 2020 at 14:14)</a>:</h4>
<p>And similarly for the rest of the algebraic hierarchy.</p>



<a name="209516307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516307">(Sep 09 2020 at 14:14)</a>:</h4>
<p>Oh cool! Is there a repo somewhere?</p>



<a name="209516316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516316">(Sep 09 2020 at 14:14)</a>:</h4>
<p>The stuff I'd most like to see universal algebra do is develop my whole subobject library for me. I think that there's an awful lot of random little theorems about subobjects and quotients etc. that apply in a broad setting.</p>



<a name="209516327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516327">(Sep 09 2020 at 14:14)</a>:</h4>
<p><span class="user-mention" data-user-id="210057">@Fabian Glöckle</span> is your code available somewhere?</p>



<a name="209516540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516540">(Sep 09 2020 at 14:15)</a>:</h4>
<p>I've written several times that I think such things are a key component of the future of proof assistants, together with more proof automation. See also <a href="https://hal.inria.fr/hal-02478907v5">https://hal.inria.fr/hal-02478907v5</a></p>



<a name="209516709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209516709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209516709">(Sep 09 2020 at 14:16)</a>:</h4>
<p>We should have human readable input files generating class and structures definitions, handling all the variations around binding, extending or parametrizing correctly etc.</p>



<a name="209518061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209518061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209518061">(Sep 09 2020 at 14:26)</a>:</h4>
<p>We (my student Yasmine and I) are definitely working on this. I can see how open she'd be to targetting Lean. It's in scope, for sure, but she's also hoping to finish her Ph.D. this term, so...</p>



<a name="209518400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209518400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209518400">(Sep 09 2020 at 14:28)</a>:</h4>
<p>Having the input files being human-readable, as <span class="user-mention" data-user-id="110031">@Patrick Massot</span> mentions, is very important. I also think that the output should be human-readable too, as the aim is for human-based reuse.  It turns out that that is not so hard [see my work on GOOL for a very concrete example.]</p>



<a name="209518596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209518596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209518596">(Sep 09 2020 at 14:29)</a>:</h4>
<p>What I'm still looking for is a good list of what we should be generating. We have a long list of things we can generate, but I'm quite sure that 1) it's missing useful things, 2) it has useless things on it.</p>



<a name="209519136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519136">(Sep 09 2020 at 14:33)</a>:</h4>
<p>Can we see the list that you have? Or is that nontrivial?</p>



<a name="209519365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519365">(Sep 09 2020 at 14:35)</a>:</h4>
<p>Hmm, I can't upload a PDF to here, can I?  There was a decent list on Yasmine's slides for her talk about our work at CICM 2020.</p>



<a name="209519469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519469">(Sep 09 2020 at 14:36)</a>:</h4>
<p>Let me try to cut-and-paste from it...</p>
<p>Signature, Product Algebra, Basic Term Language, Homomorphism, Closed Term<br>
Language, Open Term Language, Evaluator, Simplication rules, Staged terms, Finally<br>
tagless representations, induction principle, Relational Interpretation, Monomorphism,<br>
Isomorphism, Endomorphism, Congruence relation, Quotient algebra, Trivial<br>
subtheory, Flipped theory, Monoid action, Monoid Cosets, composition of morphisms,<br>
kernel of homomorphisms, parse trees.</p>



<a name="209519611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519611">(Sep 09 2020 at 14:37)</a>:</h4>
<p>Aha... (you can upload PDF's btw)</p>



<a name="209519647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519647">(Sep 09 2020 at 14:37)</a>:</h4>
<p>See the <span aria-label="paperclip" class="emoji emoji-1f4ce" role="img" title="paperclip">:paperclip:</span> below the input box where you write posts.</p>



<a name="209519649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519649">(Sep 09 2020 at 14:37)</a>:</h4>
<p><a href="/user_uploads/3121/ye3ISRIX4j_qVslPvvkwNJAa/slides-1.pdf">slides-1.pdf</a></p>



<a name="209519712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519712">(Sep 09 2020 at 14:38)</a>:</h4>
<p>Indeed I can!  Slide 16. But it's perhaps better seen in context.</p>



<a name="209519932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209519932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209519932">(Sep 09 2020 at 14:39)</a>:</h4>
<p>There is another list in her PhD proposal (<a href="https://github.com/ysharoda/PhD-Proposal">https://github.com/ysharoda/PhD-Proposal</a>). It has lots of overlap, but it is a different set.</p>



<a name="209520823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209520823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209520823">(Sep 09 2020 at 14:45)</a>:</h4>
<p>If you already target at least one similar language (Agda or Coq) then it might make sense for Lean/mathlib people to work on the Lean target--as you can see there's no shortage of people who would be interested.</p>



<a name="209520994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209520994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209520994">(Sep 09 2020 at 14:46)</a>:</h4>
<p>We are actively targeting Agda.</p>



<a name="209521102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209521102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209521102">(Sep 09 2020 at 14:47)</a>:</h4>
<p>Having some Lean/mathlib person who is Haskell-literate (our host implementation language for our infrastructure) would be fantastic.</p>



<a name="209578458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209578458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209578458">(Sep 09 2020 at 22:54)</a>:</h4>
<p>Getting back to the current PRs --- one change I've made here is marking things as irreducible at the end of the file. So hopefully it will be a moot point whether we <em>define</em> <code>tensor_algebra</code> as a quotient or as a free construction.</p>
<p>Nevertheless, I agree we should add sometime the isomorphism between these two ways of building <code>tensor_algebra</code> (and the compatibility of that isomorphism with the <code>\iota</code> and <code>lift</code>).</p>



<a name="209578503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209578503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209578503">(Sep 09 2020 at 22:54)</a>:</h4>
<p>Sorry, the discussion wandered a little bit :)</p>



<a name="209578698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209578698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209578698">(Sep 09 2020 at 22:57)</a>:</h4>
<p>It wandered it very appealing directions! We want all this stuff, of course.</p>



<a name="209590935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209590935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209590935">(Sep 10 2020 at 02:44)</a>:</h4>
<p>I've added <code>free_algebra R X ≃ₐ[R] monoid_algebra R (free_monoid X)</code> to <a href="https://github.com/leanprover-community/mathlib/issues/4077">#4077</a>.</p>



<a name="209591454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209591454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209591454">(Sep 10 2020 at 02:59)</a>:</h4>
<p>Why have both constructions in the first place if they're isomorphic?</p>



<a name="209591657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209591657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209591657">(Sep 10 2020 at 03:04)</a>:</h4>
<p>Because it's a hassle to have to think of a free algebra in this way?</p>



<a name="209591671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209591671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209591671">(Sep 10 2020 at 03:05)</a>:</h4>
<p>Maybe this is dumb, I'm really not sure.</p>



<a name="209591900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209591900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209591900">(Sep 10 2020 at 03:10)</a>:</h4>
<p>I was actually tempted just now to go even further in the same direction --- define <code>free_module R X</code>, even though it is isomorphic to <code>X \to\_0 R</code>, just to protect me from having to look at the <code>finsupp</code> API. :-)</p>
<p>What I actually want at the moment is to know that I can construct a linear map out of a free algebra by specifying its values on elements of <code>free_monoid X</code>.</p>
<p>Options:</p>
<ol>
<li>use <code>free_algebra R X ≃ₐ[R] monoid_algebra R (free_monoid X)</code>, and then unfold the definition of <code>monoid_algebra</code> in terms of <code>finsupp</code>, and muck around with finsupps by hand</li>
<li>use <code>free_algebra R X ≃ₗ[R] free_module R (free_monoid X)</code> (doesn't exist), and use <code>free_module.lift</code> (also doesn't exist) to do the construction, without ever having to know that <code>finsupp</code> was involved.</li>
</ol>



<a name="209592520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209592520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209592520">(Sep 10 2020 at 03:24)</a>:</h4>
<p>Sounds like the <code>finsupp</code> API isn't very good. <code>finsupp</code> is so close to <code>free_module</code> already that we shouldn't need to redefine it. It can't be that hard to define the UMP of free modules on <code>finsupp</code> using the UMP of <code>finsupp</code> right? Isn't it supposed to make it easier to have that API available? I don't see why it's good to not have to know <code>finsupp</code> was involved; it has almost exactly the property you want.</p>



<a name="209644026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209644026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209644026">(Sep 10 2020 at 13:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326322">Jacques Carette</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209518596">said</a>:</p>
<blockquote>
<p>What I'm still looking for is a good list of what we should be generating. We have a long list of things we can generate, but I'm quite sure that 1) it's missing useful things, 2) it has useless things on it.</p>
</blockquote>
<p>I tried to assemble a list without looking at yours too closely. I'll fix "group" as the theory in question for concreteness.</p>
<ul>
<li>Definition of a group.</li>
<li>Definition of group homomorphisms, group isomorphisms.</li>
<li>Products of groups (nullary <code>(p)unit</code> and binary <code>prod</code>, as well as indexed <code>Pi</code>)</li>
<li>Definition of a subgroup. A subgroup also forms a group, with a group hom to the original group. Image and preimage of a subgroup under a group hom. Subgroup generated by a subset.</li>
<li>Definition of a congruence. The quotient by a congruence forms a group, with a group hom from the original group. Image(?) and preimage of a congruence under a group hom. Congruence generated by a relation.</li>
<li>Free group on a set, along with its associated structure: a function from a set to a group extends uniquely to a group hom from the free group; the free group on a group has an "evaluation" map back to the group; the free group is functorial in the group; etc.</li>
</ul>
<p>Along with these come many lemmas, e.g. "the subgroup generated by a subgroup is the original subgroup" and "if two group homomorphisms agree on a subset, they agree on the subgroup generated by that subset".</p>



<a name="209645266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209645266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209645266">(Sep 10 2020 at 13:59)</a>:</h4>
<p>I would add the "groupification" of a monoid as well (i.e. the left adjoint to the forgetful functor from groups to monoids).</p>



<a name="209645685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209645685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209645685">(Sep 10 2020 at 14:01)</a>:</h4>
<p>If you allow "subgroup generated by" then you probably want that there's a Galois insertion between <code>set</code> and <code>subgroup</code>?</p>



<a name="209647611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209647611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209647611">(Sep 10 2020 at 14:06)</a>:</h4>
<p>Then there are statements in category theory, for example</p>
<ul>
<li>monomorphisms in Grp are the injective functions,</li>
<li>Grp is a cocomplete, even locally presentable category,</li>
<li>Grp is monadic over Set,</li>
<li>the forgetful functor Grp -&gt; Set preserves filtered colimits,</li>
</ul>
<p>etc. This list is basically endless, so I suggest the following approach.<br>
Inside the target theorem prover, we can also do universal algebra and prove all these statements for categories of models of algebraic theories of various sorts. So, we can generate a representation of the theory internal to the target language, e.g., as a handful of (inductive) types describing the function symbols, equations, etc. of the theory. Then, your system would emit the following:</p>
<ul>
<li>The category Grp, defined directly in terms of the notions of "group" and "group homomorphism" from above.</li>
<li>The (faithful) forgetful functor Grp -&gt; Set (in the case of a single sorted theory), making Grp into a concrete category.</li>
<li>Some data G that describe the theory of groups together with an equivalence of concrete categories between Grp and Alg G, where Alg is something defined once and for all in the target language.</li>
</ul>
<p>Then the target library (mathlib, say) can go off and prove things about monads, Lawvere theories, sketches, first order logic, whatever as it pleases, decoupled from your system.<br>
Now, it could happen that we actually want a tighter integration, say to know that the objects of the Lawvere theory for groups really are literally <code>free_group (fin n)</code> or something, but this seems like a reasonable place to start.</p>



<a name="209647762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209647762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209647762">(Sep 10 2020 at 14:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209645685">said</a>:</p>
<blockquote>
<p>If you allow "subgroup generated by" then you probably want that there's a Galois insertion between <code>set</code> and <code>subgroup</code>?</p>
</blockquote>
<p>Right, I guess this more or less qualifies as "lemmas" given what I listed, but it's good to mention it specifically.</p>



<a name="209647917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209647917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209647917">(Sep 10 2020 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209645266">said</a>:</p>
<blockquote>
<p>I would add the "groupification" of a monoid as well (i.e. the left adjoint to the forgetful functor from groups to monoids).</p>
</blockquote>
<p>This arises from some kind of morphism between theories--what to generate for those is a separate and probably more interesting list.</p>



<a name="209651831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209651831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209651831">(Sep 10 2020 at 14:19)</a>:</h4>
<p>I think even the question of how to write down a "morphism between theories" is an interesting one.</p>



<a name="209653708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209653708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209653708">(Sep 10 2020 at 14:33)</a>:</h4>
<p>There's a rigorous notion of morphism between Lawvere theories right? It basically boils down to a way of defining the operations of structure X in terms of the operations of structure Y.</p>



<a name="209653753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209653753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209653753">(Sep 10 2020 at 14:33)</a>:</h4>
<p>Yeah, it's just a functor that preserves finite products.</p>



<a name="209653896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209653896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209653896">(Sep 10 2020 at 14:34)</a>:</h4>
<p>But once the system defines free objects, that already defines the corresponding monad, at least on objects.</p>



<a name="209653939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209653939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209653939">(Sep 10 2020 at 14:34)</a>:</h4>
<p>The morphisms between theories are then "just" morphisms of monads.</p>



<a name="209654058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209654058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209654058">(Sep 10 2020 at 14:35)</a>:</h4>
<p>Or you can say a morphism of theories is an adjunction between locally presentable categories. But these are not syntactic descriptions.</p>



<a name="209654060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209654060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209654060">(Sep 10 2020 at 14:35)</a>:</h4>
<p>There's such a thing as a multi-sorted Lawvere theory right? Are these worth doing? It might be handy to have stuff like morphism of groups that preserve an action on a particular set.</p>



<a name="209654168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209654168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209654168">(Sep 10 2020 at 14:36)</a>:</h4>
<p>Yeah, certainly two-sorted things are important if you want modules :)</p>



<a name="209654911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209654911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209654911">(Sep 10 2020 at 14:37)</a>:</h4>
<p>I think the main challenge in this abstract approach (using monads or Lawvere theories, for example), is to generate the moprhism of theories when you recognize that it should exist, for example going from groups to monoids.</p>



<a name="209655295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209655295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209655295">(Sep 10 2020 at 14:39)</a>:</h4>
<p>Use type class inference? Inspect <code>group.to_monoid</code>.</p>



<a name="209655381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209655381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209655381">(Sep 10 2020 at 14:40)</a>:</h4>
<p>In the universal algebra repo I mentioned above, I defined a language <code>L</code> as a function from N to Type*, and rules as a relation on some inductive gadget built out of a language. A "morphism" of theories was then a function <code>L1 n \to L2 n</code> for every n, such that the induced map on the inductive gadget gave an implication on rules. This is not the most general thing you can do, since you can have two pairs of languages/rules which give the same theory.</p>



<a name="209659716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209659716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209659716">(Sep 10 2020 at 15:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209655295">said</a>:</p>
<blockquote>
<p>Use type class inference? Inspect <code>group.to_monoid</code>.</p>
</blockquote>
<p>I think the point is that we want some metacode to generate the classes <code>group</code> and <code>monoid</code>, and to also be able to notice, for example, that <code>group</code> should extend <code>monoid</code>.</p>



<a name="209665826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209665826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209665826">(Sep 10 2020 at 15:41)</a>:</h4>
<p>Don't forget that all this discussion is only about the trivial example (only one type involved). The first interesting case is module over a (semi)ring. This is where beginners (and not so beginners) get confused about parameters vs extension etc.</p>



<a name="209668788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209668788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209668788">(Sep 10 2020 at 16:00)</a>:</h4>
<p>Will all this help with sheaves of modules over a sheaf of rings?</p>



<a name="209668939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209668939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209668939">(Sep 10 2020 at 16:01)</a>:</h4>
<p>Sure, replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> with a sheaf topos and you're good.</p>



<a name="209669181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209669181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209669181">(Sep 10 2020 at 16:03)</a>:</h4>
<p>On a more serious note, all this universal algebra stuff can, in principle, help in defining (and working with) internal algebraic objects in categories.</p>



<a name="209669207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209669207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209669207">(Sep 10 2020 at 16:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209668939">said</a>:</p>
<blockquote>
<p>Sure, replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> with a sheaf topos and you're good.</p>
</blockquote>
<p>I might get a bit confused about parameters vs extension</p>



<a name="209776322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776322">(Sep 11 2020 at 12:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209668788">said</a>:</p>
<blockquote>
<p>Will all this help with sheaves of modules over a sheaf of rings?</p>
</blockquote>
<p>What kind of help are you looking for?</p>



<a name="209776471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776471">(Sep 11 2020 at 12:54)</a>:</h4>
<p>I guess he doesn't want to manually duplicate the entire (constructive part of the) API</p>



<a name="209776504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776504">(Sep 11 2020 at 12:55)</a>:</h4>
<p>What API though?</p>



<a name="209776778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776778">(Sep 11 2020 at 12:57)</a>:</h4>
<p>What I meant was "I cannot even formalise the statements of the theorems I want to work on, because we do not have the definition of a sheaf of modules over a sheaf of rings in mathlib as far as I know".</p>



<a name="209776867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776867">(Sep 11 2020 at 12:58)</a>:</h4>
<blockquote>
<ul>
<li>Definition of a sheaf of modules.</li>
<li>Definition of sheaf of module homomorphisms, sheaf of module isomorphisms.</li>
<li>Products of sheaf of modules (nullary <code>(p)unit</code> and binary <code>prod</code>, as well as indexed <code>Pi</code>)</li>
<li>Definition of a subsheaf of modules. A subsheaf of modules also forms a sheaf of modules, with a sheaf of module hom to the original sheaf of module hom. Image and preimage of a subsheaf of module hom under a sheaf of module hom. </li>
<li>... &lt;snip&gt;</li>
</ul>
</blockquote>



<a name="209776927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776927">(Sep 11 2020 at 12:58)</a>:</h4>
<p>I mean, as all automation, I don't think it's going to help with something that there are currently 0 examples of</p>



<a name="209776980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209776980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209776980">(Sep 11 2020 at 12:59)</a>:</h4>
<p>at least it can't help you until after you've gone and written example 1</p>



<a name="209777180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209777180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209777180">(Sep 11 2020 at 13:00)</a>:</h4>
<p>Sorry, where am I looking? I can't find sheaf of modules in the docs, in mathlib or in the PR's.</p>



<a name="209777252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209777252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209777252">(Sep 11 2020 at 13:01)</a>:</h4>
<p>That's exactly Reid's point.</p>



<a name="209777449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209777449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209777449">(Sep 11 2020 at 13:02)</a>:</h4>
<p>If M is an R-module, I bet I can make a sheaf of modules on Spec(R).</p>



<a name="209777484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209777484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209777484">(Sep 11 2020 at 13:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209776867">said</a>:</p>
<blockquote>
<blockquote>
<ul>
<li>Definition of a sheaf of modules.</li>
</ul>
</blockquote>
</blockquote>
<p>Already there are many possibilities for this definition</p>



<a name="209777535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209777535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209777535">(Sep 11 2020 at 13:03)</a>:</h4>
<p>Right, and I can't prove that the category of sheaves of modules on Spec(R) is equivalent to R-mod because I can't currently state it.</p>



<a name="209778503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209778503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209778503">(Sep 11 2020 at 13:12)</a>:</h4>
<p>It seems that the approach used to define ringed spaces won't extend easily, because the value of a sheaf of modules on an open set U is an object in a category that depends on U.</p>



<a name="209778597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209778597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209778597">(Sep 11 2020 at 13:13)</a>:</h4>
<p>Anyway, that was what I meant by "will all this abstract stuff help".</p>



<a name="209778637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209778637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209778637">(Sep 11 2020 at 13:13)</a>:</h4>
<p>But it could be a sheaf of abelian groups + extra data expressed in a non-categorical manner.</p>



<a name="209778790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209778790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209778790">(Sep 11 2020 at 13:15)</a>:</h4>
<p>It could be but then it's hard to see how to generate <em>that</em> description from the theory of a module over a ring written in the first-order style that we use in mathlib and presumably would have in the abstract definitions of theories as well.</p>



<a name="209778996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209778996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209778996">(Sep 11 2020 at 13:16)</a>:</h4>
<p>Of course the real point of a ring is that it's a monoid object in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">b</mi></mrow><mo separator="true">,</mo><mo>⊗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathrm{Ab}, \otimes)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">b</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⊗</span><span class="mclose">)</span></span></span></span> (or maybe in the associated multicategory) but we don't have this information in mathlib AFAIK.</p>



<a name="209784170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209784170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209784170">(Sep 11 2020 at 14:01)</a>:</h4>
<p>I  mentioned the following code in the <code>status of schemes</code> thread we were in a little while ago. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>
<span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">sheaves</span><span class="bp">.</span><span class="n">local_predicate</span>

<span class="kn">open</span> <span class="n">Top</span>
<span class="kn">open</span> <span class="n">topological_space</span>
<span class="kn">universe</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">Top</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}}</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">local_ring_predicate</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">ring</span> <span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)]</span> <span class="kn">extends</span> <span class="n">local_predicate</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_subring</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">},</span> <span class="n">is_subring</span> <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">),</span> <span class="n">T</span> <span class="n">x</span><span class="o">)))</span>

<span class="kn">structure</span> <span class="n">local_module_predicate</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">ring</span> <span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">local_ring_predicate</span> <span class="n">T</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">S</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">module</span> <span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">x</span><span class="o">)]</span> <span class="kn">extends</span> <span class="n">local_predicate</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_submodule</span> <span class="o">:</span> <span class="n">sorry</span><span class="o">)</span> <span class="c1">-- is_submodule doesn&#39;t exist in mathlib, but you get the idea.</span>
</code></pre></div>


<p>This approach should presumably work in the universal case as well.</p>



<a name="209784231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209784231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209784231">(Sep 11 2020 at 14:02)</a>:</h4>
<p>Assuming the metacode produces <code>is_subfoo</code> classes...</p>



<a name="209786286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209786286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209786286">(Sep 11 2020 at 14:19)</a>:</h4>
<p><code>local_ring_predicate</code> should be read <code>local_(ring_predicate)</code> and not <code>(local_ring)_predicate</code></p>



<a name="209787016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209787016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209787016">(Sep 11 2020 at 14:25)</a>:</h4>
<p>I think this is addressing a slightly later question--here the issue is how to represent even the data of a sheaf of modules</p>



<a name="209787272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209787272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209787272">(Sep 11 2020 at 14:27)</a>:</h4>
<p>A sheaf of modules is a <code>local_module_predicate</code> satsifying some gluing axioms.</p>



<a name="209787511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209787511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209787511">(Sep 11 2020 at 14:28)</a>:</h4>
<p>Hang on, I don't know what a <code>local_predicate</code> is.</p>



<a name="209787849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209787849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209787849">(Sep 11 2020 at 14:30)</a>:</h4>
<p>I guess I'm confused by the language. Surely what a sheaf of modules <strong>is</strong> is the stuff that comes earlier: <code>[Π (x : X), add_comm_group (S x)] [Π (x : X), module (T x) (S x)]</code></p>



<a name="209787929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209787929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209787929">(Sep 11 2020 at 14:31)</a>:</h4>
<p>maybe together with some more stuff</p>



<a name="209787937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209787937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209787937">(Sep 11 2020 at 14:31)</a>:</h4>
<p>This isn't how I'm used to thinking about things</p>



<a name="209788111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788111">(Sep 11 2020 at 14:32)</a>:</h4>
<p>This comes from the representation of a sheaf as a subpresheaf of the rule sending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">(</mo><mi>u</mi><mo>:</mo><mi>U</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">\Pi (u : U), T u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">u</span></span></span></span>.</p>



<a name="209788164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788164">(Sep 11 2020 at 14:33)</a>:</h4>
<p>Where you are meant to think of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">T u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">u</span></span></span></span> as some set which contains the stalk of the sheaf at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>.</p>



<a name="209788224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788224">(Sep 11 2020 at 14:33)</a>:</h4>
<p>The <code>local_predicate</code> thing is essentially saying that this gives you a presheaf, and there is another structure which ensures the sheaf axiom.</p>



<a name="209788391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788391">(Sep 11 2020 at 14:35)</a>:</h4>
<p>Errr sorry, in mathlib <code>local_predicate</code> is satisfies the sheaf axiom, but there is also a <code>prelocal_predicate</code> which gives you presheaves.</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/0c57b2da3c4e821fb2e1e351409e61e039fd7ea6/src/topology/sheaves/local_predicate.lean#L87">https://github.com/leanprover-community/mathlib/blob/0c57b2da3c4e821fb2e1e351409e61e039fd7ea6/src/topology/sheaves/local_predicate.lean#L87</a></p>



<a name="209788395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788395">(Sep 11 2020 at 14:35)</a>:</h4>
<p>So if I have an open set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> how do I get out the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">O</mi><mi>X</mi></msub><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}_X(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>-module?</p>



<a name="209788482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788482">(Sep 11 2020 at 14:35)</a>:</h4>
<p>it's the subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>U</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">\Pi (x : U), T u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">u</span></span></span></span> given by the local predicate.</p>



<a name="209788534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788534">(Sep 11 2020 at 14:36)</a>:</h4>
<p>Hence the <code>is_submodule</code></p>



<a name="209788651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788651">(Sep 11 2020 at 14:37)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi></mrow><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span></span></span> is a sheaf of modules over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi></mrow><annotation encoding="application/x-tex">\mathcal{O}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>u</mi><mo>:</mo><mi>U</mi></mrow></msub><msub><mi mathvariant="script">M</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\prod_{u : U} \mathcal{M}_u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathcal">M</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a module over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>u</mi><mo>:</mo><mi>U</mi></mrow></msub><msub><mi mathvariant="script">O</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\prod_{u : U} \mathcal{O}_u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="209788696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788696">(Sep 11 2020 at 14:37)</a>:</h4>
<p>I guess to me this seems more like a way of avoiding answering the question of what is a sheaf of modules</p>



<a name="209788882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209788882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209788882">(Sep 11 2020 at 14:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209788696">said</a>:</p>
<blockquote>
<p>I guess to me this seems more like a way of avoiding answering the question of what is a sheaf of modules</p>
</blockquote>
<p>I don't disagree, but what's the alternative aside from working internally in the sheaf topos?</p>



<a name="209789134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209789134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209789134">(Sep 11 2020 at 14:41)</a>:</h4>
<p>Well, there is the hands-on definition. (A sheaf of modules over <code>O</code> is a sheaf <code>M</code>, + for each <code>U</code> an add-group structure on <code>M U</code> and a <code>O U</code>-module structure on <code>M U</code>.</p>



<a name="209789259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209789259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209789259">(Sep 11 2020 at 14:42)</a>:</h4>
<p>Yes of course, but I think this would be harder to automate</p>



<a name="209789316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209789316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209789316">(Sep 11 2020 at 14:42)</a>:</h4>
<p>You also need all the restriction maps to be morphisms in the correct category, etc</p>



<a name="209789820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209789820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209789820">(Sep 11 2020 at 14:46)</a>:</h4>
<p>Ramon Mir used an extremely hands-on definition when making schemes for his MSc project last year, and then Kenny went on to prove things like Gamma-Spec adjointness using this definition. However, when Ramon went to port his stuff to mathlib he discovered that Scott had already put the definition of a presheaf in, and it used categories (which Ramon didn't), so we decided to wait.</p>



<a name="209791027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209791027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209791027">(Sep 11 2020 at 14:56)</a>:</h4>
<p>Another option is to define the tensor product of presheaves of abelian groups (ideally, also of sheaves by applying sheafification) and say a sheaf of modules is a module object over the monoid object that is a sheaf of rings</p>



<a name="209791306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209791306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209791306">(Sep 11 2020 at 14:58)</a>:</h4>
<p>Another option is to consider the (pseudo)functor <code>Mod(O_X(-)) : opens X -&gt; Cat</code> and define a sheaf of modules to be some kind of enhancement of a sheaf to the category of lax sections of this functor</p>



<a name="209791441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209791441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209791441">(Sep 11 2020 at 14:59)</a>:</h4>
<p>Anyways the issue here seems to be that we don't know what we want the definition to be, not an automation problem.</p>



<a name="209791612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209791612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209791612">(Sep 11 2020 at 15:00)</a>:</h4>
<p>Probably the right thing to do is to go look up how Lurie defines sheaves of modules in SAG.</p>



<a name="209792681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209792681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209792681">(Sep 11 2020 at 15:09)</a>:</h4>
<p>Looks like Lurie defines sheaves of abelian groups, he then defines sheaves of rings as monoid objects there, and modules as (<em>internal</em>) modules over those monoid objects.</p>



<a name="209792730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209792730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209792730">(Sep 11 2020 at 15:09)</a>:</h4>
<p>Definition 2.1.0.1 here <a href="https://www.math.ias.edu/~lurie/papers/SAG-rootfile.pdf">https://www.math.ias.edu/~lurie/papers/SAG-rootfile.pdf</a></p>



<a name="209793062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209793062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209793062">(Sep 11 2020 at 15:12)</a>:</h4>
<p>I'm happy with that, but I was under the impression that people wanted to avoid the internal definitions.</p>



<a name="209797241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209797241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209797241">(Sep 11 2020 at 15:41)</a>:</h4>
<p>But this definition does have an automation problem if you define sheaves of abelian groups as sheaves <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal">A</span></span></span></span></span> such that for every open <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{A}(U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal">A</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> has an abelian group structure, such that blah blah blah, and then you go and define sheaves of rings as something internal to the category of sheaves of abelian groups. How would you tell the computer to decide to define sheaves of abelian groups "externally" like above, while defining sheaves of rings internally to the corresponding category of abelian sheaves? </p>
<p>I thought the whole point of this discussion was to tell the computer: "Here are the operations and axioms for an abelian group,  here are the operations and axioms for a ring, and here is how to forget the ring structure to get an abelian group, now go and make me some categories of sheaves".</p>



<a name="209804241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209804241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209804241">(Sep 11 2020 at 16:35)</a>:</h4>
<p>I guess this gets back to my original question as well then. I don't understand what there is to automate. Don't we already have sheaves of abelian groups, which we could presumably make into a monoidal category, and monoid objects in a monoidal category, and modules over them (I'm not sure if they exist yet, but they are no harder than monoid objects)?</p>



<a name="209804549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209804549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209804549">(Sep 11 2020 at 16:38)</a>:</h4>
<p>I was envisioning automating the creation of sheaves of <code>foo</code> where <code>foo</code>is any (possibly multi-sorted) Lawvere theory (or variety in the sense of universal algebra, or ...).</p>



<a name="209804753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209804753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209804753">(Sep 11 2020 at 16:40)</a>:</h4>
<p>But maybe this just amounts to making sheaves valued in categories with enough colimits, and automating the creation of such categories from universal algebra.</p>



<a name="209804923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209804923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209804923">(Sep 11 2020 at 16:41)</a>:</h4>
<p>This is somehow easier, right? This occurred to me as well--there's some category of "rings plus modules over them"; and a sheaf of modules over a sheaf of rings is a sheaf of one of those.</p>



<a name="209804996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209804996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209804996">(Sep 11 2020 at 16:41)</a>:</h4>
<p>Yeah, you can look at the category of pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R,M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a ring and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module, with the obvious morphisms.</p>



<a name="209805061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805061">(Sep 11 2020 at 16:42)</a>:</h4>
<p>I don't know if <span class="user-mention" data-user-id="110031">@Patrick Massot</span> would be happy with that approach.</p>



<a name="209805136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805136">(Sep 11 2020 at 16:43)</a>:</h4>
<p>That's an interesting approach!</p>



<a name="209805187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805187">(Sep 11 2020 at 16:43)</a>:</h4>
<p>A sheaf of modules is a dependent sheaf, so surely dependent type theory should just love them :-)</p>



<a name="209805195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805195">(Sep 11 2020 at 16:43)</a>:</h4>
<p>It sounds pretty awkward to formulate statements like "O_{Spec R}-mod is equivalent to R-mod" in this language, though</p>



<a name="209805269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805269">(Sep 11 2020 at 16:44)</a>:</h4>
<p>Well that's the thing. Dependent type theory loves them, which is why the hands on approach didn't run into any of these questions.</p>



<a name="209805274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805274">(Sep 11 2020 at 16:44)</a>:</h4>
<p>You need to work with the "forgetful functor" from this category to the category of rings.</p>



<a name="209805403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805403">(Sep 11 2020 at 16:45)</a>:</h4>
<p>For the category theory version you would need consider some kind of "dependent functor", which is essentially the idea of<br>
<span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209791306">said</a>:</p>
<blockquote>
<p>Another option is to consider the (pseudo)functor <code>Mod(O_X(-)) : opens X -&gt; Cat</code> and define a sheaf of modules to be some kind of enhancement of a sheaf to the category of lax sections of this functor</p>
</blockquote>



<a name="209805794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805794">(Sep 11 2020 at 16:48)</a>:</h4>
<p>Using sheaves of pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R, M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> is the analogue of getting rid of dependent types by using a Sigma type</p>



<a name="209805900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209805900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209805900">(Sep 11 2020 at 16:49)</a>:</h4>
<p>then you start getting equality of types</p>



<a name="209806003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209806003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209806003">(Sep 11 2020 at 16:50)</a>:</h4>
<p>Yes, or you could insert an isomorphism--that is where things start to get awkward</p>



<a name="209835369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835369">(Sep 11 2020 at 21:07)</a>:</h4>
<p>I tried playing with this idea a bit. Even the "dependent functor" idea gives trouble. See the two sorry's below.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">Cat</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">CommRing</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">Module</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="n">def</span> <span class="n">restrict_scalars</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Ring</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="err">⟶</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">functor</span> <span class="o">(</span><span class="n">Module</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">Module</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">M</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">M</span><span class="o">,</span>
    <span class="n">is_add_comm_group</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span><span class="o">,</span>
    <span class="n">is_module</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">m</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">one_smul</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span><span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="bp">_</span><span class="o">)</span> <span class="err">•</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">apply</span> <span class="n">mul_smul</span> <span class="o">},</span>
      <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span><span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="bp">_</span><span class="o">)</span> <span class="err">•</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">apply</span> <span class="n">smul_add</span> <span class="o">},</span>
      <span class="n">smul_zero</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span><span class="n">change</span> <span class="o">(</span><span class="n">f</span> <span class="bp">_</span><span class="o">)</span> <span class="err">•</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">apply</span> <span class="n">add_smul</span> <span class="o">},</span>
      <span class="n">zero_smul</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">}},</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">M</span> <span class="n">N</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">g</span><span class="o">,</span>
    <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="n">g</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span>
    <span class="n">map_smul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">g</span><span class="bp">.</span><span class="n">map_smul</span> <span class="o">}</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">Mod</span> <span class="o">:</span> <span class="n">functor</span> <span class="n">Ring</span><span class="err">ᵒᵖ</span> <span class="n">Cat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">Cat</span><span class="bp">.</span><span class="n">of</span> <span class="err">$</span> <span class="n">Module</span> <span class="n">A</span><span class="bp">.</span><span class="n">unop</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">f</span><span class="o">,</span> <span class="n">restrict_scalars</span> <span class="n">f</span><span class="bp">.</span><span class="n">unop</span><span class="o">,</span>
  <span class="n">map_id&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- oh no!</span>
  <span class="n">map_comp&#39;</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="209835453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835453">(Sep 11 2020 at 21:08)</a>:</h4>
<p>I think you'd want to use pseudofunctors anyways</p>



<a name="209835488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835488">(Sep 11 2020 at 21:09)</a>:</h4>
<p>Yeah for sure.</p>



<a name="209835530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835530">(Sep 11 2020 at 21:10)</a>:</h4>
<p>although this is probably not that bad to prove</p>



<a name="209835582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835582">(Sep 11 2020 at 21:10)</a>:</h4>
<p>Yeah, but the fact that <code>tidy</code> didn't even get the <code>map_id</code> field was a bad sign.</p>



<a name="209835607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835607">(Sep 11 2020 at 21:10)</a>:</h4>
<p>By the way, does mathlib have the restriction of scalars functor above for possibly noncommutative rings?</p>



<a name="209835616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209835616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209835616">(Sep 11 2020 at 21:10)</a>:</h4>
<p>I know there is restriction of scalars for algebras, but that assumes some commutativity.</p>



<a name="209836255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836255">(Sep 11 2020 at 21:17)</a>:</h4>
<p>Ha. <code>tidy</code> is happy with the second sorry.</p>



<a name="209836382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836382">(Sep 11 2020 at 21:18)</a>:</h4>
<p>yep, with eta for structures, the first would be okay too</p>



<a name="209836520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836520">(Sep 11 2020 at 21:20)</a>:</h4>
<p>at least, I think it would? I guess this is a level up from the usual situation</p>



<a name="209836563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836563">(Sep 11 2020 at 21:20)</a>:</h4>
<p>namely, composition of bundled maps (of whatever kind, e.g., continuous maps) is definitionally associative, but not definitionally unital</p>



<a name="209836924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836924">(Sep 11 2020 at 21:24)</a>:</h4>
<p>But I think when you go to write down the lax limit of categories you'll end up needing to turn these equalities of functors/objects into isomorphisms anyways</p>



<a name="209836982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836982">(Sep 11 2020 at 21:25)</a>:</h4>
<p>so, it's probably easier to just work with isomorphisms (that is, a pseudofunctor) from the start</p>



<a name="209836989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209836989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209836989">(Sep 11 2020 at 21:25)</a>:</h4>
<p>Yeah I agree.</p>



<a name="209837013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837013">(Sep 11 2020 at 21:25)</a>:</h4>
<p>I was just playing with what's currently in mathlib.</p>



<a name="209837021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837021">(Sep 11 2020 at 21:25)</a>:</h4>
<p>Which doesn't have pseudofunctors, right?</p>



<a name="209837028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837028">(Sep 11 2020 at 21:25)</a>:</h4>
<p>Or 2 categories.</p>



<a name="209837072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837072">(Sep 11 2020 at 21:26)</a>:</h4>
<p>I don't think so.</p>



<a name="209837180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837180">(Sep 11 2020 at 21:27)</a>:</h4>
<p>I wonder whether it would be possible to have a version of <code>tidy</code> that could be trusted to produce sufficiently trivial data</p>



<a name="209837350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837350">(Sep 11 2020 at 21:29)</a>:</h4>
<p>I wouldn't bother with 2-categories for this purpose--Cat is the only one that matters</p>



<a name="209837412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837412">(Sep 11 2020 at 21:29)</a>:</h4>
<p>In fact, I think we already basically prove a bunch of things are pseudofunctors but we lack the language to say that that's what we're doing</p>



<a name="209837886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837886">(Sep 11 2020 at 21:34)</a>:</h4>
<p>I guess it's possible we could need pseudofunctors valued in some flavor of monoidal categories</p>



<a name="209837944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209837944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209837944">(Sep 11 2020 at 21:34)</a>:</h4>
<p>Also, bicategories wouldn't be that hard--I think it basically amounts to taking the existing monoidal category code and inserting a bunch more indices everywhere.</p>



<a name="209839017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209839017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209839017">(Sep 11 2020 at 21:45)</a>:</h4>
<p>I think if/when we end up having some higher category theory, it would be nice if <code>tidy</code> can put in simple data like <code>\lam X, X</code>for us.</p>



<a name="209847119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209847119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209847119">(Sep 11 2020 at 23:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209778996">said</a>:</p>
<blockquote>
<p>Of course the real point of a ring is that it's a monoid object in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">b</mi></mrow><mo separator="true">,</mo><mo>⊗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathrm{Ab}, \otimes)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">b</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⊗</span><span class="mclose">)</span></span></span></span> (or maybe in the associated multicategory) but we don't have this information in mathlib AFAIK.</p>
</blockquote>
<p>Still catching up on this thread, but we do have this: <a href="https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal/Module.lean#L136">https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal/Module.lean#L136</a> proves that monoid objects in R-modules are the same thing as R-algebras.</p>



<a name="209847543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209847543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209847543">(Sep 11 2020 at 23:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209804241">said</a>:</p>
<blockquote>
<p>I guess this gets back to my original question as well then. I don't understand what there is to automate. Don't we already have sheaves of abelian groups, which we could presumably make into a monoidal category, and monoid objects in a monoidal category, and modules over them (I'm not sure if they exist yet, but they are no harder than monoid objects)?</p>
</blockquote>
<p>We have the monoidal structure on presheaves in <code>C</code> when <code>C</code> is monoidal, from <a href="https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/functor_category.lean#L61">https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/functor_category.lean#L61</a>. There is still some work to do to get this for sheaves.</p>
<p>We have modules over monoid objects, as <a href="https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal.lean#L188">https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal.lean#L188</a>, although almost nothing is proved about them (besides the <code>comap</code> construction).</p>



<a name="209847699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209847699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209847699">(Sep 11 2020 at 23:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209837180">said</a>:</p>
<blockquote>
<p>I wonder whether it would be possible to have a version of <code>tidy</code> that could be trusted to produce sufficiently trivial data</p>
</blockquote>
<p>Somewhere there is a <code>follow_your_nose</code> tactic on a branch, which is essentially a cut-down version of <code>tidy</code>, further empowered to insert identity morphisms and a few other things. It's been a long time, but I'll try to find it.</p>



<a name="209873309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209873309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Fabian Glöckle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209873309">(Sep 12 2020 at 09:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209516327">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="210057">Fabian Glöckle</span> is your code available somewhere?</p>
</blockquote>
<p>(Back from holidays, sorry for moving back in the discussion.)<br>
I shared the code some while ago in this thread <a href="#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/</a><br>
It generates homomorphism types for structures defined in regular lean code, no extra "structure description format" is required.<br>
See it as a proof of concept that such things work in lean metaprogramming - the code itself might not be the cleanest.</p>



<a name="209873379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209873379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209873379">(Sep 12 2020 at 09:39)</a>:</h4>
<p>Thanks... I had lost track of the other thread already...</p>



<a name="209873383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/209873383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#209873383">(Sep 12 2020 at 09:39)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span></p>



<a name="210461465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/210461465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#210461465">(Sep 17 2020 at 22:57)</a>:</h4>
<p>Sorry to have 'disappeared' from this thread. I was expecting to get some kind of notification that it was active, but nope. Only when I tried to catch up on "everything" did I noticed it had been resurrected.</p>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> thanks a lot for that list. Luckily, it overlaps a lot with our list, as most of these constructions are indeed polymorphic over (a presentation of) an algebraic theory. So indeed at least that much automation should be in scope.</p>
<p>When moving away from single-sorted theories, things do get tricky quite quickly. I'd eventually like to get to 'essentially algebraic theories', but that's a steep hill to climb.</p>



<a name="212413785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212413785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212413785">(Oct 06 2020 at 11:29)</a>:</h4>
<p>Vaguelly related to this thread: Is it true that <code>function.injective (free_algebra.ι R : X → free_algebra R X)</code>?</p>



<a name="212414930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212414930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212414930">(Oct 06 2020 at 11:42)</a>:</h4>
<p>I can't get beyond</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ι_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">free_algebra</span> <span class="n">R</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">ι</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold_coes</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">pre.of.inj</span> <span class="n">R</span> <span class="n">infer_instance</span> <span class="n">X</span> <span class="n">_</span><span class="o">,</span>
  <span class="c1">-- h: quot.mk (rel R X) (pre.of a) = quot.mk (rel R X) (pre.of b)</span>
  <span class="c1">-- ⊢ pre.of a = pre.of b</span>
  <span class="n">sorry</span>
</code></pre></div>



<a name="212415362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212415362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212415362">(Oct 06 2020 at 11:47)</a>:</h4>
<p>I guess you need <code>nontrivial R</code>, right?</p>



<a name="212416044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212416044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212416044">(Oct 06 2020 at 11:54)</a>:</h4>
<p>I think that's implied by the fact I have a <code>submodule R X</code> instance, but I may be mistaken</p>



<a name="212416122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212416122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212416122">(Oct 06 2020 at 11:55)</a>:</h4>
<p>Isn't the zero ring a (semi)module of itself in Lean?</p>



<a name="212416224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212416224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212416224">(Oct 06 2020 at 11:56)</a>:</h4>
<p>And my issue right now is more with finding a suitable induction principle.</p>



<a name="212416381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212416381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212416381">(Oct 06 2020 at 11:57)</a>:</h4>
<p>Inducting on <code>quot.eq.mp h</code> loses the information that I started with <code>pre.of</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">quot.eq.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
</code></pre></div>



<a name="212417942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212417942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212417942">(Oct 06 2020 at 12:12)</a>:</h4>
<p>And using <code>set</code> to try and keep that information gives an <code>app_builder</code> error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ι_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">free_algebra</span> <span class="n">R</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">ι</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold_coes</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">pre.of.inj</span> <span class="n">R</span> <span class="n">infer_instance</span> <span class="n">X</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">quot.eq.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">pa</span> <span class="o">:</span> <span class="n">pre</span> <span class="n">R</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">pre.of</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">pb</span><span class="o">:</span> <span class="n">pre</span> <span class="n">R</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">pre.of</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span><span class="o">,</span>
    <span class="c1">-- [app_builder] failed to infer universe level for type</span>
    <span class="c1">-- (let pa : pre R X := pre.of a, pb : pre R X := pre.of b in</span>
    <span class="c1">-- λ (h : eqv_gen (rel R X) pa pb), pre.of a = pre.of b) h_x h_y (eqv_gen.rel h_x h_y h_a)</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212419082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212419082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212419082">(Oct 06 2020 at 12:23)</a>:</h4>
<p>Moved discussion to <a href="#narrow/stream/113488-general/topic/.60sorry.60.20tactic.20fails/near/212418947">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.60sorry.60.20tactic.20fails/near/212418947</a> - even <code>sorry</code>is failing, so this looks like a deeper problem</p>



<a name="212423010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423010">(Oct 06 2020 at 12:56)</a>:</h4>
<p>It's not clear to me how you would continue anyways. Did you have a math proof of this in mind?</p>



<a name="212423241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423241">(Oct 06 2020 at 12:58)</a>:</h4>
<p>As I recall, <code>free_algebra R M</code> is basically constructed so that by definition it has the universal property for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebras with an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>.</p>



<a name="212423489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423489">(Oct 06 2020 at 13:00)</a>:</h4>
<p>This function is injective assuming <code>R</code> is nontrivial. If you can construct some ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> with a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> which is injective, then it has to factor through <code>free_algebra R X</code> via <code>\iota</code> by the universal property, so the map will be injective for free.</p>



<a name="212423846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423846">(Oct 06 2020 at 13:03)</a>:</h4>
<p>You can probably just map into the <code>mv_polynomial</code>ring.</p>



<a name="212423893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423893">(Oct 06 2020 at 13:03)</a>:</h4>
<p>If you only care about this <code>injective</code> statement then you could get away with much less. Namely, any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> defines a square-zero extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊕</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R \oplus M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> by defining the product of two elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> to be zero.</p>



<a name="212423925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423925">(Oct 06 2020 at 13:03)</a>:</h4>
<p>That's a ring into which <code>M</code> maps injectively :)</p>



<a name="212423964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212423964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212423964">(Oct 06 2020 at 13:04)</a>:</h4>
<p>I was suggesting to use some explicit ring. The square-zero extension is a good choice.</p>



<a name="212424010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212424010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212424010">(Oct 06 2020 at 13:04)</a>:</h4>
<p>The <code>mv_polynomial</code>ring is another one.</p>



<a name="212424054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212424054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212424054">(Oct 06 2020 at 13:04)</a>:</h4>
<p>Note that the free algebra is no longer the tensor algebra (this was refactored by Scott)</p>



<a name="212424064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212424064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212424064">(Oct 06 2020 at 13:04)</a>:</h4>
<p>If you want to understand what <code>free_algebra R M</code> looks like as an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module then often a good way is to give a second construction (as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⨁</mo><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\bigoplus_{n \ge 0} M^{\otimes n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.16622em;vertical-align:-0.39488900000000005em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139799999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">≥</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39488900000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊗</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> in this case) and check it also satisfies the universal property.</p>



<a name="212424107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212424107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212424107">(Oct 06 2020 at 13:04)</a>:</h4>
<p>Sorry, my internet cut out in the middle of writing this.</p>



<a name="212425015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425015">(Oct 06 2020 at 13:12)</a>:</h4>
<p>Perhaps I should un- <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> this - I'm trying to prove that <code>algebra.adjoin R (set.range (ι R : X → free_algebra R X)) = ⊤</code></p>



<a name="212425258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425258">(Oct 06 2020 at 13:14)</a>:</h4>
<p>Oh this should be easier.</p>



<a name="212425268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425268">(Oct 06 2020 at 13:14)</a>:</h4>
<p>This sounds a lot easier, and also pretty much unrelated to injectivity...?</p>



<a name="212425316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425316">(Oct 06 2020 at 13:14)</a>:</h4>
<p>Yeah, this amounts to proving that every element of the free algebra is some sum/product of elements in the image of <code>\iota</code>.</p>



<a name="212425366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425366">(Oct 06 2020 at 13:15)</a>:</h4>
<p>And this comes essentially from the inductive definition of <code>free_algebra.pre</code></p>



<a name="212425503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425503">(Oct 06 2020 at 13:16)</a>:</h4>
<p>Injectivity came up because it looked like it was sufficient for the proof, and also seemed obviously true</p>



<a name="212425629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425629">(Oct 06 2020 at 13:17)</a>:</h4>
<p>And you give me some code with imports?</p>



<a name="212425642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425642">(Oct 06 2020 at 13:17)</a>:</h4>
<p>I think I can prove the <code>adjoin</code> statement above using <a href="https://github.com/leanprover-community/mathlib/issues/4335">#4335</a>, but my goal was to replace <a href="https://github.com/leanprover-community/mathlib/issues/4335">#4335</a> with a proof via <code>adjoin</code> instead</p>



<a name="212425643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212425643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212425643">(Oct 06 2020 at 13:17)</a>:</h4>
<p>I'll try to put something together.</p>



<a name="212426113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426113">(Oct 06 2020 at 13:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.free_algebra</span>
<span class="kn">import</span> <span class="n">ring_theory.adjoin</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">free_algebra</span>

<span class="kd">lemma</span> <span class="n">ι_generator</span> <span class="o">:</span> <span class="n">algebra.adjoin</span> <span class="n">R</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">free_algebra</span> <span class="n">R</span> <span class="n">X</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="212426474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426474">(Oct 06 2020 at 13:24)</a>:</h4>
<p>This should get you started:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.free_algebra</span>
<span class="kn">import</span> <span class="n">ring_theory.adjoin</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">free_algebra</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span> <span class="n">free_algebra</span>

<span class="kd">lemma</span> <span class="n">ι_generator</span> <span class="o">:</span> <span class="n">algebra.adjoin</span> <span class="n">R</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">free_algebra</span> <span class="n">R</span> <span class="n">X</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">simp</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span>
  <span class="n">intro</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212426553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426553">(Oct 06 2020 at 13:25)</a>:</h4>
<p>Of course, I'm cheating because I know the construction of <code>free_algebra</code> which I'm not supposed to use.</p>



<a name="212426571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426571">(Oct 06 2020 at 13:25)</a>:</h4>
<p>Hence the <code>local attribute [reducible] free_algebra</code>.</p>



<a name="212426674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426674">(Oct 06 2020 at 13:26)</a>:</h4>
<p>Yeah, I was hoping to either avoid cheating or make some extra statement about the universal property before we sealed the construction</p>



<a name="212426734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426734">(Oct 06 2020 at 13:26)</a>:</h4>
<p>Is the stronger statement <code>(lift R f).range = algebra.adjoin R (set.range f)</code> also true? (generalizing <code>ι R</code> to <code>f</code>)</p>



<a name="212426778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426778">(Oct 06 2020 at 13:27)</a>:</h4>
<p>Yeah that's also true.</p>



<a name="212426988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212426988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212426988">(Oct 06 2020 at 13:28)</a>:</h4>
<p>The induction principle in <a href="https://github.com/leanprover-community/mathlib/issues/4335">#4335</a> seems like a sensible thing to have (though we generally wouldn't bundle the conditions into a structure). I don't understand the proof in <a href="https://github.com/leanprover-community/mathlib/issues/4335">#4335</a>, but it can just be proved directly.</p>



<a name="212427229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212427229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212427229">(Oct 06 2020 at 13:30)</a>:</h4>
<p>Yeah if we don't want to temporarily make things reducible (which we probably don't), then it looks like we're missing some induction principles.</p>



<a name="212427267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212427267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212427267">(Oct 06 2020 at 13:30)</a>:</h4>
<blockquote>
<p>I don't understand the proof in <a href="https://github.com/leanprover-community/mathlib/issues/4335">#4335</a></p>
</blockquote>
<p>What proof?</p>



<a name="212427407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212427407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212427407">(Oct 06 2020 at 13:31)</a>:</h4>
<p>everything after line 303</p>



<a name="212427628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212427628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212427628">(Oct 06 2020 at 13:33)</a>:</h4>
<p>The proof should just be: since <code>free_algebra</code> is a quotient it suffices to check <code>C</code> holds on things of the form <code>quot.mk</code> of something. Now define <code>C' x</code> to be <code>C (quot.mk _ x)</code> (or whatever the syntax is). Then the conditions on <code>C</code> turn into the conditions on <code>C'</code> needed to apply induction on <code>pre</code>.</p>



<a name="212427699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212427699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212427699">(Oct 06 2020 at 13:33)</a>:</h4>
<p>Ah, the point was to generate the inductive principle from the universal property alone</p>



<a name="212428636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212428636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212428636">(Oct 06 2020 at 13:40)</a>:</h4>
<p>I see. That's also possible but it seems unnecessary.</p>



<a name="212434635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212434635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212434635">(Oct 06 2020 at 14:22)</a>:</h4>
<p>I've realized that most of that proof is actually just a crutch for <code>has_coe_to_sort (subalgebra R A)</code> not existing</p>



<a name="212443394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212443394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212443394">(Oct 06 2020 at 15:18)</a>:</h4>
<p>Or rather, something wacky going on with typeclass resolution</p>



<a name="212443422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212443422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212443422">(Oct 06 2020 at 15:19)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4335">#4335</a> updated, the proof is now much shorter</p>



<a name="212540998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212540998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212540998">(Oct 07 2020 at 10:46)</a>:</h4>
<p>I found myself needing a lemma something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">free_algebra</span> <span class="n">R</span> <span class="n">X</span><span class="o">)</span>

<span class="c1">-- better as  `ι R = (g.comp (lift R f)) ∘ ι R ↔ alg_hom.id R _ = g.comp (lift R f)`?</span>
<span class="kd">lemma</span> <span class="n">forall_ι_iff_forall</span><span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">ι</span> <span class="n">R</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">lift</span> <span class="n">R</span> <span class="n">f</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="n">x</span><span class="o">)))</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">lift</span> <span class="n">R</span> <span class="n">f</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">alg_hom.comp_apply</span><span class="o">,</span>
    <span class="n">conv_lhs</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←@</span><span class="n">alg_hom.id_apply</span> <span class="n">R</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">z</span><span class="o">},</span>
    <span class="n">revert</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">alg_hom.ext_iff</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">free_algebra.hom_ext</span> <span class="o">(</span><span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>  <span class="c1">-- ext, but written to make clear what lemma I use</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_hom.id_apply</span><span class="o">,</span> <span class="n">alg_hom.comp_apply</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">ι</span> <span class="n">R</span> <span class="n">x</span><span class="o">),</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>

<p>This feels really quite clumsy - can anyone think of a tidier proof or theorem statement? Are we missing some obvious lemmas about <code>lift</code> and <code>ι</code> that would make this easier?</p>



<a name="212546247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212546247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212546247">(Oct 07 2020 at 11:47)</a>:</h4>
<p>Two algebra maps out of the free algebra are equal (right hand side of iff) if and only if they agree on the generators <code>X</code> (left hand side of iff).</p>



<a name="212546857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212546857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212546857">(Oct 07 2020 at 11:54)</a>:</h4>
<p>I think the non-trivial direction of that statement is exactly the statement of <a href="https://leanprover-community.github.io/mathlib_docs/find/free_algebra.hom_ext">docs#free_algebra.hom_ext</a> which my proof already uses</p>



<a name="212546995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212546995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212546995">(Oct 07 2020 at 11:56)</a>:</h4>
<p>Although what you have there sounds like a nice docstring for <code>hom_ext</code></p>



<a name="212550420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212550420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212550420">(Oct 07 2020 at 12:28)</a>:</h4>
<p>Well that's the general statement here. I don't see why we would have a lemma which is specialized to the case where one algebra map is the identity and the other one is <code>lift f</code> composed with some arbitrary other map. That's what passing arguments to lemmas is for.</p>



<a name="212550767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212550767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212550767">(Oct 07 2020 at 12:31)</a>:</h4>
<p>It might be more convenient to have a version of <code>hom_ext</code> that yields an iff, and takes the algebra maps as explicit arguments, and maybe uses elementwise equality rather than equality of functions/algebra morphisms.</p>



<a name="212551196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212551196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212551196">(Oct 07 2020 at 12:35)</a>:</h4>
<blockquote>
<p>That's what passing arguments to lemmas is for.</p>
</blockquote>
<p>Agreed, that's why I felt uneasy with this proof. I'll have a go at your suggestion and see if it shortens my proof.</p>



<a name="212551456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212551456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212551456">(Oct 07 2020 at 12:37)</a>:</h4>
<p>I don't really understand what is happening in this proof without running it, but I think it would be more straightforward to use <code>have</code> or something with a statement that involves things like <code>alg_hom.id</code> and <code>g.comp (lift R f)</code>, rather than trying to backwardsly massage the statement into making those expressions appear</p>



<a name="212551647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212551647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212551647">(Oct 07 2020 at 12:39)</a>:</h4>
<p>The key """insight""" in this proof from Lean's perspective is that <code>z</code> is really the value of the identity algebra map applied to <code>z</code>, and so on. If you can get that information in as early as possible it should make the rest of the proof trivial.</p>



<a name="212551781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212551781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212551781">(Oct 07 2020 at 12:40)</a>:</h4>
<p>The reason you have to do any work at all is that Lean doesn't know how to solve problems like "what's an algebra map <code>F</code> such that for every <code>z</code>, <code>F z = z</code>?"</p>



<a name="212551981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212551981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212551981">(Oct 07 2020 at 12:42)</a>:</h4>
<p>Should that be an <code>ext</code> lemma for <code>alg_hom</code>?</p>



<a name="212552084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552084">(Oct 07 2020 at 12:43)</a>:</h4>
<p><code>(∀ z, ⇑F x = x) → F = alg_hom.id</code></p>



<a name="212552233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552233">(Oct 07 2020 at 12:44)</a>:</h4>
<p>I think you've nailed where the awkwardness is though - <code>alg_hom</code> is full of lemmas to simp to function applications, but I need to do the reverse and coalesce things into a single <code>alg_hom</code>.</p>



<a name="212552240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552240">(Oct 07 2020 at 12:44)</a>:</h4>
<p>I mean this already exists as a specialization of <code>ext</code></p>



<a name="212552490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552490">(Oct 07 2020 at 12:46)</a>:</h4>
<p>But this is also the wrong direction, it says that the map has to be <code>alg_hom</code>, but what you need is something that makes you think to try <code>alg_hom</code> in the first place</p>



<a name="212552537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552537">(Oct 07 2020 at 12:47)</a>:</h4>
<p>Right, hence your suggestion to use <code>have</code></p>



<a name="212552683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552683">(Oct 07 2020 at 12:48)</a>:</h4>
<p>Right, or I suppose you could pass the <code>alg_hom</code>s using <code>@</code> notation but there would probably be a lot of <code>_</code>s involved</p>



<a name="212552780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552780">(Oct 07 2020 at 12:49)</a>:</h4>
<p>Actually there is a mechanism to do this already--unification hints</p>



<a name="212552818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552818">(Oct 07 2020 at 12:49)</a>:</h4>
<p>but I don't know if they would work here anyways</p>



<a name="212552919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552919">(Oct 07 2020 at 12:50)</a>:</h4>
<p>Anywhere I can read about those?</p>



<a name="212552984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212552984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212552984">(Oct 07 2020 at 12:50)</a>:</h4>
<p>Well they have about a 0% chance of getting used in mathlib anyways... not sure whether they are written up anywhere</p>



<a name="212553724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212553724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212553724">(Oct 07 2020 at 12:56)</a>:</h4>
<p>In brief, you can register "hints" that tell Lean that if it is trying to solve for a metavariable <code>?m_1</code> by unification and there's not enough information, but there is a constraint like <code>?m_1.foo = bar</code>, then it should try to refine <code>?m_1</code> in some particular way. Johan and I experimented a bit with them and we have some notes at <a href="https://github.com/rwbarton/lean-omin/blob/master/old/unification_hints.lean">https://github.com/rwbarton/lean-omin/blob/master/old/unification_hints.lean</a></p>



<a name="212553755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212553755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212553755">(Oct 07 2020 at 12:57)</a>:</h4>
<p>I don't know if they would work with higher-order constraints--probably not because they're basically unsupported</p>



<a name="212554330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212554330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212554330">(Oct 07 2020 at 13:01)</a>:</h4>
<p>Oh, that looks interesting</p>



<a name="212554441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212554441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212554441">(Oct 07 2020 at 13:02)</a>:</h4>
<p>I wonder if that can be used to fix the problem I had in <a href="#narrow/stream/113488-general/topic/Type.20inference.20on.20.60.E2.86.92.60.20vs.20.60.E2.89.83.60">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type.20inference.20on.20.60.E2.86.92.60.20vs.20.60.E2.89.83.60</a></p>



<a name="212555260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212555260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212555260">(Oct 07 2020 at 13:08)</a>:</h4>
<p>Thanks for the advice anyway, I ended up with a much tidier proof in the PR</p>



<a name="212561268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/212561268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#212561268">(Oct 07 2020 at 13:53)</a>:</h4>
<p>Note that they're being removed in lean 4 as far as I understand it</p>



<a name="215835274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/215835274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#215835274">(Nov 06 2020 at 11:49)</a>:</h4>
<p>Related to free stuff, but only tangentially to the conversation above - I found that we'd missed some quite useful bundling that makes it a little easier to work with <code>lift</code> - namely framing it as an equivalence, where <code>lift.symm F</code> is <code>F.comp ι</code> (<a href="https://github.com/leanprover-community/mathlib/issues/4908">#4908</a>) - that way all of the other equiv lemmas can be used too, after converting things back to the <code>lift.symm</code> form</p>



<a name="217110413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/217110413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#217110413">(Nov 18 2020 at 09:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/212413785">said</a>:</p>
<blockquote>
<p>Vaguelly related to this thread: Is it true that <code>function.injective (free_algebra.ι R : X → free_algebra R X)</code>?</p>
</blockquote>
<p>I've circled back to wanting to prove this - it seems I need it to prove <code>nontrivial R → nontrivial X → nontrivial (free_algebra R X)</code></p>



<a name="217111685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free%20stuff/near/217111685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Free.20stuff.html#217111685">(Nov 18 2020 at 09:24)</a>:</h4>
<p>False alarm, I can prove that without it too, <a href="https://github.com/leanprover-community/mathlib/issues/5033">#5033</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>